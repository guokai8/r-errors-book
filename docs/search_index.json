[["index.html", "Mastering R Through Errors and Warnings A Comprehensive Guide to Learning R by Understanding What Goes Wrong Welcome Why This Book Exists How This Book Works Who This Book Is For What You‚Äôll Need Book Structure Conventions Used Companion Materials How to Read This Book Acknowledgments Feedback", " Mastering R Through Errors and Warnings A Comprehensive Guide to Learning R by Understanding What Goes Wrong Kai Guo 2025-10-25 Welcome Why This Book Exists You will make errors in R. Lots of them. That‚Äôs not a prediction‚Äîit‚Äôs a promise. And it‚Äôs exactly how learning works. Most R books teach you how to do things right. This book teaches you what happens when things go wrong, because: You learn more from errors than successes - Each error is a teaching moment Errors reveal R‚Äôs internal logic - Understanding why something fails helps you understand how R thinks You‚Äôll spend more time debugging than writing new code - Better to learn it systematically Error messages are often cryptic - But they follow patterns once you know what to look for How This Book Works The Error-First Approach Each chapter follows this structure: Show the error/warning - You‚Äôll see it in a red/yellow box Explain what causes it - The underlying R behavior Demonstrate the solution - Multiple approaches when applicable Provide practice problems - Intentionally broken code for you to fix Organization System We use visual indicators throughout: üî¥ ERROR: Stops execution completely üü° WARNING: Continues but alerts you to potential issues üîµ MESSAGE: Informational only ‚úÖ SOLUTION: The fix Difficulty Levels: ‚≠ê Beginner - Everyone encounters these ‚≠ê‚≠ê Intermediate - Common with experience ‚≠ê‚≠ê‚≠ê Advanced - Edge cases and complex scenarios Error Categories: üî§ Syntax/Typo üì¶ Package Issue üî¢ Type Mismatch üìè Dimension/Length üíæ File/Path üßÆ Mathematical üîó Scoping/Environment Who This Book Is For Complete beginners who want to understand R deeply from the start Self-taught R users who‚Äôve been ‚Äúgoogling errors‚Äù and want systematic knowledge Python/MATLAB/SAS users transitioning to R and confused by its quirks Data scientists who use R daily but want to master debugging Teachers looking for a new pedagogical approach What You‚Äôll Need R (version 4.0 or higher recommended) RStudio (latest version) Patience and curiosity Willingness to intentionally break things Book Structure This book is organized into 16 parts: Part I: Foundation &amp; Environment - Installation, paths, basic objects Part II: Data Types &amp; Coercion - Understanding R‚Äôs type system through errors Part III: Indexing &amp; Subsetting - The most common source of errors Part IV: Data Frames &amp; Matrices - Rectangular data structures Part V: Factors - R‚Äôs most misunderstood data type Part VI: Strings &amp; Characters - Text manipulation errors Part VII: Functions &amp; Programming - Control flow and function errors Part VIII: Data Manipulation - base R, tidyverse, and data.table Part IX: Graphics - Base graphics and ggplot2 errors Part X: Statistical Operations - Math and modeling errors Part XI: File I/O - Reading and writing data Part XII: Packages &amp; Namespaces - Installation and loading issues Part XIII: Memory &amp; Performance - Resource limitations Part XIV: Date/Time - Temporal data challenges Part XV: Advanced Topics - OOP, parallel processing, Shiny, etc. Part XVI: Debugging &amp; Best Practices - Tools and strategies Conventions Used Code Blocks Code that produces an error: # This will error x &lt;- c(1, 2, 3) x[5] # Subscript out of bounds? No! It returns NA Expected output or error: #&gt; [1] NA Icons and Symbols üí° Key insight ‚ö†Ô∏è Common pitfall üéØ Best practice üîç Deep dive üìù Exercise üöÄ Performance tip Companion Materials All code is available at: github.com/guokai8/r-errors-book Practice datasets Additional exercises Error reference cards Community forum for questions How to Read This Book For Beginners Read sequentially. Part I and II are foundational. Don‚Äôt skip ahead‚Äîthe errors build on each other. For Intermediate Users Use the error index (Appendix A) to find specific errors, but read the related chapters for context. For Advanced Users Focus on Parts VIII-XV for package-specific and advanced errors. The appendices are your quick reference. For Teachers Each chapter has exercises at the end. The ‚ÄúTry It Yourself‚Äù sections contain intentionally broken code for students to fix. Acknowledgments This book wouldn‚Äôt exist without the thousands of confused R users who‚Äôve posted their errors on Stack Overflow, the R-help mailing list, and various forums. Every error message in this book has frustrated someone‚Äîprobably multiple people. This is for all of us. Feedback Find an error in the book about errors? See an error we haven‚Äôt covered? Open an issue on GitHub or email guokai8@gmail.com. Now, let‚Äôs start breaking things‚Ä¶ "],["part-i-foundation-environment.html", "Part I: Foundation &amp; Environment", " Part I: Foundation &amp; Environment "],["installation-environment.html", "Chapter 1 Installation &amp; Environment Setup 1.1 Introduction 1.2 Error #1: Package Installation Failed 1.3 Error #2: Unable to Access Index for Repository 1.4 Error #3: Package Not Available for R Version 1.5 Error #4: Dependencies Not Available 1.6 Error #5: Lazy Loading Failed 1.7 Error #6: Package Built Under R Version 1.8 Error #7: Rtools Required But Not Installed 1.9 Error #8: Library Not Found for -lX 1.10 Error #9: Replacing Previous Import 1.11 Debugging Installation Issues 1.12 Summary 1.13 Exercises 1.14 Exercise Answers", " Chapter 1 Installation &amp; Environment Setup What You‚Äôll Learn: Package installation errors and how to fix them Understanding repository and connection issues Compilation errors on different operating systems Version compatibility problems Key Errors Covered: 15+ installation-related errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 1.1 Introduction Before you can make interesting errors in R, you need to install R and packages. Unfortunately, this is where many learners encounter their first frustrations. Installation errors are particularly annoying because they prevent you from even starting. The good news: most installation errors follow predictable patterns and have standard solutions. 1.2 Error #1: Package Installation Failed ‚≠ê BEGINNER üì¶ PACKAGE 1.2.1 The Error install.packages(&quot;ggplot2&quot;) üî¥ ERROR Warning in install.packages : installation of package &#39;ggplot2&#39; had non-zero exit status 1.2.2 What It Means The installation process failed at some point. This is a generic error that can have many causes. 1.2.3 Common Causes and Solutions 1.2.3.1 Cause 1: No Internet Connection Symptom: Cannot reach CRAN mirror ‚úÖ SOLUTION Check your internet connection Try a different CRAN mirror: # See available mirrors getCRANmirrors() # Set a specific mirror options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) # Then try again install.packages(&quot;ggplot2&quot;) 1.2.3.2 Cause 2: Firewall or Proxy Symptom: Connection times out ‚úÖ SOLUTION # Configure proxy (if behind corporate firewall) Sys.setenv(http_proxy = &quot;http://proxy.company.com:8080&quot;) Sys.setenv(https_proxy = &quot;https://proxy.company.com:8080&quot;) # Or download package manually and install from file install.packages(&quot;path/to/package.tar.gz&quot;, repos = NULL, type = &quot;source&quot;) 1.2.3.3 Cause 3: Insufficient Permissions Symptom: Permission denied errors on Windows/Mac/Linux ‚úÖ SOLUTION On Windows: - Run RStudio as Administrator - Or install to user library: # Check library paths .libPaths() # Install to user library (first in list) install.packages(&quot;ggplot2&quot;, lib = .libPaths()[1]) On Mac/Linux: # If needed, create user library directory mkdir -p ~/R/library # Then set it in R .libPaths(c(&quot;~/R/library&quot;, .libPaths())) install.packages(&quot;ggplot2&quot;) 1.2.3.4 Cause 4: Disk Space Symptom: No space left on device ‚úÖ SOLUTION Check disk space Clean up old packages: # See what&#39;s installed installed.packages()[, c(&quot;Package&quot;, &quot;Version&quot;)] # Remove old packages remove.packages(&quot;old_package_name&quot;) # Clean up temporary files unlink(tempdir(), recursive = TRUE) 1.3 Error #2: Unable to Access Index for Repository ‚≠ê BEGINNER üì¶ PACKAGE 1.3.1 The Error install.packages(&quot;dplyr&quot;) üü° WARNING Warning: unable to access index for repository https://cran.rstudio.com/src/contrib cannot open URL &#39;https://cran.rstudio.com/src/contrib/PACKAGES&#39; 1.3.2 What It Means R cannot reach the CRAN repository to download package information. 1.3.3 Solutions ‚úÖ SOLUTIONS 1. Check CRAN status: - Visit https://cran.r-project.org/ in browser - If down, try different mirror 2. Change repository: # Use RStudio&#39;s mirror options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) # Or choose interactively chooseCRANmirror() 3. Force HTTP instead of HTTPS: # If SSL issues options(repos = c(CRAN = &quot;http://cran.r-project.org&quot;)) 4. Check .Rprofile: # See if repos are hardcoded file.edit(&quot;~/.Rprofile&quot;) # Remove or update any repos settings 1.4 Error #3: Package Not Available for R Version ‚≠ê‚≠ê INTERMEDIATE üì¶ PACKAGE 1.4.1 The Error install.packages(&quot;newpackage&quot;) üü° WARNING Warning message: package &#39;newpackage&#39; is not available for R version 4.0.0 1.4.2 What It Means The package either: 1. Requires a newer R version 2. Is not on CRAN (wrong name or removed) 3. Has been archived 1.4.3 Solutions ‚úÖ SOLUTIONS 1. Check R version: R.version.string #&gt; [1] &quot;R version 4.5.0 (2025-04-11)&quot; 2. Update R if needed: - Download from https://cran.r-project.org/ - Or use installr package (Windows): install.packages(&quot;installr&quot;) installr::updateR() 3. Check package name: # Search for package available.packages()[grep(&quot;package_name&quot;, available.packages()[, &quot;Package&quot;]), ] 4. Install from archive: # If package was archived packageurl &lt;- &quot;https://cran.r-project.org/src/contrib/Archive/package/package_1.0.tar.gz&quot; install.packages(packageurl, repos = NULL, type = &quot;source&quot;) 5. Install from GitHub: # Many packages in development install.packages(&quot;devtools&quot;) devtools::install_github(&quot;author/package&quot;) üí° Key Insight: Package Lifecycle Packages can be: - On CRAN: Current and maintained - Archived: Old version still available but removed from current CRAN - On GitHub only: Development version or not submitted to CRAN - Superseded: Replaced by another package (e.g., reshape ‚Üí reshape2 ‚Üí tidyr) 1.5 Error #4: Dependencies Not Available ‚≠ê‚≠ê INTERMEDIATE üì¶ PACKAGE 1.5.1 The Error install.packages(&quot;complexpackage&quot;) üî¥ ERROR ERROR: dependencies &#39;pkgA&#39;, &#39;pkgB&#39; are not available for package &#39;complexpackage&#39; 1.5.2 What It Means The package needs other packages (dependencies) that aren‚Äôt available or can‚Äôt be installed. 1.5.3 Solutions ‚úÖ SOLUTIONS 1. Install dependencies first: # R usually does this automatically, but sometimes fails install.packages(&quot;pkgA&quot;) install.packages(&quot;pkgB&quot;) install.packages(&quot;complexpackage&quot;) 2. Force dependency installation: install.packages(&quot;complexpackage&quot;, dependencies = TRUE) 3. Check for Bioconductor packages: # Some dependencies are on Bioconductor, not CRAN if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;dependencyPackage&quot;) 4. Manual dependency resolution: # See what&#39;s needed tools::package_dependencies(&quot;complexpackage&quot;, recursive = TRUE) # Install each one sapply(deps, install.packages) 1.6 Error #5: Lazy Loading Failed ‚≠ê‚≠ê INTERMEDIATE üì¶ PACKAGE 1.6.1 The Error library(ggplot2) üî¥ ERROR Error: package or namespace load failed for &#39;ggplot2&#39;: .onLoad failed in loadNamespace() for &#39;ggplot2&#39;, details: call: NULL error: lazy-load database &#39;path/to/ggplot2/R/ggplot2.rdb&#39; is corrupt 1.6.2 What It Means The package installation is corrupted or incomplete. 1.6.3 Solutions ‚úÖ SOLUTIONS 1. Reinstall the package: remove.packages(&quot;ggplot2&quot;) install.packages(&quot;ggplot2&quot;) 2. Restart R session: # In RStudio: Session &gt; Restart R .rs.restartR() # Or from command line q() # Then restart R 3. Check for partial installation: # See package status library(ggplot2) packageVersion(&quot;ggplot2&quot;) # Compare to CRAN version available.packages()[&quot;ggplot2&quot;, &quot;Version&quot;] 4. Install from source: install.packages(&quot;ggplot2&quot;, type = &quot;source&quot;) 5. Clear package cache: # Sometimes helps unlink(.libPaths()[1], recursive = TRUE) dir.create(.libPaths()[1]) install.packages(&quot;ggplot2&quot;) ‚ö†Ô∏è Common Pitfall: Interrupted Installation If you interrupt package installation (Ctrl+C or ESC): 1. The package may be partially installed 2. Loading it will fail with lazy-load errors 3. Always reinstall after interruption Prevention: - Let installations complete - If it‚Äôs taking too long, check your internet connection first 1.7 Error #6: Package Built Under R Version ‚≠ê BEGINNER üì¶ PACKAGE 1.7.1 The Warning library(dplyr) üü° WARNING Warning message: package &#39;dplyr&#39; was built under R version 4.2.3 1.7.2 What It Means You‚Äôre using R 4.2.0, but the package was compiled for R 4.2.3. Usually this is fine, but can cause issues. 1.7.3 Should You Worry? Usually NO - Minor version differences (4.2.0 vs 4.2.3) rarely cause problems. Maybe YES - If you experience: - Strange errors from that package - Crashes - Unexpected behavior 1.7.4 Solutions ‚úÖ SOLUTIONS 1. Ignore it (usually fine): Most of the time, this warning is harmless. 2. Update R: # Check your version R.version # Update if significantly behind # Windows: use installr # Mac: download from CRAN # Linux: use system package manager 3. Reinstall package from source: install.packages(&quot;dplyr&quot;, type = &quot;source&quot;) 4. Suppress warning: # Only if you&#39;re sure it&#39;s fine suppressWarnings(library(dplyr)) # Or globally options(warn = -1) # Not recommended! 1.8 Error #7: Rtools Required But Not Installed ‚≠ê‚≠ê INTERMEDIATE üì¶ PACKAGE Platform: Windows only 1.8.1 The Warning install.packages(&quot;package_with_cpp&quot;, type = &quot;source&quot;) üü° WARNING WARNING: Rtools is required to build R packages but is not currently installed. Please download and install Rtools from https://cran.r-project.org/bin/windows/Rtools/ 1.8.2 What It Means You‚Äôre trying to install a package that needs compilation (C/C++/Fortran code), but Windows doesn‚Äôt have the necessary compilers. 1.8.3 Solutions ‚úÖ SOLUTIONS 1. Install binary instead: # Use pre-compiled version install.packages(&quot;package_name&quot;) # default uses binary 2. Install Rtools: 1. Download from https://cran.r-project.org/bin/windows/Rtools/ 2. Run installer (default options usually work) 3. Restart R/RStudio 4. Verify installation: Sys.which(&quot;make&quot;) # Should show path like: C:\\\\rtools43\\\\usr\\\\bin\\\\make.exe 3. Configure PATH: Sometimes Rtools doesn‚Äôt add itself to PATH: # Add to .Renviron writeLines(&#39;PATH=&quot;${RTOOLS43_HOME}\\\\usr\\\\bin;${PATH}&quot;&#39;, con = &quot;~/.Renviron&quot;) # Restart R .rs.restartR() üí° Key Insight: Source vs Binary Packages Binary packages: - Pre-compiled for your OS - Fast to install - Can‚Äôt modify source code Source packages: - Raw R + C/C++ code - Requires compilation tools - Necessary for package development - Sometimes more up-to-date On Windows: Use binaries unless you need source On Mac/Linux: Source compilation more common 1.9 Error #8: Library Not Found for -lX ‚≠ê‚≠ê‚≠ê ADVANCED üì¶ PACKAGE Platform: Mac/Linux 1.9.1 The Error install.packages(&quot;XML&quot;) üî¥ ERROR ld: library not found for -lxml2 clang: error: linker command failed with exit code 1 1.9.2 What It Means The package requires external libraries (system dependencies) that aren‚Äôt installed. 1.9.3 Solutions ‚úÖ SOLUTIONS Mac (using Homebrew): # Install Homebrew if needed /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; # Install required library brew install libxml2 # Then in R install.packages(&quot;XML&quot;) Ubuntu/Debian: sudo apt-get update sudo apt-get install libxml2-dev Fedora/RedHat: sudo yum install libxml2-devel Common Dependencies: # For common R packages # Ubuntu/Debian: sudo apt-get install \\ libcurl4-openssl-dev \\ libssl-dev \\ libxml2-dev \\ libgit2-dev \\ libharfbuzz-dev \\ libfribidi-dev # Mac: brew install libgit2 openssl libxml2 üéØ Best Practice: Document System Requirements If you‚Äôre sharing code that requires specific packages: # Create a requirements file cat(&quot;# System requirements (Ubuntu/Debian): # sudo apt-get install libcurl4-openssl-dev libssl-dev # R packages: required_packages &lt;- c(&#39;dplyr&#39;, &#39;ggplot2&#39;, &#39;readr&#39;) install.packages(required_packages) &quot;, file = &quot;requirements.txt&quot;) 1.10 Error #9: Replacing Previous Import ‚≠ê BEGINNER üì¶ PACKAGE 1.10.1 The Warning library(dplyr) library(plyr) üü° WARNING Attaching package: &#39;plyr&#39; The following objects are masked from &#39;package:dplyr&#39;: arrange, count, desc, failwith, id, mutate, rename, summarise, summarize 1.10.2 What It Means Both packages have functions with the same names. The later-loaded package‚Äôs functions will be used by default. 1.10.3 Should You Worry? YES - This can cause confusing behavior if you expect dplyr‚Äôs mutate() but get plyr‚Äôs version. 1.10.4 Solutions ‚úÖ SOLUTIONS 1. Load packages in correct order: library(plyr) # Load first library(dplyr) # Load second (masks plyr) # Now dplyr functions take precedence 2. Use package::function notation: dplyr::mutate(data, new_col = x + 1) # Explicit plyr::mutate(data, new_col = x + 1) # Explicit 3. Avoid loading conflicting packages: # Don&#39;t load plyr if you&#39;re using dplyr # dplyr supersedes most plyr functionality library(dplyr) 4. Check for conflicts: # See all conflicts conflicts() # With details library(conflicted) conflict_scout() 1.11 Debugging Installation Issues 1.11.1 General Troubleshooting Steps üéØ Systematic Approach Restart R .rs.restartR() # RStudio # Or: Session &gt; Restart R Update R R.version.string #&gt; [1] &quot;R version 4.5.0 (2025-04-11)&quot; # Compare to https://cran.r-project.org/ Update packages update.packages(ask = FALSE) Check installation details # Verbose output install.packages(&quot;package&quot;, verbose = TRUE) # Keep source for inspection install.packages(&quot;package&quot;, INSTALL_opts = &quot;--no-clean-on-error&quot;) Check session info sessionInfo() #&gt; R version 4.5.0 (2025-04-11) #&gt; Platform: x86_64-apple-darwin20 #&gt; Running under: macOS Ventura 13.7.5 #&gt; #&gt; Matrix products: default #&gt; BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib #&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.5-x86_64/Resources/lib/libRlapack.dylib; LAPACK version 3.12.1 #&gt; #&gt; locale: #&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #&gt; #&gt; time zone: Asia/Shanghai #&gt; tzcode source: internal #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] digest_0.6.37 R6_2.6.1 bookdown_0.45 fastmap_1.2.0 #&gt; [5] xfun_0.53 cachem_1.1.0 knitr_1.50 htmltools_0.5.8.1 #&gt; [9] rmarkdown_2.30 lifecycle_1.0.4 cli_3.6.5 sass_0.4.10 #&gt; [13] jquerylib_0.1.4 compiler_4.5.0 rstudioapi_0.17.1 tools_4.5.0 #&gt; [17] evaluate_1.0.5 bslib_0.9.0 yaml_2.3.10 jsonlite_2.0.0 #&gt; [21] rlang_1.1.6 # Shows R version, platform, loaded packages Test in clean session # Start R with no saved data R --vanilla 1.11.2 Getting Help üí° When Asking for Help, Provide: Error message (complete, not summary) R version: R.version.string Platform: Sys.info()[\"sysname\"] What you tried: Your code Session info: sessionInfo() Good question format: I&#39;m trying to install package X on Windows 11 with R 4.3.0. Error message: [paste complete error] I tried: - Updating R - Different CRAN mirror - Installing dependencies sessionInfo() output: [paste] 1.12 Summary Key Takeaways: Most installation errors are environmental, not code-related Binary vs source matters on Windows System dependencies are common on Mac/Linux Package conflicts happen - use package::function() Reinstalling solves many issues Update regularly but cautiously Quick Reference: Error First Try Installation failed Restart R, try again Repository access Change CRAN mirror Version mismatch Update R Dependencies missing Install with dependencies = TRUE Lazy-load corruption Reinstall package Rtools (Windows) Install Rtools Library not found (Mac/Linux) Install system library Package conflicts Load order or use :: 1.13 Exercises üìù Exercise 1: Diagnosis Practice What‚Äôs wrong with each scenario? # Scenario 1 install.packages(&quot;dplyr&quot;) # Warning: unable to access index for repository # Scenario 2 library(ggplot2) # Error: package &#39;ggplot2&#39; was built before R 4.0.0 # Scenario 3 install.packages(&quot;devtools&quot;) # ERROR: dependency &#39;usethis&#39; is not available Answers at end of chapter üìù Exercise 2: Prevention Set up your R environment for smooth package installation: Configure a reliable CRAN mirror Set up a user library path Install essential build tools for your OS Create a package installation script Try writing this setup code. 1.14 Exercise Answers Click to see answers Exercise 1: Scenario 1: Cannot reach CRAN repository - Solution: Check internet, try different mirror Scenario 2: R version too old - Solution: Update R to 4.0.0 or higher Scenario 3: Missing dependency - Solution: install.packages(\"devtools\", dependencies = TRUE) Exercise 2: # Setup script setup_r_environment &lt;- function() { # 1. Set CRAN mirror options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;)) # 2. Set user library user_lib &lt;- &quot;~/R/library&quot; if (!dir.exists(user_lib)) dir.create(user_lib, recursive = TRUE) .libPaths(c(user_lib, .libPaths())) # 3. Install essential packages essentials &lt;- c(&quot;devtools&quot;, &quot;tidyverse&quot;, &quot;rmarkdown&quot;) new_packages &lt;- essentials[!(essentials %in% installed.packages()[,&quot;Package&quot;])] if(length(new_packages)) install.packages(new_packages) # 4. Save to .Rprofile for future sessions cat(&#39;options(repos = c(CRAN = &quot;https://cloud.r-project.org&quot;))\\n&#39;, file = &quot;~/.Rprofile&quot;, append = TRUE) message(&quot;R environment configured!&quot;) } "],["working-directory-paths.html", "Chapter 2 Working Directory &amp; Path Errors 2.1 Introduction 2.2 Error #1: Cannot Open File - No Such File or Directory 2.3 Error #2: Cannot Change Working Directory 2.4 Error #3: Invalid Multibyte String 2.5 Error #4: Embedded Nul in String 2.6 Error #5: Cannot Open the Connection 2.7 Error #6: Incomplete Final Line Found 2.8 Path Construction Best Practices 2.9 Debugging Path Issues 2.10 Summary 2.11 Exercises 2.12 Exercise Answers", " Chapter 2 Working Directory &amp; Path Errors What You‚Äôll Learn: Understanding R‚Äôs working directory concept Common file path errors and solutions Absolute vs relative paths Cross-platform path compatibility File encoding issues Key Errors Covered: 12+ path and file-related errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 2.1 Introduction ‚ÄúIt worked on my computer!‚Äù This famous phrase often stems from working directory and path issues. R needs to know where your files are, and this seemingly simple concept causes endless frustration. In this chapter, you‚Äôll master: - How R finds files - Why paths break across systems - Encoding nightmares - Connection errors 2.2 Error #1: Cannot Open File - No Such File or Directory ‚≠ê BEGINNER üíæ FILE/PATH 2.2.1 The Error data &lt;- read.csv(&quot;mydata.csv&quot;) üî¥ ERROR Error in file(file, &quot;rt&quot;) : cannot open the connection In addition: Warning message: In file(file, &quot;rt&quot;) : cannot open file &#39;mydata.csv&#39;: No such file or directory 2.2.2 What It Means R looked for mydata.csv in the current working directory and didn‚Äôt find it. 2.2.3 Understanding Working Directory # Where is R looking? getwd() #&gt; [1] &quot;/Users/bioguo/Downloads/r_errors_book&quot; This is your working directory - R‚Äôs current location in your file system. 2.2.4 Common Causes 2.2.4.1 Cause 1: File is Elsewhere # Your file is here: ~/Documents/project/data/mydata.csv # But R is looking here: getwd() #&gt; [1] &quot;/Users/username/Documents&quot; # R won&#39;t find it! read.csv(&quot;mydata.csv&quot;) # Error! 2.2.4.2 Cause 2: Wrong Working Directory # You opened R in wrong folder getwd() #&gt; [1] &quot;/Users/username&quot; # But your file is in: # /Users/username/Documents/R_projects/project1/ 2.2.4.3 Cause 3: Typo in Filename # File is named: &quot;mydata.csv&quot; read.csv(&quot;myData.csv&quot;) # Wrong case! read.csv(&quot;my_data.csv&quot;) # Wrong underscore! read.csv(&quot;mydata.txt&quot;) # Wrong extension! 2.2.5 Solutions ‚úÖ SOLUTION 1: Change Working Directory # Set working directory to where file is setwd(&quot;/Users/username/Documents/R_projects/project1&quot;) getwd() # Verify # Now this works: read.csv(&quot;mydata.csv&quot;) In RStudio: - Session &gt; Set Working Directory &gt; Choose Directory - Or use Files pane &gt; More &gt; Set As Working Directory ‚úÖ SOLUTION 2: Use Full Path # Absolute path (always works, regardless of wd) data &lt;- read.csv(&quot;/Users/username/Documents/R_projects/project1/mydata.csv&quot;) # Windows: data &lt;- read.csv(&quot;C:/Users/username/Documents/project1/mydata.csv&quot;) # Note: Forward slashes! or escaped backslashes: &quot;C:\\\\Users\\\\...&quot; ‚úÖ SOLUTION 3: Use Relative Path # If working directory is: /Users/username/Documents/R_projects # And file is in: /Users/username/Documents/R_projects/project1/data/ # Relative path: data &lt;- read.csv(&quot;project1/data/mydata.csv&quot;) # Go up one directory: data &lt;- read.csv(&quot;../other_project/data.csv&quot;) ‚úÖ SOLUTION 4: Use RStudio Projects Best Practice! File &gt; New Project &gt; New Directory Place all files in project directory Always use relative paths Working directory auto-set to project root # With project structure: # myproject/ # ‚îú‚îÄ‚îÄ myproject.Rproj # ‚îú‚îÄ‚îÄ scripts/ # ‚îÇ ‚îî‚îÄ‚îÄ analysis.R # ‚îî‚îÄ‚îÄ data/ # ‚îî‚îÄ‚îÄ mydata.csv # In any script: data &lt;- read.csv(&quot;data/mydata.csv&quot;) # Always works! ‚úÖ SOLUTION 5: Use here Package library(here) # Automatically finds project root here() # Build paths relative to project root data &lt;- read.csv(here(&quot;data&quot;, &quot;mydata.csv&quot;)) # Works everywhere, across all systems! ‚ö†Ô∏è Common Pitfall: setwd() in Scripts DON‚ÄôT DO THIS: # hardcoded-badscript.R setwd(&quot;/Users/alice/Documents/my_project&quot;) # Only works on Alice&#39;s computer! data &lt;- read.csv(&quot;data.csv&quot;) DO THIS INSTEAD: # Use R Projects + relative paths # Or use here package library(here) data &lt;- read.csv(here(&quot;data&quot;, &quot;data.csv&quot;)) Why? - Your path won‚Äôt work on others‚Äô computers - Breaks reproducibility - Fails when you move project 2.2.6 Checking If File Exists üéØ Best Practice: Defensive File Reading filename &lt;- &quot;data/mydata.csv&quot; # Check before reading if (file.exists(filename)) { data &lt;- read.csv(filename) message(&quot;File loaded successfully!&quot;) } else { stop(&quot;File not found: &quot;, filename, &quot;\\n&quot;, &quot;Current directory: &quot;, getwd(), &quot;\\n&quot;, &quot;Files available: &quot;, paste(list.files(), collapse = &quot;, &quot;)) } 2.3 Error #2: Cannot Change Working Directory ‚≠ê BEGINNER üíæ FILE/PATH 2.3.1 The Error setwd(&quot;/path/that/doesnt/exist&quot;) üî¥ ERROR Error in setwd(&quot;/path/that/doesnt/exist&quot;) : cannot change working directory 2.3.2 Common Causes 2.3.2.1 Cause 1: Directory Doesn‚Äôt Exist setwd(&quot;/Users/alice/Documents/nonexistent&quot;) # Typo or not created 2.3.2.2 Cause 2: Permission Denied # Trying to access restricted directory setwd(&quot;/private/var/root&quot;) # No permission! 2.3.2.3 Cause 3: Wrong Path Format # Windows: backslashes need escaping setwd(&quot;C:\\Users\\alice\\Documents&quot;) # ERROR! # Should be: setwd(&quot;C:/Users/alice/Documents&quot;) # Forward slashes setwd(&quot;C:\\\\Users\\\\alice\\\\Documents&quot;) # Escaped backslashes 2.3.3 Solutions ‚úÖ SOLUTIONS 1. Verify directory exists: path &lt;- &quot;/Users/alice/Documents/project&quot; dir.exists(path) # Check first if (dir.exists(path)) { setwd(path) } else { dir.create(path, recursive = TRUE) # Create if needed setwd(path) } 2. List available directories: # See what&#39;s in current location list.dirs(getwd(), recursive = FALSE) 3. Use correct path separators: # Cross-platform path building path &lt;- file.path(&quot;Users&quot;, &quot;alice&quot;, &quot;Documents&quot;, &quot;project&quot;) setwd(file.path(&quot;/&quot;, path)) # Works on all systems 4. Check permissions: # See if you can write to directory test_file &lt;- file.path(path, &quot;test.txt&quot;) tryCatch({ writeLines(&quot;test&quot;, test_file) file.remove(test_file) message(&quot;Directory is writable&quot;) }, error = function(e) { message(&quot;Permission denied or directory doesn&#39;t exist&quot;) }) 2.4 Error #3: Invalid Multibyte String ‚≠ê‚≠ê INTERMEDIATE üíæ FILE/PATH 2.4.1 The Error data &lt;- read.csv(&quot;donn√©es.csv&quot;) üî¥ ERROR Error in read.table(file = file, header = header, sep = sep, quote = quote, : invalid multibyte string at &#39;&lt;...&gt;&#39; 2.4.2 What It Means The file contains characters that R can‚Äôt interpret with the current encoding. Common with: - Accented characters (√©, √±, √º) - Non-Latin scripts (‰∏≠Êñá, ÿßŸÑÿπÿ±ÿ®Ÿäÿ©, —Ä—É—Å—Å–∫–∏–π) - Special symbols (‚Ç¨, ¬£, ¬©) 2.4.3 Solutions ‚úÖ SOLUTION 1: Specify Encoding # Try different encodings data &lt;- read.csv(&quot;donn√©es.csv&quot;, fileEncoding = &quot;UTF-8&quot;) data &lt;- read.csv(&quot;donn√©es.csv&quot;, fileEncoding = &quot;latin1&quot;) data &lt;- read.csv(&quot;donn√©es.csv&quot;, fileEncoding = &quot;ISO-8859-1&quot;) # For readr (tidyverse) library(readr) data &lt;- read_csv(&quot;donn√©es.csv&quot;, locale = locale(encoding = &quot;UTF-8&quot;)) ‚úÖ SOLUTION 2: Detect Encoding # Auto-detect encoding library(readr) guess_encoding(&quot;donn√©es.csv&quot;) # Use detected encoding encoding_info &lt;- guess_encoding(&quot;donn√©es.csv&quot;) data &lt;- read_csv(&quot;donn√©es.csv&quot;, locale = locale(encoding = encoding_info$encoding[1])) ‚úÖ SOLUTION 3: Handle in Filename # Rename file to avoid non-ASCII characters file.rename(&quot;donn√©es.csv&quot;, &quot;donnees.csv&quot;) data &lt;- read.csv(&quot;donnees.csv&quot;) üí° Key Insight: Common Encodings UTF-8: Universal, handles all languages (use this!) Latin1 (ISO-8859-1): Western European languages Windows-1252: Windows default (similar to Latin1) ASCII: Basic English only Best Practice: Always save files in UTF-8 2.5 Error #4: Embedded Nul in String ‚≠ê‚≠ê‚≠ê ADVANCED üíæ FILE/PATH 2.5.1 The Error data &lt;- read.csv(&quot;corrupted.csv&quot;) üî¥ ERROR Error in read.table(file = file, header = header, sep = sep, quote = quote, : embedded nul in string: &#39;&lt;text&gt;\\0more_text&#39; 2.5.2 What It Means The file contains null bytes (\\0), indicating file corruption or wrong file type. 2.5.3 Common Causes File is corrupted File is not actually text/CSV (might be binary) Encoding issues Incomplete download 2.5.4 Solutions ‚úÖ SOLUTIONS 1. Verify file type: # Check file file.info(&quot;corrupted.csv&quot;) # Try to read first few bytes readBin(&quot;corrupted.csv&quot;, &quot;raw&quot;, n = 100) # If you see lots of 00, it&#39;s binary or corrupted 2. Remove null bytes: # Read as binary and clean con &lt;- file(&quot;corrupted.csv&quot;, &quot;rb&quot;) raw_data &lt;- readBin(con, &quot;raw&quot;, n = file.info(&quot;corrupted.csv&quot;)$size) close(con) # Remove null bytes clean_data &lt;- raw_data[raw_data != 0] # Write cleaned file writeBin(clean_data, &quot;cleaned.csv&quot;) # Now try reading data &lt;- read.csv(&quot;cleaned.csv&quot;) 3. Re-download file: If downloaded from internet, download again - might have been interrupted. 4. Use readr (more robust): library(readr) data &lt;- read_csv(&quot;corrupted.csv&quot;) # Often handles better 2.6 Error #5: Cannot Open the Connection ‚≠ê‚≠ê INTERMEDIATE üíæ FILE/PATH 2.6.1 The Error con &lt;- file(&quot;data.csv&quot;, &quot;r&quot;) data &lt;- read.csv(con) üî¥ ERROR Error in file(file, &quot;rt&quot;) : cannot open the connection 2.6.2 Common Causes 2.6.2.1 Cause 1: File is Open in Another Program # File open in Excel - Windows locks it read.csv(&quot;data.csv&quot;) # Error! Solution: Close the file in other programs 2.6.2.2 Cause 2: File is Being Written By Another Process # One R process writing, another trying to read writeLines(text, &quot;file.txt&quot;) # Process 1 data &lt;- readLines(&quot;file.txt&quot;) # Process 2 - might fail Solution: Wait or use proper locking 2.6.2.3 Cause 3: Connection Already Open con &lt;- file(&quot;data.csv&quot;, &quot;r&quot;) # ... forgot to close ... con &lt;- file(&quot;data.csv&quot;, &quot;r&quot;) # Error! Already connected Solution: close(con) # Close first con &lt;- file(&quot;data.csv&quot;, &quot;r&quot;) # Now works 2.6.2.4 Cause 4: Network Path Issues # Reading from network drive read.csv(&quot;//server/share/data.csv&quot;) # Might fail if not connected 2.6.3 Solutions ‚úÖ SOLUTIONS 1. Close all connections: # See open connections showConnections() # Close all closeAllConnections() 2. Use on.exit() for cleanup: read_file_safely &lt;- function(filename) { con &lt;- file(filename, &quot;r&quot;) on.exit(close(con)) # Always closes, even if error data &lt;- readLines(con) return(data) } 3. Use tryCatch: tryCatch({ data &lt;- read.csv(&quot;data.csv&quot;) }, error = function(e) { message(&quot;Could not read file. Is it open in another program?&quot;) message(&quot;Error: &quot;, e$message) closeAllConnections() }) 4. Check file accessibility: check_file_accessible &lt;- function(filename) { # Check exists if (!file.exists(filename)) { stop(&quot;File doesn&#39;t exist: &quot;, filename) } # Check readable if (file.access(filename, mode = 4) != 0) { stop(&quot;File not readable: &quot;, filename) } # Try to open tryCatch({ con &lt;- file(filename, &quot;r&quot;) close(con) return(TRUE) }, error = function(e) { stop(&quot;Cannot open file (locked or in use?): &quot;, filename) }) } 2.7 Error #6: Incomplete Final Line Found ‚≠ê BEGINNER üíæ FILE/PATH 2.7.1 The Warning data &lt;- read.csv(&quot;data.csv&quot;) üü° WARNING Warning message: In read.table(file = file, header = header, sep = sep, quote = quote, : incomplete final line found by readTableHeader on &#39;data.csv&#39; 2.7.2 What It Means The file doesn‚Äôt end with a newline character. Text files should end with \\n, but this one doesn‚Äôt. 2.7.3 Should You Worry? Usually NO - R still reads the file correctly. It‚Äôs just being pedantic about file format. Maybe YES - If you notice missing data from last line. 2.7.4 Solutions ‚úÖ SOLUTIONS 1. Ignore it (if data looks complete): Data is usually fine, just suppress warning if annoying: suppressWarnings(data &lt;- read.csv(&quot;data.csv&quot;)) 2. Fix the file: # Read file lines &lt;- readLines(&quot;data.csv&quot;) # Add final newline writeLines(lines, &quot;data.csv&quot;) # Now reads without warning data &lt;- read.csv(&quot;data.csv&quot;) 3. Use readr (no warning): library(readr) data &lt;- read_csv(&quot;data.csv&quot;) # No warning 2.8 Path Construction Best Practices üéØ Cross-Platform Paths Problem: Paths differ across operating systems - Windows: C:\\Users\\alice\\Documents - Mac/Linux: /Users/alice/Documents Solution: Use file.path() # Works on ALL systems project_path &lt;- file.path(&quot;Users&quot;, &quot;alice&quot;, &quot;Documents&quot;, &quot;project&quot;) data_file &lt;- file.path(project_path, &quot;data&quot;, &quot;mydata.csv&quot;) print(data_file) #&gt; [1] &quot;Users/alice/Documents/project/data/mydata.csv&quot; # Compare to manual (breaks on Windows): wrong &lt;- &quot;Users/alice/Documents/project/data/mydata.csv&quot; Benefits: - Automatic path separator - No escaping needed - Works everywhere üéØ Project Structure Organize files consistently: myproject/ ‚îú‚îÄ‚îÄ myproject.Rproj # RStudio project file ‚îú‚îÄ‚îÄ README.md # Project documentation ‚îú‚îÄ‚îÄ .gitignore # Git ignore file ‚îú‚îÄ‚îÄ data/ # Data files ‚îÇ ‚îú‚îÄ‚îÄ raw/ # Original, unmodified data ‚îÇ ‚îî‚îÄ‚îÄ processed/ # Cleaned data ‚îú‚îÄ‚îÄ scripts/ # R scripts ‚îÇ ‚îú‚îÄ‚îÄ 01-import.R ‚îÇ ‚îú‚îÄ‚îÄ 02-clean.R ‚îÇ ‚îî‚îÄ‚îÄ 03-analyze.R ‚îú‚îÄ‚îÄ functions/ # Custom functions ‚îÇ ‚îî‚îÄ‚îÄ helpers.R ‚îú‚îÄ‚îÄ output/ # Results ‚îÇ ‚îú‚îÄ‚îÄ figures/ ‚îÇ ‚îî‚îÄ‚îÄ tables/ ‚îî‚îÄ‚îÄ reports/ # Rmarkdown documents ‚îî‚îÄ‚îÄ analysis.Rmd Then use: library(here) # Always works, regardless of working directory data &lt;- read.csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;mydata.csv&quot;)) source(here(&quot;functions&quot;, &quot;helpers.R&quot;)) ggsave(here(&quot;output&quot;, &quot;figures&quot;, &quot;plot1.png&quot;)) 2.9 Debugging Path Issues üí° Diagnosis Toolkit # Where am I? getwd() # What&#39;s here? list.files() list.files(recursive = TRUE) # Include subdirectories # Can I read this file? file.exists(&quot;data.csv&quot;) file.access(&quot;data.csv&quot;, mode = 4) # 4 = read # What&#39;s the full path? normalizePath(&quot;data.csv&quot;) # Get file info file.info(&quot;data.csv&quot;) # Open connections? showConnections() # Project root (with here package) library(here) here() 2.10 Summary Key Takeaways: Use R Projects - Auto-manages working directory Use here package - Build paths that work everywhere Avoid setwd() in scripts - Breaks portability Use file.path() - Cross-platform compatibility Handle encodings - UTF-8 for everything Close connections - Use on.exit() for safety Check files exist before reading Quick Reference: Problem Solution File not found Check with file.exists(), verify working directory Can‚Äôt change directory Verify path exists with dir.exists() Encoding issues Specify fileEncoding = \"UTF-8\" Embedded nul File corrupted or binary; re-download Can‚Äôt open connection Close other programs; use closeAllConnections() Incomplete final line Usually harmless; use readr to avoid The Golden Rule: # Setup once (in project) library(here) data &lt;- read.csv(here(&quot;data&quot;, &quot;mydata.csv&quot;)) # Works everywhere, every time! 2.11 Exercises üìù Exercise 1: Path Detective You receive this error: data &lt;- read.csv(&quot;../../data/experiment1/results.csv&quot;) # Error: cannot open file Your working directory is: /Users/bob/projects/analysis/scripts/R Where is R looking for the file? What‚Äôs the full path it‚Äôs trying? Write three different ways to fix it. üìù Exercise 2: Cross-Platform Script Write a script that: 1. Works on Windows, Mac, and Linux 2. Reads data from data/input.csv 3. Saves output to results/output.csv 4. Creates directories if they don‚Äôt exist 5. Handles errors gracefully Use best practices from this chapter. üìù Exercise 3: Encoding Hunter You have a CSV with French text that produces encoding errors. How do you detect the encoding? How do you read it correctly? How do you convert it to UTF-8? How do you prevent this issue in future? 2.12 Exercise Answers Click to see answers Exercise 1: 1-2. R looks for: /Users/bob/projects/data/experiment1/results.csv Three solutions: # Solution 1: Change working directory setwd(&quot;/Users/bob/projects&quot;) data &lt;- read.csv(&quot;data/experiment1/results.csv&quot;) # Solution 2: Full path data &lt;- read.csv(&quot;/Users/bob/projects/data/experiment1/results.csv&quot;) # Solution 3: Use here (BEST) library(here) here() # Finds project root data &lt;- read.csv(here(&quot;data&quot;, &quot;experiment1&quot;, &quot;results.csv&quot;)) Exercise 2: # cross_platform_script.R library(here) # Function with error handling read_and_process &lt;- function() { # Define paths input_file &lt;- here(&quot;data&quot;, &quot;input.csv&quot;) output_dir &lt;- here(&quot;results&quot;) output_file &lt;- here(&quot;results&quot;, &quot;output.csv&quot;) # Create output directory if needed if (!dir.exists(output_dir)) { dir.create(output_dir, recursive = TRUE) message(&quot;Created directory: &quot;, output_dir) } # Check input file exists if (!file.exists(input_file)) { stop(&quot;Input file not found: &quot;, input_file) } # Read data data &lt;- tryCatch({ read.csv(input_file) }, error = function(e) { stop(&quot;Could not read input file: &quot;, e$message) }) # Process (example) results &lt;- data # Your processing here # Write results tryCatch({ write.csv(results, output_file, row.names = FALSE) message(&quot;Results saved to: &quot;, output_file) }, error = function(e) { stop(&quot;Could not write output file: &quot;, e$message) }) return(results) } # Run read_and_process() Exercise 3: library(readr) # 1. Detect encoding encoding_info &lt;- guess_encoding(&quot;french_data.csv&quot;) print(encoding_info) # 2. Read with correct encoding data &lt;- read_csv(&quot;french_data.csv&quot;, locale = locale(encoding = encoding_info$encoding[1])) # 3. Convert to UTF-8 write_csv(data, &quot;french_data_utf8.csv&quot;) # 4. Prevention: # - Always save files as UTF-8 # - Document encoding in README # - Use readr::write_csv() which always uses UTF-8 # - Add encoding check in data import scripts "],["objects-variables.html", "Chapter 3 Objects and Variables 3.1 Introduction 3.2 Error #1: object 'x' not found 3.3 Error #2: could not find function \"x\" 3.4 Error #3: unexpected symbol in \"x\" 3.5 Error #4: unexpected '=' in \"x\" 3.6 Error #5: object of type 'closure' is not subsettable 3.7 Error #6: cannot change value of locked binding 3.8 Understanding Variable Scope 3.9 Naming Conventions 3.10 Summary 3.11 Exercises 3.12 Exercise Answers", " Chapter 3 Objects and Variables What You‚Äôll Learn: How R stores and finds objects The most common beginner errors Understanding R‚Äôs case sensitivity and naming rules Scoping basics that prevent errors Key Errors Covered: 10+ object-related errors Difficulty: ‚≠ê Beginner 3.1 Introduction Every R session starts with creating objects. And every R learner‚Äôs journey starts with object 'x' not found. This error is so universal that it deserves deep understanding. # Your first R command x &lt;- 42 x #&gt; [1] 42 Simple, right? Until it‚Äôs not. Let‚Äôs explore what goes wrong. 3.2 Error #1: object 'x' not found ‚≠ê BEGINNER üîó SCOPING 3.2.1 The Error # Try to use an object that doesn&#39;t exist my_number + 5 #&gt; Error: object &#39;my_number&#39; not found üî¥ ERROR Error: object &#39;my_number&#39; not found 3.2.2 What It Means R looked for an object named my_number in: 1. The current environment (.GlobalEnv) 2. All loaded packages (in search path order) 3. The base environment ‚Ä¶and couldn‚Äôt find it anywhere. 3.2.3 Common Causes 3.2.3.1 Cause 1: Typo in Object Name my_variable &lt;- 10 my_varaible + 5 # Notice the typo: varaible vs variable #&gt; Error: object &#39;my_varaible&#39; not found üí° Key Insight: R is case-sensitive! Temperature &lt;- 98.6 temperature # Wrong case! #&gt; Error: object &#39;temperature&#39; not found # These are THREE different objects: myVariable &lt;- 1 MyVariable &lt;- 2 myvariable &lt;- 3 ls() # All three exist #&gt; [1] &quot;data_file&quot; &quot;error_box&quot; &quot;message_box&quot; &quot;my_variable&quot; &quot;myvariable&quot; #&gt; [6] &quot;myVariable&quot; &quot;MyVariable&quot; &quot;project_path&quot; &quot;solution_box&quot; &quot;Temperature&quot; #&gt; [11] &quot;warning_box&quot; &quot;wrong&quot; &quot;x&quot; 3.2.3.2 Cause 2: Never Created the Object # Forgot to run this line: # result &lt;- 100 * 2 # Trying to use it: result / 4 #&gt; Error: object &#39;result&#39; not found 3.2.3.3 Cause 3: Object Created in Different Scope my_function &lt;- function() { local_var &lt;- 42 print(local_var) # Works inside function } my_function() #&gt; [1] 42 local_var # Doesn&#39;t exist outside function! #&gt; Error: object &#39;local_var&#39; not found 3.2.3.4 Cause 4: Cleared Environment x &lt;- 10 x # Exists #&gt; [1] 10 rm(x) # Removed it # Now: x # Gone! #&gt; Error: object &#39;x&#39; not found 3.2.3.5 Cause 5: Running Lines Out of Order # If you run line 10 before line 5: # Line 5 my_data &lt;- read.csv(&quot;data.csv&quot;) # Line 10 (run this first by mistake) summary(my_data) # Error! my_data doesn&#39;t exist yet 3.2.4 Solutions ‚úÖ SOLUTIONS 1. Check spelling carefully: my_variable &lt;- 10 my_variable + 5 # Correct spelling #&gt; [1] 15 2. Verify object exists: # List all objects ls() #&gt; [1] &quot;data_file&quot; &quot;error_box&quot; &quot;message_box&quot; &quot;my_function&quot; &quot;my_variable&quot; #&gt; [6] &quot;myvariable&quot; &quot;myVariable&quot; &quot;MyVariable&quot; &quot;project_path&quot; &quot;solution_box&quot; #&gt; [11] &quot;Temperature&quot; &quot;warning_box&quot; &quot;wrong&quot; # Check if specific object exists exists(&quot;my_variable&quot;) #&gt; [1] TRUE # Search in environment grep(&quot;var&quot;, ls(), value = TRUE) # Find objects with &quot;var&quot; #&gt; [1] &quot;my_variable&quot; &quot;myvariable&quot; 3. Use RStudio‚Äôs autocomplete: - Type the first few letters - Press Tab to see available objects 4. Check your environment pane: In RStudio, look at the Environment pane (top-right) to see all objects. 5. Run all necessary code: Make sure you‚Äôve executed all lines that create the objects you need. 6. Restart and run from top: # Clear everything and start fresh rm(list = ls()) # Or: Ctrl+Shift+F10 in RStudio (restart R) üéØ Best Practices Use consistent naming: Choose a style and stick to it snake_case (recommended for R) camelCase Avoid dot.case (can be confusing with S3 methods) Meaningful names: temperature_celsius &gt; temp &gt; t Avoid similar names: # Confusing: data1 &lt;- ... data2 &lt;- ... data_new &lt;- ... data_final &lt;- ... data_final2 &lt;- ... # Better: raw_data &lt;- ... clean_data &lt;- ... analyzed_data &lt;- ... Run scripts top-to-bottom: Your script should work when run fresh 3.3 Error #2: could not find function \"x\" ‚≠ê BEGINNER üì¶ PACKAGE 3.3.1 The Error # Try to use a function from unloaded package read_csv(&quot;data.csv&quot;) #&gt; Error in read_csv(&quot;data.csv&quot;): could not find function &quot;read_csv&quot; üî¥ ERROR Error: could not find function &quot;read_csv&quot; 3.3.2 What It Means R can‚Äôt find a function with that name. Functions are searched in: 1. The current environment 2. All loaded packages 3. NOT inside unloaded packages 3.3.3 Common Causes 3.3.3.1 Cause 1: Package Not Loaded # tidyverse not loaded read_csv(&quot;data.csv&quot;) # Error! # Solution: library(readr) read_csv(&quot;data.csv&quot;) # Works! 3.3.3.2 Cause 2: Package Not Installed library(somepackage) # If not installed, this errors Error in library(somepackage) : there is no package called &#39;somepackage&#39; 3.3.3.3 Cause 3: Typo in Function Name # Base R function is read.csv (dot), not read_csv (underscore) meen(c(1, 2, 3)) # Typo: mean #&gt; Error in meen(c(1, 2, 3)): could not find function &quot;meen&quot; 3.3.3.4 Cause 4: Object Overwrote Function # Created an object with same name as a function mean &lt;- 42 mean #&gt; [1] 42 # Now the function is gone! mean(c(1, 2, 3)) #&gt; [1] 2 üî¥ ERROR Error in mean(c(1, 2, 3)) : could not find function &quot;mean&quot; Wait, what? We just used mean! But we overwrote it with the number 42. 3.3.4 Solutions ‚úÖ SOLUTIONS 1. Load the required package: library(readr) read_csv(&quot;data.csv&quot;) 2. Install then load: install.packages(&quot;readr&quot;) library(readr) 3. Use package::function notation: # Use function without loading entire package readr::read_csv(&quot;data.csv&quot;) # Always works, no library() needed dplyr::mutate(data, new_col = x + 1) 4. Check function spelling: # Base R uses dots read.csv(&quot;data.csv&quot;) # Note the dot # tidyverse uses underscores library(readr) read_csv(&quot;data.csv&quot;) # Note the underscore 5. Remove conflicting object: # If you accidentally overwrote: mean &lt;- 42 # Bad! rm(mean) # Remove the object mean(c(1, 2, 3)) # Now the function works #&gt; [1] 2 6. Find where function lives: # Search for functions ??read_csv help.search(&quot;read_csv&quot;) # Find package find(&quot;read_csv&quot;) ‚ö†Ô∏è Common Pitfall: Overwriting Functions Never name objects after common functions: Avoid naming objects: - mean, sum, length, data, df, c, t, T, F - matrix, list, vector, table - plot, points, lines - Any function you use regularly! If you accidentally do it: # You created: sum &lt;- 100 sum(1:10) # Error! # Fix: rm(sum) # Remove it sum(1:10) # Works now # Or restart R session: Ctrl+Shift+F10 3.4 Error #3: unexpected symbol in \"x\" ‚≠ê BEGINNER üî§ SYNTAX 3.4.1 The Error my variable &lt;- 10 #&gt; Error in parse(text = input): &lt;text&gt;:1:4: unexpected symbol #&gt; 1: my variable #&gt; ^ üî¥ ERROR Error: unexpected symbol in &quot;my variable&quot; 3.4.2 What It Means R‚Äôs parser encountered something it didn‚Äôt expect. Usually a space or character where it shouldn‚Äôt be. 3.4.3 Common Causes 3.4.3.1 Cause 1: Space in Variable Name my variable &lt;- 10 # Spaces not allowed! #&gt; Error in parse(text = input): &lt;text&gt;:1:4: unexpected symbol #&gt; 1: my variable #&gt; ^ # Solutions: my_variable &lt;- 10 # underscore myVariable &lt;- 10 # camelCase my.variable &lt;- 10 # dot (less recommended) 3.4.3.2 Cause 2: Missing Operator x &lt;- 5 y &lt;- 10 result &lt;- x y # Missing operator! #&gt; Error in parse(text = input): &lt;text&gt;:3:13: unexpected symbol #&gt; 2: y &lt;- 10 #&gt; 3: result &lt;- x y #&gt; ^ # Fix: result &lt;- x * y # or +, -, /, etc. #&gt; Error: object &#39;x&#39; not found 3.4.3.3 Cause 3: Two Statements on One Line x &lt;- 5 y &lt;- 10 # Two assignments without separator #&gt; Error in parse(text = input): &lt;text&gt;:1:8: unexpected symbol #&gt; 1: x &lt;- 5 y #&gt; ^ # Solutions: x &lt;- 5; y &lt;- 10 # Semicolon separator # Or on separate lines (preferred): x &lt;- 5 y &lt;- 10 3.4.3.4 Cause 4: Incorrect String Quotes text &lt;- &quot;Hello world&quot; # Unmatched quotes # Fix: text &lt;- &quot;Hello world&quot; # Matching quotes 3.4.3.5 Cause 5: Copying from Formatted Text # Copying from Word/PDF might include smart quotes or special characters name &lt;- &quot;John&quot; # These aren&#39;t regular quotes! # Should be: name &lt;- &quot;John&quot; # Regular ASCII quotes 3.4.4 Solutions ‚úÖ SOLUTIONS 1. Use underscores for multi-word names: total_sales &lt;- 1000 average_temperature &lt;- 72.5 2. Add missing operators: a &lt;- 10 b &lt;- 5 c &lt;- a + b # Not: c &lt;- a b 3. Separate statements: # One per line: x &lt;- 1 y &lt;- 2 # Or use semicolon: x &lt;- 1; y &lt;- 2 4. Use consistent quotes: # Choose one style and stick to it: text1 &lt;- &quot;double quotes&quot; # More common in R text2 &lt;- &#39;single quotes&#39; # Also fine # They&#39;re equivalent: identical(text1, &quot;double quotes&quot;) #&gt; [1] TRUE identical(text2, &#39;single quotes&#39;) #&gt; [1] TRUE 3.5 Error #4: unexpected '=' in \"x\" ‚≠ê BEGINNER üî§ SYNTAX 3.5.1 The Error x = 5 = y #&gt; Error in 5 = y: invalid (do_set) left-hand side to assignment üî¥ ERROR Error: unexpected &#39;=&#39; in &quot;x = 5 =&quot; 3.5.2 What It Means You used = where R didn‚Äôt expect it. 3.5.3 Common Causes 3.5.3.1 Cause 1: Chained Assignment (doesn‚Äôt work like math) # Trying to set x and y to 5 (like math: x = y = 5) x = 5 = y # Doesn&#39;t work! #&gt; Error in 5 = y: invalid (do_set) left-hand side to assignment # Solutions: x &lt;- y &lt;- 5 # This works # Or: x &lt;- 5 y &lt;- 5 3.5.3.2 Cause 2: Using = Instead of == x &lt;- 10 if (x = 10) { # Assignment, not comparison! print(&quot;yes&quot;) } #&gt; Error in parse(text = input): &lt;text&gt;:2:7: unexpected &#39;=&#39; #&gt; 1: x &lt;- 10 #&gt; 2: if (x = #&gt; ^ # Fix: use == for comparison if (x == 10) { print(&quot;yes&quot;) } 3.5.3.3 Cause 3: Wrong Context for = # Inside function arguments, = is fine: mean(x = c(1, 2, 3)) # OK # For assignment, &lt;- is clearer: x &lt;- c(1, 2, 3) # Better style 3.5.4 Solutions ‚úÖ SOLUTIONS 1. Use &lt;- for assignment: # Preferred in R x &lt;- 10 2. Use == for comparison: x &lt;- 10 x == 10 # TRUE #&gt; [1] TRUE x == 5 # FALSE #&gt; [1] FALSE 3. Use = only in function arguments: # Good: mean(x = c(1, 2, 3), na.rm = TRUE) #&gt; [1] 2 # Also fine, but &lt;- preferred for assignment: x &lt;- c(1, 2, 3) mean(x, na.rm = TRUE) #&gt; [1] 2 üí° Key Insight: &lt;- vs = # Both work for assignment: x &lt;- 10 x = 10 # But &lt;- is preferred because: # 1. Clearer intent (unambiguous assignment) # 2. Works everywhere # 3. R community standard # = can be ambiguous: mean(x = 1:10) # Named argument (good) #&gt; [1] 5.5 x = 1:10 # Assignment (works, but &lt;- preferred) Best Practice: Use &lt;- for assignment, = for function arguments 3.6 Error #5: object of type 'closure' is not subsettable ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 3.6.1 The Error mean[1] # Trying to subset the mean function #&gt; Error in mean[1]: object of type &#39;closure&#39; is not subsettable üî¥ ERROR Error in mean[1] : object of type &#39;closure&#39; is not subsettable 3.6.2 What It Means ‚ÄúClosure‚Äù = function. You‚Äôre trying to use [ on a function, which doesn‚Äôt make sense. 3.6.3 Common Causes 3.6.3.1 Cause 1: Forgot to Call the Function data &lt;- c(1, 2, 3, 4, 5) result &lt;- mean # Forgot parentheses! result[1] # Trying to subset the function itself #&gt; Error in result[1]: object of type &#39;closure&#39; is not subsettable # Fix: result &lt;- mean(data) # Call the function result # Now it&#39;s a number #&gt; [1] 3 3.6.3.2 Cause 2: Accidentally Accessed Function Instead of Object # You have an object named &#39;data&#39; data &lt;- data.frame(x = 1:5, y = 6:10) # But there&#39;s also a function called &#39;data&#39; data[1, ] # If you somehow reference the function... #&gt; x y #&gt; 1 1 6 This is rare, but shows why naming is important. 3.6.3.3 Cause 3: Function Name Typo Leads to Another Function c &lt;- c(1, 2, 3) # Bad! &#39;c&#39; is a function c[1] # Now trying to subset the c() function #&gt; [1] 1 3.6.4 Solutions ‚úÖ SOLUTIONS 1. Call the function: # Wrong: data &lt;- c(1, 2, 3) result &lt;- mean result[1] # Error #&gt; Error in result[1]: object of type &#39;closure&#39; is not subsettable # Right: result &lt;- mean(data) # Call it result # Number, can&#39;t subset but don&#39;t need to #&gt; [1] 2 2. Check if it‚Äôs a function: is.function(mean) # TRUE #&gt; [1] TRUE is.function(c(1,2,3)) # FALSE #&gt; [1] FALSE 3. Don‚Äôt overwrite function names: # Bad: c &lt;- c(1, 2, 3) t &lt;- read.csv(&quot;data.csv&quot;) data &lt;- process_data() # Good: my_vector &lt;- c(1, 2, 3) my_data &lt;- read.csv(&quot;data.csv&quot;) processed_data &lt;- process_data() 3.7 Error #6: cannot change value of locked binding ‚≠ê‚≠ê INTERMEDIATE üîó SCOPING 3.7.1 The Error T &lt;- FALSE # Trying to change T üî¥ ERROR Error in T &lt;- FALSE : cannot change value of locked binding for &#39;T&#39; 3.7.2 What It Means You‚Äôre trying to modify a protected object. Some objects are locked to prevent accidental changes. 3.7.3 Common Protected Objects # These are locked: T # TRUE F # FALSE pi letters LETTERS month.name month.abb 3.7.4 Why This Protection Exists # Imagine if you could do this: T &lt;- FALSE F &lt;- TRUE # Now: if (T) { # But T is FALSE! print(&quot;This won&#39;t print&quot;) } # Chaos! 3.7.5 Solutions ‚úÖ SOLUTIONS 1. Use a different name: # Don&#39;t: # T &lt;- FALSE # Do: my_test &lt;- FALSE temperature &lt;- 72 2. Use full names (better practice anyway): # Instead of T/F: my_var &lt;- TRUE # Not T other_var &lt;- FALSE # Not F # More readable and no risk of confusion 3. Never use T/F in code: # Bad: if (x &gt; 0) T else F #&gt; Error in if (x &gt; 0) T else F: the condition has length &gt; 1 # Good: if (x &gt; 0) TRUE else FALSE #&gt; Error in if (x &gt; 0) TRUE else FALSE: the condition has length &gt; 1 ‚ö†Ô∏è Common Pitfall: T and F Never use T and F as shortcuts for TRUE and FALSE Why? - They can be overwritten (in older R) - Less readable - Can cause subtle bugs # Dangerous: result &lt;- T # What if someone changed T? # Safe: result &lt;- TRUE # Can never be changed 3.8 Understanding Variable Scope üí° Key Insight: Where Variables Live # Global environment x &lt;- 10 my_function &lt;- function() { # Function environment y &lt;- 20 # Can see global x print(x) # Can see local y print(y) } my_function() #&gt; [1] 10 #&gt; [1] 20 # Global can&#39;t see local y print(y) # Error! #&gt; [1] 5 Scoping Rules: 1. Look in current environment 2. Look in parent environment 3. Keep going up until found (or not) 3.9 Naming Conventions üéØ R Naming Best Practices Valid names: # Letters, numbers, dots, underscores my_variable myVariable my.variable my_variable2 var_123 .hidden_var # Starts with dot (not shown by ls()) Invalid names: # Can&#39;t start with number 2var &lt;- 10 # ERROR # Can&#39;t have spaces my var &lt;- 10 # ERROR # Can&#39;t use special characters my-var &lt;- 10 # ERROR (minus sign) my$var &lt;- 10 # ERROR my@var &lt;- 10 # ERROR Reserved words (can‚Äôt use): # These are taken: if, else, repeat, while, function, for, in, next, break TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_ Recommended style: # Snake case (recommended for R) total_sales &lt;- 1000 avg_temperature &lt;- 72 customer_age &lt;- 35 # CamelCase (also fine) totalSales &lt;- 1000 avgTemperature &lt;- 72 customerAge &lt;- 35 # Whatever you choose, be consistent! 3.10 Summary Key Takeaways: R is case-sensitive: X ‚â† x Check spelling: Most ‚Äúobject not found‚Äù errors are typos Load packages: Functions need library() or :: Don‚Äôt overwrite functions: Avoid naming objects after functions Use &lt;- for assignment: Clearer than = No spaces in names: Use _ or camelCase Check environment: Use ls() and RStudio‚Äôs Environment pane Never use T/F: Always write TRUE/FALSE Quick Fixes: Error Likely Cause Fix object not found Typo or not created Check spelling, use ls() function not found Package not loaded library() or package::function() unexpected symbol Space in name Use _ instead unexpected = Used = instead of == Use == for comparison closure not subsettable Forgot () on function Add parentheses locked binding Tried to change T/F Use different name 3.11 Exercises üìù Exercise 1: Spot the Errors What‚Äôs wrong with each line? # 1 my result &lt;- 100 # 2 Mean &lt;- mean(c(1, 2, 3)) meen(c(4, 5, 6)) # 3 x = 10 if (x = 10) print(&quot;yes&quot;) # 4 c &lt;- c(1, 2, 3) c[1] # 5 library(dplyr) select(data, column1) # data doesn&#39;t exist # 6 T &lt;- FALSE üìù Exercise 2: Debug This Script Fix all errors: # Load data my data &lt;- read.csv(&quot;results.csv&quot;) # Calculate mean average &lt;- Mean(my data$value) # Compare if (average = 50) { print(&quot;Average is 50&quot;) } # Store result T &lt;- average &gt; 50 üìù Exercise 3: Good Names Rename these variables following best practices: # Current (bad) names: x &lt;- data.frame(...) data &lt;- read.csv(&quot;sales.csv&quot;) t &lt;- TRUE result1 &lt;- ... result2 &lt;- ... finaldata &lt;- ... 3.12 Exercise Answers Click to see answers Exercise 1: # 1 - Space in name my_result &lt;- 100 # or myResult # 2 - Typo in function name Mean &lt;- mean(c(1, 2, 3)) # OK (but confusing name) mean(c(4, 5, 6)) # Fix: mean not meen # 3 - Used = instead of == x &lt;- 10 if (x == 10) print(&quot;yes&quot;) # 4 - Overwrote c() function my_vector &lt;- c(1, 2, 3) my_vector[1] # 5 - Object &#39;data&#39; doesn&#39;t exist (need to create first) # Also need to create it before this line # 6 - Can&#39;t change T my_test &lt;- FALSE # Use different name Exercise 2: # Load data my_data &lt;- read.csv(&quot;results.csv&quot;) # Underscore, not space # Calculate mean average &lt;- mean(my_data$value) # mean not Mean # Compare if (average == 50) { # == not = print(&quot;Average is 50&quot;) } # Store result is_above_50 &lt;- average &gt; 50 # Don&#39;t use T Exercise 3: # Better names: sales_dataframe &lt;- data.frame(...) # or just sales_data sales_data &lt;- read.csv(&quot;sales.csv&quot;) is_valid &lt;- TRUE # or use full TRUE raw_results &lt;- ... clean_results &lt;- ... final_sales_data &lt;- ... # or analyzed_sales "],["part-ii-data-types-coercion.html", "Part II: Data Types &amp; Coercion", " Part II: Data Types &amp; Coercion "],["type-mismatch.html", "Chapter 4 Type Mismatch Errors 4.1 Introduction 4.2 R‚Äôs Basic Types 4.3 Error #1: non-numeric argument to binary operator 4.4 Error #2: non-numeric argument to mathematical function 4.5 Error #3: (list) object cannot be coerced to type 'double' 4.6 Error #4: invalid type (closure) for variable 'X' 4.7 Error #5: cannot coerce class \"X\" to a data.frame 4.8 Error #6: NAs introduced by coercion 4.9 Error #7: character string is not in a standard unambiguous format 4.10 Type Checking Functions 4.11 Type Conversion Functions 4.12 Summary 4.13 Exercises 4.14 Exercise Answers", " Chapter 4 Type Mismatch Errors What You‚Äôll Learn: Understanding R‚Äôs type system How coercion works (and fails) Type checking and conversion Common type mismatch scenarios How to prevent type errors Key Errors Covered: 20+ type-related errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 4.1 Introduction R is dynamically typed but strongly typed. This means: - You don‚Äôt declare types (dynamic) - But types matter for operations (strong) x &lt;- 5 # R figures out it&#39;s numeric y &lt;- &quot;5&quot; # R figures out it&#39;s character But try to mix them: x + y # Error! #&gt; Error in x + y: non-numeric argument to binary operator Understanding type errors is fundamental to R mastery. This chapter covers every type mismatch you‚Äôll encounter. 4.2 R‚Äôs Basic Types üí° Key Insight: The Six Atomic Types R has six atomic (fundamental) types: # 1. Logical is_true &lt;- TRUE typeof(is_true) #&gt; [1] &quot;logical&quot; # 2. Integer age &lt;- 25L # Note the L typeof(age) #&gt; [1] &quot;integer&quot; # 3. Double (numeric) price &lt;- 19.99 typeof(price) #&gt; [1] &quot;double&quot; # 4. Character name &lt;- &quot;Alice&quot; typeof(name) #&gt; [1] &quot;character&quot; # 5. Complex z &lt;- 3 + 2i typeof(z) #&gt; [1] &quot;complex&quot; # 6. Raw (rarely used) raw_byte &lt;- charToRaw(&quot;A&quot;) typeof(raw_byte) #&gt; [1] &quot;raw&quot; Most common: logical, integer, double, character 4.3 Error #1: non-numeric argument to binary operator ‚≠ê BEGINNER üî¢ TYPE 4.3.1 The Error &quot;10&quot; + 5 #&gt; Error in &quot;10&quot; + 5: non-numeric argument to binary operator üî¥ ERROR Error in &quot;10&quot; + 5 : non-numeric argument to binary operator 4.3.2 What It Means You tried to use a mathematical operator (+, -, *, /, ^, %%, %/%) with something that isn‚Äôt a number. Binary operator = operator that works on two things (left + right) 4.3.3 Common Causes 4.3.3.1 Cause 1: Character That Looks Like Number # Read from CSV without proper type specification age &lt;- &quot;25&quot; # Actually character! age + 10 # Error #&gt; Error in age + 10: non-numeric argument to binary operator # Check type class(age) #&gt; [1] &quot;character&quot; is.numeric(age) #&gt; [1] FALSE is.character(age) #&gt; [1] TRUE 4.3.3.2 Cause 2: Factor Instead of Numeric # Factors are secretly integers with labels scores &lt;- factor(c(&quot;90&quot;, &quot;85&quot;, &quot;95&quot;)) scores + 10 # Error! #&gt; Warning in Ops.factor(scores, 10): &#39;+&#39; not meaningful for factors #&gt; [1] NA NA NA class(scores) #&gt; [1] &quot;factor&quot; typeof(scores) # &quot;integer&quot; but can&#39;t do math on it! #&gt; [1] &quot;integer&quot; 4.3.3.3 Cause 3: Missing Data Coerced to Character # One NA can turn everything to character values &lt;- c(10, 20, NA, 40) values &lt;- as.character(values) # Accidentally values[1] + 5 # Error! #&gt; Error in values[1] + 5: non-numeric argument to binary operator 4.3.3.4 Cause 4: Logical in Math (This Actually Works!) # Wait, this works? TRUE + 5 # TRUE becomes 1 #&gt; [1] 6 FALSE + 5 # FALSE becomes 0 #&gt; [1] 5 # This is by design - logical coerces to numeric sum(c(TRUE, FALSE, TRUE)) # Counts TRUEs #&gt; [1] 2 But mixing with character doesn‚Äôt: &quot;TRUE&quot; + 5 # Character, not logical #&gt; Error in &quot;TRUE&quot; + 5: non-numeric argument to binary operator 4.3.4 Solutions ‚úÖ SOLUTION 1: Convert to Numeric # Basic conversion age &lt;- &quot;25&quot; age &lt;- as.numeric(age) age + 10 #&gt; [1] 35 # Check before converting if (is.character(age)) { age &lt;- as.numeric(age) } ‚úÖ SOLUTION 2: Handle Factors Correctly # Wrong way: scores &lt;- factor(c(&quot;90&quot;, &quot;85&quot;, &quot;95&quot;)) as.numeric(scores) # Gives factor levels (1,2,3), not values! #&gt; [1] 2 1 3 # Right way: as.numeric(as.character(scores)) # Convert to char first #&gt; [1] 90 85 95 # Better way: as.numeric(levels(scores)[scores]) #&gt; [1] 90 85 95 ‚úÖ SOLUTION 3: Read Data with Correct Types # Base R - specify column types data &lt;- read.csv(&quot;file.csv&quot;, colClasses = c(&quot;numeric&quot;, &quot;character&quot;, &quot;numeric&quot;)) # tidyverse - specify on read library(readr) data &lt;- read_csv(&quot;file.csv&quot;, col_types = cols( age = col_double(), name = col_character(), score = col_double() )) ‚úÖ SOLUTION 4: Safe Conversion with Error Handling safe_as_numeric &lt;- function(x) { result &lt;- suppressWarnings(as.numeric(x)) if (all(is.na(result)) &amp;&amp; !all(is.na(x))) { warning(&quot;Conversion produced all NAs - check your data&quot;) } return(result) } # Test safe_as_numeric(&quot;25&quot;) # Works #&gt; [1] 25 safe_as_numeric(&quot;abc&quot;) # Warning + NA #&gt; Warning in safe_as_numeric(&quot;abc&quot;): Conversion produced all NAs - check your #&gt; data #&gt; [1] NA safe_as_numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;)) # Partial conversion #&gt; [1] 1 2 NA ‚ö†Ô∏è Common Pitfall: Silent Failures # This looks like it worked... x &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;four&quot;) x &lt;- as.numeric(x) #&gt; Warning: NAs introduced by coercion x #&gt; [1] 1 2 3 NA Problem: ‚Äúfour‚Äù became NA silently! Solution: Check for NAs after conversion: if (any(is.na(x))) { warning(&quot;Some values couldn&#39;t be converted&quot;) } #&gt; Warning: Some values couldn&#39;t be converted 4.4 Error #2: non-numeric argument to mathematical function ‚≠ê BEGINNER üî¢ TYPE 4.4.1 The Error sqrt(&quot;16&quot;) #&gt; Error in sqrt(&quot;16&quot;): non-numeric argument to mathematical function üî¥ ERROR Error in sqrt(&quot;16&quot;) : non-numeric argument to mathematical function 4.4.2 What It Means Mathematical functions (sqrt, log, exp, sin, cos, etc.) need numbers, not characters or other types. 4.4.3 Common Functions That Give This Error # All of these error with character input: sqrt(&quot;16&quot;) #&gt; Error in sqrt(&quot;16&quot;): non-numeric argument to mathematical function log(&quot;10&quot;) #&gt; Error in log(&quot;10&quot;): non-numeric argument to mathematical function exp(&quot;2&quot;) #&gt; Error in exp(&quot;2&quot;): non-numeric argument to mathematical function abs(&quot;-5&quot;) #&gt; Error in abs(&quot;-5&quot;): non-numeric argument to mathematical function round(&quot;3.14&quot;) #&gt; Error in round(&quot;3.14&quot;): non-numeric argument to mathematical function floor(&quot;4.7&quot;) #&gt; Error in floor(&quot;4.7&quot;): non-numeric argument to mathematical function ceiling(&quot;4.2&quot;) #&gt; Error in ceiling(&quot;4.2&quot;): non-numeric argument to mathematical function 4.4.4 Solutions ‚úÖ SOLUTIONS 1. Convert before calling function: sqrt(as.numeric(&quot;16&quot;)) #&gt; [1] 4 log(as.numeric(&quot;10&quot;)) #&gt; [1] 2.302585 2. Vectorized conversion and operation: values &lt;- c(&quot;16&quot;, &quot;25&quot;, &quot;36&quot;) sqrt(as.numeric(values)) #&gt; [1] 4 5 6 3. Use type-safe reading: # When reading data data &lt;- read.csv(&quot;data.csv&quot;, stringsAsFactors = FALSE) data$numeric_col &lt;- as.numeric(data$numeric_col) 4.5 Error #3: (list) object cannot be coerced to type 'double' ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 4.5.1 The Error my_list &lt;- list(a = 1, b = 2, c = 3) sum(my_list) #&gt; Error in sum(my_list): invalid &#39;type&#39; (list) of argument üî¥ ERROR Error in sum(my_list) : invalid &#39;type&#39; (list) of argument 4.5.2 What It Means You‚Äôre trying to do mathematical operations on a list, which is a container that can hold anything. R can‚Äôt automatically convert a list to numbers. 4.5.3 Common Causes 4.5.3.1 Cause 1: Using List Instead of Vector # List (wrong for math) numbers_list &lt;- list(1, 2, 3, 4, 5) mean(numbers_list) # Error! #&gt; Warning in mean.default(numbers_list): argument is not numeric or logical: #&gt; returning NA #&gt; [1] NA # Vector (right for math) numbers_vec &lt;- c(1, 2, 3, 4, 5) mean(numbers_vec) # Works! #&gt; [1] 3 4.5.3.2 Cause 2: Extracting From Data Frame Incorrectly df &lt;- data.frame(x = 1:5, y = 6:10) # Single bracket returns data frame (list-based) sum(df[1]) # Error - still a data frame #&gt; [1] 15 # Double bracket returns vector sum(df[[1]]) # Works! #&gt; [1] 15 # Dollar sign returns vector sum(df$x) # Works! #&gt; [1] 15 4.5.3.3 Cause 3: List Column in Data Frame # Modern R can have list columns df &lt;- data.frame(id = 1:3) df$values &lt;- list(c(1,2), c(3,4), c(5,6)) # Can&#39;t do math on list column sum(df$values) # Error! #&gt; Error in sum(df$values): invalid &#39;type&#39; (list) of argument 4.5.4 Solutions ‚úÖ SOLUTION 1: Convert List to Vector my_list &lt;- list(a = 1, b = 2, c = 3) # Unlist to vector unlist(my_list) #&gt; a b c #&gt; 1 2 3 sum(unlist(my_list)) #&gt; [1] 6 # Or use do.call do.call(sum, my_list) #&gt; [1] 6 ‚úÖ SOLUTION 2: Use Correct Extraction df &lt;- data.frame(x = 1:5, y = 6:10) # Good ways: sum(df$x) # Dollar sign #&gt; [1] 15 sum(df[[1]]) # Double bracket #&gt; [1] 15 sum(df[, 1]) # Bracket with comma #&gt; [1] 15 # Bad way: # sum(df[1]) # Single bracket = data frame ‚úÖ SOLUTION 3: Handle List Columns df &lt;- data.frame(id = 1:3) df$values &lt;- list(c(1,2), c(3,4), c(5,6)) # Apply operation to each list element sapply(df$values, sum) #&gt; [1] 3 7 11 lapply(df$values, mean) #&gt; [[1]] #&gt; [1] 1.5 #&gt; #&gt; [[2]] #&gt; [1] 3.5 #&gt; #&gt; [[3]] #&gt; [1] 5.5 # Or unnest first (tidyverse) library(tidyr) df %&gt;% unnest(values) #&gt; # A tibble: 6 √ó 2 #&gt; id values #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 1 #&gt; 2 1 2 #&gt; 3 2 3 #&gt; 4 2 4 #&gt; 5 3 5 #&gt; 6 3 6 üí° Key Insight: List vs Vector # Vector: All same type vec &lt;- c(1, 2, 3) typeof(vec) #&gt; [1] &quot;double&quot; class(vec) #&gt; [1] &quot;numeric&quot; # List: Can mix types lst &lt;- list(1, &quot;two&quot;, TRUE) typeof(lst) #&gt; [1] &quot;list&quot; class(lst) #&gt; [1] &quot;list&quot; # Data frame: Special list of vectors df &lt;- data.frame(x = 1:3, y = 4:6) typeof(df) # &quot;list&quot;! #&gt; [1] &quot;list&quot; class(df) # &quot;data.frame&quot; #&gt; [1] &quot;data.frame&quot; # Single bracket keeps structure df[1] # Data frame (list) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 df[[1]] # Vector #&gt; [1] 1 2 3 4.6 Error #4: invalid type (closure) for variable 'X' ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 4.6.1 The Error # Accidentally using a function as data data &lt;- data.frame(x = 1:5) plot(mean, data$x) # mean is the function! #&gt; Error in curve(expr = x, from = from, to = to, xlim = xlim, ylab = ylab, : &#39;expr&#39; did not evaluate to an object of length &#39;n&#39; üî¥ ERROR Error in plot.xy(xy.coords(x, y), type = type, ...) : invalid type (closure) for variable &#39;mean&#39; 4.6.2 What It Means ‚ÄúClosure‚Äù = function. You passed a function where R expected data. 4.6.3 Common Causes 4.6.3.1 Cause 1: Forgot to Call Function numbers &lt;- 1:10 plot(mean, numbers) # Passed function itself #&gt; Error in curve(expr = x, from = from, to = to, xlim = xlim, ylab = ylab, : &#39;expr&#39; did not evaluate to an object of length &#39;n&#39; # Fix: Call the function plot(mean(numbers), numbers) #&gt; Error in xy.coords(x, y, xlabel, ylabel, log): &#39;x&#39; and &#39;y&#39; lengths differ 4.6.3.2 Cause 2: Variable Name Same as Function # Created variable named &#39;c&#39; c &lt;- 100 data &lt;- c(1, 2, 3) # Now c() function is masked! # Later, someone tries to use the function # But &#39;c&#39; is now the number 100 # Check what something is is.function(mean) #&gt; [1] TRUE is.function(100) #&gt; [1] FALSE 4.6.4 Solutions ‚úÖ SOLUTIONS 1. Call the function (add parentheses): # Wrong: plot(mean, data) # Right: plot(mean(data), ...) 2. Don‚Äôt name variables after functions: # Bad: # mean &lt;- 42 # sum &lt;- 100 # data &lt;- my_data # Good: average_value &lt;- 42 total_sum &lt;- 100 my_data &lt;- ... #&gt; Error: &#39;...&#39; used in an incorrect context 3. Remove conflicting variable: # If you accidentally created: # sum &lt;- 100 # Remove it: rm(sum) #&gt; Warning in rm(sum): object &#39;sum&#39; not found # Now sum() function works again sum(1:10) #&gt; [1] 55 4.7 Error #5: cannot coerce class \"X\" to a data.frame ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 4.7.1 The Error # Trying to convert incompatible type my_func &lt;- function() { return(42) } as.data.frame(my_func) #&gt; Error in as.data.frame.default(my_func): cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame üî¥ ERROR Error in as.data.frame.default(my_func) : cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame 4.7.2 Common Causes 4.7.2.1 Cause 1: Wrong Object Type # Can&#39;t convert function as.data.frame(mean) #&gt; Error in as.data.frame.default(mean): cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame # Can&#39;t convert environment as.data.frame(.GlobalEnv) #&gt; Error in as.data.frame.default(.GlobalEnv): cannot coerce class &#39;&quot;environment&quot;&#39; to a data.frame 4.7.2.2 Cause 2: Wrong List Structure # Uneven list lengths bad_list &lt;- list(a = 1:3, b = 1:5) as.data.frame(bad_list) # Error - different lengths! #&gt; Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 5 # Must be same length or length 1 good_list &lt;- list(a = 1:3, b = 4:6) as.data.frame(good_list) #&gt; a b #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 # Or use recycling recycled_list &lt;- list(a = 1:3, b = 1) # b recycled as.data.frame(recycled_list) #&gt; a b #&gt; 1 1 1 #&gt; 2 2 1 #&gt; 3 3 1 4.7.2.3 Cause 3: Matrix With Wrong Type # Some object types don&#39;t convert cleanly nested &lt;- list(list(1, 2), list(3, 4)) as.data.frame(nested) # Error - nested lists! #&gt; X1 X2 X3 X4 #&gt; 1 1 2 3 4 4.7.3 Solutions ‚úÖ SOLUTION 1: Fix List Structure # Uneven lengths - fix it bad_list &lt;- list(a = 1:3, b = 1:5) # Option 1: Trim to shortest min_len &lt;- min(lengths(bad_list)) fixed_list &lt;- lapply(bad_list, function(x) x[1:min_len]) as.data.frame(fixed_list) #&gt; a b #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 3 # Option 2: Pad with NA max_len &lt;- max(lengths(bad_list)) fixed_list &lt;- lapply(bad_list, function(x) { c(x, rep(NA, max_len - length(x))) }) as.data.frame(fixed_list) #&gt; a b #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 3 #&gt; 4 NA 4 #&gt; 5 NA 5 ‚úÖ SOLUTION 2: Convert Correctly # From matrix mat &lt;- matrix(1:6, nrow = 2) as.data.frame(mat) #&gt; V1 V2 V3 #&gt; 1 1 3 5 #&gt; 2 2 4 6 # From vector with names vec &lt;- c(a = 1, b = 2, c = 3) as.data.frame(as.list(vec)) #&gt; a b c #&gt; 1 1 2 3 # From nested list - flatten first nested &lt;- list(list(1, 2), list(3, 4)) flat &lt;- unlist(nested, recursive = FALSE) # Or handle differently depending on structure ‚úÖ SOLUTION 3: Check Before Converting safe_as_df &lt;- function(x) { # Check if it&#39;s already a data frame if (is.data.frame(x)) return(x) # Check if it&#39;s a matrix if (is.matrix(x)) return(as.data.frame(x)) # Check if it&#39;s a list with equal lengths if (is.list(x)) { lens &lt;- lengths(x) if (length(unique(lens)) == 1 || all(lens == 1 | lens == max(lens))) { return(as.data.frame(x)) } else { stop(&quot;List elements have incompatible lengths: &quot;, paste(lens, collapse = &quot;, &quot;)) } } # Try generic conversion tryCatch( as.data.frame(x), error = function(e) { stop(&quot;Cannot convert &quot;, class(x), &quot; to data.frame: &quot;, e$message) } ) } # Test safe_as_df(list(a = 1:3, b = 4:6)) # Works #&gt; a b #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 4.8 Error #6: NAs introduced by coercion ‚≠ê BEGINNER üî¢ TYPE 4.8.1 The Warning (Usually) as.numeric(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)) #&gt; Warning: NAs introduced by coercion #&gt; [1] 1 2 NA 4 üü° WARNING Warning message: NAs introduced by coercion 4.8.2 What It Means R tried to convert something to numeric, but some values couldn‚Äôt be converted, so they became NA. 4.8.3 Common Scenarios 4.8.3.1 Scenario 1: Text in Numeric Column # Data entry errors scores &lt;- c(&quot;90&quot;, &quot;85&quot;, &quot;N/A&quot;, &quot;92&quot;, &quot;absent&quot;) as.numeric(scores) #&gt; Warning: NAs introduced by coercion #&gt; [1] 90 85 NA 92 NA # Check which became NA is.na(as.numeric(scores)) #&gt; Warning: NAs introduced by coercion #&gt; [1] FALSE FALSE TRUE FALSE TRUE 4.8.3.2 Scenario 2: Special Characters # Currency symbols prices &lt;- c(&quot;$10.99&quot;, &quot;$25.50&quot;, &quot;$8.75&quot;) as.numeric(prices) # All become NA! #&gt; Warning: NAs introduced by coercion #&gt; [1] NA NA NA # Need to remove $ first as.numeric(gsub(&quot;\\\\$&quot;, &quot;&quot;, prices)) #&gt; [1] 10.99 25.50 8.75 4.8.3.3 Scenario 3: Scientific Notation Issues # Usually these work fine as.numeric(&quot;1.5e-10&quot;) # Scientific notation OK #&gt; [1] 1.5e-10 # But typos don&#39;t as.numeric(&quot;1.5E-10a&quot;) # Typo creates NA #&gt; Warning: NAs introduced by coercion #&gt; [1] NA 4.8.3.4 Scenario 4: Factors with Text Levels # Factor with non-numeric levels responses &lt;- factor(c(&quot;Yes&quot;, &quot;No&quot;, &quot;Yes&quot;, &quot;Maybe&quot;)) as.numeric(responses) # Gives factor codes (1,2,1,3), not what you want #&gt; [1] 3 2 3 1 # And trying to convert to the levels gives NA as.numeric(as.character(responses)) #&gt; Warning: NAs introduced by coercion #&gt; [1] NA NA NA NA 4.8.4 Solutions ‚úÖ SOLUTION 1: Clean Data First # Remove non-numeric characters dirty &lt;- c(&quot;$10.99&quot;, &quot;‚Ç¨25.50&quot;, &quot;8.75&quot;) # Remove currency symbols clean &lt;- gsub(&quot;[^0-9.]&quot;, &quot;&quot;, dirty) as.numeric(clean) #&gt; [1] 10.99 25.50 8.75 # More robust cleaning clean_numeric &lt;- function(x) { # Remove everything except numbers, decimal, minus cleaned &lt;- gsub(&quot;[^0-9.-]&quot;, &quot;&quot;, x) as.numeric(cleaned) } clean_numeric(c(&quot;$10.99&quot;, &quot;-25.5%&quot;, &quot;8 dollars&quot;)) #&gt; [1] 10.99 -25.50 8.00 ‚úÖ SOLUTION 2: Handle NAs Explicitly values &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;) converted &lt;- as.numeric(values) #&gt; Warning: NAs introduced by coercion # Check which failed failed &lt;- is.na(converted) &amp; !is.na(values) if (any(failed)) { message(&quot;Could not convert: &quot;, paste(values[failed], collapse = &quot;, &quot;)) } #&gt; Could not convert: three # Or replace NAs with default converted[is.na(converted)] &lt;- 0 converted #&gt; [1] 1 2 0 4 ‚úÖ SOLUTION 3: Use readr‚Äôs parse_number() library(readr) # Automatically extracts numbers parse_number(&quot;$10.99&quot;) #&gt; [1] 10.99 parse_number(&quot;Price: $25.50&quot;) #&gt; [1] 25.5 parse_number(&quot;8.75%&quot;) #&gt; [1] 8.75 # Vector parse_number(c(&quot;$10.99&quot;, &quot;‚Ç¨25.50&quot;, &quot;8.75&quot;)) #&gt; [1] 10.99 25.50 8.75 üéØ Best Practice: Validate After Coercion coerce_with_validation &lt;- function(x, to = &quot;numeric&quot;) { original &lt;- x if (to == &quot;numeric&quot;) { converted &lt;- as.numeric(x) } else if (to == &quot;integer&quot;) { converted &lt;- as.integer(x) } else { stop(&quot;Unsupported conversion type&quot;) } # Count NAs original_nas &lt;- sum(is.na(original)) new_nas &lt;- sum(is.na(converted)) introduced_nas &lt;- new_nas - original_nas if (introduced_nas &gt; 0) { warning(introduced_nas, &quot; NAs introduced by coercion&quot;) failed_values &lt;- original[is.na(converted) &amp; !is.na(original)] message(&quot;Failed to convert: &quot;, paste(head(failed_values, 5), collapse = &quot;, &quot;), if(length(failed_values) &gt; 5) &quot;...&quot; else &quot;&quot;) } return(converted) } # Test coerce_with_validation(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)) #&gt; Warning in coerce_with_validation(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)): NAs introduced by #&gt; coercion #&gt; Warning in coerce_with_validation(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;)): 1 NAs introduced #&gt; by coercion #&gt; Failed to convert: three #&gt; [1] 1 2 NA 4 4.9 Error #7: character string is not in a standard unambiguous format ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 4.9.1 The Error as.Date(&quot;2024/13/01&quot;) # Month 13 doesn&#39;t exist #&gt; Error in charToDate(x): character string is not in a standard unambiguous format üî¥ ERROR Error in charToDate(x) : character string is not in a standard unambiguous format 4.9.2 What It Means You‚Äôre trying to convert a string to a Date, but R can‚Äôt figure out the format, or the date is invalid. 4.9.3 Common Causes 4.9.3.1 Cause 1: Wrong Date Format # American format (month/day/year) as.Date(&quot;12/25/2024&quot;) # R expects YYYY-MM-DD #&gt; Error in charToDate(x): character string is not in a standard unambiguous format # Specify format as.Date(&quot;12/25/2024&quot;, format = &quot;%m/%d/%Y&quot;) #&gt; [1] &quot;2024-12-25&quot; 4.9.3.2 Cause 2: Invalid Date as.Date(&quot;2024-02-30&quot;) # February doesn&#39;t have 30 days #&gt; Error in charToDate(x): character string is not in a standard unambiguous format as.Date(&quot;2024-13-01&quot;) # Month 13 doesn&#39;t exist #&gt; Error in charToDate(x): character string is not in a standard unambiguous format 4.9.3.3 Cause 3: Ambiguous Format # Is this Jan 2 or Feb 1? as.Date(&quot;01/02/2024&quot;) # R gets confused #&gt; [1] &quot;0001-02-20&quot; # Be explicit as.Date(&quot;01/02/2024&quot;, format = &quot;%m/%d/%Y&quot;) # Jan 2 #&gt; [1] &quot;2024-01-02&quot; as.Date(&quot;01/02/2024&quot;, format = &quot;%d/%m/%Y&quot;) # Feb 1 #&gt; [1] &quot;2024-02-01&quot; 4.9.4 Solutions ‚úÖ SOLUTION 1: Specify Format # Common formats as.Date(&quot;2024-12-25&quot;) # ISO format (default) #&gt; [1] &quot;2024-12-25&quot; as.Date(&quot;12/25/2024&quot;, format = &quot;%m/%d/%Y&quot;) #&gt; [1] &quot;2024-12-25&quot; as.Date(&quot;25/12/2024&quot;, format = &quot;%d/%m/%Y&quot;) #&gt; [1] &quot;2024-12-25&quot; as.Date(&quot;Dec 25, 2024&quot;, format = &quot;%b %d, %Y&quot;) #&gt; [1] &quot;2024-12-25&quot; as.Date(&quot;December 25, 2024&quot;, format = &quot;%B %d, %Y&quot;) #&gt; [1] &quot;2024-12-25&quot; Format codes: - %Y = 4-digit year (2024) - %y = 2-digit year (24) - %m = numeric month (12) - %d = day of month (25) - %b = abbreviated month (Dec) - %B = full month (December) ‚úÖ SOLUTION 2: Use lubridate (Easier!) library(lubridate) #&gt; #&gt; Attaching package: &#39;lubridate&#39; #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; date, intersect, setdiff, union # Auto-detect common formats ymd(&quot;2024-12-25&quot;) #&gt; [1] &quot;2024-12-25&quot; mdy(&quot;12/25/2024&quot;) #&gt; [1] &quot;2024-12-25&quot; dmy(&quot;25/12/2024&quot;) #&gt; [1] &quot;2024-12-25&quot; mdy(&quot;Dec 25, 2024&quot;) #&gt; [1] &quot;2024-12-25&quot; # Vector of dates dates &lt;- c(&quot;2024-12-25&quot;, &quot;2024/01/15&quot;, &quot;2024.06.30&quot;) ymd(dates) #&gt; [1] &quot;2024-12-25&quot; &quot;2024-01-15&quot; &quot;2024-06-30&quot; ‚úÖ SOLUTION 3: Handle Parse Failures dates &lt;- c(&quot;2024-12-25&quot;, &quot;invalid&quot;, &quot;2024-02-30&quot;, &quot;2024-01-15&quot;) # Base R - NAs for failures parsed &lt;- as.Date(dates) # Warnings parsed #&gt; [1] &quot;2024-12-25&quot; NA NA &quot;2024-01-15&quot; # lubridate - shows which failed library(lubridate) parsed &lt;- ymd(dates, quiet = FALSE) #&gt; Warning: 2 failed to parse. parsed #&gt; [1] &quot;2024-12-25&quot; NA NA &quot;2024-01-15&quot; # Custom handling safe_parse_date &lt;- function(x, format = &quot;%Y-%m-%d&quot;) { result &lt;- as.Date(x, format = format) # Report failures failed &lt;- is.na(result) &amp; !is.na(x) if (any(failed)) { message(&quot;Failed to parse &quot;, sum(failed), &quot; dates:&quot;) message(paste(x[failed], collapse = &quot;, &quot;)) } return(result) } safe_parse_date(dates) #&gt; Failed to parse 2 dates: #&gt; invalid, 2024-02-30 #&gt; [1] &quot;2024-12-25&quot; NA NA &quot;2024-01-15&quot; 4.10 Type Checking Functions üéØ Best Practice: Check Types Before Operating # Checking functions is.numeric(5) # TRUE for integer or double #&gt; [1] TRUE is.integer(5L) # TRUE only for integer #&gt; [1] TRUE is.double(5.0) # TRUE only for double #&gt; [1] TRUE is.character(&quot;5&quot;) # TRUE for character #&gt; [1] TRUE is.logical(TRUE) # TRUE for logical #&gt; [1] TRUE is.factor(factor(1:3)) # TRUE for factor #&gt; [1] TRUE # Getting type info typeof(5) # &quot;double&quot; #&gt; [1] &quot;double&quot; class(5) # &quot;numeric&quot; #&gt; [1] &quot;numeric&quot; mode(5) # &quot;numeric&quot; #&gt; [1] &quot;numeric&quot; # More specific checks is.na(NA) # TRUE for NA #&gt; [1] TRUE is.null(NULL) # TRUE for NULL #&gt; [1] TRUE is.nan(NaN) # TRUE for NaN (not a number) #&gt; [1] TRUE is.infinite(Inf) # TRUE for Inf #&gt; [1] TRUE is.finite(5) # TRUE for normal numbers #&gt; [1] TRUE # Structure checks is.vector(c(1,2,3)) # TRUE #&gt; [1] TRUE is.list(list(1,2)) # TRUE #&gt; [1] TRUE is.matrix(matrix(1:4, 2, 2)) # TRUE #&gt; [1] TRUE is.data.frame(data.frame(x=1:3)) # TRUE #&gt; [1] TRUE is.array(array(1:8, dim=c(2,2,2))) # TRUE #&gt; [1] TRUE 4.11 Type Conversion Functions üí° Key Insight: Conversion Functions # To numeric as.numeric(&quot;5&quot;) #&gt; [1] 5 as.integer(&quot;5&quot;) #&gt; [1] 5 as.double(&quot;5.5&quot;) #&gt; [1] 5.5 # To character as.character(5) #&gt; [1] &quot;5&quot; as.character(TRUE) #&gt; [1] &quot;TRUE&quot; # To logical as.logical(1) # TRUE #&gt; [1] TRUE as.logical(0) # FALSE #&gt; [1] FALSE as.logical(&quot;TRUE&quot;) # TRUE #&gt; [1] TRUE as.logical(&quot;T&quot;) # TRUE #&gt; [1] TRUE # To factor as.factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;)) #&gt; [1] A B A #&gt; Levels: A B # Special conversions as.Date(&quot;2024-01-15&quot;) #&gt; [1] &quot;2024-01-15&quot; as.POSIXct(&quot;2024-01-15 10:30:00&quot;) #&gt; [1] &quot;2024-01-15 10:30:00 CST&quot; Coercion Hierarchy: logical ‚Üí integer ‚Üí double ‚Üí character Everything can become character! c(TRUE, 1L, 1.5, &quot;text&quot;) # All become character #&gt; [1] &quot;TRUE&quot; &quot;1&quot; &quot;1.5&quot; &quot;text&quot; 4.12 Summary Key Takeaways: R has 6 atomic types: logical, integer, double, character, complex, raw Check types before operations: Use typeof(), class(), is.*() functions Explicit is better than implicit: Use as.numeric() rather than hoping Watch for silent failures: Check for NAs after coercion Factors are tricky: Convert to character before numeric Lists aren‚Äôt vectors: Use unlist() or [[]] extraction Specify date formats: Don‚Äôt rely on auto-detection Use lubridate for dates: Much easier than base R Quick Reference: Error Cause Fix non-numeric argument to binary operator Character in math as.numeric() non-numeric argument to math function Character in function as.numeric() (list) cannot be coerced Wrong structure unlist() or [[]] invalid type (closure) Function instead of data Call function or rename variable cannot coerce to data.frame Incompatible type Fix structure or use correct conversion NAs introduced by coercion Invalid values Clean data first character string not in standard format Date parse failure Specify format or use lubridate Type Checking Checklist: # Before doing math: is.numeric(x) # Before subsetting: is.vector(x) || is.list(x) # Before data frame operations: is.data.frame(df) # After conversion: any(is.na(result)) 4.13 Exercises üìù Exercise 1: Type Detective What‚Äôs wrong and how do you fix it? # Scenario 1 age &lt;- &quot;25&quot; next_year &lt;- age + 1 # Scenario 2 scores &lt;- factor(c(&quot;90&quot;, &quot;85&quot;, &quot;95&quot;)) average &lt;- mean(as.numeric(scores)) # Scenario 3 df &lt;- data.frame(x = 1:5) total &lt;- sum(df[1]) # Scenario 4 dates &lt;- c(&quot;2024-01-15&quot;, &quot;15/01/2024&quot;, &quot;Jan 15 2024&quot;) parsed &lt;- as.Date(dates) üìù Exercise 2: Type Conversion Write a function that: 1. Takes a vector of any type 2. Tries to convert to numeric 3. Reports which values failed 4. Returns numeric vector with NAs for failures 5. Provides a summary of conversions üìù Exercise 3: Real Data You receive this data: sales &lt;- c(&quot;$1,234.56&quot;, &quot;$987.65&quot;, &quot;N/A&quot;, &quot;$2,345.67&quot;, &quot;pending&quot;) dates &lt;- c(&quot;01/15/2024&quot;, &quot;2024-02-20&quot;, &quot;Mar 15, 2024&quot;) Clean and convert both to appropriate types. üìù Exercise 4: Data Frame Types Debug this code: df &lt;- data.frame( id = 1:3, value = c(&quot;100&quot;, &quot;200&quot;, &quot;300&quot;), date = c(&quot;2024-01-15&quot;, &quot;2024-02-20&quot;, &quot;2024-03-25&quot;) ) # Want to do: df$value_doubled &lt;- df$value * 2 df$days_since &lt;- Sys.Date() - df$date Fix the types so operations work. 4.14 Exercise Answers Click to see answers Exercise 1: # Scenario 1 - Character in math age &lt;- &quot;25&quot; age &lt;- as.numeric(age) # Fix next_year &lt;- age + 1 # Scenario 2 - Factor to numeric wrong way scores &lt;- factor(c(&quot;90&quot;, &quot;85&quot;, &quot;95&quot;)) # Wrong: as.numeric(scores) gives 1,2,3 # Right: scores_num &lt;- as.numeric(as.character(scores)) average &lt;- mean(scores_num) # Scenario 3 - Single bracket returns data frame df &lt;- data.frame(x = 1:5) # Wrong: df[1] is still data frame # Right: total &lt;- sum(df[[1]]) # or sum(df$x) # Scenario 4 - Mixed date formats dates &lt;- c(&quot;2024-01-15&quot;, &quot;15/01/2024&quot;, &quot;Jan 15 2024&quot;) # Need different formats for each library(lubridate) parsed &lt;- c(ymd(&quot;2024-01-15&quot;), dmy(&quot;15/01/2024&quot;), mdy(&quot;Jan 15 2024&quot;)) Exercise 2: smart_numeric_convert &lt;- function(x) { # Store original original &lt;- x original_class &lt;- class(x) # Attempt conversion converted &lt;- suppressWarnings(as.numeric(x)) # Identify failures original_na &lt;- is.na(original) new_na &lt;- is.na(converted) failures &lt;- new_na &amp; !original_na # Report cat(&quot;Conversion Summary:\\n&quot;) cat(&quot; Original type:&quot;, original_class, &quot;\\n&quot;) cat(&quot; Total values:&quot;, length(x), &quot;\\n&quot;) cat(&quot; Successful:&quot;, sum(!new_na), &quot;\\n&quot;) cat(&quot; Failed:&quot;, sum(failures), &quot;\\n&quot;) cat(&quot; Already NA:&quot;, sum(original_na), &quot;\\n\\n&quot;) if (any(failures)) { cat(&quot;Failed values:\\n&quot;) print(head(original[failures], 10)) } return(converted) } # Test smart_numeric_convert(c(&quot;1&quot;, &quot;2&quot;, &quot;three&quot;, &quot;4&quot;, &quot;five&quot;)) #&gt; Conversion Summary: #&gt; Original type: character #&gt; Total values: 5 #&gt; Successful: 3 #&gt; Failed: 2 #&gt; Already NA: 0 #&gt; #&gt; Failed values: #&gt; [1] &quot;three&quot; &quot;five&quot; #&gt; [1] 1 2 NA 4 NA Exercise 3: library(readr) library(lubridate) # Clean sales sales &lt;- c(&quot;$1,234.56&quot;, &quot;$987.65&quot;, &quot;N/A&quot;, &quot;$2,345.67&quot;, &quot;pending&quot;) # Remove currency and commas, handle text sales_clean &lt;- gsub(&quot;[$,]&quot;, &quot;&quot;, sales) sales_num &lt;- suppressWarnings(as.numeric(sales_clean)) sales_num[is.na(sales_num)] &lt;- 0 # Or handle differently # Clean dates dates &lt;- c(&quot;01/15/2024&quot;, &quot;2024-02-20&quot;, &quot;Mar 15, 2024&quot;) # Try multiple formats dates_parsed &lt;- as.Date(parse_date_time(dates, orders = c(&quot;mdy&quot;, &quot;ymd&quot;, &quot;bdy&quot;))) # Result data.frame( sales = sales_num, date = dates_parsed ) #&gt; Error in data.frame(sales = sales_num, date = dates_parsed): arguments imply differing number of rows: 5, 3 Exercise 4: df &lt;- data.frame( id = 1:3, value = c(&quot;100&quot;, &quot;200&quot;, &quot;300&quot;), date = c(&quot;2024-01-15&quot;, &quot;2024-02-20&quot;, &quot;2024-03-25&quot;), stringsAsFactors = FALSE ) # Fix types df$value &lt;- as.numeric(df$value) df$date &lt;- as.Date(df$date) # Now operations work df$value_doubled &lt;- df$value * 2 df$days_since &lt;- as.numeric(Sys.Date() - df$date) df #&gt; id value date value_doubled days_since #&gt; 1 1 100 2024-01-15 200 649 #&gt; 2 2 200 2024-02-20 400 613 #&gt; 3 3 300 2024-03-25 600 579 "],["vectors-recycling.html", "Chapter 5 Vectors &amp; Recycling 5.1 Introduction 5.2 Understanding Recycling 5.3 Error #1: longer object length is not a multiple 5.4 Error #2: replacement has X rows, data has Y 5.5 Error #3: number of items to replace is not a multiple 5.6 Error #4: replacement has length zero 5.7 Vectorization Best Practices 5.8 Understanding Vector Operations 5.9 Edge Cases and Gotchas 5.10 Debugging Recycling Issues 5.11 Summary 5.12 Exercises 5.13 Exercise Answers", " Chapter 5 Vectors &amp; Recycling What You‚Äôll Learn: How R‚Äôs vector recycling works When recycling helps and when it hurts Length mismatch errors Replacement length errors Vectorization best practices Key Errors Covered: 15+ recycling and length errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 5.1 Introduction R‚Äôs superpower is vectorization - operations work on entire vectors at once. But with this power comes a quirky feature called recycling that causes endless confusion. # Simple vectorization c(1, 2, 3) + c(10, 20, 30) #&gt; [1] 11 22 33 But what about this? # Different lengths! c(1, 2, 3, 4) + c(10, 20) #&gt; [1] 11 22 13 24 It works! But is this what you wanted? Let‚Äôs explore when recycling helps and when it causes errors. 5.2 Understanding Recycling üí° Key Insight: The Recycling Rule When vectors of different lengths are used together, R repeats the shorter one to match the longer one. # What happens: c(1, 2, 3, 4) + c(10, 20) #&gt; [1] 11 22 13 24 # R expands to: c(1, 2, 3, 4) + c(10, 20, 10, 20) #&gt; [1] 11 22 13 24 # ‚Üë ‚Üë recycled! Works smoothly when: - One vector is length 1 (scalar) - Lengths are multiples (2 and 4, 3 and 6) Warns when: - Lengths aren‚Äôt multiples (3 and 5) Errors when: - Replacement context and lengths don‚Äôt match 5.3 Error #1: longer object length is not a multiple ‚≠ê BEGINNER üìè LENGTH 5.3.1 The Warning c(1, 2, 3) + c(10, 20, 30, 40, 50) #&gt; Warning in c(1, 2, 3) + c(10, 20, 30, 40, 50): longer object length is not a #&gt; multiple of shorter object length #&gt; [1] 11 22 33 41 52 üü° WARNING Warning message: In c(1, 2, 3) + c(10, 20, 30, 40, 50) : longer object length is not a multiple of shorter object length 5.3.2 What It Means R is recycling, but the lengths don‚Äôt match evenly. This usually indicates a mistake. 5.3.3 Common Causes 5.3.3.1 Cause 1: Data Mismatch # You have 100 observations data &lt;- rnorm(100) # But only 3 group labels groups &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # Recycling happens combined &lt;- data.frame(value = data, group = groups) #&gt; Error in data.frame(value = data, group = groups): arguments imply differing number of rows: 100, 3 The warning tells you: ‚ÄúHey, are you sure about this?‚Äù 5.3.3.2 Cause 2: Filtering Gone Wrong x &lt;- 1:10 y &lt;- 1:7 # Oops, lost some values # Operations warn x + y #&gt; Warning in x + y: longer object length is not a multiple of shorter object #&gt; length #&gt; [1] 2 4 6 8 10 12 14 9 11 13 x * y #&gt; Warning in x * y: longer object length is not a multiple of shorter object #&gt; length #&gt; [1] 1 4 9 16 25 36 49 8 18 30 5.3.3.3 Cause 3: Unintended Partial Matching treatment &lt;- c(&quot;Drug&quot;, &quot;Placebo&quot;) outcomes &lt;- rnorm(25) # 25 subjects # Assigning treatment to outcomes data.frame(outcome = outcomes, treatment = treatment) #&gt; Error in data.frame(outcome = outcomes, treatment = treatment): arguments imply differing number of rows: 25, 2 Warning: 25 is not a multiple of 2! 5.3.4 Solutions ‚úÖ SOLUTION 1: Fix the Lengths # Original problem x &lt;- 1:10 y &lt;- 1:7 # Option A: Trim to match min_len &lt;- min(length(x), length(y)) x[1:min_len] + y[1:min_len] #&gt; [1] 2 4 6 8 10 12 14 # Option B: Extend with NA y_extended &lt;- c(y, rep(NA, length(x) - length(y))) x + y_extended #&gt; [1] 2 4 6 8 10 12 14 NA NA NA # Option C: Explicit recycling (if intentional) y_recycled &lt;- rep(y, length.out = length(x)) x + y_recycled #&gt; [1] 2 4 6 8 10 12 14 9 11 13 ‚úÖ SOLUTION 2: Check Lengths Before Operating safe_operation &lt;- function(x, y, op = `+`) { if (length(x) != length(y)) { # Check if one is length 1 (scalar - OK) if (length(x) == 1 || length(y) == 1) { return(op(x, y)) } # Check if lengths are multiples if (max(length(x), length(y)) %% min(length(x), length(y)) != 0) { warning(&quot;Lengths are not multiples: &quot;, length(x), &quot; and &quot;, length(y)) } } return(op(x, y)) } # Test safe_operation(1:10, 1:7, `+`) # Warns #&gt; Warning in safe_operation(1:10, 1:7, `+`): Lengths are not multiples: 10 and 7 #&gt; Warning in op(x, y): longer object length is not a multiple of shorter object #&gt; length #&gt; [1] 2 4 6 8 10 12 14 9 11 13 safe_operation(1:10, 1:5, `+`) # No warning (10/5 = 2) #&gt; [1] 2 4 6 8 10 7 9 11 13 15 safe_operation(1:10, 2, `+`) # No warning (scalar) #&gt; [1] 3 4 5 6 7 8 9 10 11 12 ‚úÖ SOLUTION 3: Use rep() Explicitly # Make intention clear x &lt;- 1:12 pattern &lt;- c(1, 2, 3) # Explicit recycling y &lt;- rep(pattern, length.out = length(x)) x + y #&gt; [1] 2 4 6 5 7 9 8 10 12 11 13 15 # Or with times y &lt;- rep(pattern, times = length(x) / length(pattern)) x + y #&gt; [1] 2 4 6 5 7 9 8 10 12 11 13 15 ‚ö†Ô∏è Common Pitfall: Silent Recycling with Multiples # No warning when lengths are multiples! x &lt;- 1:6 y &lt;- c(10, 20, 30) # 6 is multiple of 3 result &lt;- x + y result #&gt; [1] 11 22 33 14 25 36 # R expanded y to: c(10, 20, 30, 10, 20, 30) # Was this intended? Always check: Just because it doesn‚Äôt warn doesn‚Äôt mean it‚Äôs correct! 5.4 Error #2: replacement has X rows, data has Y ‚≠ê‚≠ê INTERMEDIATE üìè LENGTH 5.4.1 The Error df &lt;- data.frame(x = 1:5, y = 6:10) df$z &lt;- 1:3 # Wrong length! #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, z, value = 1:3): replacement has 3 rows, data has 5 üî¥ ERROR Error in `$&lt;-.data.frame`(`*tmp*`, z, value = 1:3) : replacement has 3 rows, data has 5 5.4.2 What It Means You‚Äôre trying to add/replace a column, but the number of values doesn‚Äôt match the number of rows. 5.4.3 Common Causes 5.4.3.1 Cause 1: Wrong Length Column df &lt;- data.frame(id = 1:10) # Calculated something with wrong length summary_values &lt;- c(100, 200, 300) # Only 3 values # Try to add as column df$summary &lt;- summary_values # Error! #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, summary, value = c(100, 200, 300)): replacement has 3 rows, data has 10 5.4.3.2 Cause 2: Filtered Data Reassignment df &lt;- data.frame(x = 1:10, y = rnorm(10)) # Filter subset_df &lt;- df[df$y &gt; 0, ] # Maybe 6 rows # Create column for subset new_values &lt;- 1:6 # Try to add to original df$new &lt;- new_values # Error! Original has 10 rows #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, new, value = 1:6): replacement has 6 rows, data has 10 5.4.3.3 Cause 3: Aggregation Length Mismatch # 20 observations df &lt;- data.frame( id = 1:20, group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 10) ) # Aggregate to 2 values (one per group) group_means &lt;- tapply(df$id, df$group, mean) # Try to add back to original df$group_mean &lt;- group_means # Error! 2 values, 20 rows 5.4.4 Solutions ‚úÖ SOLUTION 1: Match the Length df &lt;- data.frame(id = 1:10) summary_values &lt;- c(100, 200, 300) # Recycle explicitly df$summary &lt;- rep(summary_values, length.out = nrow(df)) # Or extend with NA df$summary &lt;- c(summary_values, rep(NA, nrow(df) - length(summary_values))) ‚úÖ SOLUTION 2: Use Merge/Join for Aggregates # Original data df &lt;- data.frame( id = 1:20, group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 10), value = rnorm(20) ) # Aggregate group_summary &lt;- aggregate(value ~ group, df, mean) names(group_summary)[2] &lt;- &quot;group_mean&quot; # Merge back df &lt;- merge(df, group_summary, by = &quot;group&quot;) head(df) #&gt; group id value group_mean #&gt; 1 A 1 1.16715753 0.3217156 #&gt; 2 A 2 0.18647019 0.3217156 #&gt; 3 A 3 1.05538946 0.3217156 #&gt; 4 A 4 0.14981825 0.3217156 #&gt; 5 A 5 -0.39747942 0.3217156 #&gt; 6 A 6 0.05905702 0.3217156 ‚úÖ SOLUTION 3: dplyr Way (Cleaner) library(dplyr) #&gt; #&gt; Attaching package: &#39;dplyr&#39; #&gt; The following objects are masked from &#39;package:stats&#39;: #&gt; #&gt; filter, lag #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; intersect, setdiff, setequal, union df &lt;- data.frame( id = 1:20, group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 10), value = rnorm(20) ) # Add group mean to each row df &lt;- df %&gt;% group_by(group) %&gt;% mutate(group_mean = mean(value)) %&gt;% ungroup() head(df) #&gt; # A tibble: 6 √ó 4 #&gt; id group value group_mean #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 A 0.528 0.168 #&gt; 2 2 A 1.03 0.168 #&gt; 3 3 A 1.23 0.168 #&gt; 4 4 A 0.860 0.168 #&gt; 5 5 A -0.813 0.168 #&gt; 6 6 A 0.482 0.168 5.5 Error #3: number of items to replace is not a multiple ‚≠ê‚≠ê INTERMEDIATE üìè LENGTH 5.5.1 The Error x &lt;- 1:10 x[1:7] &lt;- c(100, 200) # 7 positions, 2 values #&gt; Warning in x[1:7] &lt;- c(100, 200): number of items to replace is not a multiple #&gt; of replacement length üî¥ ERROR Error in x[1:7] &lt;- c(100, 200) : number of items to replace is not a multiple of replacement length 5.5.2 What It Means You‚Äôre replacing a subset, but the lengths don‚Äôt match evenly (not multiples). 5.5.3 When This Happens # Replacing 10 items with 3 values x &lt;- 1:10 x[] &lt;- c(1, 2, 3) # 10 is not a multiple of 3 #&gt; Warning in x[] &lt;- c(1, 2, 3): number of items to replace is not a multiple of #&gt; replacement length # Replacing 7 items with 2 values x[1:7] &lt;- c(10, 20) # 7 is not a multiple of 2 #&gt; Warning in x[1:7] &lt;- c(10, 20): number of items to replace is not a multiple of #&gt; replacement length But these work: # Length 1 always works x &lt;- 1:10 x[1:7] &lt;- 99 x #&gt; [1] 99 99 99 99 99 99 99 8 9 10 # Multiples work x &lt;- 1:10 x[1:6] &lt;- c(10, 20, 30) # 6 is multiple of 3 x #&gt; [1] 10 20 30 10 20 30 7 8 9 10 5.5.4 Solutions ‚úÖ SOLUTION 1: Make Lengths Match x &lt;- 1:10 # Option A: Recycle explicitly replacement &lt;- rep(c(100, 200), length.out = 7) x[1:7] &lt;- replacement x #&gt; [1] 100 200 100 200 100 200 100 8 9 10 # Option B: Subset to match x &lt;- 1:10 x[1:2] &lt;- c(100, 200) # Only replace 2 x #&gt; [1] 100 200 3 4 5 6 7 8 9 10 ‚úÖ SOLUTION 2: Use ifelse() for Conditional Replacement x &lt;- 1:10 # Replace first 7 with pattern x &lt;- ifelse(seq_along(x) &lt;= 7, rep(c(100, 200), length.out = length(x))[seq_along(x)], x) x #&gt; [1] 100 200 100 200 100 200 100 8 9 10 5.6 Error #4: replacement has length zero ‚≠ê‚≠ê INTERMEDIATE üìè LENGTH 5.6.1 The Error x &lt;- 1:5 x[3] &lt;- c() # Empty vector! #&gt; Error in x[3] &lt;- c(): replacement has length zero üî¥ ERROR Error in x[3] &lt;- c() : replacement has length zero 5.6.2 What It Means You‚Äôre trying to replace elements with an empty vector (length 0). 5.6.3 Common Causes 5.6.3.1 Cause 1: Empty Filter Result df &lt;- data.frame(x = 1:10, y = letters[1:10]) # Filter returns empty subset_values &lt;- df$x[df$y == &quot;z&quot;] # No &quot;z&quot;, returns numeric(0) # Try to use for replacement df$new[1:5] &lt;- subset_values # Error! 5.6.3.2 Cause 2: Function Returns Empty get_values &lt;- function(condition) { if (condition) { return(1:5) } else { return(numeric(0)) # Oops! } } x &lt;- 1:10 x[1:5] &lt;- get_values(FALSE) # Error! #&gt; Error in x[1:5] &lt;- get_values(FALSE): replacement has length zero 5.6.4 Solutions ‚úÖ SOLUTION 1: Check Before Replacing x &lt;- 1:10 replacement &lt;- numeric(0) # Empty # Check first if (length(replacement) &gt; 0) { x[1:length(replacement)] &lt;- replacement } else { message(&quot;No replacement values&quot;) } #&gt; No replacement values ‚úÖ SOLUTION 2: Use NA as Default get_values_safe &lt;- function(condition) { if (condition) { return(1:5) } else { return(NA) # Or a default value } } x &lt;- 1:10 x[1:5] &lt;- get_values_safe(FALSE) # Works, assigns NA x #&gt; [1] NA NA NA NA NA 6 7 8 9 10 5.7 Vectorization Best Practices üéØ Best Practice: Length-Safe Operations # 1. Check lengths match operate_safely &lt;- function(x, y, fun) { if (length(x) != length(y)) { stop(&quot;Vectors must be same length. Got &quot;, length(x), &quot; and &quot;, length(y)) } fun(x, y) } # 2. Use recycling intentionally (scalars only) add_scalar &lt;- function(vec, scalar) { stopifnot(length(scalar) == 1) vec + scalar } # 3. Document recycling behavior #&#39; Add vectors with explicit recycling #&#39; @param x numeric vector #&#39; @param y numeric vector (will be recycled to length of x) add_with_recycling &lt;- function(x, y) { if (length(y) == 1) { return(x + y) # Scalar - always OK } y_recycled &lt;- rep(y, length.out = length(x)) return(x + y_recycled) } 5.8 Understanding Vector Operations üí° Key Insight: What Gets Recycled # Arithmetic operators 1:4 + c(10, 20) # Addition #&gt; [1] 11 22 13 24 1:4 - c(10, 20) # Subtraction #&gt; [1] -9 -18 -7 -16 1:4 * c(2, 3) # Multiplication #&gt; [1] 2 6 6 12 1:4 / c(2, 4) # Division #&gt; [1] 0.5 0.5 1.5 1.0 # Logical operators c(TRUE, FALSE) &amp; c(TRUE, TRUE, FALSE, FALSE) #&gt; [1] TRUE FALSE FALSE FALSE c(TRUE, FALSE) | c(FALSE, FALSE, TRUE, TRUE) #&gt; [1] TRUE FALSE TRUE TRUE # Comparison operators 1:6 &gt; c(2, 4, 6) # Recycles both #&gt; [1] FALSE FALSE FALSE TRUE TRUE FALSE # Assignment x &lt;- 1:12 x[] &lt;- c(1, 2, 3) # Recycles to 12 x #&gt; [1] 1 2 3 1 2 3 1 2 3 1 2 3 Key point: Recycling happens in MANY contexts! 5.9 Edge Cases and Gotchas 5.9.1 Gotcha #1: Matrix Recycling # Matrices recycle by column! matrix(1:2, nrow = 3, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 1 2 #&gt; [2,] 2 1 2 1 #&gt; [3,] 1 2 1 2 Warning appears because 12 (3√ó4) is not multiple of 2. 5.9.2 Gotcha #2: Data Frame Column Recycling # This works - length 1 always recycles df &lt;- data.frame( x = 1:5, y = 10 # Recycled to 5 ) df #&gt; x y #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 # This works - multiple lengths df &lt;- data.frame( x = 1:6, y = c(1, 2) # Recycled to 6 ) df #&gt; x y #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 1 #&gt; 4 4 2 #&gt; 5 5 1 #&gt; 6 6 2 # This fails - not a multiple df &lt;- data.frame( x = 1:5, y = c(1, 2) # 5 is not multiple of 2 ) #&gt; Error in data.frame(x = 1:5, y = c(1, 2)): arguments imply differing number of rows: 5, 2 5.9.3 Gotcha #3: List Operations Don‚Äôt Recycle # Vectors recycle c(1, 2) + c(10, 20, 30) # Works (with warning) #&gt; Warning in c(1, 2) + c(10, 20, 30): longer object length is not a multiple of #&gt; shorter object length #&gt; [1] 11 22 31 # Lists don&#39;t list(1, 2) + list(10, 20, 30) # Error! #&gt; Error in list(1, 2) + list(10, 20, 30): non-numeric argument to binary operator Lists need explicit handling: x &lt;- list(1, 2, 3) y &lt;- list(10, 20) # Use Map or mapply Map(`+`, x, rep(y, length.out = length(x))) #&gt; [[1]] #&gt; [1] 11 #&gt; #&gt; [[2]] #&gt; [1] 22 #&gt; #&gt; [[3]] #&gt; [1] 13 5.10 Debugging Recycling Issues üí° Debugging Checklist # 1. Check lengths x &lt;- 1:10 y &lt;- 1:7 length(x) #&gt; [1] 10 length(y) #&gt; [1] 7 # 2. Check if they&#39;re multiples max(length(x), length(y)) %% min(length(x), length(y)) #&gt; [1] 3 # 0 = clean multiple, anything else = partial recycling # 3. Visualize recycling rep(y, length.out = length(x)) #&gt; [1] 1 2 3 4 5 6 7 1 2 3 # 4. Test operation tryCatch( x + y, warning = function(w) { message(&quot;Warning caught: &quot;, w$message) } ) #&gt; Warning caught: longer object length is not a multiple of shorter object length # 5. Check for unexpected conversions class(x); typeof(x) #&gt; [1] &quot;integer&quot; #&gt; [1] &quot;integer&quot; class(y); typeof(y) #&gt; [1] &quot;integer&quot; #&gt; [1] &quot;integer&quot; 5.11 Summary Key Takeaways: Recycling is automatic: R repeats shorter vectors to match longer ones Warnings appear: When lengths aren‚Äôt multiples (except scalars) Scalars always work: Length 1 recycles to any length Check before operating: Use length() to verify matches Explicit is better: Use rep() to show intent Data frames are strict: Column lengths must match (or be length 1) Errors vs warnings: Replacement operations error, arithmetic operations warn Quick Reference: Situation Behavior Same length No recycling needed One is length 1 Silent recycling (scalar) Lengths are multiples Silent recycling (e.g., 2 and 6) Lengths not multiples Warning + recycling (e.g., 3 and 7) Replacement, wrong length Error (not multiples) Replacement, length 0 Error Data frame column Error if not length 1 or nrow Prevention: # Always check stopifnot(length(x) == length(y)) # Or use scalars only stopifnot(length(y) == 1) # Or recycle explicitly y &lt;- rep(y, length.out = length(x)) Remember: No warning doesn‚Äôt mean correct! Multiples recycle silently. 5.12 Exercises üìù Exercise 1: Predict the Outcome What will happen? Will it work, warn, or error? # A c(1, 2, 3, 4) + c(10, 20) # B c(1, 2, 3, 4, 5) + c(10, 20) # C df &lt;- data.frame(x = 1:10) df$y &lt;- c(1, 2, 3, 4, 5) # D x &lt;- 1:12 x[] &lt;- c(1, 2, 3, 4) # E matrix(1:5, nrow = 5, ncol = 5) üìù Exercise 2: Fix the Code Debug these recycling problems: # Problem 1 students &lt;- 1:25 groups &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) data.frame(student = students, group = groups) # Problem 2 values &lt;- rnorm(100) weights &lt;- c(1, 2, 3) weighted &lt;- values * weights # Problem 3 df &lt;- data.frame(id = 1:20) summary_stats &lt;- c(mean = 50, sd = 10, n = 20) df$mean &lt;- summary_stats[&quot;mean&quot;] üìù Exercise 3: Safe Operations Write a function safe_add(x, y) that: 1. Checks if lengths match 2. If not, asks user what to do: - Error - Recycle shorter - Trim longer - Extend with NA 3. Performs the operation 4. Returns result with attribute showing what was done üìù Exercise 4: Real World You have exam scores for 100 students across 4 quarters: scores_q1 &lt;- rnorm(100, mean = 75, sd = 10) scores_q2 &lt;- rnorm(98, mean = 78, sd = 10) # 2 students dropped scores_q3 &lt;- rnorm(102, mean = 80, sd = 10) # 2 new students scores_q4 &lt;- rnorm(100, mean = 82, sd = 10) Create a data frame with: - All students who completed at least one quarter - NA for missing scores - Calculate average score per student 5.13 Exercise Answers Click to see answers Exercise 1: # A - Works, silent (4 is multiple of 2) c(1, 2, 3, 4) + c(10, 20) #&gt; [1] 11 22 13 24 # B - Works, warns (5 not multiple of 2) c(1, 2, 3, 4, 5) + c(10, 20) #&gt; Warning in c(1, 2, 3, 4, 5) + c(10, 20): longer object length is not a multiple #&gt; of shorter object length #&gt; [1] 11 22 13 24 15 # C - Errors (10 not multiple of 5) tryCatch( data.frame(x = 1:10, y = c(1, 2, 3, 4, 5)), error = function(e) message(&quot;Error: &quot;, e$message) ) #&gt; x y #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 3 #&gt; 4 4 4 #&gt; 5 5 5 #&gt; 6 6 1 #&gt; 7 7 2 #&gt; 8 8 3 #&gt; 9 9 4 #&gt; 10 10 5 # D - Works, silent (12 is multiple of 4) x &lt;- 1:12 x[] &lt;- c(1, 2, 3, 4) x #&gt; [1] 1 2 3 4 1 2 3 4 1 2 3 4 # E - Works, silent (25 is multiple of 5) matrix(1:5, nrow = 5, ncol = 5) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 1 1 1 1 #&gt; [2,] 2 2 2 2 2 #&gt; [3,] 3 3 3 3 3 #&gt; [4,] 4 4 4 4 4 #&gt; [5,] 5 5 5 5 5 Exercise 2: # Problem 1 - Recycle groups explicitly students &lt;- 1:25 groups &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) data.frame( student = students, group = rep(groups, length.out = length(students)) ) #&gt; student group #&gt; 1 1 A #&gt; 2 2 B #&gt; 3 3 C #&gt; 4 4 A #&gt; 5 5 B #&gt; 6 6 C #&gt; 7 7 A #&gt; 8 8 B #&gt; 9 9 C #&gt; 10 10 A #&gt; 11 11 B #&gt; 12 12 C #&gt; 13 13 A #&gt; 14 14 B #&gt; 15 15 C #&gt; 16 16 A #&gt; 17 17 B #&gt; 18 18 C #&gt; 19 19 A #&gt; 20 20 B #&gt; 21 21 C #&gt; 22 22 A #&gt; 23 23 B #&gt; 24 24 C #&gt; 25 25 A # Problem 2 - Make intention clear values &lt;- rnorm(100) weights &lt;- c(1, 2, 3) weights_full &lt;- rep(weights, length.out = length(values)) weighted &lt;- values * weights_full # Problem 3 - Extract scalar properly df &lt;- data.frame(id = 1:20) summary_stats &lt;- c(mean = 50, sd = 10, n = 20) df$mean &lt;- summary_stats[[&quot;mean&quot;]] # Single value Exercise 3: safe_add &lt;- function(x, y, action = c(&quot;error&quot;, &quot;recycle&quot;, &quot;trim&quot;, &quot;extend&quot;)) { action &lt;- match.arg(action) if (length(x) == length(y)) { result &lt;- x + y attr(result, &quot;action&quot;) &lt;- &quot;none_needed&quot; return(result) } if (action == &quot;error&quot;) { stop(&quot;Lengths don&#39;t match: &quot;, length(x), &quot; vs &quot;, length(y)) } if (action == &quot;recycle&quot;) { max_len &lt;- max(length(x), length(y)) x &lt;- rep(x, length.out = max_len) y &lt;- rep(y, length.out = max_len) result &lt;- x + y attr(result, &quot;action&quot;) &lt;- &quot;recycled&quot; } if (action == &quot;trim&quot;) { min_len &lt;- min(length(x), length(y)) result &lt;- x[1:min_len] + y[1:min_len] attr(result, &quot;action&quot;) &lt;- &quot;trimmed&quot; } if (action == &quot;extend&quot;) { max_len &lt;- max(length(x), length(y)) x &lt;- c(x, rep(NA, max_len - length(x))) y &lt;- c(y, rep(NA, max_len - length(y))) result &lt;- x + y attr(result, &quot;action&quot;) &lt;- &quot;extended&quot; } return(result) } # Test safe_add(1:5, 1:3, &quot;recycle&quot;) #&gt; [1] 2 4 6 5 7 #&gt; attr(,&quot;action&quot;) #&gt; [1] &quot;recycled&quot; Exercise 4: # Create scores with different lengths set.seed(123) scores_q1 &lt;- rnorm(100, mean = 75, sd = 10) scores_q2 &lt;- rnorm(98, mean = 78, sd = 10) scores_q3 &lt;- rnorm(102, mean = 80, sd = 10) scores_q4 &lt;- rnorm(100, mean = 82, sd = 10) # Find max number of students max_students &lt;- max(length(scores_q1), length(scores_q2), length(scores_q3), length(scores_q4)) # Extend all to max length with NA extend_with_na &lt;- function(x, target_len) { c(x, rep(NA, target_len - length(x))) } # Create data frame df &lt;- data.frame( student_id = 1:max_students, q1 = extend_with_na(scores_q1, max_students), q2 = extend_with_na(scores_q2, max_students), q3 = extend_with_na(scores_q3, max_students), q4 = extend_with_na(scores_q4, max_students) ) # Calculate average (ignoring NAs) df$average &lt;- rowMeans(df[, c(&quot;q1&quot;, &quot;q2&quot;, &quot;q3&quot;, &quot;q4&quot;)], na.rm = TRUE) # Keep only students with at least one score df &lt;- df[!is.nan(df$average), ] head(df) #&gt; student_id q1 q2 q3 q4 average #&gt; 1 1 69.39524 70.89593 73.88834 74.84758 72.25677 #&gt; 2 2 72.69823 80.56884 68.14520 74.47311 73.97134 #&gt; 3 3 90.58708 75.53308 101.98810 72.61461 85.18072 #&gt; 4 4 75.70508 74.52457 93.12413 71.47487 78.70716 #&gt; 5 5 76.29288 68.48381 77.34855 77.62840 74.93841 #&gt; 6 6 92.15065 77.54972 85.43194 85.31179 85.11103 "],["na-null-nan-inf.html", "Chapter 6 NA, NULL, NaN, Inf 6.1 Introduction 6.2 NA: Not Available 6.3 Error #1: missing values where TRUE/FALSE needed 6.4 Error #2: missing values and NaN's not allowed 6.5 Error #3: 'x' contains missing values 6.6 NULL: The Absence of Value 6.7 Error #4: argument is of length zero 6.8 NaN: Not a Number 6.9 Error #5: NaNs produced 6.10 Inf: Infinity 6.11 Error #6: infinite or missing values in 'x' 6.12 Testing for Special Values 6.13 Handling Missing Data Strategies 6.14 Summary 6.15 Exercises 6.16 Exercise Answers", " Chapter 6 NA, NULL, NaN, Inf What You‚Äôll Learn: The four ‚Äúmissing‚Äù value types in R Critical differences between NA, NULL, NaN, and Inf Common errors with missing data How to handle missing values properly Testing and detecting special values Key Errors Covered: 15+ missing data errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 6.1 Introduction R has four special ‚Äúnon-values‚Äù that trip up everyone: NA # Not Available #&gt; [1] NA NULL # Nothing #&gt; NULL NaN # Not a Number #&gt; [1] NaN Inf # Infinity #&gt; [1] Inf They look similar but behave very differently, and confusing them causes endless errors. üí° Key Insight: The Four Special Values # NA - Missing data (most common) ages &lt;- c(25, 30, NA, 35) # One age is missing # NULL - Absence of value (empty) result &lt;- NULL # No result yet # NaN - Invalid math result 0 / 0 # Undefined #&gt; [1] NaN # Inf - Infinite value 1 / 0 # Positive infinity #&gt; [1] Inf -1 / 0 # Negative infinity #&gt; [1] -Inf Think of it this way: - NA: ‚ÄúI don‚Äôt know what this is‚Äù - NULL: ‚ÄúThere‚Äôs nothing here‚Äù - NaN: ‚ÄúThis calculation doesn‚Äôt make sense‚Äù - Inf: ‚ÄúThis is beyond measurement‚Äù 6.2 NA: Not Available 6.2.1 What is NA? # NA is a placeholder for missing data x &lt;- c(1, 2, NA, 4, 5) x #&gt; [1] 1 2 NA 4 5 # It has a type! typeof(NA) # logical #&gt; [1] &quot;logical&quot; typeof(NA_real_) # double #&gt; [1] &quot;double&quot; typeof(NA_integer_) # integer #&gt; [1] &quot;integer&quot; typeof(NA_character_) # character #&gt; [1] &quot;character&quot; 6.3 Error #1: missing values where TRUE/FALSE needed ‚≠ê BEGINNER üî¢ TYPE 6.3.1 The Error x &lt;- NA if (x &gt; 5) { print(&quot;Large&quot;) } #&gt; Error in if (x &gt; 5) {: missing value where TRUE/FALSE needed üî¥ ERROR Error in if (x &gt; 5) { : missing value where TRUE/FALSE needed 6.3.2 What It Means if() needs TRUE or FALSE, but got NA. R won‚Äôt guess which branch to take. 6.3.3 Common Causes 6.3.3.1 Cause 1: Comparison with NA x &lt;- c(1, 2, NA, 4, 5) # Comparisons with NA give NA x &gt; 3 #&gt; [1] FALSE FALSE NA TRUE TRUE # Using in if() if (x[3] &gt; 3) { # x[3] is NA print(&quot;yes&quot;) } #&gt; Error in if (x[3] &gt; 3) {: missing value where TRUE/FALSE needed 6.3.3.2 Cause 2: Missing Data in Condition df &lt;- data.frame( age = c(25, NA, 35), name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) ) # This creates NA in condition if (df$age[2] &gt; 30) { print(&quot;Senior&quot;) } #&gt; Error in if (df$age[2] &gt; 30) {: missing value where TRUE/FALSE needed 6.3.3.3 Cause 3: Function Returns NA get_value &lt;- function() { return(NA) } if (get_value() == 10) { print(&quot;Ten!&quot;) } #&gt; Error in if (get_value() == 10) {: missing value where TRUE/FALSE needed 6.3.4 Solutions ‚úÖ SOLUTION 1: Test for NA First x &lt;- NA # Check for NA before using if (!is.na(x) &amp;&amp; x &gt; 5) { print(&quot;Large&quot;) } else { print(&quot;Not large or is NA&quot;) } #&gt; [1] &quot;Not large or is NA&quot; # Or handle NA explicitly if (is.na(x)) { print(&quot;Missing value&quot;) } else if (x &gt; 5) { print(&quot;Large&quot;) } else { print(&quot;Small&quot;) } #&gt; [1] &quot;Missing value&quot; ‚úÖ SOLUTION 2: Use isTRUE() x &lt;- NA # isTRUE() converts NA to FALSE if (isTRUE(x &gt; 5)) { print(&quot;Large&quot;) } # Equivalent to: if (!is.na(x) &amp;&amp; x &gt; 5) { print(&quot;Large&quot;) } ‚úÖ SOLUTION 3: Use %in% for Comparisons x &lt;- NA # == with NA gives NA x == 5 # NA #&gt; [1] NA # %in% handles NA better x %in% c(5) # FALSE #&gt; [1] FALSE # But still need to check: 5 %in% c(NA, 5) # TRUE #&gt; [1] TRUE NA %in% c(NA, 5) # TRUE #&gt; [1] TRUE ‚ö†Ô∏è Common Pitfall: &amp;&amp; vs &amp; x &lt;- c(NA, 2, 3) # Single &amp; returns vector with NA x &gt; 1 &amp; x &lt; 5 #&gt; [1] NA TRUE TRUE # Double &amp;&amp; errors on vector if (x &gt; 1 &amp;&amp; x &lt; 5) { # Error! print(&quot;yes&quot;) } #&gt; Error in x &gt; 1 &amp;&amp; x &lt; 5: &#39;length = 3&#39; in coercion to &#39;logical(1)&#39; For if(): Use &amp;&amp; but check for NA first For vectorized ops: Use &amp; and handle NAs appropriately 6.4 Error #2: missing values and NaN's not allowed ‚≠ê BEGINNER üßÆ MATH 6.4.1 The Error x &lt;- c(1, 2, NA, 4, 5) var(x) # Without na.rm #&gt; [1] NA üî¥ ERROR Error in var(x) : missing values and NaN&#39;s not allowed if &#39;na.rm&#39; is FALSE 6.4.2 What It Means Some functions refuse to work with NA unless you explicitly tell them how to handle it. 6.4.3 Common Functions With This Error x &lt;- c(1, 2, NA, 4, 5) # These error without na.rm: var(x) #&gt; [1] NA sd(x) #&gt; [1] NA cov(x, x) #&gt; [1] NA cor(x, x) #&gt; [1] NA 6.4.4 Solutions ‚úÖ SOLUTION 1: Use na.rm = TRUE x &lt;- c(1, 2, NA, 4, 5) # Remove NAs for calculation var(x, na.rm = TRUE) #&gt; [1] 3.333333 sd(x, na.rm = TRUE) #&gt; [1] 1.825742 mean(x, na.rm = TRUE) #&gt; [1] 3 sum(x, na.rm = TRUE) #&gt; [1] 12 ‚úÖ SOLUTION 2: Remove NAs First x &lt;- c(1, 2, NA, 4, 5) # Complete cases only x_complete &lt;- x[!is.na(x)] var(x_complete) #&gt; [1] 3.333333 # Or use na.omit() x_complete &lt;- na.omit(x) var(x_complete) #&gt; [1] 3.333333 ‚úÖ SOLUTION 3: Replace NAs x &lt;- c(1, 2, NA, 4, 5) # Replace with mean x_filled &lt;- x x_filled[is.na(x_filled)] &lt;- mean(x, na.rm = TRUE) var(x_filled) #&gt; [1] 2.5 # Replace with median (more robust) x_filled &lt;- x x_filled[is.na(x_filled)] &lt;- median(x, na.rm = TRUE) var(x_filled) #&gt; [1] 2.5 6.5 Error #3: 'x' contains missing values ‚≠ê BEGINNER üßÆ MATH 6.5.1 The Error x &lt;- c(1, 2, NA, 4) y &lt;- c(2, 3, 4, 5) t.test(x, y) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: x and y #&gt; t = -1.0675, df = 3.9593, p-value = 0.3465 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -4.213398 1.880065 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 2.333333 3.500000 üî¥ ERROR Error in t.test.default(x, y) : &#39;x&#39; contains missing values 6.5.2 What It Means Statistical tests often require complete data and won‚Äôt work with NAs. 6.5.3 Common Functions x &lt;- c(1, 2, NA, 4, 5) y &lt;- c(2, 3, 4, 5, 6) # These need complete data: t.test(x, y) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: x and y #&gt; t = -0.86603, df = 6.0472, p-value = 0.4195 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -3.820108 1.820108 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 3 4 wilcox.test(x, y) #&gt; Warning in wilcox.test.default(x, y): cannot compute exact p-value with ties #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: x and y #&gt; W = 6.5, p-value = 0.4568 #&gt; alternative hypothesis: true location shift is not equal to 0 chisq.test(x, y) #&gt; Warning in chisq.test(x, y): Chi-squared approximation may be incorrect #&gt; #&gt; Pearson&#39;s Chi-squared test #&gt; #&gt; data: x and y #&gt; X-squared = 12, df = 9, p-value = 0.2133 6.5.4 Solutions ‚úÖ SOLUTIONS 1. Remove NAs from both vectors: x &lt;- c(1, 2, NA, 4, 5) y &lt;- c(2, 3, 4, 5, 6) # Find complete cases complete &lt;- complete.cases(x, y) x_clean &lt;- x[complete] y_clean &lt;- y[complete] t.test(x_clean, y_clean) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: x_clean and y_clean #&gt; t = -0.7746, df = 6, p-value = 0.468 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -4.15895 2.15895 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 3 4 2. Use na.action: # For functions that support it df &lt;- data.frame(x = c(1, 2, NA, 4), y = c(2, 3, 4, 5)) t.test(x ~ 1, data = df, na.action = na.omit) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: x #&gt; t = 2.6458, df = 2, p-value = 0.1181 #&gt; alternative hypothesis: true mean is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -1.461250 6.127916 #&gt; sample estimates: #&gt; mean of x #&gt; 2.333333 3. Impute missing values (advanced): library(mice) imputed &lt;- mice(data, m = 5, method = &quot;pmm&quot;) 6.6 NULL: The Absence of Value 6.6.1 What is NULL? # NULL means &quot;nothing&quot; x &lt;- NULL x #&gt; NULL # Length zero length(NULL) #&gt; [1] 0 # NULL disappears in vectors c(1, 2, NULL, 4) #&gt; [1] 1 2 4 # Different from NA c(1, 2, NA, 4) #&gt; [1] 1 2 NA 4 6.7 Error #4: argument is of length zero ‚≠ê‚≠ê INTERMEDIATE üìè LENGTH 6.7.1 The Error x &lt;- NULL if (x &gt; 5) { print(&quot;yes&quot;) } #&gt; Error in if (x &gt; 5) {: argument is of length zero üî¥ ERROR Error in if (x &gt; 5) { : argument is of length zero 6.7.2 What It Means You‚Äôre trying to use NULL in a context that needs at least one value. 6.7.3 Common Causes 6.7.3.1 Cause 1: Uninitialized Variable # Forgot to assign result &lt;- NULL # Try to use if (result == 100) { print(&quot;success&quot;) } #&gt; Error in if (result == 100) {: argument is of length zero 6.7.3.2 Cause 2: Empty Subset df &lt;- data.frame(x = 1:5, y = 6:10) # Filter returns nothing subset_val &lt;- df$x[df$x &gt; 10] # numeric(0) subset_val &lt;- NULL # Or explicitly NULL # Try to use if (subset_val &gt; 0) { print(&quot;positive&quot;) } #&gt; Error in if (subset_val &gt; 0) {: argument is of length zero 6.7.3.3 Cause 3: Function Returns NULL get_value &lt;- function(x) { if (x &gt; 10) { return(x * 2) } # Implicitly returns NULL when x &lt;= 10 } result &lt;- get_value(5) # NULL if (result &gt; 0) { print(&quot;positive&quot;) } #&gt; Error in if (result &gt; 0) {: argument is of length zero 6.7.4 Solutions ‚úÖ SOLUTION 1: Check for NULL x &lt;- NULL # Check before using if (!is.null(x) &amp;&amp; x &gt; 5) { print(&quot;Large&quot;) } else { print(&quot;NULL or not large&quot;) } #&gt; [1] &quot;NULL or not large&quot; # Or use default if (is.null(x)) { x &lt;- 0 # Default value } if (x &gt; 5) { print(&quot;Large&quot;) } ‚úÖ SOLUTION 2: Check Length x &lt;- NULL # Check length instead if (length(x) &gt; 0 &amp;&amp; x &gt; 5) { print(&quot;Large&quot;) } # Works for both NULL and empty vectors y &lt;- numeric(0) if (length(y) &gt; 0 &amp;&amp; y[1] &gt; 5) { print(&quot;Large&quot;) } ‚úÖ SOLUTION 3: Use Default Values get_value_safe &lt;- function(x) { if (x &gt; 10) { return(x * 2) } else { return(0) # Default instead of NULL } } result &lt;- get_value_safe(5) if (result &gt; 0) { print(&quot;positive&quot;) } 6.8 NaN: Not a Number 6.8.1 What is NaN? # Result of invalid math 0 / 0 #&gt; [1] NaN Inf - Inf #&gt; [1] NaN Inf / Inf #&gt; [1] NaN # NaN is a special type of NA is.na(NaN) # TRUE #&gt; [1] TRUE is.nan(NA) # FALSE #&gt; [1] FALSE 6.9 Error #5: NaNs produced ‚≠ê BEGINNER üßÆ MATH 6.9.1 The Warning sqrt(-1) #&gt; Warning in sqrt(-1): NaNs produced #&gt; [1] NaN log(-1) #&gt; Warning in log(-1): NaNs produced #&gt; [1] NaN 0/0 #&gt; [1] NaN üü° WARNING Warning message: In sqrt(-1) : NaNs produced 6.9.2 What It Means You performed a mathematically invalid operation. Result is NaN. 6.9.3 Common Causes 6.9.3.1 Cause 1: Negative Square Root # Real square root of negative number doesn&#39;t exist sqrt(-1) #&gt; Warning in sqrt(-1): NaNs produced #&gt; [1] NaN sqrt(c(1, 4, -9, 16)) #&gt; Warning in sqrt(c(1, 4, -9, 16)): NaNs produced #&gt; [1] 1 2 NaN 4 6.9.3.2 Cause 2: Log of Negative/Zero # Log of negative or zero log(0) # -Inf #&gt; [1] -Inf log(-1) # NaN #&gt; Warning in log(-1): NaNs produced #&gt; [1] NaN # Log of vector with negatives values &lt;- c(1, 10, -5, 100) log(values) #&gt; Warning in log(values): NaNs produced #&gt; [1] 0.000000 2.302585 NaN 4.605170 6.9.3.3 Cause 3: Invalid Division # 0/0 is undefined 0 / 0 #&gt; [1] NaN # Inf operations Inf - Inf #&gt; [1] NaN Inf / Inf #&gt; [1] NaN 6.9.4 Solutions ‚úÖ SOLUTION 1: Check Input Before Operation safe_sqrt &lt;- function(x) { if (any(x &lt; 0, na.rm = TRUE)) { warning(&quot;Negative values found, returning NA for those&quot;) } result &lt;- sqrt(x) return(result) } safe_sqrt(c(1, 4, -9, 16)) #&gt; Warning in safe_sqrt(c(1, 4, -9, 16)): Negative values found, returning NA for #&gt; those #&gt; Warning in sqrt(x): NaNs produced #&gt; [1] 1 2 NaN 4 ‚úÖ SOLUTION 2: Handle NaN After Operation x &lt;- c(1, -4, 9, -16) result &lt;- sqrt(x) #&gt; Warning in sqrt(x): NaNs produced # Replace NaN with NA (more standard) result[is.nan(result)] &lt;- NA result #&gt; [1] 1 NA 3 NA # Or with a specific value result &lt;- sqrt(x) #&gt; Warning in sqrt(x): NaNs produced result[is.nan(result)] &lt;- 0 result #&gt; [1] 1 0 3 0 ‚úÖ SOLUTION 3: Use Complex Numbers for Sqrt # For genuinely needing complex results x &lt;- -1 sqrt(as.complex(x)) # 0+1i #&gt; [1] 0+1i # Vector x &lt;- c(1, -4, 9, -16) sqrt(as.complex(x)) #&gt; [1] 1+0i 0+2i 3+0i 0+4i 6.10 Inf: Infinity 6.10.1 What is Inf? # Division by zero (non-zero) 1 / 0 # Inf #&gt; [1] Inf -1 / 0 # -Inf #&gt; [1] -Inf # Very large calculations exp(1000) # Inf #&gt; [1] Inf # Inf in comparisons Inf &gt; 1e100 # TRUE #&gt; [1] TRUE -Inf &lt; -1e100 # TRUE #&gt; [1] TRUE 6.11 Error #6: infinite or missing values in 'x' ‚≠ê‚≠ê INTERMEDIATE üßÆ MATH 6.11.1 The Error x &lt;- c(1, 2, Inf, 4) y &lt;- c(2, 3, 4, 5) cor(x, y) #&gt; [1] NaN üî¥ ERROR Error in cor(x, y) : infinite or missing values in &#39;x&#39; 6.11.2 What It Means Some functions can‚Äôt handle infinite values and need finite numbers. 6.11.3 Solutions ‚úÖ SOLUTIONS 1. Check for and remove Inf: x &lt;- c(1, 2, Inf, 4, -Inf, 5) # Find finite values is.finite(x) #&gt; [1] TRUE TRUE FALSE TRUE FALSE TRUE # Keep only finite x_finite &lt;- x[is.finite(x)] y_finite &lt;- y[is.finite(x)] cor(x_finite, y_finite) #&gt; [1] NA 2. Replace Inf with large number: x &lt;- c(1, 2, Inf, 4, -Inf, 5) # Replace Inf with max/min of finite values x_fixed &lt;- x x_fixed[x == Inf] &lt;- max(x[is.finite(x)]) * 10 x_fixed[x == -Inf] &lt;- min(x[is.finite(x)]) * 10 x_fixed #&gt; [1] 1 2 50 4 10 5 3. Check before calculation: safe_cor &lt;- function(x, y) { finite_both &lt;- is.finite(x) &amp; is.finite(y) if (sum(finite_both) &lt; 2) { stop(&quot;Need at least 2 finite pairs&quot;) } cor(x[finite_both], y[finite_both]) } 6.12 Testing for Special Values üéØ Best Practice: Comprehensive Testing # Test functions x &lt;- c(1, NA, NaN, Inf, -Inf, 0) # Individual tests is.na(x) # TRUE for NA and NaN #&gt; [1] FALSE TRUE TRUE FALSE FALSE FALSE is.nan(x) # TRUE only for NaN #&gt; [1] FALSE FALSE TRUE FALSE FALSE FALSE is.infinite(x) # TRUE for Inf and -Inf #&gt; [1] FALSE FALSE FALSE TRUE TRUE FALSE is.finite(x) # TRUE for normal numbers #&gt; [1] TRUE FALSE FALSE FALSE FALSE TRUE # NULL is different y &lt;- NULL is.null(y) # TRUE #&gt; [1] TRUE is.na(y) # logical(0) - no value to test #&gt; logical(0) # Combined checks is_valid &lt;- function(x) { !is.na(x) &amp; !is.nan(x) &amp; is.finite(x) } is_valid(x) #&gt; [1] TRUE FALSE FALSE FALSE FALSE TRUE Decision Tree: if (is.null(x)) { # Handle NULL - no value at all } else if (is.nan(x)) { # Handle NaN - invalid math result } else if (is.infinite(x)) { # Handle Inf/-Inf - beyond limits } else if (is.na(x)) { # Handle NA - missing data } else { # Normal value } 6.13 Handling Missing Data Strategies üí° Key Insight: Missing Data Strategies 1. Complete Case Analysis (Listwise Deletion) df &lt;- data.frame( x = c(1, 2, NA, 4, 5), y = c(10, NA, 30, 40, 50) ) # Keep only complete rows complete.cases(df) #&gt; [1] TRUE FALSE FALSE TRUE TRUE df_complete &lt;- df[complete.cases(df), ] df_complete #&gt; x y #&gt; 1 1 10 #&gt; 4 4 40 #&gt; 5 5 50 2. Available Case Analysis (Pairwise Deletion) # Use all available data for each calculation cor(df, use = &quot;pairwise.complete.obs&quot;) #&gt; x y #&gt; x 1 1 #&gt; y 1 1 3. Imputation (Replacing with Estimates) # Replace with mean (simple) df$x[is.na(df$x)] &lt;- mean(df$x, na.rm = TRUE) # Replace with median (robust to outliers) df$y[is.na(df$y)] &lt;- median(df$y, na.rm = TRUE) 4. Keep as NA (Most Honest) # Just handle NAs in analysis mean(df$x, na.rm = TRUE) #&gt; [1] 3 When to use each: - Complete case: When data missing completely at random (MCAR) - Pairwise: When you want to use all available information - Imputation: When you have good reason to estimate missing values - Keep NA: When missingness is informative 6.14 Summary Key Takeaways: Four special values: NA (missing), NULL (nothing), NaN (invalid math), Inf (infinite) NA vs NULL: NA is a placeholder in a vector, NULL is absence of vector Test before using: Always check is.na(), is.null(), is.finite() Use isTRUE(): For conditions that might be NA na.rm = TRUE: Most statistical functions need this with NAs NaN from invalid math: sqrt(-1), 0/0, etc. Inf from overflow: 1/0, exp(1000), etc. Quick Reference: Value Test Meaning Example NA is.na() Missing data Survey non-response NULL is.null() No value Uninitialized variable NaN is.nan() Invalid math 0/0 Inf is.infinite() Infinite 1/0 In if() statements: # ‚ùå Dangerous if (x &gt; 5) { } # Errors if x is NA or NULL # ‚úÖ Safe if (!is.na(x) &amp;&amp; x &gt; 5) { } if (isTRUE(x &gt; 5)) { } if (length(x) &gt; 0 &amp;&amp; !is.na(x) &amp;&amp; x &gt; 5) { } With functions: # ‚ùå May error mean(x) var(x) cor(x, y) # ‚úÖ Handle missing mean(x, na.rm = TRUE) var(x[is.finite(x)]) cor(x, y, use = &quot;complete.obs&quot;) 6.15 Exercises üìù Exercise 1: Identify the Type What are these and why? # A x &lt;- c() typeof(x) # B y &lt;- sqrt(-1) class(y) # C z &lt;- 1/0 is.finite(z) # D w &lt;- c(1, 2, NA, 4) w == NA üìù Exercise 2: Fix the Code Debug these: # Problem 1 data &lt;- c(1, 2, NA, 4, 5) if (mean(data) &gt; 3) { print(&quot;High average&quot;) } # Problem 2 get_score &lt;- function(x) { if (x &gt; 10) { return(x * 2) } } score &lt;- get_score(5) if (score &gt; 10) { print(&quot;High score&quot;) } # Problem 3 values &lt;- c(10, 20, 0, 30) log_values &lt;- log(values) mean(log_values) üìù Exercise 3: Robust Function Write robust_mean(x) that: 1. Handles NA, NULL, NaN, Inf 2. Reports how many of each were found 3. Calculates mean of valid values 4. Returns list with mean and diagnostics üìù Exercise 4: Data Cleaning You have survey data: survey &lt;- data.frame( age = c(25, NA, 35, -999, 40), # -999 = missing income = c(50000, 75000, 0, 80000, NA), # 0 = refused satisfaction = c(5, 3, NA, 4, 99) # 99 = invalid ) Clean it: 1. Convert -999 to NA 2. Convert 0 in income to NA 3. Convert 99 in satisfaction to NA 4. Calculate complete case statistics 6.16 Exercise Answers Click to see answers Exercise 1: # A - Empty vector x &lt;- c() typeof(x) # &quot;logical&quot; (default empty type) #&gt; [1] &quot;NULL&quot; # B - NaN from invalid math y &lt;- sqrt(-1) #&gt; Warning in sqrt(-1): NaNs produced class(y) # &quot;numeric&quot; #&gt; [1] &quot;numeric&quot; is.nan(y) # TRUE #&gt; [1] TRUE # C - Inf from division by zero z &lt;- 1/0 is.finite(z) # FALSE (Inf is not finite) #&gt; [1] FALSE # D - Comparison with NA gives NA w &lt;- c(1, 2, NA, 4) w == NA # All NA! Use is.na() instead #&gt; [1] NA NA NA NA is.na(w) # Correct way #&gt; [1] FALSE FALSE TRUE FALSE Exercise 2: # Problem 1 - Need na.rm data &lt;- c(1, 2, NA, 4, 5) mean_val &lt;- mean(data, na.rm = TRUE) if (!is.na(mean_val) &amp;&amp; mean_val &gt; 3) { print(&quot;High average&quot;) } # Problem 2 - Check for NULL get_score &lt;- function(x) { if (x &gt; 10) { return(x * 2) } else { return(0) # Return 0 instead of NULL } } score &lt;- get_score(5) if (!is.null(score) &amp;&amp; score &gt; 10) { print(&quot;High score&quot;) } # Problem 3 - Handle -Inf from log(0) values &lt;- c(10, 20, 0, 30) log_values &lt;- log(values) log_values[is.infinite(log_values)] &lt;- NA mean(log_values, na.rm = TRUE) #&gt; [1] 2.899838 Exercise 3: robust_mean &lt;- function(x) { # Initialize diagnostics diagnostics &lt;- list( total = length(x), null = is.null(x), na = 0, nan = 0, inf = 0, valid = 0 ) # Check for NULL if (is.null(x)) { return(list(mean = NULL, diagnostics = diagnostics)) } # Count special values diagnostics$na &lt;- sum(is.na(x) &amp; !is.nan(x)) diagnostics$nan &lt;- sum(is.nan(x)) diagnostics$inf &lt;- sum(is.infinite(x)) # Find valid values valid &lt;- x[!is.na(x) &amp; !is.nan(x) &amp; is.finite(x)] diagnostics$valid &lt;- length(valid) # Calculate mean if (length(valid) == 0) { mean_val &lt;- NA } else { mean_val &lt;- mean(valid) } # Return list( mean = mean_val, diagnostics = diagnostics ) } # Test robust_mean(c(1, 2, NA, NaN, Inf, 5, -Inf)) #&gt; $mean #&gt; [1] 2.666667 #&gt; #&gt; $diagnostics #&gt; $diagnostics$total #&gt; [1] 7 #&gt; #&gt; $diagnostics$null #&gt; [1] FALSE #&gt; #&gt; $diagnostics$na #&gt; [1] 1 #&gt; #&gt; $diagnostics$nan #&gt; [1] 1 #&gt; #&gt; $diagnostics$inf #&gt; [1] 2 #&gt; #&gt; $diagnostics$valid #&gt; [1] 3 Exercise 4: survey &lt;- data.frame( age = c(25, NA, 35, -999, 40), income = c(50000, 75000, 0, 80000, NA), satisfaction = c(5, 3, NA, 4, 99) ) # Clean data clean_survey &lt;- survey # Convert -999 to NA in age clean_survey$age[clean_survey$age == -999] &lt;- NA # Convert 0 to NA in income clean_survey$income[clean_survey$income == 0] &lt;- NA # Convert 99 to NA in satisfaction clean_survey$satisfaction[clean_survey$satisfaction == 99] &lt;- NA # Complete case analysis clean_survey_complete &lt;- clean_survey[complete.cases(clean_survey), ] # Statistics list( n_complete = nrow(clean_survey_complete), mean_age = mean(clean_survey_complete$age), mean_income = mean(clean_survey_complete$income), mean_satisfaction = mean(clean_survey_complete$satisfaction) ) #&gt; $n_complete #&gt; [1] 1 #&gt; #&gt; $mean_age #&gt; [1] 25 #&gt; #&gt; $mean_income #&gt; [1] 50000 #&gt; #&gt; $mean_satisfaction #&gt; [1] 5 "],["part-iii-indexing-subsetting.html", "Part III: Indexing &amp; Subsetting", " Part III: Indexing &amp; Subsetting "],["subscript-dimension.html", "Chapter 7 Subscript &amp; Dimension Errors 7.1 Introduction 7.2 R‚Äôs Indexing Methods 7.3 Error #1: subscript out of bounds 7.4 Error #2: undefined columns selected 7.5 Error #3: incorrect number of dimensions 7.6 Error #4: incorrect number of subscripts on matrix 7.7 Error #5: only 0's may be mixed with negative subscripts 7.8 Error #6: negative length vectors are not allowed 7.9 Logical Indexing 7.10 Error #7: [ ] with missing values only allowed for atomic vectors 7.11 Matrix Indexing Special Cases 7.12 Summary 7.13 Exercises 7.14 Exercise Answers", " Chapter 7 Subscript &amp; Dimension Errors What You‚Äôll Learn: How R‚Äôs indexing system works Understanding dimensions and subscripts Common indexing mistakes Negative vs positive indexing Logical indexing pitfalls Matrix and array subsetting Key Errors Covered: 18+ indexing errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 7.1 Introduction R‚Äôs indexing system is powerful but confusing. You‚Äôll see these errors constantly: x &lt;- 1:5 x[10] # Wait, this works? #&gt; [1] NA x[10] # Returns NA, not an error! #&gt; [1] NA But this doesn‚Äôt: x[[10]] # Now it&#39;s an error #&gt; Error in x[[10]]: subscript out of bounds Understanding R‚Äôs indexing is critical for avoiding errors. Let‚Äôs master it. 7.2 R‚Äôs Indexing Methods üí° Key Insight: Five Ways to Index x &lt;- c(10, 20, 30, 40, 50) # 1. Positive integers (positions) x[c(1, 3, 5)] #&gt; [1] 10 30 50 # 2. Negative integers (exclusion) x[-c(2, 4)] #&gt; [1] 10 30 50 # 3. Logical vectors x[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 10 30 50 # 4. Names (if vector has names) names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) x[c(&quot;a&quot;, &quot;c&quot;, &quot;e&quot;)] #&gt; a c e #&gt; 10 30 50 # 5. Empty (returns all) x[] #&gt; a b c d e #&gt; 10 20 30 40 50 Each method has different error patterns! 7.3 Error #1: subscript out of bounds ‚≠ê BEGINNER üìè DIMENSION 7.3.1 The Error x &lt;- 1:5 x[[10]] # Double bracket #&gt; Error in x[[10]]: subscript out of bounds üî¥ ERROR Error in x[[10]] : subscript out of bounds 7.3.2 What It Means You‚Äôre trying to access an element beyond the vector‚Äôs length using [[]]. 7.3.3 Single vs Double Bracket x &lt;- 1:5 # Single bracket: Returns NA, no error x[10] #&gt; [1] NA # Double bracket: Errors x[[10]] #&gt; Error in x[[10]]: subscript out of bounds Why the difference? - [ can return multiple elements or NA - [[ must return exactly one element 7.3.4 Common Causes 7.3.4.1 Cause 1: Off-by-One Error scores &lt;- c(85, 90, 95) # Loop goes too far for (i in 1:4) { # Only 3 elements! print(scores[[i]]) } #&gt; [1] 85 #&gt; [1] 90 #&gt; [1] 95 #&gt; Error in scores[[i]]: subscript out of bounds 7.3.4.2 Cause 2: Wrong Length Assumption data &lt;- c(10, 20, 30) # Assumed it had 5 elements first_five &lt;- data[[1:5]] # Error on 4th #&gt; Error in data[[1:5]]: attempt to select more than one element in vectorIndex 7.3.4.3 Cause 3: After Filtering values &lt;- 1:10 large_values &lt;- values[values &gt; 100] # Empty! # Try to access first element large_values[[1]] # Out of bounds (length 0) #&gt; Error in large_values[[1]]: subscript out of bounds 7.3.4.4 Cause 4: List Indexing my_list &lt;- list(a = 1, b = 2, c = 3) # Trying to access 4th element my_list[[4]] # Only 3 elements #&gt; Error in my_list[[4]]: subscript out of bounds 7.3.5 Solutions ‚úÖ SOLUTION 1: Check Length First x &lt;- 1:5 index &lt;- 10 # Safe access if (index &lt;= length(x)) { x[[index]] } else { message(&quot;Index &quot;, index, &quot; is out of bounds&quot;) NA } #&gt; Index 10 is out of bounds #&gt; [1] NA ‚úÖ SOLUTION 2: Use Single Bracket x &lt;- 1:5 # Single bracket returns NA instead of error x[10] # NA #&gt; [1] NA # Good for loops where you want to continue for (i in 1:10) { val &lt;- x[i] if (!is.na(val)) { print(val) } } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 ‚úÖ SOLUTION 3: Safe Indexing Function safe_extract &lt;- function(x, i, default = NA) { if (i &lt; 1 || i &gt; length(x)) { return(default) } return(x[[i]]) } # Test x &lt;- 1:5 safe_extract(x, 3) # 3 #&gt; [1] 3 safe_extract(x, 10) # NA #&gt; [1] NA safe_extract(x, 10, default = 0) # 0 #&gt; [1] 0 ‚úÖ SOLUTION 4: Use seq_along() in Loops values &lt;- c(10, 20, 30) # Wrong: assumes length for (i in 1:5) { # Error on 4th iteration } # Right: uses actual length for (i in seq_along(values)) { print(values[[i]]) # Safe } #&gt; [1] 10 #&gt; [1] 20 #&gt; [1] 30 # Even safer: iterate over values directly for (val in values) { print(val) } #&gt; [1] 10 #&gt; [1] 20 #&gt; [1] 30 ‚ö†Ô∏è Common Pitfall: Empty Vectors # Filter returns empty x &lt;- 1:10 big_numbers &lt;- x[x &gt; 100] # numeric(0) length(big_numbers) # 0 #&gt; [1] 0 # This errors! big_numbers[[1]] #&gt; Error in big_numbers[[1]]: subscript out of bounds # Always check if (length(big_numbers) &gt; 0) { big_numbers[[1]] } else { NA } #&gt; [1] NA 7.4 Error #2: undefined columns selected ‚≠ê BEGINNER üìè DIMENSION 7.4.1 The Error df &lt;- data.frame(x = 1:5, y = 6:10) df[, &quot;z&quot;] # Column doesn&#39;t exist #&gt; Error in `[.data.frame`(df, , &quot;z&quot;): undefined columns selected üî¥ ERROR Error in `[.data.frame`(df, , &quot;z&quot;) : undefined columns selected 7.4.2 What It Means You‚Äôre trying to select columns that don‚Äôt exist in the data frame. 7.4.3 Common Causes 7.4.3.1 Cause 1: Typo in Column Name df &lt;- data.frame(age = c(25, 30, 35), name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) # Typo: &quot;agee&quot; instead of &quot;age&quot; df[, &quot;agee&quot;] #&gt; Error in `[.data.frame`(df, , &quot;agee&quot;): undefined columns selected 7.4.3.2 Cause 2: Case Sensitivity df &lt;- data.frame(Age = c(25, 30, 35)) # Wrong case df[, &quot;age&quot;] # Error! It&#39;s &quot;Age&quot; not &quot;age&quot; #&gt; Error in `[.data.frame`(df, , &quot;age&quot;): undefined columns selected 7.4.3.3 Cause 3: Column Doesn‚Äôt Exist Yet df &lt;- data.frame(x = 1:5) # Trying to select column before creating it df[, c(&quot;x&quot;, &quot;y&quot;)] # &quot;y&quot; doesn&#39;t exist #&gt; Error in `[.data.frame`(df, , c(&quot;x&quot;, &quot;y&quot;)): undefined columns selected 7.4.3.4 Cause 4: After Subsetting df &lt;- data.frame(x = 1:5, y = 6:10, z = 11:15) # Select some columns df_subset &lt;- df[, c(&quot;x&quot;, &quot;y&quot;)] # Try to access z (no longer exists) df_subset[, &quot;z&quot;] #&gt; Error in `[.data.frame`(df_subset, , &quot;z&quot;): undefined columns selected 7.4.4 Solutions ‚úÖ SOLUTION 1: Check Column Names df &lt;- data.frame(age = c(25, 30, 35), name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) # List all columns names(df) #&gt; [1] &quot;age&quot; &quot;name&quot; colnames(df) #&gt; [1] &quot;age&quot; &quot;name&quot; # Check if column exists &quot;age&quot; %in% names(df) # TRUE #&gt; [1] TRUE &quot;agee&quot; %in% names(df) # FALSE #&gt; [1] FALSE # Safe selection col_name &lt;- &quot;age&quot; if (col_name %in% names(df)) { df[, col_name] } else { message(&quot;Column &quot;, col_name, &quot; not found&quot;) NULL } #&gt; [1] 25 30 35 ‚úÖ SOLUTION 2: Use exists in dplyr library(dplyr) df &lt;- data.frame(x = 1:5, y = 6:10) # Select only existing columns cols_to_select &lt;- c(&quot;x&quot;, &quot;z&quot;, &quot;y&quot;) existing_cols &lt;- cols_to_select[cols_to_select %in% names(df)] df %&gt;% select(all_of(existing_cols)) #&gt; x y #&gt; 1 1 6 #&gt; 2 2 7 #&gt; 3 3 8 #&gt; 4 4 9 #&gt; 5 5 10 ‚úÖ SOLUTION 3: Safe Column Selection Function safe_select_cols &lt;- function(df, cols) { # Check which columns exist existing &lt;- cols[cols %in% names(df)] missing &lt;- cols[!cols %in% names(df)] if (length(missing) &gt; 0) { warning(&quot;Columns not found: &quot;, paste(missing, collapse = &quot;, &quot;)) } if (length(existing) == 0) { return(data.frame()) # Empty data frame } return(df[, existing, drop = FALSE]) } # Test df &lt;- data.frame(x = 1:5, y = 6:10) safe_select_cols(df, c(&quot;x&quot;, &quot;z&quot;, &quot;y&quot;)) #&gt; Warning in safe_select_cols(df, c(&quot;x&quot;, &quot;z&quot;, &quot;y&quot;)): Columns not found: z #&gt; x y #&gt; 1 1 6 #&gt; 2 2 7 #&gt; 3 3 8 #&gt; 4 4 9 #&gt; 5 5 10 7.5 Error #3: incorrect number of dimensions ‚≠ê‚≠ê INTERMEDIATE üìè DIMENSION 7.5.1 The Error x &lt;- 1:5 # Vector (1D) x[1, 2] # Using 2D indexing on 1D object #&gt; Error in x[1, 2]: incorrect number of dimensions üî¥ ERROR Error in x[1, 2] : incorrect number of dimensions 7.5.2 What It Means You‚Äôre using the wrong number of indices for the object‚Äôs dimensions. 7.5.3 Understanding Dimensions # Vector: 1 dimension vec &lt;- 1:5 length(vec) #&gt; [1] 5 dim(vec) # NULL #&gt; NULL # Matrix: 2 dimensions mat &lt;- matrix(1:6, nrow = 2, ncol = 3) dim(mat) # 2 3 #&gt; [1] 2 3 # Array: 3+ dimensions arr &lt;- array(1:24, dim = c(2, 3, 4)) dim(arr) # 2 3 4 #&gt; [1] 2 3 4 # Data frame: 2 dimensions (special) df &lt;- data.frame(x = 1:3, y = 4:6) dim(df) # 3 2 #&gt; [1] 3 2 7.5.4 Common Causes 7.5.4.1 Cause 1: Treating Vector as Matrix x &lt;- c(10, 20, 30, 40, 50) # Vector needs 1 index x[3] # Correct #&gt; [1] 30 # Not 2 indices x[1, 3] # Error! #&gt; Error in x[1, 3]: incorrect number of dimensions 7.5.4.2 Cause 2: Treating Matrix as Vector mat &lt;- matrix(1:6, nrow = 2, ncol = 3) # Matrix needs 2 indices mat[1, 2] # Correct #&gt; [1] 3 # Or can use 1 index (treats as vector) mat[5] # Also works! (column-major order) #&gt; [1] 5 # But this is confusing: mat[1] # First element, not first row #&gt; [1] 1 7.5.4.3 Cause 3: After Subsetting mat &lt;- matrix(1:12, nrow = 3, ncol = 4) # Extract one column (becomes vector!) col1 &lt;- mat[, 1] class(col1) # &quot;numeric&quot; (not matrix) #&gt; [1] &quot;integer&quot; # Now 1D, can&#39;t use 2D indexing col1[1, 1] # Error! #&gt; Error in col1[1, 1]: incorrect number of dimensions 7.5.4.4 Cause 4: List vs Data Frame Confusion # List: 1D (use single bracket or [[]]) my_list &lt;- list(a = 1:3, b = 4:6) my_list[[1]] # Correct #&gt; [1] 1 2 3 my_list[1, 2] # Error! #&gt; Error in my_list[1, 2]: incorrect number of dimensions # Data frame: 2D (use row, col) df &lt;- data.frame(a = 1:3, b = 4:6) df[1, 2] # Correct #&gt; [1] 4 df[[1]] # Also works (returns column) #&gt; [1] 1 2 3 7.5.5 Solutions ‚úÖ SOLUTION 1: Check Dimensions Before Indexing x &lt;- 1:5 # Check what you have ndims &lt;- length(dim(x)) # 0 for vector if (is.null(dim(x))) { # Vector: use 1 index x[3] } else if (length(dim(x)) == 2) { # Matrix/data frame: use 2 indices x[1, 3] } #&gt; [1] 3 ‚úÖ SOLUTION 2: Preserve Dimensions with drop = FALSE mat &lt;- matrix(1:12, nrow = 3, ncol = 4) # Default: drops to vector col1 &lt;- mat[, 1] class(col1) # &quot;numeric&quot; #&gt; [1] &quot;integer&quot; # Preserve matrix structure col1 &lt;- mat[, 1, drop = FALSE] class(col1) # &quot;matrix&quot; #&gt; [1] &quot;matrix&quot; &quot;array&quot; dim(col1) # 3 1 #&gt; [1] 3 1 # Now can still use 2D indexing col1[1, 1] #&gt; [1] 1 ‚úÖ SOLUTION 3: Use Appropriate Functions mat &lt;- matrix(1:12, nrow = 3, ncol = 4) # For vectors: use vector operations vec &lt;- 1:5 vec[3] #&gt; [1] 3 vec[c(1, 3, 5)] #&gt; [1] 1 3 5 # For matrices: use matrix operations mat[1, ] # First row #&gt; [1] 1 4 7 10 mat[, 2] # Second column #&gt; [1] 4 5 6 mat[1:2, 3:4] # Submatrix #&gt; [,1] [,2] #&gt; [1,] 7 10 #&gt; [2,] 8 11 # For data frames: mix of both df &lt;- data.frame(x = 1:5, y = 6:10) df[, &quot;x&quot;] # Column (becomes vector) #&gt; [1] 1 2 3 4 5 df[, &quot;x&quot;, drop = FALSE] # Column (stays data frame) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 df$x # Column (vector) #&gt; [1] 1 2 3 4 5 7.6 Error #4: incorrect number of subscripts on matrix ‚≠ê BEGINNER üìè DIMENSION 7.6.1 The Error mat &lt;- matrix(1:6, nrow = 2, ncol = 3) mat[1, 2, 3] # Too many indices! #&gt; Error in mat[1, 2, 3]: incorrect number of dimensions üî¥ ERROR Error in mat[1, 2, 3] : incorrect number of subscripts on matrix 7.6.2 What It Means Matrix needs exactly 2 indices (or 1), but you provided a different number. 7.6.3 Correct Matrix Indexing mat &lt;- matrix(1:6, nrow = 2, ncol = 3) mat #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # Correct ways: mat[1, 2] # Single element #&gt; [1] 3 mat[1, ] # Entire row #&gt; [1] 1 3 5 mat[, 2] # Entire column #&gt; [1] 3 4 mat[1:2, 2:3] # Submatrix #&gt; [,1] [,2] #&gt; [1,] 3 5 #&gt; [2,] 4 6 # Also works (treats as vector): mat[5] # 5th element (column-major) #&gt; [1] 5 # Wrong: # mat[1, 2, 3] # Too many indices 7.6.4 Solutions ‚úÖ SOLUTION 1: Use Correct Number of Indices mat &lt;- matrix(1:6, nrow = 2, ncol = 3) # For matrix: [row, col] mat[1, 2] #&gt; [1] 3 # For array: [dim1, dim2, dim3, ...] arr &lt;- array(1:24, dim = c(2, 3, 4)) arr[1, 2, 3] #&gt; [1] 15 ‚úÖ SOLUTION 2: Check Object Type First check_and_subset &lt;- function(x, ...) { indices &lt;- list(...) if (is.matrix(x)) { if (length(indices) &gt; 2) { stop(&quot;Matrix needs 1 or 2 indices, got &quot;, length(indices)) } return(do.call(`[`, c(list(x), indices))) } else if (is.array(x)) { expected &lt;- length(dim(x)) if (length(indices) != expected) { stop(&quot;Array needs &quot;, expected, &quot; indices, got &quot;, length(indices)) } return(do.call(`[`, c(list(x), indices))) } else { return(x[[indices[[1]]]]) } } 7.7 Error #5: only 0's may be mixed with negative subscripts ‚≠ê‚≠ê INTERMEDIATE üî§ SYNTAX 7.7.1 The Error x &lt;- 1:10 x[c(-1, 5)] # Can&#39;t mix negative and positive! #&gt; Error in x[c(-1, 5)]: only 0&#39;s may be mixed with negative subscripts üî¥ ERROR Error in x[c(-1, 5)] : only 0&#39;s may be mixed with negative subscripts 7.7.2 What It Means R won‚Äôt let you mix negative indices (exclusion) with positive indices (selection). 7.7.3 Negative Indexing Rules x &lt;- 1:10 # Positive: select elements x[c(1, 3, 5)] #&gt; [1] 1 3 5 # Negative: exclude elements x[-c(1, 3, 5)] #&gt; [1] 2 4 6 7 8 9 10 # Zero: ignored x[c(0, 1, 3)] # Same as x[c(1, 3)] #&gt; [1] 1 3 # Can mix zero with negative x[c(0, -1, -3)] # Same as x[-c(1, 3)] #&gt; [1] 2 4 5 6 7 8 9 10 # CANNOT mix positive and negative x[c(-1, 5)] # Error! #&gt; Error in x[c(-1, 5)]: only 0&#39;s may be mixed with negative subscripts x[c(1, -5)] # Error! #&gt; Error in x[c(1, -5)]: only 0&#39;s may be mixed with negative subscripts 7.7.4 Why This Rule? # Ambiguous meaning: x[c(-1, 5)] # Does this mean: # &quot;Select 5th, excluding 1st&quot;? # &quot;Exclude 1st, but also select 5th&quot;? # R refuses to guess! 7.7.5 Solutions ‚úÖ SOLUTION 1: Use Only Positive or Only Negative x &lt;- 1:10 # Want elements 2-10 (exclude 1st)? # Use negative: x[-1] #&gt; [1] 2 3 4 5 6 7 8 9 10 # Want elements except 1 and 3? # Use negative: x[-c(1, 3)] #&gt; [1] 2 4 5 6 7 8 9 10 # Want only 1, 3, 5? # Use positive: x[c(1, 3, 5)] #&gt; [1] 1 3 5 ‚úÖ SOLUTION 2: Convert to Logical x &lt;- 1:10 # Want: &quot;not 1, not 3, but yes 5&quot; # Create logical vector indices &lt;- rep(TRUE, length(x)) indices[c(1, 3)] &lt;- FALSE # Exclude these indices[5] &lt;- TRUE # Include this (already TRUE) x[indices] #&gt; [1] 2 4 5 6 7 8 9 10 ‚úÖ SOLUTION 3: Use setdiff() x &lt;- 1:10 # Want all except positions 1 and 3 exclude &lt;- c(1, 3) keep &lt;- setdiff(seq_along(x), exclude) x[keep] #&gt; [1] 2 4 5 6 7 8 9 10 # More complex: all except 1 and 3, but must include 5 exclude &lt;- c(1, 3) include &lt;- 5 keep &lt;- union(setdiff(seq_along(x), exclude), include) keep &lt;- sort(unique(keep)) x[keep] #&gt; [1] 2 4 5 6 7 8 9 10 7.8 Error #6: negative length vectors are not allowed ‚≠ê BEGINNER üìè LENGTH 7.8.1 The Error n &lt;- -5 x &lt;- numeric(n) # Can&#39;t have negative length! #&gt; Error in numeric(n): invalid &#39;length&#39; argument üî¥ ERROR Error in numeric(n) : negative length vectors are not allowed 7.8.2 What It Means You‚Äôre trying to create a vector with negative length, which is impossible. 7.8.3 Common Causes 7.8.3.1 Cause 1: Calculation Error n_start &lt;- 5 n_end &lt;- 3 # Calculation gives negative n &lt;- n_end - n_start # -2 result &lt;- numeric(n) # Error! #&gt; Error in numeric(n): invalid &#39;length&#39; argument 7.8.3.2 Cause 2: User Input create_vector &lt;- function(n) { numeric(n) } create_vector(-5) # Error! #&gt; Error in numeric(n): invalid &#39;length&#39; argument 7.8.3.3 Cause 3: Filtering Gone Wrong data &lt;- c(10, 20, 30) threshold &lt;- 50 # No values meet criteria n_above &lt;- sum(data &gt; threshold) # 0 # Then you subtract n_below &lt;- length(data) - n_above - 5 # Negative! result &lt;- numeric(n_below) # Error! #&gt; Error in numeric(n_below): invalid &#39;length&#39; argument 7.8.4 Solutions ‚úÖ SOLUTION 1: Validate Before Creating create_vector_safe &lt;- function(n, default_value = 0) { if (n &lt; 0) { warning(&quot;Negative length requested: &quot;, n, &quot;. Using 0.&quot;) n &lt;- 0 } if (n == 0) { return(numeric(0)) } return(rep(default_value, n)) } # Test create_vector_safe(5) #&gt; [1] 0 0 0 0 0 create_vector_safe(-5) #&gt; Warning in create_vector_safe(-5): Negative length requested: -5. Using 0. #&gt; numeric(0) create_vector_safe(0) #&gt; numeric(0) ‚úÖ SOLUTION 2: Use max() for Safety n_start &lt;- 5 n_end &lt;- 3 # Ensure non-negative n &lt;- max(0, n_end - n_start) result &lt;- numeric(n) # Safe result #&gt; numeric(0) 7.9 Logical Indexing üí° Key Insight: Logical Indexing x &lt;- c(10, 20, 30, 40, 50) # Logical vector x &gt; 25 #&gt; [1] FALSE FALSE TRUE TRUE TRUE # Use for indexing x[x &gt; 25] #&gt; [1] 30 40 50 # Multiple conditions x[x &gt; 25 &amp; x &lt; 45] #&gt; [1] 30 40 # With which() which(x &gt; 25) #&gt; [1] 3 4 5 x[which(x &gt; 25)] #&gt; [1] 30 40 50 Important: Logical indexing with NA creates NA in result! x &lt;- c(10, NA, 30, 40) x &gt; 25 # Has NA #&gt; [1] FALSE NA TRUE TRUE # Result includes NA x[x &gt; 25] #&gt; [1] NA 30 40 # Remove NA from condition x[which(x &gt; 25)] # which() drops NA #&gt; [1] 30 40 7.10 Error #7: [ ] with missing values only allowed for atomic vectors ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 7.10.1 The Error my_list &lt;- list(a = 1, b = 2, c = 3) indices &lt;- c(1, NA, 3) my_list[indices] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $&lt;NA&gt; #&gt; NULL #&gt; #&gt; $c #&gt; [1] 3 üî¥ ERROR Error in my_list[indices] : [ ] with missing values only allowed for atomic vectors 7.10.2 What It Means You can use NA in indices for vectors, but not for lists or data frames without special handling. 7.10.3 Atomic vs Non-Atomic # Atomic vector: NA indexing works vec &lt;- c(10, 20, 30) vec[c(1, NA, 3)] # Returns with NA #&gt; [1] 10 NA 30 # List: NA indexing fails my_list &lt;- list(a = 1, b = 2, c = 3) my_list[c(1, NA, 3)] # Error! #&gt; $a #&gt; [1] 1 #&gt; #&gt; $&lt;NA&gt; #&gt; NULL #&gt; #&gt; $c #&gt; [1] 3 7.10.4 Solutions ‚úÖ SOLUTION 1: Remove NAs from Indices my_list &lt;- list(a = 1, b = 2, c = 3) indices &lt;- c(1, NA, 3) # Remove NAs clean_indices &lt;- indices[!is.na(indices)] my_list[clean_indices] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $c #&gt; [1] 3 ‚úÖ SOLUTION 2: Use Logical Indexing my_list &lt;- list(a = 1, b = 2, c = 3) indices &lt;- c(1, NA, 3) # Convert to logical logical_indices &lt;- seq_along(my_list) %in% indices my_list[logical_indices] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $c #&gt; [1] 3 7.11 Matrix Indexing Special Cases üéØ Best Practice: Matrix Indexing Mastery mat &lt;- matrix(1:12, nrow = 3, ncol = 4) mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 # Single index: column-major order mat[5] # Row 2, Column 2 #&gt; [1] 5 # Row, column mat[2, 2] #&gt; [1] 5 # Entire row mat[2, ] #&gt; [1] 2 5 8 11 # Entire column mat[, 2] #&gt; [1] 4 5 6 # Multiple rows/columns mat[1:2, 2:3] #&gt; [,1] [,2] #&gt; [1,] 4 7 #&gt; [2,] 5 8 # Logical indexing (rows) mat[mat[, 1] &gt; 1, ] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 5 8 11 #&gt; [2,] 3 6 9 12 # Negative indexing mat[-1, ] # All but first row #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 5 8 11 #&gt; [2,] 3 6 9 12 mat[, -c(1, 4)] # All but first and last column #&gt; [,1] [,2] #&gt; [1,] 4 7 #&gt; [2,] 5 8 #&gt; [3,] 6 9 # Preserve matrix structure mat[, 2] # Becomes vector #&gt; [1] 4 5 6 mat[, 2, drop = FALSE] # Stays matrix #&gt; [,1] #&gt; [1,] 4 #&gt; [2,] 5 #&gt; [3,] 6 7.12 Summary Key Takeaways: [ ] vs [[]]: Single bracket is lenient (returns NA), double bracket is strict (errors) Check bounds: Always validate indices before using [[]] Dimensions matter: Vectors (1D), matrices (2D), arrays (3D+) Negative indexing: Can‚Äôt mix with positive (except 0) Logical indexing: Watch for NA in conditions drop = FALSE: Preserves matrix structure seq_along(): Safer than 1:length() for loops Quick Reference: Error Cause Fix subscript out of bounds Index &gt; length with [[]] Check length first undefined columns Column name doesn‚Äôt exist Check with %in% names() incorrect number of dimensions Wrong # of indices Match object dimensions incorrect number of subscripts Too many/few indices Matrix needs 2, array needs n only 0‚Äôs may be mixed with negative Positive + negative indices Use one or the other negative length vectors Tried length &lt; 0 Validate with max(0, n) [ ] with missing values NA index on list Remove NAs or use logical Safe Indexing Checklist: # Before indexing: length(x) # Check size dim(x) # Check dimensions names(x) # Check names (if using) seq_along(x) # Safe iteration index %in% seq_along(x) # Validate index # For conditional indexing: which(condition) # Drops NA automatically x[!is.na(x) &amp; x &gt; 0] # Handle NA explicitly 7.13 Exercises üìù Exercise 1: Predict the Outcome What happens? Error, NA, or value? # A x &lt;- 1:5 x[10] # B x[[10]] # C mat &lt;- matrix(1:6, nrow = 2) mat[3, 1] # D x[c(-1, 5)] # E my_list &lt;- list(a = 1, b = 2) my_list[c(1, NA)] üìù Exercise 2: Fix the Code Debug these indexing problems: # Problem 1 scores &lt;- c(85, 90, 95) top_score &lt;- scores[[4]] # Problem 2 df &lt;- data.frame(x = 1:5, y = 6:10) result &lt;- df[, &quot;z&quot;] # Problem 3 vec &lt;- 1:10 subset &lt;- vec[c(-1, -2, 5, 6)] # Problem 4 mat &lt;- matrix(1:6, nrow = 2) col2 &lt;- mat[, 2] element &lt;- col2[1, 1] üìù Exercise 3: Safe Indexing Function Write safe_index(x, i) that: 1. Works with vectors, lists, matrices 2. Never errors on out-of-bounds 3. Returns NA for invalid indices 4. Handles both [ ] and [[ ]] style 5. Reports what went wrong üìù Exercise 4: Matrix Subsetting Given a matrix, write functions to: 1. Get elements on the diagonal 2. Get upper triangle (above diagonal) 3. Get lower triangle (below diagonal) 4. Get border elements (edges only) 5. Handle any matrix size 7.14 Exercise Answers Click to see answers Exercise 1: # A - Returns NA (single bracket is lenient) x &lt;- 1:5 x[10] #&gt; [1] NA # B - Errors (double bracket is strict) tryCatch(x[[10]], error = function(e) &quot;ERROR&quot;) #&gt; [1] &quot;ERROR&quot; # C - Errors (only 2 rows) mat &lt;- matrix(1:6, nrow = 2) tryCatch(mat[3, 1], error = function(e) &quot;ERROR&quot;) #&gt; [1] &quot;ERROR&quot; # D - Errors (can&#39;t mix positive and negative) tryCatch(x[c(-1, 5)], error = function(e) &quot;ERROR&quot;) #&gt; [1] &quot;ERROR&quot; # E - Errors (lists don&#39;t allow NA indices) my_list &lt;- list(a = 1, b = 2) tryCatch(my_list[c(1, NA)], error = function(e) &quot;ERROR&quot;) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $&lt;NA&gt; #&gt; NULL Exercise 2: # Problem 1 - Out of bounds scores &lt;- c(85, 90, 95) # Fix: Check length if (4 &lt;= length(scores)) { top_score &lt;- scores[[4]] } else { top_score &lt;- NA } # Problem 2 - Column doesn&#39;t exist df &lt;- data.frame(x = 1:5, y = 6:10) # Fix: Check column exists if (&quot;z&quot; %in% names(df)) { result &lt;- df[, &quot;z&quot;] } else { result &lt;- NULL } # Problem 3 - Mixing positive and negative vec &lt;- 1:10 # Fix: Use only negative subset &lt;- vec[-c(1, 2)] # Or only positive subset &lt;- vec[c(5, 6)] # Problem 4 - Vector can&#39;t use 2D indexing mat &lt;- matrix(1:6, nrow = 2) col2 &lt;- mat[, 2, drop = FALSE] # Keep as matrix element &lt;- col2[1, 1] # Or: col2 &lt;- mat[, 2] # Vector element &lt;- col2[1] # 1D indexing Exercise 3: safe_index &lt;- function(x, i, double_bracket = FALSE) { # Handle different object types if (is.null(x)) { message(&quot;Object is NULL&quot;) return(NULL) } # Get valid range max_index &lt;- if (is.list(x)) { length(x) } else if (!is.null(dim(x))) { length(x) # For matrices, treat as vector } else { length(x) } # Check index validity if (any(is.na(i))) { message(&quot;Index contains NA&quot;) i &lt;- i[!is.na(i)] } if (length(i) == 0) { message(&quot;No valid indices&quot;) return(if (double_bracket) NA else x[integer(0)]) } if (any(i &lt; 1 | i &gt; max_index)) { invalid &lt;- i[i &lt; 1 | i &gt; max_index] message(&quot;Invalid indices: &quot;, paste(invalid, collapse = &quot;, &quot;)) i &lt;- i[i &gt;= 1 &amp; i &lt;= max_index] } if (length(i) == 0) { return(NA) } # Extract if (double_bracket) { if (length(i) &gt; 1) { message(&quot;Double bracket with multiple indices, using first&quot;) i &lt;- i[1] } return(x[[i]]) } else { return(x[i]) } } # Test x &lt;- 1:5 safe_index(x, 3) #&gt; [1] 3 safe_index(x, 10) #&gt; Invalid indices: 10 #&gt; [1] NA safe_index(x, c(1, 10, 3)) #&gt; Invalid indices: 10 #&gt; [1] 1 3 Exercise 4: # Get diagonal elements get_diagonal &lt;- function(mat) { if (!is.matrix(mat)) stop(&quot;Input must be a matrix&quot;) n &lt;- min(nrow(mat), ncol(mat)) mat[cbind(1:n, 1:n)] } # Get upper triangle get_upper_tri &lt;- function(mat, include_diag = FALSE) { if (!is.matrix(mat)) stop(&quot;Input must be a matrix&quot;) mat[upper.tri(mat, diag = include_diag)] } # Get lower triangle get_lower_tri &lt;- function(mat, include_diag = FALSE) { if (!is.matrix(mat)) stop(&quot;Input must be a matrix&quot;) mat[lower.tri(mat, diag = include_diag)] } # Get border elements get_border &lt;- function(mat) { if (!is.matrix(mat)) stop(&quot;Input must be a matrix&quot;) nr &lt;- nrow(mat) nc &lt;- ncol(mat) if (nr == 1 || nc == 1) { return(as.vector(mat)) } c( mat[1, ], # Top row mat[nr, ], # Bottom row mat[2:(nr-1), 1], # Left column (excluding corners) mat[2:(nr-1), nc] # Right column (excluding corners) ) } # Test mat &lt;- matrix(1:20, nrow = 4, ncol = 5) mat #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 5 9 13 17 #&gt; [2,] 2 6 10 14 18 #&gt; [3,] 3 7 11 15 19 #&gt; [4,] 4 8 12 16 20 get_diagonal(mat) #&gt; [1] 1 6 11 16 get_upper_tri(mat) #&gt; [1] 5 9 10 13 14 15 17 18 19 20 get_lower_tri(mat) #&gt; [1] 2 3 4 7 8 12 get_border(mat) #&gt; [1] 1 5 9 13 17 4 8 12 16 20 2 3 18 19 "],["dollar-double-bracket.html", "Chapter 8 $ and [[ Operator Errors 8.1 Introduction 8.2 Error #1: $ operator is invalid for atomic vectors 8.3 Error #2: recursive indexing failed at level X 8.4 Error #3: attempt to select less than one element 8.5 Error #4: attempt to select more than one element 8.6 Partial Matching with $ 8.7 Comparing Operators 8.8 Data Frame Special Cases 8.9 Summary 8.10 Exercises 8.11 Exercise Answers", " Chapter 8 $ and [[ Operator Errors What You‚Äôll Learn: Differences between $, [[]], and [] When each operator works (and fails) Recursive indexing in lists Partial matching pitfalls Atomic vector vs list extraction Key Errors Covered: 12+ operator-specific errors Difficulty: ‚≠ê‚≠ê Intermediate 8.1 Introduction R has three main extraction operators that confuse everyone: my_list &lt;- list(name = &quot;Alice&quot;, age = 25, scores = c(85, 90, 95)) # Three ways to get the same thing: my_list$name #&gt; [1] &quot;Alice&quot; my_list[[&quot;name&quot;]] #&gt; [1] &quot;Alice&quot; my_list[&quot;name&quot;] # Wait, this is different! #&gt; $name #&gt; [1] &quot;Alice&quot; # Check the types class(my_list$name) # &quot;character&quot; #&gt; [1] &quot;character&quot; class(my_list[[&quot;name&quot;]]) # &quot;character&quot; #&gt; [1] &quot;character&quot; class(my_list[&quot;name&quot;]) # &quot;list&quot; - different! #&gt; [1] &quot;list&quot; Understanding these differences prevents endless frustration. üí° Key Insight: The Three Operators lst &lt;- list(x = 1:3, y = &quot;text&quot;, z = list(a = 10)) # $ - Extract by name (partial matching!) lst$x # c(1, 2, 3) #&gt; [1] 1 2 3 lst$x # Same as lst[[&quot;x&quot;]] #&gt; [1] 1 2 3 # [[ ]] - Extract single element (no partial matching) lst[[&quot;x&quot;]] # c(1, 2, 3) #&gt; [1] 1 2 3 lst[[1]] # Can use position too #&gt; [1] 1 2 3 # [ ] - Extract sub-list (keeps structure) lst[&quot;x&quot;] # list(x = 1:3) #&gt; $x #&gt; [1] 1 2 3 lst[1] # list(x = 1:3) #&gt; $x #&gt; [1] 1 2 3 lst[1:2] # list(x = 1:3, y = &quot;text&quot;) #&gt; $x #&gt; [1] 1 2 3 #&gt; #&gt; $y #&gt; [1] &quot;text&quot; Rule of thumb: - $ : Quick named access (interactive use) - [[]] : Safe programmatic access - [] : When you need to keep list structure 8.2 Error #1: $ operator is invalid for atomic vectors ‚≠ê BEGINNER üî¢ TYPE 8.2.1 The Error x &lt;- c(a = 1, b = 2, c = 3) # Named vector x$a # $ doesn&#39;t work on vectors! #&gt; Error in x$a: $ operator is invalid for atomic vectors üî¥ ERROR Error in x$a : $ operator is invalid for atomic vectors 8.2.2 What It Means The $ operator only works on recursive objects (lists, data frames, environments). It doesn‚Äôt work on atomic vectors. 8.2.3 Understanding the Difference # Atomic vector (1D, all same type) vec &lt;- c(a = 1, b = 2, c = 3) is.atomic(vec) # TRUE #&gt; [1] TRUE is.recursive(vec) # FALSE #&gt; [1] FALSE # Use names indexing instead vec[&quot;a&quot;] #&gt; a #&gt; 1 vec[[&quot;a&quot;]] #&gt; [1] 1 # List (recursive) lst &lt;- list(a = 1, b = 2, c = 3) is.atomic(lst) # FALSE #&gt; [1] FALSE is.recursive(lst) # TRUE #&gt; [1] TRUE # $ works here lst$a #&gt; [1] 1 8.2.4 Common Causes 8.2.4.1 Cause 1: Confusion Between Vector and List # Created a vector values &lt;- c(x = 10, y = 20) # Treating it like a list values$x # Error! #&gt; Error in values$x: $ operator is invalid for atomic vectors 8.2.4.2 Cause 2: After Extracting from Data Frame df &lt;- data.frame(x = 1:3, y = 4:6) # Extract column (becomes vector!) col &lt;- df$x class(col) # &quot;integer&quot; (atomic vector) #&gt; [1] &quot;integer&quot; # Can&#39;t use $ on result col$something # Error! #&gt; Error in col$something: $ operator is invalid for atomic vectors 8.2.4.3 Cause 3: Function Returns Vector get_values &lt;- function() { c(a = 1, b = 2) # Returns atomic vector } result &lt;- get_values() result$a # Error! #&gt; Error in result$a: $ operator is invalid for atomic vectors 8.2.5 Solutions ‚úÖ SOLUTION 1: Use Correct Indexing for Vectors vec &lt;- c(a = 1, b = 2, c = 3) # Right way for vectors: vec[&quot;a&quot;] # Single bracket #&gt; a #&gt; 1 vec[[&quot;a&quot;]] # Double bracket #&gt; [1] 1 # Get multiple elements vec[c(&quot;a&quot;, &quot;c&quot;)] #&gt; a c #&gt; 1 3 # All names names(vec) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ‚úÖ SOLUTION 2: Convert to List if Needed vec &lt;- c(a = 1, b = 2, c = 3) # Convert to list lst &lt;- as.list(vec) # Now $ works lst$a #&gt; [1] 1 ‚úÖ SOLUTION 3: Check Object Type First safe_dollar &lt;- function(x, name) { if (is.atomic(x) &amp;&amp; !is.null(names(x))) { message(&quot;Using [[ ]] for atomic vector&quot;) return(x[[name]]) } else if (is.recursive(x)) { return(x[[name]]) } else { stop(&quot;Cannot extract &#39;&quot;, name, &quot;&#39; from &quot;, class(x)[1]) } } # Test vec &lt;- c(a = 1, b = 2) safe_dollar(vec, &quot;a&quot;) #&gt; Using [[ ]] for atomic vector #&gt; [1] 1 lst &lt;- list(a = 1, b = 2) safe_dollar(lst, &quot;a&quot;) #&gt; [1] 1 ‚ö†Ô∏è Common Pitfall: Data Frame Columns df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Extracting a column col &lt;- df$x # Vector (atomic) col$something # Error! #&gt; Error in col$something: $ operator is invalid for atomic vectors # Selecting columns keeps data frame subset &lt;- df[&quot;x&quot;] # Data frame (recursive) subset$x # Works! #&gt; [1] 1 2 3 # Rule: Single column with $ or [[ ]] ‚Üí vector # One or more columns with [ ] ‚Üí data frame 8.3 Error #2: recursive indexing failed at level X ‚≠ê‚≠ê INTERMEDIATE üìè DIMENSION 8.3.1 The Error my_list &lt;- list(a = list(b = 1)) my_list[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]] # Too deep! #&gt; Error in my_list[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]]: subscript out of bounds üî¥ ERROR Error in my_list[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]] : recursive indexing failed at level 3 8.3.2 What It Means You‚Äôre trying to index deeper into a nested list than it actually goes. 8.3.3 Recursive Indexing # Nested list nested &lt;- list( a = list( b = list( c = 42 ) ) ) # Recursive indexing with vector nested[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)]] #&gt; [1] 42 # Equivalent to: nested[[&quot;a&quot;]][[&quot;b&quot;]][[&quot;c&quot;]] #&gt; [1] 42 # But this fails (only 3 levels deep): nested[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)]] # Level 4 doesn&#39;t exist! #&gt; Error in nested[[c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)]]: subscript out of bounds 8.3.4 Common Causes 8.3.4.1 Cause 1: Wrong Path data &lt;- list( user = list( name = &quot;Alice&quot;, age = 25 ) ) # Typo in path data[[c(&quot;user&quot;, &quot;email&quot;)]] # &quot;email&quot; doesn&#39;t exist #&gt; NULL 8.3.4.2 Cause 2: Mixed Types data &lt;- list( values = c(10, 20, 30) # Atomic vector, not list! ) # Can&#39;t recurse into atomic vector data[[c(&quot;values&quot;, &quot;1&quot;)]] # Error at level 2 #&gt; Error in data[[c(&quot;values&quot;, &quot;1&quot;)]]: subscript out of bounds 8.3.4.3 Cause 3: Dynamic Path Too Long data &lt;- list(a = list(b = 1)) path &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Path too long data[[path]] # Error #&gt; Error in data[[path]]: subscript out of bounds 8.3.5 Solutions ‚úÖ SOLUTION 1: Check Path Exists nested &lt;- list(a = list(b = list(c = 42))) safe_deep_extract &lt;- function(x, path) { for (i in seq_along(path)) { if (!is.list(x) &amp;&amp; !is.environment(x)) { stop(&quot;Cannot recurse at level &quot;, i, &quot;: object is &quot;, class(x)[1], &quot;, not list&quot;) } if (!path[i] %in% names(x)) { stop(&quot;Name &#39;&quot;, path[i], &quot;&#39; not found at level &quot;, i) } x &lt;- x[[path[i]]] } return(x) } # Test safe_deep_extract(nested, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) # Works #&gt; [1] 42 safe_deep_extract(nested, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) # Informative error #&gt; Error in safe_deep_extract(nested, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)): Cannot recurse at level 4: object is numeric, not list ‚úÖ SOLUTION 2: Use purrr::pluck() library(purrr) #&gt; Warning: package &#39;purrr&#39; was built under R version 4.5.1 nested &lt;- list(a = list(b = list(c = 42))) # Safe extraction with default pluck(nested, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;) #&gt; [1] 42 pluck(nested, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # Returns NULL, not error #&gt; NULL pluck(nested, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, .default = NA) #&gt; [1] NA ‚úÖ SOLUTION 3: Step-by-Step Extraction nested &lt;- list(a = list(b = list(c = 42))) path &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Extract step by step with checking result &lt;- nested for (step in path) { if (is.null(result)) { message(&quot;Path ended at NULL&quot;) break } if (!step %in% names(result)) { message(&quot;&#39;&quot;, step, &quot;&#39; not found&quot;) result &lt;- NULL break } result &lt;- result[[step]] } result #&gt; [1] 42 8.4 Error #3: attempt to select less than one element ‚≠ê‚≠ê INTERMEDIATE üìè DIMENSION 8.4.1 The Error my_list &lt;- list(a = 1, b = 2) my_list[[integer(0)]] # Empty index! #&gt; Error in my_list[[integer(0)]]: attempt to select less than one element in get1index üî¥ ERROR Error in my_list[[integer(0)]] : attempt to select less than one element in integerOneIndex 8.4.2 What It Means [[]] must select exactly one element, but you provided an empty index. 8.4.3 Common Causes 8.4.3.1 Cause 1: Empty Which() Result my_list &lt;- list(a = 1, b = 2, c = 3) # Find elements meeting condition indices &lt;- which(sapply(my_list, function(x) x &gt; 10)) length(indices) # 0 #&gt; [1] 0 # Try to extract my_list[[indices]] # Error! #&gt; Error in my_list[[indices]]: attempt to select less than one element in get1index 8.4.3.2 Cause 2: Filtered Index values &lt;- list(a = 5, b = 10, c = 15) # Filter for values &gt; 20 big_ones &lt;- which(sapply(values, function(x) x &gt; 20)) # Try to get first values[[big_ones[1]]] # NA[1] ‚Üí error! #&gt; NULL 8.4.3.3 Cause 3: Off-by-One with Subtraction my_list &lt;- list(a = 1, b = 2) index &lt;- 1 - 1 # 0 my_list[[index]] # Can&#39;t select 0th element #&gt; Error in my_list[[index]]: attempt to select less than one element in get1index &lt;real&gt; 8.4.4 Solutions ‚úÖ SOLUTION 1: Check Before Extracting my_list &lt;- list(a = 1, b = 2, c = 3) indices &lt;- which(sapply(my_list, function(x) x &gt; 10)) # Check first if (length(indices) &gt; 0) { my_list[[indices[1]]] } else { message(&quot;No elements found&quot;) NULL } #&gt; No elements found #&gt; NULL ‚úÖ SOLUTION 2: Use [ ] for Multiple/Zero Elements my_list &lt;- list(a = 1, b = 2, c = 3) indices &lt;- which(sapply(my_list, function(x) x &gt; 10)) # [ ] handles empty gracefully my_list[indices] # Returns empty list #&gt; named list() ‚úÖ SOLUTION 3: Safe Extraction Function safe_extract_one &lt;- function(x, i, default = NULL) { if (length(i) == 0) { message(&quot;No index provided&quot;) return(default) } if (is.na(i)) { message(&quot;Index is NA&quot;) return(default) } if (i &lt; 1 || i &gt; length(x)) { message(&quot;Index out of bounds: &quot;, i) return(default) } return(x[[i]]) } # Test my_list &lt;- list(a = 1, b = 2) safe_extract_one(my_list, integer(0)) #&gt; No index provided #&gt; NULL safe_extract_one(my_list, 1) #&gt; [1] 1 safe_extract_one(my_list, 10) #&gt; Index out of bounds: 10 #&gt; NULL 8.5 Error #4: attempt to select more than one element ‚≠ê BEGINNER üìè DIMENSION 8.5.1 The Error my_list &lt;- list(a = 1, b = 2, c = 3) my_list[[c(1, 2)]] # Multiple indices! #&gt; Error in my_list[[c(1, 2)]]: subscript out of bounds üî¥ ERROR Error in my_list[[c(1, 2)]] : attempt to select more than one element in integerOneIndex 8.5.2 What It Means [[]] extracts exactly one element. For multiple elements, use []. 8.5.3 Single vs Multiple Selection my_list &lt;- list(a = 1, b = 2, c = 3) # [[ ]] - One element my_list[[1]] # Element 1 #&gt; [1] 1 my_list[[&quot;a&quot;]] # By name #&gt; [1] 1 # [ ] - Multiple elements (returns list) my_list[1] # List with element 1 #&gt; $a #&gt; [1] 1 my_list[1:2] # List with elements 1 and 2 #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 2 my_list[c(&quot;a&quot;, &quot;c&quot;)] # By names #&gt; $a #&gt; [1] 1 #&gt; #&gt; $c #&gt; [1] 3 8.5.4 Common Causes 8.5.4.1 Cause 1: Meant to Use [ ] data &lt;- list(x = 1:5, y = 6:10, z = 11:15) # Want first two elements data[[1:2]] # Error! #&gt; [1] 2 # Use [ ] instead data[1:2] #&gt; $x #&gt; [1] 1 2 3 4 5 #&gt; #&gt; $y #&gt; [1] 6 7 8 9 10 8.5.4.2 Cause 2: Vector of Names data &lt;- list(name = &quot;Alice&quot;, age = 25, city = &quot;NYC&quot;) # Try to get multiple by name cols &lt;- c(&quot;name&quot;, &quot;age&quot;) data[[cols]] # Error! #&gt; Error in data[[cols]]: subscript out of bounds # Use [ ] for multiple data[cols] #&gt; $name #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $age #&gt; [1] 25 # Or extract separately lapply(cols, function(col) data[[col]]) #&gt; [[1]] #&gt; [1] &quot;Alice&quot; #&gt; #&gt; [[2]] #&gt; [1] 25 8.5.4.3 Cause 3: Recursive Indexing Confusion nested &lt;- list(a = list(b = 1, c = 2)) # This works (recursive indexing) nested[[c(&quot;a&quot;, &quot;b&quot;)]] # Goes to nested$a$b #&gt; [1] 1 # But not multiple at one level nested[[c(&quot;a&quot;), c(&quot;b&quot;, &quot;c&quot;)]] # Error! #&gt; Error in nested[[c(&quot;a&quot;), c(&quot;b&quot;, &quot;c&quot;)]]: incorrect number of subscripts 8.5.5 Solutions ‚úÖ SOLUTION 1: Use [ ] for Multiple Elements my_list &lt;- list(a = 1, b = 2, c = 3, d = 4) # Multiple elements - use single bracket my_list[c(1, 3)] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $c #&gt; [1] 3 my_list[c(&quot;a&quot;, &quot;c&quot;)] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $c #&gt; [1] 3 # Single element - use double bracket my_list[[1]] #&gt; [1] 1 my_list[[&quot;a&quot;]] #&gt; [1] 1 ‚úÖ SOLUTION 2: Loop or Apply for Multiple data &lt;- list(x = 1:3, y = 4:6, z = 7:9) elements_wanted &lt;- c(&quot;x&quot;, &quot;z&quot;) # Extract each separately result &lt;- lapply(elements_wanted, function(name) data[[name]]) names(result) &lt;- elements_wanted result #&gt; $x #&gt; [1] 1 2 3 #&gt; #&gt; $z #&gt; [1] 7 8 9 # Or use [ ] and unlist if needed data[elements_wanted] #&gt; $x #&gt; [1] 1 2 3 #&gt; #&gt; $z #&gt; [1] 7 8 9 8.6 Partial Matching with $ ‚ö†Ô∏è Dangerous Pitfall: Partial Matching The $ operator does partial matching by default: my_list &lt;- list(name = &quot;Alice&quot;, age = 25) # Exact match my_list$name #&gt; [1] &quot;Alice&quot; # Partial match (DANGEROUS!) my_list$n # Matches &quot;name&quot; #&gt; Warning in my_list$n: partial match of &#39;n&#39; to &#39;name&#39; #&gt; [1] &quot;Alice&quot; my_list$na # Matches &quot;name&quot; #&gt; Warning in my_list$na: partial match of &#39;na&#39; to &#39;name&#39; #&gt; [1] &quot;Alice&quot; my_list$nam # Matches &quot;name&quot; #&gt; Warning in my_list$nam: partial match of &#39;nam&#39; to &#39;name&#39; #&gt; [1] &quot;Alice&quot; # Ambiguous partial match returns NULL my_list$a # Could be &quot;age&quot; - but only one letter, returns NULL #&gt; Warning in my_list$a: partial match of &#39;a&#39; to &#39;age&#39; #&gt; [1] 25 # [[ ]] does NOT partial match (SAFER) my_list[[&quot;n&quot;]] # NULL #&gt; NULL my_list[[&quot;name&quot;]] # Works #&gt; [1] &quot;Alice&quot; Best Practice: Use [[]] in production code to avoid partial matching surprises. # Instead of: # data$col # Use: data[[&quot;col&quot;]] # Exact match required #&gt; NULL 8.7 Comparing Operators üí° Key Insight: Complete Comparison lst &lt;- list(x = 1:3, y = &quot;text&quot;, z = list(a = 10, b = 20)) # Extraction comparison lst$x # c(1, 2, 3) - vector #&gt; [1] 1 2 3 lst[[&quot;x&quot;]] # c(1, 2, 3) - vector #&gt; [1] 1 2 3 lst[&quot;x&quot;] # list(x = c(1, 2, 3)) - list #&gt; $x #&gt; [1] 1 2 3 # Type returned class(lst$x) # &quot;integer&quot; #&gt; [1] &quot;integer&quot; class(lst[[&quot;x&quot;]]) # &quot;integer&quot; #&gt; [1] &quot;integer&quot; class(lst[&quot;x&quot;]) # &quot;list&quot; #&gt; [1] &quot;list&quot; # Multiple elements # lst$c(&quot;x&quot;, &quot;y&quot;) # Can&#39;t do this # lst[[c(&quot;x&quot;, &quot;y&quot;)]] # Error lst[c(&quot;x&quot;, &quot;y&quot;)] # Works - returns list #&gt; $x #&gt; [1] 1 2 3 #&gt; #&gt; $y #&gt; [1] &quot;text&quot; # Nested access # lst$z$a # 10 lst[[&quot;z&quot;]]$a # 10 #&gt; [1] 10 lst[[&quot;z&quot;]][[&quot;a&quot;]] # 10 #&gt; [1] 10 lst[[c(&quot;z&quot;, &quot;a&quot;)]] # 10 (recursive indexing) #&gt; [1] 10 # lst[c(&quot;z&quot;, &quot;a&quot;)] # list with both z and a (different!) Decision Tree: Need to extract from list/data frame? ‚îú‚îÄ One element? ‚îÇ ‚îú‚îÄ Known name, interactive? ‚Üí use $ ‚îÇ ‚îú‚îÄ Programmatic, exact name? ‚Üí use [[]] ‚îÇ ‚îî‚îÄ By position? ‚Üí use [[]] ‚îî‚îÄ Multiple elements? ‚îî‚îÄ Use [] 8.8 Data Frame Special Cases üéØ Best Practice: Data Frame Extraction df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Column extraction df$x # Vector (drops to 1D) #&gt; [1] 1 2 3 df[[&quot;x&quot;]] # Vector (drops to 1D) #&gt; [1] 1 2 3 df[&quot;x&quot;] # Data frame (keeps 2D) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 df[, &quot;x&quot;] # Vector (drops by default) #&gt; [1] 1 2 3 df[, &quot;x&quot;, drop = FALSE] # Data frame (preserved) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 # Multiple columns # df$c(&quot;x&quot;, &quot;y&quot;) # Can&#39;t do # df[[c(&quot;x&quot;, &quot;y&quot;)]] # Error df[c(&quot;x&quot;, &quot;y&quot;)] # Data frame with 2 columns #&gt; x y #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 df[, c(&quot;x&quot;, &quot;y&quot;)] # Data frame with 2 columns #&gt; x y #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 # With dplyr (clearest!) library(dplyr) df %&gt;% pull(x) # Vector #&gt; [1] 1 2 3 df %&gt;% select(x) # Data frame #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 df %&gt;% select(x, y) # Data frame #&gt; x y #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 Rule: - $ and [[]] ‚Üí Drop to vector (single column) - [] ‚Üí Keep as data frame - [, , drop = FALSE] ‚Üí Force data frame 8.9 Summary Key Takeaways: $ only works on lists/data frames - Not atomic vectors [[ ]] requires exact names - No partial matching [[ ]] extracts one element - Use [] for multiple Recursive indexing - [[c(‚Äúa‚Äù, ‚Äúb‚Äù)]] goes deep $ does partial matching - Dangerous, use [[ ]] in code [] keeps structure - Returns list/data frame [[ ]] and $ simplify - Return element itself Quick Reference: Operator Structure Elements Partial Match Use Case $ List/DF One Yes Interactive [[]] Any One No Programmatic [] Any Multiple No Subsetting Common Errors: Error Cause Fix $ invalid for atomic vectors Used $ on vector Use [[ ]] or [] recursive indexing failed Path too deep Check structure select less than one Empty index in [[ ]] Check length first select more than one Multiple indices in [[ ]] Use [] instead Best Practices: # ‚úÖ Good data[[&quot;column&quot;]] # Exact, no partial matching data[c(&quot;col1&quot;, &quot;col2&quot;)] # Multiple columns if (length(idx) &gt; 0) data[[idx]] # Check before [[]] # ‚ùå Avoid in production data$col # Partial matching risk data[[multiple_indices]] # Will error data[[empty_vector]] # Will error 8.10 Exercises üìù Exercise 1: Operator Selection Which operator(s) work for each scenario? vec &lt;- c(a = 1, b = 2) lst &lt;- list(a = 1, b = 2) df &lt;- data.frame(a = 1:3, b = 4:6) # A: Get element &quot;a&quot; from vec # B: Get element &quot;a&quot; from lst # C: Get column &quot;a&quot; from df as vector # D: Get column &quot;a&quot; from df as data frame # E: Get elements &quot;a&quot; and &quot;b&quot; from lst üìù Exercise 2: Debug the Extraction Fix these extraction errors: # Problem 1 numbers &lt;- c(x = 10, y = 20, z = 30) result &lt;- numbers$x # Problem 2 data &lt;- list(values = c(1, 2, 3)) item &lt;- data[[c(&quot;values&quot;, &quot;1&quot;)]] # Problem 3 my_list &lt;- list(a = 1, b = 2, c = 3) subset &lt;- my_list[[c(1, 3)]] # Problem 4 nested &lt;- list(level1 = list(level2 = 10)) value &lt;- nested$level1$level2$level3 üìù Exercise 3: Safe Accessor Write safe_get(x, path, default = NULL) that: 1. Works with nested lists 2. Handles missing names gracefully 3. Returns default if path doesn‚Äôt exist 4. Works with both character names and numeric indices 5. Provides helpful error messages üìù Exercise 4: Extraction Comparison For this structure, show what each extraction returns: data &lt;- list( user = list( name = &quot;Alice&quot;, scores = c(85, 90, 95) ) ) # What does each return? (value and type) data$user data[[&quot;user&quot;]] data[&quot;user&quot;] data$user$name data[[c(&quot;user&quot;, &quot;name&quot;)]] data[[&quot;user&quot;]][[&quot;scores&quot;]][[2]] 8.11 Exercise Answers Click to see answers Exercise 1: vec &lt;- c(a = 1, b = 2) lst &lt;- list(a = 1, b = 2) df &lt;- data.frame(a = 1:3, b = 4:6) # A: Get &quot;a&quot; from vector vec[&quot;a&quot;] # ‚úÖ Works #&gt; a #&gt; 1 vec[[&quot;a&quot;]] # ‚úÖ Works #&gt; [1] 1 # vec$a # ‚ùå Error (atomic vector) # B: Get &quot;a&quot; from list lst$a # ‚úÖ Works #&gt; [1] 1 lst[[&quot;a&quot;]] # ‚úÖ Works #&gt; [1] 1 lst[&quot;a&quot;] # ‚úÖ Works (but returns list) #&gt; $a #&gt; [1] 1 # C: Get column &quot;a&quot; as vector df$a # ‚úÖ Works #&gt; [1] 1 2 3 df[[&quot;a&quot;]] # ‚úÖ Works #&gt; [1] 1 2 3 df[, &quot;a&quot;] # ‚úÖ Works #&gt; [1] 1 2 3 # df[&quot;a&quot;] # ‚ùå Returns data frame, not vector # D: Get column &quot;a&quot; as data frame df[&quot;a&quot;] # ‚úÖ Works #&gt; a #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 df[, &quot;a&quot;, drop = FALSE] # ‚úÖ Works #&gt; a #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 # df$a # ‚ùå Returns vector # df[[&quot;a&quot;]] # ‚ùå Returns vector # E: Get multiple elements from list lst[c(&quot;a&quot;, &quot;b&quot;)] # ‚úÖ Only this works #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 2 # lst$c(&quot;a&quot;, &quot;b&quot;) # ‚ùå Syntax error # lst[[c(&quot;a&quot;, &quot;b&quot;)]] # ‚ùå Error Exercise 2: # Problem 1 - $ on atomic vector numbers &lt;- c(x = 10, y = 20, z = 30) result &lt;- numbers[[&quot;x&quot;]] # or numbers[&quot;x&quot;] # Problem 2 - Can&#39;t recurse into atomic vector data &lt;- list(values = c(1, 2, 3)) item &lt;- data[[&quot;values&quot;]][1] # or data$values[1] # Problem 3 - Multiple indices in [[]] my_list &lt;- list(a = 1, b = 2, c = 3) subset &lt;- my_list[c(1, 3)] # Use single bracket # Problem 4 - Path doesn&#39;t exist nested &lt;- list(level1 = list(level2 = 10)) # Check if exists first if (!is.null(nested$level1$level2)) { value &lt;- nested$level1$level2 } else { value &lt;- NA } # Or just: value &lt;- nested$level1$level2 # This is 10 # nested$level1$level2$level3 would be NULL Exercise 3: safe_get &lt;- function(x, path, default = NULL) { # Handle empty path if (length(path) == 0) { return(x) } # Iterate through path current &lt;- x for (i in seq_along(path)) { step &lt;- path[i] # Check if current is indexable if (!is.list(current) &amp;&amp; !is.environment(current)) { message(&quot;Cannot index into &quot;, class(current)[1], &quot; at step &quot;, i) return(default) } # Check if step exists if (is.character(step)) { if (!step %in% names(current)) { message(&quot;Name &#39;&quot;, step, &quot;&#39; not found at step &quot;, i) return(default) } current &lt;- current[[step]] } else if (is.numeric(step)) { if (step &lt; 1 || step &gt; length(current)) { message(&quot;Index &quot;, step, &quot; out of bounds at step &quot;, i) return(default) } current &lt;- current[[step]] } else { stop(&quot;Path element must be character or numeric&quot;) } } return(current) } # Test nested &lt;- list(a = list(b = list(c = 42))) safe_get(nested, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) # 42 #&gt; [1] 42 safe_get(nested, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) # NULL #&gt; Cannot index into numeric at step 4 #&gt; NULL safe_get(nested, c(&quot;a&quot;, &quot;x&quot;), default = NA) # NA #&gt; Name &#39;x&#39; not found at step 2 #&gt; [1] NA safe_get(nested, c(1, 1, 1)) # 42 (by index) #&gt; [1] 42 Exercise 4: data &lt;- list( user = list( name = &quot;Alice&quot;, scores = c(85, 90, 95) ) ) # data$user # Returns: list(name = &quot;Alice&quot;, scores = c(85, 90, 95)) # Type: list # data[[&quot;user&quot;]] # Returns: list(name = &quot;Alice&quot;, scores = c(85, 90, 95)) # Type: list # data[&quot;user&quot;] # Returns: list(user = list(name = &quot;Alice&quot;, scores = c(85, 90, 95))) # Type: list (wrapped in another list!) # data$user$name # Returns: &quot;Alice&quot; # Type: character # data[[c(&quot;user&quot;, &quot;name&quot;)]] # Returns: &quot;Alice&quot; # Type: character # data[[&quot;user&quot;]][[&quot;scores&quot;]][[2]] # Returns: 90 # Type: numeric # Show them data$user #&gt; $name #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $scores #&gt; [1] 85 90 95 data[[&quot;user&quot;]] #&gt; $name #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $scores #&gt; [1] 85 90 95 data[&quot;user&quot;] #&gt; $user #&gt; $user$name #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $user$scores #&gt; [1] 85 90 95 data$user$name #&gt; [1] &quot;Alice&quot; data[[c(&quot;user&quot;, &quot;name&quot;)]] #&gt; [1] &quot;Alice&quot; data[[&quot;user&quot;]][[&quot;scores&quot;]][[2]] #&gt; [1] 90 "],["part-iv-data-frames-matrices.html", "Part IV: Data Frames &amp; Matrices", " Part IV: Data Frames &amp; Matrices "],["dataframe-construction.html", "Chapter 9 Data Frame Construction 9.1 Introduction 9.2 Data Frame Basics 9.3 Error #1: arguments imply differing number of rows 9.4 Error #2: row names supplied are of wrong length 9.5 Error #3: duplicate row.names are not allowed 9.6 Error #4: invalid type (list) for variable 9.7 Error #5: cannot coerce class X to a data.frame 9.8 Stringsasfactors Historical Issue 9.9 Creating Data Frames: All Methods 9.10 Summary 9.11 Exercises 9.12 Exercise Answers", " Chapter 9 Data Frame Construction What You‚Äôll Learn: How data frames are constructed Row and column length requirements Type coercion during construction Row names and their pitfalls Converting between structures Key Errors Covered: 15+ construction errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 9.1 Introduction Data frames are R‚Äôs workhorse for tabular data. But creating them can be tricky: # This looks innocent... data.frame(x = 1:3, y = 1:5) #&gt; Error in data.frame(x = 1:3, y = 1:5): arguments imply differing number of rows: 3, 5 üî¥ ERROR Error in data.frame(x = 1:3, y = 1:5) : arguments imply differing number of rows: 3, 5 Let‚Äôs master data frame construction and avoid all the common pitfalls. 9.2 Data Frame Basics üí° Key Insight: What is a Data Frame? A data frame is a list of vectors with special properties: # Create a data frame df &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), age = c(25, 30, 35), score = c(85, 90, 95) ) # It&#39;s actually a list! typeof(df) #&gt; [1] &quot;list&quot; is.list(df) #&gt; [1] TRUE # But special class(df) #&gt; [1] &quot;data.frame&quot; is.data.frame(df) #&gt; [1] TRUE # Each column is a vector df$name #&gt; [1] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; df$age #&gt; [1] 25 30 35 # All columns must have same length length(df$name) #&gt; [1] 3 length(df$age) #&gt; [1] 3 Key requirements: 1. All columns must be same length (or length 1) 2. Each column must be a vector (atomic or list) 3. Row names must be unique 4. Column names should be unique (R allows duplicates but it‚Äôs confusing) 9.3 Error #1: arguments imply differing number of rows ‚≠ê BEGINNER üìè DIMENSION 9.3.1 The Error data.frame( x = 1:5, y = 1:3 ) #&gt; Error in data.frame(x = 1:5, y = 1:3): arguments imply differing number of rows: 5, 3 üî¥ ERROR Error in data.frame(x = 1:5, y = 1:3) : arguments imply differing number of rows: 5, 3 9.3.2 What It Means You‚Äôre trying to create a data frame with columns of different lengths that aren‚Äôt compatible. 9.3.3 The Recycling Rule Data frames allow recycling, but only in specific cases: # Length 1 always recycles data.frame( x = 1:5, y = 10 # Recycled to 5 ) #&gt; x y #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 # Multiples work data.frame( x = 1:6, y = c(1, 2) # Recycled to 6 (multiple of 2) ) #&gt; x y #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 1 #&gt; 4 4 2 #&gt; 5 5 1 #&gt; 6 6 2 # Non-multiples fail data.frame( x = 1:5, y = 1:3 # 5 is not a multiple of 3 ) #&gt; Error in data.frame(x = 1:5, y = 1:3): arguments imply differing number of rows: 5, 3 9.3.4 Common Causes 9.3.4.1 Cause 1: Filtered Data # Start with same length ids &lt;- 1:10 values &lt;- rnorm(10) # Filter one but not the other filtered_values &lt;- values[values &gt; 0] # Might be 6 elements # Try to combine data.frame(id = ids, value = filtered_values) # Error! #&gt; Error in data.frame(id = ids, value = filtered_values): arguments imply differing number of rows: 10, 3 9.3.4.2 Cause 2: Calculation Gone Wrong # Generate data x &lt;- 1:5 y &lt;- x * 2 # Accidentally modify one y &lt;- y[-3] # Remove one element # Try to create data frame data.frame(x = x, y = y) #&gt; Error in data.frame(x = x, y = y): arguments imply differing number of rows: 5, 4 9.3.4.3 Cause 3: Reading Different Sources # Simulating reading from different sources col1 &lt;- readLines(textConnection(&quot;a\\nb\\nc\\nd\\ne&quot;)) col2 &lt;- readLines(textConnection(&quot;1\\n2\\n3&quot;)) # Shorter! # Try to combine data.frame(col1 = col1, col2 = col2) #&gt; Error in data.frame(col1 = col1, col2 = col2): arguments imply differing number of rows: 5, 3 9.3.4.4 Cause 4: List Column with Wrong Length # Regular columns df &lt;- data.frame(id = 1:5) # Try to add list column of wrong length df$nested &lt;- list(a = 1:3, b = 4:6) # Length 2, not 5! #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, nested, value = list(a = 1:3, b = 4:6)): replacement has 2 rows, data has 5 9.3.5 Solutions ‚úÖ SOLUTION 1: Match Lengths Before Creating ids &lt;- 1:10 values &lt;- rnorm(10) filtered_values &lt;- values[values &gt; 0] # Option A: Filter both the same way keep &lt;- values &gt; 0 data.frame( id = ids[keep], value = filtered_values ) #&gt; id value #&gt; 1 1 0.4922286 #&gt; 2 2 0.2678350 #&gt; 3 3 0.6532577 #&gt; 4 8 0.4302847 #&gt; 5 9 0.5353988 # Option B: Extend shorter with NA max_len &lt;- max(length(ids), length(filtered_values)) ids_ext &lt;- c(ids, rep(NA, max_len - length(ids))) val_ext &lt;- c(filtered_values, rep(NA, max_len - length(filtered_values))) data.frame(id = ids_ext, value = val_ext) #&gt; id value #&gt; 1 1 0.4922286 #&gt; 2 2 0.2678350 #&gt; 3 3 0.6532577 #&gt; 4 4 0.4302847 #&gt; 5 5 0.5353988 #&gt; 6 6 NA #&gt; 7 7 NA #&gt; 8 8 NA #&gt; 9 9 NA #&gt; 10 10 NA # Option C: Trim longer to match min_len &lt;- min(length(ids), length(filtered_values)) data.frame( id = ids[1:min_len], value = filtered_values[1:min_len] ) #&gt; id value #&gt; 1 1 0.4922286 #&gt; 2 2 0.2678350 #&gt; 3 3 0.6532577 #&gt; 4 4 0.4302847 #&gt; 5 5 0.5353988 ‚úÖ SOLUTION 2: Check Lengths First safe_data_frame &lt;- function(...) { # Get all arguments args &lt;- list(...) # Get lengths lens &lt;- sapply(args, length) # Check compatibility max_len &lt;- max(lens) valid &lt;- lens == 1 | lens == max_len | max_len %% lens == 0 if (!all(valid)) { invalid_lens &lt;- unique(lens[!valid]) stop(&quot;Incompatible lengths: &quot;, paste(lens, collapse = &quot;, &quot;)) } # Create data frame data.frame(..., stringsAsFactors = FALSE) } # Test safe_data_frame(x = 1:5, y = 10) # Works #&gt; x y #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 safe_data_frame(x = 1:6, y = c(1,2)) # Works #&gt; x y #&gt; 1 1 1 #&gt; 2 2 2 #&gt; 3 3 1 #&gt; 4 4 2 #&gt; 5 5 1 #&gt; 6 6 2 safe_data_frame(x = 1:5, y = 1:3) # Clear error #&gt; Error in safe_data_frame(x = 1:5, y = 1:3): Incompatible lengths: 5, 3 ‚úÖ SOLUTION 3: Use tidyverse for Better Errors library(tibble) # tibble is stricter - no recycling except length 1 tibble( x = 1:5, y = 10 # Length 1 OK ) #&gt; # A tibble: 5 √ó 2 #&gt; x y #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 # Doesn&#39;t allow multiple recycling tibble( x = 1:6, y = c(1, 2) # Error! Clearer message ) #&gt; Error in `tibble()`: #&gt; ! Tibble columns must have compatible sizes. #&gt; ‚Ä¢ Size 6: Existing data. #&gt; ‚Ä¢ Size 2: Column `y`. #&gt; ‚Ñπ Only values of size one are recycled. ‚ö†Ô∏è Common Pitfall: Silent Recycling # This works but may not be intended! df &lt;- data.frame( group = 1:12, label = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) # Recycled 4 times ) df #&gt; group label #&gt; 1 1 A #&gt; 2 2 B #&gt; 3 3 C #&gt; 4 4 A #&gt; 5 5 B #&gt; 6 6 C #&gt; 7 7 A #&gt; 8 8 B #&gt; 9 9 C #&gt; 10 10 A #&gt; 11 11 B #&gt; 12 12 C # Was this intended? Hard to tell! # Explicit is better: df &lt;- data.frame( group = 1:12, label = rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), times = 4) ) 9.4 Error #2: row names supplied are of wrong length ‚≠ê BEGINNER üìè DIMENSION 9.4.1 The Error data.frame( x = 1:5, y = 6:10, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Only 3 names for 5 rows! ) #&gt; Error in data.frame(x = 1:5, y = 6:10, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): row names supplied are of the wrong length üî¥ ERROR Error in data.frame(x = 1:5, y = 6:10, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) : row names supplied are of wrong length 9.4.2 What It Means Row names must be exactly one per row. No more, no less. 9.4.3 Row Names Basics # Row names are optional df &lt;- data.frame(x = 1:3, y = 4:6) rownames(df) # Default: &quot;1&quot;, &quot;2&quot;, &quot;3&quot; #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # Can set custom row names df &lt;- data.frame( x = 1:3, y = 4:6, row.names = c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;) ) rownames(df) #&gt; [1] &quot;first&quot; &quot;second&quot; &quot;third&quot; # Or set after creation df &lt;- data.frame(x = 1:3, y = 4:6) rownames(df) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) rownames(df) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 9.4.4 Common Causes 9.4.4.1 Cause 1: Wrong Count df &lt;- data.frame(x = 1:10, y = 11:20) # Too few row names rownames(df) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) #&gt; Error in `.rowNamesDF&lt;-`(x, value = value): invalid &#39;row.names&#39; length 9.4.4.2 Cause 2: After Subsetting df &lt;- data.frame(x = 1:5, y = 6:10) original_names &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) rownames(df) &lt;- original_names # Subset data frame df_subset &lt;- df[1:3, ] rownames(df_subset) # Kept original names (good) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # But if you try to reuse original names on subset: rownames(df_subset) &lt;- original_names # Error! 5 names for 3 rows #&gt; Error in `.rowNamesDF&lt;-`(x, value = value): invalid &#39;row.names&#39; length 9.4.4.3 Cause 3: From External Source data_values &lt;- data.frame(x = 1:5, y = 6:10) labels &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # From somewhere else, wrong length rownames(data_values) &lt;- labels #&gt; Error in `.rowNamesDF&lt;-`(x, value = value): invalid &#39;row.names&#39; length 9.4.5 Solutions ‚úÖ SOLUTION 1: Match Length df &lt;- data.frame(x = 1:5, y = 6:10) names_available &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Option A: Extend with numbers all_names &lt;- c(names_available, paste0(&quot;row&quot;, (length(names_available)+1):nrow(df))) rownames(df) &lt;- all_names # Option B: Use only available, add column instead df$label &lt;- c(names_available, rep(NA, nrow(df) - length(names_available))) df #&gt; x y label #&gt; a 1 6 a #&gt; b 2 7 b #&gt; c 3 8 c #&gt; row4 4 9 &lt;NA&gt; #&gt; row5 5 10 &lt;NA&gt; ‚úÖ SOLUTION 2: Check Before Assigning safe_set_rownames &lt;- function(df, names) { if (length(names) != nrow(df)) { warning(&quot;Row names length (&quot;, length(names), &quot;) doesn&#39;t match rows (&quot;, nrow(df), &quot;)&quot;) return(df) } rownames(df) &lt;- names return(df) } # Test df &lt;- data.frame(x = 1:5, y = 6:10) df &lt;- safe_set_rownames(df, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) # Warning, unchanged #&gt; Warning in safe_set_rownames(df, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): Row names length (3) #&gt; doesn&#39;t match rows (5) df &lt;- safe_set_rownames(df, letters[1:5]) # Works ‚úÖ SOLUTION 3: Use Column Instead # Modern best practice: avoid row names df &lt;- data.frame( id = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;), x = 1:5, y = 6:10 ) # Use first column as identifier df #&gt; id x y #&gt; 1 a 1 6 #&gt; 2 b 2 7 #&gt; 3 c 3 8 #&gt; 4 d 4 9 #&gt; 5 e 5 10 # Can still use for indexing df[df$id == &quot;c&quot;, ] #&gt; id x y #&gt; 3 c 3 8 üéØ Best Practice: Avoid Row Names Row names are a legacy feature. Modern R style: # Old style (avoid) df &lt;- data.frame(x = 1:3, y = 4:6, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) # New style (prefer) df &lt;- data.frame( id = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x = 1:3, y = 4:6 ) # Tibbles don&#39;t even support row names! library(tibble) tibble(id = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), x = 1:3, y = 4:6) #&gt; # A tibble: 3 √ó 3 #&gt; id x y #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 a 1 4 #&gt; 2 b 2 5 #&gt; 3 c 3 6 Why? - Row names are easily lost in operations - Harder to work with programmatically - Not supported by modern tidyverse - Column is more explicit and flexible 9.5 Error #3: duplicate row.names are not allowed ‚≠ê BEGINNER üî§ SYNTAX 9.5.1 The Error data.frame( x = 1:3, y = 4:6, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;) # Duplicate! ) #&gt; Error in data.frame(x = 1:3, y = 4:6, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)): duplicate row.names: a üî¥ ERROR Error in data.frame(x = 1:3, y = 4:6, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;)) : duplicate row.names: a 9.5.2 What It Means Row names must be unique identifiers. Duplicates aren‚Äôt allowed. 9.5.3 Common Causes 9.5.3.1 Cause 1: Non-Unique IDs df &lt;- data.frame(x = 1:5, y = 6:10) ids &lt;- c(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;) rownames(df) &lt;- ids # Error! #&gt; Warning: non-unique value when setting &#39;row.names&#39;: &#39;sample2&#39; #&gt; Error in `.rowNamesDF&lt;-`(x, value = value): duplicate &#39;row.names&#39; are not allowed 9.5.3.2 Cause 2: After Combining Data Frames df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(x = 4:6, row.names = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) # &quot;c&quot; repeats! # rbind checks for this rbind(df1, df2) # Error! #&gt; x #&gt; a 1 #&gt; b 2 #&gt; c 3 #&gt; c1 4 #&gt; d 5 #&gt; e 6 9.5.3.3 Cause 3: Default Row Names from Subsetting df &lt;- data.frame(x = 1:10, row.names = letters[1:10]) # Take rows df1 &lt;- df[1:3, ] df2 &lt;- df[2:4, ] # Overlaps with df1 # Try to combine rbind(df1, df2) # Error! &quot;b&quot; and &quot;c&quot; appear twice #&gt; [,1] [,2] [,3] #&gt; df1 1 2 3 #&gt; df2 2 3 4 9.5.4 Solutions ‚úÖ SOLUTION 1: Make Unique df &lt;- data.frame(x = 1:5, y = 6:10) ids &lt;- c(&quot;sample1&quot;, &quot;sample2&quot;, &quot;sample2&quot;, &quot;sample3&quot;, &quot;sample4&quot;) # Make unique automatically unique_ids &lt;- make.unique(ids, sep = &quot;_&quot;) unique_ids #&gt; [1] &quot;sample1&quot; &quot;sample2&quot; &quot;sample2_1&quot; &quot;sample3&quot; &quot;sample4&quot; rownames(df) &lt;- unique_ids df #&gt; x y #&gt; sample1 1 6 #&gt; sample2 2 7 #&gt; sample2_1 3 8 #&gt; sample3 4 9 #&gt; sample4 5 10 ‚úÖ SOLUTION 2: Reset Row Names When Combining df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(x = 4:6, row.names = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) # Remove row names before combining rownames(df1) &lt;- NULL rownames(df2) &lt;- NULL rbind(df1, df2) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 # Or use row.names = FALSE df_combined &lt;- rbind(df1, df2) # Still errors # Better: let R assign new row names df1_clean &lt;- df1 df2_clean &lt;- df2 rownames(df1_clean) &lt;- NULL rownames(df2_clean) &lt;- NULL rbind(df1_clean, df2_clean) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 #&gt; 6 6 ‚úÖ SOLUTION 3: Check for Duplicates First safe_set_rownames_unique &lt;- function(df, names) { if (anyDuplicated(names)) { dupes &lt;- names[duplicated(names)] warning(&quot;Duplicate row names found: &quot;, paste(unique(dupes), collapse = &quot;, &quot;)) names &lt;- make.unique(names, sep = &quot;_&quot;) } rownames(df) &lt;- names return(df) } # Test df &lt;- data.frame(x = 1:5) df &lt;- safe_set_rownames_unique(df, c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;)) #&gt; Warning in safe_set_rownames_unique(df, c(&quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;d&quot;)): Duplicate #&gt; row names found: a rownames(df) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;a_1&quot; &quot;c&quot; &quot;d&quot; 9.6 Error #4: invalid type (list) for variable ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 9.6.1 The Error # Trying to create column from nested list data.frame( id = 1:3, values = list(1:3, 4:6, 7:9) # List column - old data.frame rejects ) #&gt; id values.1.3 values.4.6 values.7.9 #&gt; 1 1 1 4 7 #&gt; 2 2 2 5 8 #&gt; 3 3 3 6 9 üî¥ ERROR (in older R versions or strict mode) Error in data.frame(...) : invalid type (list) for variable &#39;values&#39; 9.6.2 What It Means Traditional data.frame() doesn‚Äôt easily support list columns. Each column should be an atomic vector. 9.6.3 Modern Solution: List Columns # Modern R allows this with I() df &lt;- data.frame( id = 1:3, values = I(list(1:3, 4:6, 7:9)) ) df #&gt; id values #&gt; 1 1 1, 2, 3 #&gt; 2 2 4, 5, 6 #&gt; 3 3 7, 8, 9 # Access list column df$values[[1]] #&gt; [1] 1 2 3 # Tibbles make it easier library(tibble) tibble( id = 1:3, values = list(1:3, 4:6, 7:9) ) #&gt; # A tibble: 3 √ó 2 #&gt; id values #&gt; &lt;int&gt; &lt;list&gt; #&gt; 1 1 &lt;int [3]&gt; #&gt; 2 2 &lt;int [3]&gt; #&gt; 3 3 &lt;int [3]&gt; 9.6.4 Common Causes 9.6.4.1 Cause 1: Nested Data # Have nested data nested &lt;- list( list(x = 1, y = 2), list(x = 3, y = 4), list(x = 5, y = 6) ) # Try to put in data frame data.frame( id = 1:3, data = nested # Old error ) #&gt; id data.x data.y data.x.1 data.y.1 data.x.2 data.y.2 #&gt; 1 1 1 2 3 4 5 6 #&gt; 2 2 1 2 3 4 5 6 #&gt; 3 3 1 2 3 4 5 6 9.6.4.2 Cause 2: Split/Group Result # Split creates list values &lt;- 1:12 groups &lt;- rep(1:3, each = 4) split_data &lt;- split(values, groups) # Try to put in data frame directly data.frame( group = 1:3, values = split_data # May error ) #&gt; Error in data.frame(group = 1:3, values = split_data): arguments imply differing number of rows: 3, 4 9.6.5 Solutions ‚úÖ SOLUTION 1: Use I() to Protect List # Wrap in I() to inhibit conversion df &lt;- data.frame( id = 1:3, values = I(list(1:3, 4:6, 7:9)) ) # Or use list column explicitly df &lt;- data.frame(id = 1:3) df$values &lt;- list(1:3, 4:6, 7:9) df #&gt; id values #&gt; 1 1 1, 2, 3 #&gt; 2 2 4, 5, 6 #&gt; 3 3 7, 8, 9 ‚úÖ SOLUTION 2: Use Tibble (Easier) library(tibble) # Tibbles naturally support list columns tib &lt;- tibble( id = 1:3, values = list(1:3, 4:6, 7:9), nested = list( list(a = 1, b = 2), list(a = 3, b = 4), list(a = 5, b = 6) ) ) tib #&gt; # A tibble: 3 √ó 3 #&gt; id values nested #&gt; &lt;int&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 &lt;int [3]&gt; &lt;named list [2]&gt; #&gt; 2 2 &lt;int [3]&gt; &lt;named list [2]&gt; #&gt; 3 3 &lt;int [3]&gt; &lt;named list [2]&gt; # Clean syntax tib$values #&gt; [[1]] #&gt; [1] 1 2 3 #&gt; #&gt; [[2]] #&gt; [1] 4 5 6 #&gt; #&gt; [[3]] #&gt; [1] 7 8 9 tib$nested[[1]] #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 2 ‚úÖ SOLUTION 3: Unnest if Possible # If you don&#39;t need list column, unnest library(tidyr) # Start with list column df &lt;- tibble( id = 1:3, values = list(1:3, 4:6, 7:9) ) # Unnest to regular columns unnest(df, values) #&gt; # A tibble: 9 √ó 2 #&gt; id values #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 1 #&gt; 2 1 2 #&gt; 3 1 3 #&gt; 4 2 4 #&gt; 5 2 5 #&gt; 6 2 6 #&gt; 7 3 7 #&gt; 8 3 8 #&gt; 9 3 9 9.7 Error #5: cannot coerce class X to a data.frame ‚≠ê BEGINNER üî¢ TYPE 9.7.1 The Error # Try to convert function to data frame my_func &lt;- function(x) x + 1 as.data.frame(my_func) #&gt; Error in as.data.frame.default(my_func): cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame üî¥ ERROR Error in as.data.frame.default(my_func) : cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame 9.7.2 What It Means You‚Äôre trying to convert something to a data frame that can‚Äôt be converted. 9.7.3 Common Causes 9.7.3.1 Cause 1: Wrong Object Type # Can&#39;t convert these: as.data.frame(mean) # Function #&gt; Error in as.data.frame.default(mean): cannot coerce class &#39;&quot;function&quot;&#39; to a data.frame as.data.frame(environment()) # Environment #&gt; Error in as.data.frame.default(environment()): cannot coerce class &#39;&quot;environment&quot;&#39; to a data.frame 9.7.3.2 Cause 2: Incompatible Structure # Uneven list irregular &lt;- list( a = 1:3, b = 1:5, # Different length! c = 1:2 ) as.data.frame(irregular) #&gt; Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 3, 5, 2 9.7.3.3 Cause 3: After Failed Operation # Operation returns something unexpected result &lt;- try(stop(&quot;Error&quot;), silent = TRUE) class(result) # &quot;try-error&quot; #&gt; [1] &quot;try-error&quot; as.data.frame(result) # Can&#39;t convert error object #&gt; x #&gt; 1 Error in try(stop(&quot;Error&quot;), silent = TRUE) : Error\\n 9.7.4 Solutions ‚úÖ SOLUTION 1: Check Type First safe_as_dataframe &lt;- function(x) { # Check if already data frame if (is.data.frame(x)) { return(x) } # Check if matrix if (is.matrix(x)) { return(as.data.frame(x)) } # Check if list with equal lengths if (is.list(x)) { lens &lt;- lengths(x) if (length(unique(lens)) == 1 || all(lens == 1 | lens == max(lens))) { return(as.data.frame(x, stringsAsFactors = FALSE)) } else { stop(&quot;List has incompatible lengths: &quot;, paste(lens, collapse = &quot;, &quot;)) } } # Check if vector if (is.atomic(x)) { return(data.frame(value = x, stringsAsFactors = FALSE)) } stop(&quot;Cannot convert &quot;, class(x)[1], &quot; to data frame&quot;) } # Test safe_as_dataframe(1:5) #&gt; value #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 #&gt; 4 4 #&gt; 5 5 safe_as_dataframe(matrix(1:6, 2, 3)) #&gt; V1 V2 V3 #&gt; 1 1 3 5 #&gt; 2 2 4 6 safe_as_dataframe(list(a = 1:3, b = 4:6)) #&gt; a b #&gt; 1 1 4 #&gt; 2 2 5 #&gt; 3 3 6 ‚úÖ SOLUTION 2: Fix Structure First # Uneven list irregular &lt;- list( a = 1:3, b = 1:5, c = 1:2 ) # Option A: Pad with NA max_len &lt;- max(lengths(irregular)) regular &lt;- lapply(irregular, function(x) { c(x, rep(NA, max_len - length(x))) }) as.data.frame(regular) #&gt; a b c #&gt; 1 1 1 1 #&gt; 2 2 2 2 #&gt; 3 3 3 NA #&gt; 4 NA 4 NA #&gt; 5 NA 5 NA # Option B: Trim to shortest min_len &lt;- min(lengths(irregular)) regular &lt;- lapply(irregular, function(x) x[1:min_len]) as.data.frame(regular) #&gt; a b c #&gt; 1 1 1 1 #&gt; 2 2 2 2 9.8 Stringsasfactors Historical Issue ‚ö†Ô∏è Historical Pitfall: stringsAsFactors In R &lt; 4.0.0, stringsAsFactors = TRUE was default: # R &lt; 4.0.0 behavior df_old &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;), age = c(25, 30), stringsAsFactors = TRUE # Was default ) class(df_old$name) # &quot;factor&quot; (was default) #&gt; [1] &quot;factor&quot; # R &gt;= 4.0.0 behavior df_new &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;), age = c(25, 30) # stringsAsFactors = FALSE is now default ) class(df_new$name) # &quot;character&quot; #&gt; [1] &quot;character&quot; Best Practice: Always specify explicitly: # For compatibility across R versions data.frame(..., stringsAsFactors = FALSE) # Or use tibble (never converts to factor) tibble(...) 9.9 Creating Data Frames: All Methods üéØ Best Practice: Data Frame Creation Methods # Method 1: data.frame() - base R df1 &lt;- data.frame( x = 1:3, y = 4:6, stringsAsFactors = FALSE ) # Method 2: tibble() - modern tidyverse library(tibble) df2 &lt;- tibble( x = 1:3, y = 4:6 ) # Method 3: From matrix mat &lt;- matrix(1:6, nrow = 2, ncol = 3) df3 &lt;- as.data.frame(mat) # Method 4: From list lst &lt;- list(x = 1:3, y = 4:6) df4 &lt;- as.data.frame(lst) # Method 5: From vectors x &lt;- 1:3 y &lt;- 4:6 df5 &lt;- data.frame(x, y) # Method 6: Reading data df6 &lt;- read.csv(&quot;file.csv&quot;) # Base R #&gt; Warning in file(file, &quot;rt&quot;): cannot open file &#39;file.csv&#39;: No such file or #&gt; directory #&gt; Error in file(file, &quot;rt&quot;): cannot open the connection # df7 &lt;- read_csv(&quot;file.csv&quot;) # readr (tibble) # Method 7: tribble() - row-wise library(tibble) df8 &lt;- tribble( ~x, ~y, 1, 4, 2, 5, 3, 6 ) When to use each: - data.frame(): Base R compatibility needed - tibble(): Modern code, better defaults - as.data.frame(): Converting from other structures - tribble(): Small data, readable layout 9.10 Summary Key Takeaways: All columns must be same length (or length 1 for recycling) Row names must be unique (if used at all) Avoid row names in modern code - use column instead List columns need I() in data.frame(), or use tibble stringsAsFactors = FALSE for compatibility Check lengths before construction tibble is stricter and usually better Quick Reference: Error Cause Fix differing number of rows Unequal lengths Match lengths or use length 1 row names wrong length Row names ‚â† nrows Provide correct number duplicate row.names Non-unique names Use make.unique() or remove invalid type (list) List column in old data.frame Use I() or tibble cannot coerce to data.frame Wrong structure Check type and fix structure Construction Checklist: # Before creating data frame: lengths(list_of_vectors) # Check all lengths anyDuplicated(row_names) # Check for duplicates class(each_column) # Verify types # Safe construction: tibble(...) # Stricter checking data.frame(..., stringsAsFactors = FALSE) # Explicit # After construction: str(df) # Verify structure anyDuplicated(rownames(df)) # Check row names Modern Best Practices: # ‚úÖ Good tibble(x = 1:5, y = 10) # Stricter data.frame(x = 1:5, stringsAsFactors = FALSE) # Explicit # ‚ùå Avoid data.frame(x = 1:5) # stringsAsFactors unclear df &lt;- data.frame(x = 1:5, row.names = names) # Row names fragile 9.11 Exercises üìù Exercise 1: Diagnose the Error What‚Äôs wrong and how do you fix it? # Scenario 1 df &lt;- data.frame( id = 1:10, group = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) ) # Scenario 2 df &lt;- data.frame( x = 1:5, y = 6:10, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;e&quot;) ) # Scenario 3 df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(x = 4:6, row.names = c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) combined &lt;- rbind(df1, df2) # Scenario 4 data.frame( id = 1:3, data = list( c(1, 2, 3), c(4, 5), c(6, 7, 8, 9) ) ) üìù Exercise 2: Safe Constructor Write safe_df(...) that: 1. Checks all vectors are same length or length 1 2. Warns about recycling 3. Checks for duplicate names 4. Returns tibble or data.frame 5. Handles list columns properly üìù Exercise 3: Fix Irregular Data You have: data &lt;- list( id = 1:5, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), score = c(85, 90, 95, 88) ) Create a data frame handling the unequal lengths gracefully. üìù Exercise 4: Combine with Row Names You have multiple data frames with overlapping row names: df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(y = 4:6, row.names = c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) df3 &lt;- data.frame(z = 7:9, row.names = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) Combine them into one data frame keeping all data. 9.12 Exercise Answers Click to see answers Exercise 1: # Scenario 1 - Length mismatch (10 vs 3) # Fix: Recycle explicitly or trim df &lt;- data.frame( id = 1:10, group = rep(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), length.out = 10) ) # Scenario 2 - Duplicate row name &quot;a&quot; df &lt;- data.frame( x = 1:5, y = 6:10, row.names = make.unique(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;e&quot;)) ) # Scenario 3 - Overlapping row names df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(x = 4:6, row.names = c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) # Option A: Remove row names combined &lt;- rbind( data.frame(x = df1$x), data.frame(x = df2$x) ) # Option B: Keep as column combined &lt;- rbind( data.frame(id = rownames(df1), x = df1$x), data.frame(id = rownames(df2), x = df2$x) ) # Scenario 4 - List column (different lengths within) # Use tibble or I() library(tibble) df &lt;- tibble( id = 1:3, data = list( c(1, 2, 3), c(4, 5), c(6, 7, 8, 9) ) ) # Or with data.frame: df &lt;- data.frame(id = 1:3) df$data &lt;- list(c(1,2,3), c(4,5), c(6,7,8,9)) Exercise 2: safe_df &lt;- function(..., use_tibble = TRUE) { args &lt;- list(...) # Get lengths lens &lt;- sapply(args, length) # Check for issues max_len &lt;- max(lens) # Check compatibility recyclable &lt;- lens == 1 | lens == max_len if (!all(recyclable)) { # Check if multiples multiples &lt;- max_len %% lens == 0 if (!all(recyclable | multiples)) { stop(&quot;Incompatible lengths: &quot;, paste(lens, collapse = &quot;, &quot;), &quot;\\nMax length: &quot;, max_len) } warning(&quot;Recycling vectors of length &quot;, paste(unique(lens[!recyclable]), collapse = &quot;, &quot;), &quot; to length &quot;, max_len) } # Check names arg_names &lt;- names(args) if (!is.null(arg_names) &amp;&amp; anyDuplicated(arg_names)) { warning(&quot;Duplicate column names: &quot;, paste(arg_names[duplicated(arg_names)], collapse = &quot;, &quot;)) } # Create data frame if (use_tibble) { library(tibble) result &lt;- tibble(...) } else { result &lt;- data.frame(..., stringsAsFactors = FALSE) } return(result) } # Test safe_df(x = 1:5, y = 10) #&gt; # A tibble: 5 √ó 2 #&gt; x y #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 safe_df(x = 1:6, y = c(1, 2)) # Warning about recycling #&gt; Warning in safe_df(x = 1:6, y = c(1, 2)): Recycling vectors of length 2 to #&gt; length 6 #&gt; Error in `tibble()`: #&gt; ! Tibble columns must have compatible sizes. #&gt; ‚Ä¢ Size 6: Existing data. #&gt; ‚Ä¢ Size 2: Column `y`. #&gt; ‚Ñπ Only values of size one are recycled. Exercise 3: data &lt;- list( id = 1:5, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), score = c(85, 90, 95, 88) ) # Option A: Extend shorter with NA max_len &lt;- max(lengths(data)) data_fixed &lt;- lapply(data, function(x) { c(x, rep(NA, max_len - length(x))) }) df &lt;- as.data.frame(data_fixed, stringsAsFactors = FALSE) df #&gt; id name score #&gt; 1 1 Alice 85 #&gt; 2 2 Bob 90 #&gt; 3 3 Charlie 95 #&gt; 4 4 &lt;NA&gt; 88 #&gt; 5 5 &lt;NA&gt; NA # Option B: Trim all to shortest min_len &lt;- min(lengths(data)) data_fixed &lt;- lapply(data, function(x) x[1:min_len]) df &lt;- as.data.frame(data_fixed, stringsAsFactors = FALSE) df #&gt; id name score #&gt; 1 1 Alice 85 #&gt; 2 2 Bob 90 #&gt; 3 3 Charlie 95 # Option C: Use only complete cases # (more complex - requires pairing) Exercise 4: library(tibble) df1 &lt;- data.frame(x = 1:3, row.names = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- data.frame(y = 4:6, row.names = c(&quot;b&quot;, &quot;c&quot;, &quot;d&quot;)) df3 &lt;- data.frame(z = 7:9, row.names = c(&quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) # Convert row names to column df1_with_id &lt;- tibble(id = rownames(df1), x = df1$x) df2_with_id &lt;- tibble(id = rownames(df2), y = df2$y) df3_with_id &lt;- tibble(id = rownames(df3), z = df3$z) # Full join to keep all library(dplyr) result &lt;- df1_with_id %&gt;% full_join(df2_with_id, by = &quot;id&quot;) %&gt;% full_join(df3_with_id, by = &quot;id&quot;) result #&gt; # A tibble: 5 √ó 4 #&gt; id x y z #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 a 1 NA NA #&gt; 2 b 2 4 NA #&gt; 3 c 3 5 7 #&gt; 4 d NA 6 8 #&gt; 5 e NA NA 9 # Alternative: using merge result &lt;- merge(df1_with_id, df2_with_id, by = &quot;id&quot;, all = TRUE) result &lt;- merge(result, df3_with_id, by = &quot;id&quot;, all = TRUE) result #&gt; id x y z #&gt; 1 a 1 NA NA #&gt; 2 b 2 4 NA #&gt; 3 c 3 5 7 #&gt; 4 d NA 6 8 #&gt; 5 e NA NA 9 "],["column-manipulation.html", "Chapter 10 Column Manipulation 10.1 Introduction 10.2 Column Basics 10.3 Error #1: undefined columns selected 10.4 Error #2: replacement has X rows, data has Y 10.5 Error #3: duplicate column names 10.6 Error #4: names attribute must be same length as vector 10.7 Removing Columns 10.8 Column Reordering 10.9 Type Preservation 10.10 Adding Multiple Columns 10.11 Summary 10.12 Exercises 10.13 Exercise Answers", " Chapter 10 Column Manipulation What You‚Äôll Learn: Adding and removing columns safely Column name handling Type preservation during operations Renaming strategies Common manipulation pitfalls Key Errors Covered: 12+ column manipulation errors Difficulty: ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate 10.1 Introduction Working with data frame columns is a daily task, but it‚Äôs full of traps: df &lt;- data.frame(x = 1:5, y = 6:10) df[, &quot;z&quot;] # Typo in column name #&gt; Error in `[.data.frame`(df, , &quot;z&quot;): undefined columns selected # Or this: df$new_column &lt;- 1:3 # Wrong length! #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, new_column, value = 1:3): replacement has 3 rows, data has 5 Let‚Äôs master column manipulation to avoid these common errors. 10.2 Column Basics üí° Key Insight: Data Frame is a List Understanding this is key to column operations: df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Data frame is a special list is.list(df) #&gt; [1] TRUE length(df) # Number of columns! #&gt; [1] 3 # Each column is a list element df[[1]] # First column (vector) #&gt; [1] 1 2 3 df[1] # First column (data frame) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 # Three ways to access columns: df$x # Dollar sign #&gt; [1] 1 2 3 df[[&quot;x&quot;]] # Double bracket #&gt; [1] 1 2 3 df[&quot;x&quot;] # Single bracket (returns data frame) #&gt; x #&gt; 1 1 #&gt; 2 2 #&gt; 3 3 # Column names names(df) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; colnames(df) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; 10.3 Error #1: undefined columns selected ‚≠ê BEGINNER üìè DIMENSION 10.3.1 The Error df &lt;- data.frame(age = c(25, 30, 35), name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) df[, &quot;salary&quot;] # Column doesn&#39;t exist #&gt; Error in `[.data.frame`(df, , &quot;salary&quot;): undefined columns selected üî¥ ERROR Error in `[.data.frame`(df, , &quot;salary&quot;) : undefined columns selected 10.3.2 What It Means You‚Äôre trying to select a column that doesn‚Äôt exist in the data frame. 10.3.3 Common Causes 10.3.3.1 Cause 1: Typo df &lt;- data.frame(temperature = c(20, 25, 30)) # Typo df[, &quot;tempurature&quot;] #&gt; Error in `[.data.frame`(df, , &quot;tempurature&quot;): undefined columns selected 10.3.3.2 Cause 2: Case Sensitivity df &lt;- data.frame(Name = c(&quot;Alice&quot;, &quot;Bob&quot;)) # Wrong case df[, &quot;name&quot;] # It&#39;s &quot;Name&quot; not &quot;name&quot; #&gt; Error in `[.data.frame`(df, , &quot;name&quot;): undefined columns selected 10.3.3.3 Cause 3: Column Doesn‚Äôt Exist Yet df &lt;- data.frame(x = 1:5) # Trying to select before creating df[, c(&quot;x&quot;, &quot;y&quot;)] # &quot;y&quot; doesn&#39;t exist #&gt; Error in `[.data.frame`(df, , c(&quot;x&quot;, &quot;y&quot;)): undefined columns selected 10.3.3.4 Cause 4: After Transformation df &lt;- data.frame(x = 1:5, y = 6:10, z = 11:15) # Select some columns df_subset &lt;- df[, c(&quot;x&quot;, &quot;y&quot;)] # Try to access original column df_subset[, &quot;z&quot;] # No longer exists #&gt; Error in `[.data.frame`(df_subset, , &quot;z&quot;): undefined columns selected 10.3.4 Solutions ‚úÖ SOLUTION 1: Check Column Exists df &lt;- data.frame(age = c(25, 30, 35), name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) # Check before accessing if (&quot;salary&quot; %in% names(df)) { df[, &quot;salary&quot;] } else { message(&quot;Column &#39;salary&#39; not found&quot;) NULL } #&gt; Column &#39;salary&#39; not found #&gt; NULL # Or for multiple columns cols_wanted &lt;- c(&quot;age&quot;, &quot;salary&quot;, &quot;name&quot;) cols_available &lt;- cols_wanted[cols_wanted %in% names(df)] df[, cols_available] #&gt; age name #&gt; 1 25 Alice #&gt; 2 30 Bob #&gt; 3 35 Charlie ‚úÖ SOLUTION 2: Use dplyr‚Äôs select() with Helpers library(dplyr) df &lt;- data.frame(age = c(25, 30, 35), name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) # Select only existing columns df %&gt;% select(any_of(c(&quot;age&quot;, &quot;salary&quot;, &quot;name&quot;))) #&gt; age name #&gt; 1 25 Alice #&gt; 2 30 Bob #&gt; 3 35 Charlie # Or with error on missing df %&gt;% select(all_of(c(&quot;age&quot;, &quot;salary&quot;))) # Errors on missing #&gt; Error in `select()`: #&gt; ‚Ñπ In argument: `all_of(c(&quot;age&quot;, &quot;salary&quot;))`. #&gt; Caused by error in `all_of()`: #&gt; ! Can&#39;t subset elements that don&#39;t exist. #&gt; ‚úñ Element `salary` doesn&#39;t exist. ‚úÖ SOLUTION 3: Safe Column Selection Function safe_select &lt;- function(df, cols, warn = TRUE) { existing &lt;- cols[cols %in% names(df)] missing &lt;- cols[!cols %in% names(df)] if (length(missing) &gt; 0 &amp;&amp; warn) { warning(&quot;Columns not found: &quot;, paste(missing, collapse = &quot;, &quot;)) } if (length(existing) == 0) { return(data.frame()) # Empty data frame } return(df[, existing, drop = FALSE]) } # Test df &lt;- data.frame(x = 1:5, y = 6:10) safe_select(df, c(&quot;x&quot;, &quot;z&quot;, &quot;y&quot;)) #&gt; Warning in safe_select(df, c(&quot;x&quot;, &quot;z&quot;, &quot;y&quot;)): Columns not found: z #&gt; x y #&gt; 1 1 6 #&gt; 2 2 7 #&gt; 3 3 8 #&gt; 4 4 9 #&gt; 5 5 10 10.4 Error #2: replacement has X rows, data has Y ‚≠ê BEGINNER üìè DIMENSION 10.4.1 The Error df &lt;- data.frame(x = 1:5, y = 6:10) df$z &lt;- 1:3 # Wrong length! #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, z, value = 1:3): replacement has 3 rows, data has 5 üî¥ ERROR Error in `$&lt;-.data.frame`(`*tmp*`, z, value = 1:3) : replacement has 3 rows, data has 5 10.4.2 What It Means When adding/replacing a column, the new values must match the number of rows (or be length 1). 10.4.3 The Recycling Rule for Columns df &lt;- data.frame(x = 1:5) # Length 1: recycles df$y &lt;- 10 df #&gt; x y #&gt; 1 1 10 #&gt; 2 2 10 #&gt; 3 3 10 #&gt; 4 4 10 #&gt; 5 5 10 # Same length: works df$z &lt;- 11:15 df #&gt; x y z #&gt; 1 1 10 11 #&gt; 2 2 10 12 #&gt; 3 3 10 13 #&gt; 4 4 10 14 #&gt; 5 5 10 15 # Wrong length: errors df$w &lt;- 1:3 #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, w, value = 1:3): replacement has 3 rows, data has 5 10.4.4 Common Causes 10.4.4.1 Cause 1: Calculation Resulted in Wrong Length df &lt;- data.frame(id = 1:10, value = rnorm(10)) # Filter creates shorter vector high_values &lt;- df$value[df$value &gt; 0] # Maybe 6 elements # Try to add back df$high &lt;- high_values # Error! 6 vs 10 #&gt; Error in `$&lt;-.data.frame`(`*tmp*`, high, value = c(1.77950290977515, 0.286424419628825, : replacement has 7 rows, data has 10 10.4.4.2 Cause 2: Using Summary on Column df &lt;- data.frame( group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 5), value = 1:10 ) # Calculate group means (2 values) group_means &lt;- tapply(df$value, df$group, mean) # Try to add as column df$mean &lt;- group_means # Error! 2 vs 10 10.4.4.3 Cause 3: After Subsetting df &lt;- data.frame(x = 1:10, y = 11:20) # Subset rows df_sub &lt;- df[1:5, ] # Create column for full df new_col &lt;- 1:5 # Try to add to original df$new &lt;- new_col # Error! 5 vs 10 10.4.5 Solutions ‚úÖ SOLUTION 1: Match Lengths df &lt;- data.frame(id = 1:10, value = rnorm(10)) high_values &lt;- df$value[df$value &gt; 0] # Option A: Use NA for missing df$high &lt;- NA df$high[df$value &gt; 0] &lt;- high_values df #&gt; id value high #&gt; 1 1 -0.19051680 NA #&gt; 2 2 0.37842390 0.37842390 #&gt; 3 3 0.30003855 0.30003855 #&gt; 4 4 -1.00563626 NA #&gt; 5 5 0.01925927 0.01925927 #&gt; 6 6 -1.07742065 NA #&gt; 7 7 0.71270333 0.71270333 #&gt; 8 8 1.08477509 1.08477509 #&gt; 9 9 -2.22498770 NA #&gt; 10 10 1.23569346 1.23569346 # Option B: Use ifelse df$high &lt;- ifelse(df$value &gt; 0, df$value, NA) ‚úÖ SOLUTION 2: Use Merge for Aggregates df &lt;- data.frame( group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 5), value = 1:10 ) # Calculate group means group_summary &lt;- aggregate(value ~ group, df, mean) names(group_summary)[2] &lt;- &quot;group_mean&quot; # Merge back df &lt;- merge(df, group_summary, by = &quot;group&quot;) df #&gt; group value group_mean #&gt; 1 A 1 3 #&gt; 2 A 2 3 #&gt; 3 A 3 3 #&gt; 4 A 4 3 #&gt; 5 A 5 3 #&gt; 6 B 6 8 #&gt; 7 B 7 8 #&gt; 8 B 8 8 #&gt; 9 B 9 8 #&gt; 10 B 10 8 ‚úÖ SOLUTION 3: Use dplyr (Cleaner) library(dplyr) df &lt;- data.frame( group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 5), value = 1:10 ) # Add group mean to each row df &lt;- df %&gt;% group_by(group) %&gt;% mutate(group_mean = mean(value)) %&gt;% ungroup() df #&gt; # A tibble: 10 √ó 3 #&gt; group value group_mean #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 A 1 3 #&gt; 2 A 2 3 #&gt; 3 A 3 3 #&gt; 4 A 4 3 #&gt; 5 A 5 3 #&gt; 6 B 6 8 #&gt; 7 B 7 8 #&gt; 8 B 8 8 #&gt; 9 B 9 8 #&gt; 10 B 10 8 10.5 Error #3: duplicate column names ‚≠ê BEGINNER üî§ SYNTAX 10.5.1 The Warning/Problem df &lt;- data.frame(x = 1:3, x = 4:6, check.names = FALSE) names(df) #&gt; [1] &quot;x&quot; &quot;x&quot; R allows duplicate column names (with warning), but it causes problems: # Which x? df$x # Gets first one #&gt; [1] 1 2 3 # Confusion! df[, &quot;x&quot;] # Gets first one #&gt; [1] 1 2 3 10.5.2 Why It‚Äôs Dangerous # Create with duplicates df &lt;- data.frame(value = 1:3, value = 4:6, check.names = FALSE) # Operations become unpredictable df$value &lt;- df$value * 2 # Which one gets modified? df #&gt; value value #&gt; 1 2 4 #&gt; 2 4 5 #&gt; 3 6 6 # Selection is confusing df[, c(&quot;value&quot;, &quot;value&quot;)] # Gets same column twice #&gt; value value.1 #&gt; 1 2 2 #&gt; 2 4 4 #&gt; 3 6 6 10.5.3 Solutions ‚úÖ SOLUTION 1: Let R Fix Names # Default: R makes names unique df &lt;- data.frame(x = 1:3, x = 4:6) # check.names = TRUE by default names(df) # &quot;x&quot; and &quot;x.1&quot; #&gt; [1] &quot;x&quot; &quot;x.1&quot; # Or manually names_original &lt;- c(&quot;value&quot;, &quot;value&quot;, &quot;score&quot;) names_fixed &lt;- make.names(names_original, unique = TRUE) names_fixed #&gt; [1] &quot;value&quot; &quot;value.1&quot; &quot;score&quot; ‚úÖ SOLUTION 2: Check and Fix Names fix_duplicate_names &lt;- function(df) { col_names &lt;- names(df) if (anyDuplicated(col_names)) { dupes &lt;- col_names[duplicated(col_names)] warning(&quot;Duplicate column names found: &quot;, paste(unique(dupes), collapse = &quot;, &quot;)) names(df) &lt;- make.names(col_names, unique = TRUE) } return(df) } # Test df &lt;- data.frame(x = 1:3, x = 4:6, check.names = FALSE) df &lt;- fix_duplicate_names(df) #&gt; Warning in fix_duplicate_names(df): Duplicate column names found: x names(df) #&gt; [1] &quot;x&quot; &quot;x.1&quot; ‚úÖ SOLUTION 3: Prevent Duplicates safe_add_column &lt;- function(df, name, values) { if (name %in% names(df)) { stop(&quot;Column &#39;&quot;, name, &quot;&#39; already exists. &quot;, &quot;Use a different name or remove the existing column first.&quot;) } df[[name]] &lt;- values return(df) } # Test df &lt;- data.frame(x = 1:3) df &lt;- safe_add_column(df, &quot;y&quot;, 4:6) # Works df &lt;- safe_add_column(df, &quot;x&quot;, 7:9) # Errors #&gt; Error in safe_add_column(df, &quot;x&quot;, 7:9): Column &#39;x&#39; already exists. Use a different name or remove the existing column first. 10.6 Error #4: names attribute must be same length as vector ‚≠ê BEGINNER üìè DIMENSION 10.6.1 The Error df &lt;- data.frame(x = 1:5, y = 6:10, z = 11:15) names(df) &lt;- c(&quot;a&quot;, &quot;b&quot;) # Only 2 names for 3 columns! üî¥ ERROR Error in names(df) &lt;- c(&quot;a&quot;, &quot;b&quot;) : &#39;names&#39; attribute must be the same length as the vector (3) 10.6.2 What It Means When setting column names, you must provide exactly one name per column. 10.6.3 Common Causes 10.6.3.1 Cause 1: Wrong Count df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Too few names(df) &lt;- c(&quot;first&quot;, &quot;second&quot;) # Too many names(df) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;) #&gt; Error in names(df) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;): &#39;names&#39; attribute [4] must be the same length as the vector [3] 10.6.3.2 Cause 2: After Adding Columns df &lt;- data.frame(x = 1:3, y = 4:6) new_names &lt;- c(&quot;a&quot;, &quot;b&quot;) # Add a column df$z &lt;- 7:9 # Try to use old names names(df) &lt;- new_names # Error! Now 3 columns 10.6.3.3 Cause 3: From External Source df &lt;- data.frame(matrix(1:12, nrow = 3, ncol = 4)) column_labels &lt;- c(&quot;ID&quot;, &quot;Value&quot;) # Wrong number names(df) &lt;- column_labels 10.6.4 Solutions ‚úÖ SOLUTION 1: Match Number of Names df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Provide all names names(df) &lt;- c(&quot;first&quot;, &quot;second&quot;, &quot;third&quot;) # Or rename specific columns names(df)[1] &lt;- &quot;id&quot; names(df)[3] &lt;- &quot;score&quot; names(df) #&gt; [1] &quot;id&quot; &quot;second&quot; &quot;score&quot; ‚úÖ SOLUTION 2: Use Named Vector for Partial Rename library(dplyr) df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Rename specific columns df &lt;- df %&gt;% rename(id = x, score = z) names(df) #&gt; [1] &quot;id&quot; &quot;y&quot; &quot;score&quot; # Or base R names(df)[names(df) == &quot;y&quot;] &lt;- &quot;value&quot; names(df) #&gt; [1] &quot;id&quot; &quot;value&quot; &quot;score&quot; ‚úÖ SOLUTION 3: Safe Rename Function safe_rename &lt;- function(df, ...) { name_mapping &lt;- list(...) for (old_name in names(name_mapping)) { new_name &lt;- name_mapping[[old_name]] if (!old_name %in% names(df)) { warning(&quot;Column &#39;&quot;, old_name, &quot;&#39; not found, skipping&quot;) next } if (new_name %in% names(df) &amp;&amp; new_name != old_name) { warning(&quot;Column &#39;&quot;, new_name, &quot;&#39; already exists, skipping&quot;) next } names(df)[names(df) == old_name] &lt;- new_name } return(df) } # Test df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) df &lt;- safe_rename(df, x = &quot;id&quot;, z = &quot;score&quot;, w = &quot;missing&quot;) #&gt; Warning in safe_rename(df, x = &quot;id&quot;, z = &quot;score&quot;, w = &quot;missing&quot;): Column &#39;w&#39; #&gt; not found, skipping names(df) #&gt; [1] &quot;id&quot; &quot;y&quot; &quot;score&quot; 10.7 Removing Columns üéØ Best Practice: Removing Columns df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) # Method 1: Set to NULL df$y &lt;- NULL df #&gt; x z #&gt; 1 1 7 #&gt; 2 2 8 #&gt; 3 3 9 # Method 2: Subset (keep what you want) df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) df &lt;- df[, c(&quot;x&quot;, &quot;z&quot;)] df #&gt; x z #&gt; 1 1 7 #&gt; 2 2 8 #&gt; 3 3 9 # Method 3: Subset (exclude what you don&#39;t want) df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) df &lt;- df[, !names(df) %in% c(&quot;y&quot;)] df #&gt; x z #&gt; 1 1 7 #&gt; 2 2 8 #&gt; 3 3 9 # Method 4: dplyr select with minus library(dplyr) df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9) df &lt;- df %&gt;% select(-y) df #&gt; x z #&gt; 1 1 7 #&gt; 2 2 8 #&gt; 3 3 9 # Method 5: Remove multiple df &lt;- data.frame(x = 1:3, y = 4:6, z = 7:9, w = 10:12) df &lt;- df %&gt;% select(-c(y, w)) df #&gt; x z #&gt; 1 1 7 #&gt; 2 2 8 #&gt; 3 3 9 Never do this: # ‚ùå Bad: modifies in place df[, &quot;y&quot;] &lt;- NULL # Doesn&#39;t work as expected! # ‚úÖ Good: explicit assignment df$y &lt;- NULL 10.8 Column Reordering üí° Key Insight: Reordering Columns df &lt;- data.frame(z = 7:9, x = 1:3, y = 4:6) names(df) #&gt; [1] &quot;z&quot; &quot;x&quot; &quot;y&quot; # Method 1: Specify order explicitly df &lt;- df[, c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)] names(df) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; # Method 2: Sort alphabetically df &lt;- df[, sort(names(df))] names(df) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; # Method 3: Move specific columns first df &lt;- data.frame(z = 7:9, x = 1:3, y = 4:6) df &lt;- df[, c(&quot;x&quot;, setdiff(names(df), &quot;x&quot;))] names(df) #&gt; [1] &quot;x&quot; &quot;z&quot; &quot;y&quot; # Method 4: dplyr relocate library(dplyr) df &lt;- data.frame(z = 7:9, x = 1:3, y = 4:6) df &lt;- df %&gt;% relocate(x, y, z) names(df) #&gt; [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; # Or move to front/end df &lt;- data.frame(z = 7:9, x = 1:3, y = 4:6) df &lt;- df %&gt;% relocate(x, .before = everything()) df %&gt;% relocate(z, .after = everything()) #&gt; x y z #&gt; 1 1 4 7 #&gt; 2 2 5 8 #&gt; 3 3 6 9 10.9 Type Preservation ‚ö†Ô∏è Common Pitfall: Type Changes # Start with factors df &lt;- data.frame( id = 1:3, category = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), stringsAsFactors = TRUE ) class(df$category) # &quot;factor&quot; #&gt; [1] &quot;factor&quot; # Select columns - type changes! df_subset &lt;- df[, &quot;category&quot;] class(df_subset) # &quot;factor&quot; (still) #&gt; [1] &quot;factor&quot; # But extract as vector vec &lt;- df$category class(vec) # &quot;factor&quot; #&gt; [1] &quot;factor&quot; # With drop = TRUE (default) df_subset &lt;- df[, &quot;category&quot;, drop = TRUE] class(df_subset) # &quot;factor&quot; - becomes vector #&gt; [1] &quot;factor&quot; # With drop = FALSE df_subset &lt;- df[, &quot;category&quot;, drop = FALSE] class(df_subset) # &quot;data.frame&quot; - stays data frame #&gt; [1] &quot;data.frame&quot; Best practice: # Use drop = FALSE when you want to keep data frame structure df[, &quot;category&quot;, drop = FALSE] #&gt; category #&gt; 1 A #&gt; 2 B #&gt; 3 C # Or use $ when you explicitly want a vector df$category #&gt; [1] A B C #&gt; Levels: A B C 10.10 Adding Multiple Columns üéØ Best Practice: Adding Multiple Columns df &lt;- data.frame(x = 1:5) # Method 1: One at a time df$y &lt;- 6:10 df$z &lt;- 11:15 # Method 2: cbind df &lt;- data.frame(x = 1:5) df &lt;- cbind(df, data.frame(y = 6:10, z = 11:15)) # Method 3: dplyr mutate library(dplyr) df &lt;- data.frame(x = 1:5) df &lt;- df %&gt;% mutate( y = x + 5, z = y + 5 ) # Method 4: Transform base R df &lt;- data.frame(x = 1:5) df &lt;- transform(df, y = x + 5, z = y + 5 # Can reference previous ) #&gt; Error in data.frame(structure(list(x = 1:5), class = &quot;data.frame&quot;, row.names = c(NA, : arguments imply differing number of rows: 5, 3 # Method 5: within df &lt;- data.frame(x = 1:5) df &lt;- within(df, { y &lt;- x + 5 z &lt;- y + 5 }) 10.11 Summary Key Takeaways: Check column exists before accessing with %in% names() Match row count when adding columns (or use length 1) Avoid duplicate names - check with anyDuplicated() Provide all names when renaming - one per column Use drop = FALSE to preserve data frame structure $ sets to NULL removes columns cleanly dplyr is clearer for complex column operations Quick Reference: Error Cause Fix undefined columns selected Column doesn‚Äôt exist Check with %in% names() replacement has X rows Wrong length column Match nrows or use length 1 duplicate column names Non-unique names Use make.names(unique=TRUE) names attribute wrong length Wrong # of names Provide one per column Column Operations Checklist: # Before accessing: &quot;colname&quot; %in% names(df) # Check exists anyDuplicated(names(df)) # Check no duplicates # When adding column: length(new_values) == nrow(df) || length(new_values) == 1 # When renaming: length(new_names) == ncol(df) !anyDuplicated(new_names) # Safe patterns: df$col &lt;- NULL # Remove column df[, cols, drop = FALSE] # Keep as data frame Best Practices: # ‚úÖ Good df %&gt;% select(any_of(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))) # Safe selection df %&gt;% mutate(new = old * 2) # Add column names(df)[names(df) == &quot;old&quot;] &lt;- &quot;new&quot; # Rename one # ‚ùå Avoid df[, &quot;missing_col&quot;] # No check df$new &lt;- wrong_length_vector # No validation names(df) &lt;- c(&quot;a&quot;, &quot;b&quot;) # Partial names 10.12 Exercises üìù Exercise 1: Safe Column Access Write a function that safely gets a column: - Returns the column if it exists - Returns default value if it doesn‚Äôt - Warns user about missing columns - Handles both $ and [[ ]] style access üìù Exercise 2: Batch Rename You have: df &lt;- data.frame( old_name_1 = 1:5, old_name_2 = 6:10, old_name_3 = 11:15 ) Write a function to rename all columns matching a pattern. üìù Exercise 3: Safe Column Addition Write add_column(df, name, values) that: 1. Checks if name already exists 2. Validates values length 3. Handles recycling appropriately 4. Returns modified data frame 5. Gives informative errors üìù Exercise 4: Column Audit Write a function that audits a data frame and reports: - Missing column names - Duplicate column names - Invalid column names (non-syntactic) - Columns with NA names 10.13 Exercise Answers Click to see answers Exercise 1: safe_get_column &lt;- function(df, col, default = NULL, warn = TRUE) { if (!col %in% names(df)) { if (warn) { warning(&quot;Column &#39;&quot;, col, &quot;&#39; not found in data frame&quot;) } return(default) } return(df[[col]]) } # Test df &lt;- data.frame(x = 1:5, y = 6:10) safe_get_column(df, &quot;x&quot;) # Returns column #&gt; [1] 1 2 3 4 5 safe_get_column(df, &quot;z&quot;) # Returns NULL with warning #&gt; Warning in safe_get_column(df, &quot;z&quot;): Column &#39;z&#39; not found in data frame #&gt; NULL safe_get_column(df, &quot;z&quot;, default = NA, warn = FALSE) #&gt; [1] NA Exercise 2: rename_pattern &lt;- function(df, pattern, replacement) { old_names &lt;- names(df) new_names &lt;- gsub(pattern, replacement, old_names) if (identical(old_names, new_names)) { message(&quot;No columns matched pattern &#39;&quot;, pattern, &quot;&#39;&quot;) return(df) } # Check for duplicates after rename if (anyDuplicated(new_names)) { warning(&quot;Renaming would create duplicate names, using make.unique()&quot;) new_names &lt;- make.unique(new_names) } names(df) &lt;- new_names # Report changes changed &lt;- old_names != new_names if (any(changed)) { message(&quot;Renamed &quot;, sum(changed), &quot; columns:&quot;) for (i in which(changed)) { message(&quot; &quot;, old_names[i], &quot; -&gt; &quot;, new_names[i]) } } return(df) } # Test df &lt;- data.frame( old_name_1 = 1:5, old_name_2 = 6:10, old_name_3 = 11:15 ) df &lt;- rename_pattern(df, &quot;old_name_&quot;, &quot;new_col_&quot;) #&gt; Renamed 3 columns: #&gt; old_name_1 -&gt; new_col_1 #&gt; old_name_2 -&gt; new_col_2 #&gt; old_name_3 -&gt; new_col_3 names(df) #&gt; [1] &quot;new_col_1&quot; &quot;new_col_2&quot; &quot;new_col_3&quot; Exercise 3: add_column &lt;- function(df, name, values, overwrite = FALSE) { # Check if name exists if (name %in% names(df) &amp;&amp; !overwrite) { stop(&quot;Column &#39;&quot;, name, &quot;&#39; already exists. &quot;, &quot;Use overwrite = TRUE to replace.&quot;) } # Check length n_rows &lt;- nrow(df) n_values &lt;- length(values) if (n_values == n_rows) { # Perfect match df[[name]] &lt;- values } else if (n_values == 1) { # Recycle single value message(&quot;Recycling single value to &quot;, n_rows, &quot; rows&quot;) df[[name]] &lt;- values } else if (n_rows %% n_values == 0) { # Multiple recycling message(&quot;Recycling &quot;, n_values, &quot; values to &quot;, n_rows, &quot; rows&quot;) df[[name]] &lt;- rep(values, length.out = n_rows) } else { stop(&quot;Length mismatch: values has &quot;, n_values, &quot; elements but data frame has &quot;, n_rows, &quot; rows&quot;) } return(df) } # Test df &lt;- data.frame(x = 1:5) df &lt;- add_column(df, &quot;y&quot;, 10) # Recycles #&gt; Recycling single value to 5 rows df &lt;- add_column(df, &quot;z&quot;, 11:15) # Matches df &lt;- add_column(df, &quot;w&quot;, 1:3) # Errors #&gt; Error in add_column(df, &quot;w&quot;, 1:3): Length mismatch: values has 3 elements but data frame has 5 rows Exercise 4: audit_columns &lt;- function(df) { col_names &lt;- names(df) issues &lt;- list() # Check for missing names if (any(is.na(col_names) | col_names == &quot;&quot;)) { issues$missing &lt;- which(is.na(col_names) | col_names == &quot;&quot;) } # Check for duplicates if (anyDuplicated(col_names)) { dupes &lt;- col_names[duplicated(col_names)] issues$duplicates &lt;- unique(dupes) } # Check for invalid names (non-syntactic) valid &lt;- make.names(col_names) == col_names if (!all(valid)) { issues$invalid &lt;- col_names[!valid] } # Report if (length(issues) == 0) { message(&quot;‚úì All column names are valid&quot;) return(invisible(TRUE)) } message(&quot;Column name issues found:&quot;) if (!is.null(issues$missing)) { message(&quot; Missing names at positions: &quot;, paste(issues$missing, collapse = &quot;, &quot;)) } if (!is.null(issues$duplicates)) { message(&quot; Duplicate names: &quot;, paste(issues$duplicates, collapse = &quot;, &quot;)) } if (!is.null(issues$invalid)) { message(&quot; Invalid names: &quot;, paste(issues$invalid, collapse = &quot;, &quot;)) message(&quot; Suggested: &quot;, paste(make.names(issues$invalid), collapse = &quot;, &quot;)) } return(invisible(issues)) } # Test df_good &lt;- data.frame(x = 1:3, y = 4:6) audit_columns(df_good) #&gt; ‚úì All column names are valid df_bad &lt;- data.frame(x = 1:3, x = 4:6, `2bad` = 7:9, check.names = FALSE) audit_columns(df_bad) #&gt; Column name issues found: #&gt; Duplicate names: x #&gt; Invalid names: 2bad #&gt; Suggested: X2bad "],["matrix-operations.html", "Chapter 11 Matrix Operations 11.1 Introduction 11.2 Matrix Basics 11.3 Error #1: non-conformable arrays 11.4 Error #2: non-conformable arguments 11.5 Error #3: system is computationally singular 11.6 Matrix Creation Errors 11.7 Matrix Operations Reference 11.8 Dimension Preservation 11.9 Converting Between Structures 11.10 Summary 11.11 Exercises 11.12 Exercise Answers", " Chapter 11 Matrix Operations What You‚Äôll Learn: Matrix creation and structure Matrix algebra operations Dimension requirements Transpose and multiplication Common matrix errors Key Errors Covered: 12+ matrix operation errors Difficulty: ‚≠ê‚≠ê Intermediate 11.1 Introduction Matrices are fundamental to many R operations, especially statistics and linear algebra: A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) # Try to add them A + B #&gt; Error in A + B: non-conformable arrays üî¥ ERROR Error in A + B : non-conformable arrays Let‚Äôs master matrix operations and avoid dimension mismatches. 11.2 Matrix Basics üí° Key Insight: Matrices vs Data Frames # Matrix: all same type mat &lt;- matrix(1:6, nrow = 2, ncol = 3) typeof(mat) # &quot;integer&quot; #&gt; [1] &quot;integer&quot; is.matrix(mat) #&gt; [1] TRUE is.data.frame(mat) #&gt; [1] FALSE # Data frame: can mix types df &lt;- data.frame( x = 1:2, y = c(&quot;a&quot;, &quot;b&quot;) ) is.matrix(df) #&gt; [1] FALSE is.data.frame(df) #&gt; [1] TRUE # Can convert as.matrix(df) # Coerces to character! #&gt; x y #&gt; [1,] &quot;1&quot; &quot;a&quot; #&gt; [2,] &quot;2&quot; &quot;b&quot; as.data.frame(mat) #&gt; V1 V2 V3 #&gt; 1 1 3 5 #&gt; 2 2 4 6 # Matrix properties dim(mat) # 2 3 (rows, cols) #&gt; [1] 2 3 nrow(mat) #&gt; [1] 2 ncol(mat) #&gt; [1] 3 length(mat) # 6 (total elements) #&gt; [1] 6 Key differences: - Matrices: All same type, 2D array - Data frames: Can mix types, list of vectors 11.3 Error #1: non-conformable arrays ‚≠ê‚≠ê INTERMEDIATE üìè DIMENSION 11.3.1 The Error A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:10, nrow = 2, ncol = 5) A + B # Different dimensions! #&gt; Error in A + B: non-conformable arrays üî¥ ERROR Error in A + B : non-conformable arrays 11.3.2 What It Means For element-wise operations (+, -, *, /), matrices must have the same dimensions. 11.3.3 Conformability Rules # Same dimensions - OK A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(7:12, nrow = 2, ncol = 3) A + B #&gt; [,1] [,2] [,3] #&gt; [1,] 8 12 16 #&gt; [2,] 10 14 18 # Scalar - OK (recycled) A + 10 #&gt; [,1] [,2] [,3] #&gt; [1,] 11 13 15 #&gt; [2,] 12 14 16 # Vector recycling A + c(1, 2) # Recycles down columns #&gt; [,1] [,2] [,3] #&gt; [1,] 2 4 6 #&gt; [2,] 4 6 8 # But these fail: A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) A + B # Different dimensions #&gt; Error in A + B: non-conformable arrays 11.3.4 Common Causes 11.3.4.1 Cause 1: Transposed Matrix A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) # B is transpose of A shape A + B # Error #&gt; Error in A + B: non-conformable arrays # Fix: transpose one A + t(B) #&gt; [,1] [,2] [,3] #&gt; [1,] 2 5 8 #&gt; [2,] 6 9 12 11.3.4.2 Cause 2: Wrong Construction # Meant to be same size A &lt;- matrix(1:6, nrow = 2) # 2x3 B &lt;- matrix(1:8, nrow = 2) # 2x4 A + B # Error #&gt; Error in A + B: non-conformable arrays 11.3.4.3 Cause 3: After Subsetting A &lt;- matrix(1:12, nrow = 3, ncol = 4) B &lt;- matrix(1:12, nrow = 3, ncol = 4) # Subset changes dimensions A_sub &lt;- A[, 1:2] # Now 3x2 B_sub &lt;- B[, 1:3] # Now 3x3 A_sub + B_sub # Error! #&gt; Error in A_sub + B_sub: non-conformable arrays 11.3.5 Solutions ‚úÖ SOLUTION 1: Check Dimensions First safe_matrix_add &lt;- function(A, B) { if (!identical(dim(A), dim(B))) { stop(&quot;Matrices have different dimensions: &quot;, paste(dim(A), collapse = &quot;x&quot;), &quot; vs &quot;, paste(dim(B), collapse = &quot;x&quot;)) } return(A + B) } # Test A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(7:12, nrow = 2, ncol = 3) safe_matrix_add(A, B) #&gt; [,1] [,2] [,3] #&gt; [1,] 8 12 16 #&gt; [2,] 10 14 18 ‚úÖ SOLUTION 2: Reshape to Match A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) # Transpose B to match B_matched &lt;- t(B) A + B_matched #&gt; [,1] [,2] [,3] #&gt; [1,] 2 5 8 #&gt; [2,] 6 9 12 # Or reshape B_reshaped &lt;- matrix(B, nrow = 2, ncol = 3) A + B_reshaped #&gt; [,1] [,2] [,3] #&gt; [1,] 2 6 10 #&gt; [2,] 4 8 12 ‚úÖ SOLUTION 3: Extract Common Dimensions A &lt;- matrix(1:12, nrow = 3, ncol = 4) B &lt;- matrix(1:15, nrow = 3, ncol = 5) # Find common dimensions common_rows &lt;- min(nrow(A), nrow(B)) common_cols &lt;- min(ncol(A), ncol(B)) # Extract submatrices A_sub &lt;- A[1:common_rows, 1:common_cols] B_sub &lt;- B[1:common_rows, 1:common_cols] A_sub + B_sub #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 2 8 14 20 #&gt; [2,] 4 10 16 22 #&gt; [3,] 6 12 18 24 11.4 Error #2: non-conformable arguments ‚≠ê‚≠ê INTERMEDIATE üìè DIMENSION 11.4.1 The Error A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 2, ncol = 3) # Try matrix multiplication A %*% B #&gt; Error in A %*% B: non-conformable arguments üî¥ ERROR Error in A %*% B : non-conformable arguments 11.4.2 What It Means For matrix multiplication (%*%), the number of columns in A must equal the number of rows in B. 11.4.3 Matrix Multiplication Rules üí° Matrix Multiplication Requirements For A %*% B: - A must be m √ó n - B must be n √ó p - Result will be m √ó p # A is 2√ó3, B is 3√ó2 - OK A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) dim(A) # 2 3 #&gt; [1] 2 3 dim(B) # 3 2 #&gt; [1] 3 2 result &lt;- A %*% B dim(result) # 2 2 (outer dimensions) #&gt; [1] 2 2 Rule: Inner dimensions must match, outer dimensions form result. (2 √ó 3) %*% (3 √ó 2) = (2 √ó 2) ‚Üë ‚Üë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò must match 11.4.4 Common Causes 11.4.4.1 Cause 1: Wrong Order A &lt;- matrix(1:6, nrow = 2, ncol = 3) # 2√ó3 B &lt;- matrix(1:10, nrow = 2, ncol = 5) # 2√ó5 # A has 3 cols, B has 2 rows - mismatch! A %*% B #&gt; Error in A %*% B: non-conformable arguments # But reverse works! B %*% A # 2√ó5 times 5√ó3... wait, A is 2√ó3 #&gt; Error in B %*% A: non-conformable arguments # Need to transpose A B %*% t(A) # 2√ó5 times 5√ó2 = 2√ó2 #&gt; Error in B %*% t(A): non-conformable arguments 11.4.4.2 Cause 2: Using Element-wise Instead A &lt;- matrix(1:4, nrow = 2) B &lt;- matrix(5:8, nrow = 2) # Element-wise multiplication (different!) A * B # Hadamard product #&gt; [,1] [,2] #&gt; [1,] 5 21 #&gt; [2,] 12 32 # Matrix multiplication A %*% t(B) # Need to transpose #&gt; [,1] [,2] #&gt; [1,] 26 30 #&gt; [2,] 38 44 11.4.5 Solutions ‚úÖ SOLUTION 1: Check Conformability can_multiply &lt;- function(A, B) { ncol(A) == nrow(B) } safe_matrix_mult &lt;- function(A, B) { if (!can_multiply(A, B)) { stop(&quot;Cannot multiply: A is &quot;, nrow(A), &quot;√ó&quot;, ncol(A), &quot;, B is &quot;, nrow(B), &quot;√ó&quot;, ncol(B), &quot;\\nNeed ncol(A) = nrow(B)&quot;) } return(A %*% B) } # Test A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) safe_matrix_mult(A, B) #&gt; [,1] [,2] #&gt; [1,] 22 49 #&gt; [2,] 28 64 ‚úÖ SOLUTION 2: Auto-transpose if Needed smart_mult &lt;- function(A, B) { # Try as-is if (ncol(A) == nrow(B)) { return(A %*% B) } # Try transposing B if (ncol(A) == ncol(B)) { message(&quot;Transposing B&quot;) return(A %*% t(B)) } # Try transposing A if (nrow(A) == nrow(B)) { message(&quot;Transposing A&quot;) return(t(A) %*% B) } stop(&quot;Matrices not conformable in any configuration&quot;) } # Test A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 2, ncol = 3) smart_mult(A, B) # Transposes B #&gt; Transposing B #&gt; [,1] [,2] #&gt; [1,] 35 44 #&gt; [2,] 44 56 11.5 Error #3: system is computationally singular ‚≠ê‚≠ê‚≠ê ADVANCED üßÆ MATH 11.5.1 The Error # Singular matrix (not invertible) A &lt;- matrix(c(1, 2, 2, 4), nrow = 2) A #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 2 4 solve(A) # Try to invert #&gt; Error in solve.default(A): Lapack routine dgesv: system is exactly singular: U[2,2] = 0 üî¥ ERROR Error in solve.default(A) : system is computationally singular: reciprocal condition number = 0 11.5.2 What It Means The matrix is singular (non-invertible). Its determinant is 0 (or very close to 0). 11.5.3 Why Matrices Become Singular # Linearly dependent rows A &lt;- matrix(c(1, 2, 2, 4), nrow = 2) A #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 2 4 # Row 2 = 2 * Row 1 det(A) # 0 (singular) #&gt; [1] 0 # Compare to invertible matrix B &lt;- matrix(c(1, 2, 3, 4), nrow = 2) det(B) # -2 (non-zero, invertible) #&gt; [1] -2 solve(B) # Works #&gt; [,1] [,2] #&gt; [1,] -2 1.5 #&gt; [2,] 1 -0.5 11.5.4 Common Causes 11.5.4.1 Cause 1: Perfect Collinearity # Data with perfect correlation x1 &lt;- 1:5 x2 &lt;- 2 * x1 # Perfectly correlated X &lt;- cbind(1, x1, x2) # Design matrix A &lt;- t(X) %*% X # X&#39;X matrix solve(A) # Singular! #&gt; Error in solve.default(A): Lapack routine dgesv: system is exactly singular: U[3,3] = 0 11.5.4.2 Cause 2: More Variables Than Observations # 3 observations, 5 variables X &lt;- matrix(rnorm(15), nrow = 3, ncol = 5) A &lt;- t(X) %*% X # 5√ó5 matrix solve(A) # Singular! #&gt; Error in solve.default(A): Lapack routine dgesv: system is exactly singular: U[5,5] = 0 11.5.4.3 Cause 3: Numerical Issues # Very small numbers can cause numerical singularity A &lt;- matrix(c(1, 1e-10, 1e-10, 1), nrow = 2) solve(A) # May fail due to numerical precision #&gt; [,1] [,2] #&gt; [1,] 1e+00 -1e-10 #&gt; [2,] -1e-10 1e+00 11.5.5 Solutions ‚úÖ SOLUTION 1: Check Before Inverting safe_solve &lt;- function(A, tol = 1e-10) { # Check if square if (nrow(A) != ncol(A)) { stop(&quot;Matrix must be square&quot;) } # Check determinant d &lt;- det(A) if (abs(d) &lt; tol) { stop(&quot;Matrix is singular (det = &quot;, d, &quot;)&quot;) } return(solve(A)) } # Test B &lt;- matrix(c(1, 2, 3, 4), nrow = 2) safe_solve(B) # Works #&gt; [,1] [,2] #&gt; [1,] -2 1.5 #&gt; [2,] 1 -0.5 A &lt;- matrix(c(1, 2, 2, 4), nrow = 2) safe_solve(A) # Clear error message #&gt; Error in safe_solve(A): Matrix is singular (det = 0) ‚úÖ SOLUTION 2: Use Generalized Inverse library(MASS) #&gt; #&gt; Attaching package: &#39;MASS&#39; #&gt; The following object is masked _by_ &#39;.GlobalEnv&#39;: #&gt; #&gt; survey #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; select # Singular matrix A &lt;- matrix(c(1, 2, 2, 4), nrow = 2) # Moore-Penrose generalized inverse A_inv &lt;- ginv(A) A_inv #&gt; [,1] [,2] #&gt; [1,] 0.04 0.08 #&gt; [2,] 0.08 0.16 # Check: A %*% ginv(A) %*% A = A all.equal(A, A %*% A_inv %*% A) #&gt; [1] TRUE ‚úÖ SOLUTION 3: Remove Collinear Variables # Detect and remove collinear columns remove_collinear &lt;- function(X, threshold = 0.99) { cor_matrix &lt;- cor(X) # Find highly correlated pairs high_cor &lt;- which(abs(cor_matrix) &gt; threshold &amp; upper.tri(cor_matrix, diag = FALSE), arr.ind = TRUE) if (nrow(high_cor) &gt; 0) { # Remove second column of correlated pairs remove_cols &lt;- unique(high_cor[, 2]) message(&quot;Removing collinear columns: &quot;, paste(remove_cols, collapse = &quot;, &quot;)) X &lt;- X[, -remove_cols] } return(X) } # Test x1 &lt;- 1:5 x2 &lt;- 2 * x1 x3 &lt;- rnorm(5) X &lt;- cbind(x1, x2, x3) X_clean &lt;- remove_collinear(X) #&gt; Removing collinear columns: 2 ncol(X_clean) # One less column #&gt; [1] 2 11.6 Matrix Creation Errors ‚ö†Ô∏è Common Pitfall: Matrix Filling # Matrix fills by COLUMN (default) matrix(1:6, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # To fill by row: matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 # This catches many people! matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 # NOT what you might expect! # Want row-wise? Use byrow: matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 11.7 Matrix Operations Reference üéØ Best Practice: Common Matrix Operations A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) # Transpose t(A) #&gt; [,1] [,2] #&gt; [1,] 1 2 #&gt; [2,] 3 4 #&gt; [3,] 5 6 # Matrix multiplication A %*% B # Result: 2√ó2 #&gt; [,1] [,2] #&gt; [1,] 22 49 #&gt; [2,] 28 64 # Element-wise operations (same dimensions needed) C &lt;- matrix(7:12, nrow = 2, ncol = 3) A + C #&gt; [,1] [,2] [,3] #&gt; [1,] 8 12 16 #&gt; [2,] 10 14 18 A - C #&gt; [,1] [,2] [,3] #&gt; [1,] -6 -6 -6 #&gt; [2,] -6 -6 -6 A * C # Hadamard product (element-wise) #&gt; [,1] [,2] [,3] #&gt; [1,] 7 27 55 #&gt; [2,] 16 40 72 A / C #&gt; [,1] [,2] [,3] #&gt; [1,] 0.1428571 0.3333333 0.4545455 #&gt; [2,] 0.2500000 0.4000000 0.5000000 # Cross product crossprod(A) # t(A) %*% A #&gt; [,1] [,2] [,3] #&gt; [1,] 5 11 17 #&gt; [2,] 11 25 39 #&gt; [3,] 17 39 61 tcrossprod(A) # A %*% t(A) #&gt; [,1] [,2] #&gt; [1,] 35 44 #&gt; [2,] 44 56 # Determinant D &lt;- matrix(c(1, 2, 3, 4), nrow = 2) det(D) #&gt; [1] -2 # Inverse (square matrices only) solve(D) #&gt; [,1] [,2] #&gt; [1,] -2 1.5 #&gt; [2,] 1 -0.5 # Diagonal diag(D) # Extract diagonal #&gt; [1] 1 4 diag(c(1, 2, 3)) # Create diagonal matrix #&gt; [,1] [,2] [,3] #&gt; [1,] 1 0 0 #&gt; [2,] 0 2 0 #&gt; [3,] 0 0 3 # Eigenvalues and eigenvectors eigen(D) #&gt; eigen() decomposition #&gt; $values #&gt; [1] 5.3722813 -0.3722813 #&gt; #&gt; $vectors #&gt; [,1] [,2] #&gt; [1,] -0.5657675 -0.9093767 #&gt; [2,] -0.8245648 0.4159736 # Singular value decomposition svd(A) #&gt; $d #&gt; [1] 9.5255181 0.5143006 #&gt; #&gt; $u #&gt; [,1] [,2] #&gt; [1,] -0.6196295 -0.7848945 #&gt; [2,] -0.7848945 0.6196295 #&gt; #&gt; $v #&gt; [,1] [,2] #&gt; [1,] -0.2298477 0.8834610 #&gt; [2,] -0.5247448 0.2407825 #&gt; [3,] -0.8196419 -0.4018960 11.8 Dimension Preservation ‚ö†Ô∏è Common Pitfall: Dropping Dimensions A &lt;- matrix(1:12, nrow = 3, ncol = 4) # Extract row (becomes vector!) row1 &lt;- A[1, ] dim(row1) # NULL (it&#39;s a vector now) #&gt; NULL # Extract column (becomes vector!) col1 &lt;- A[, 1] dim(col1) # NULL #&gt; NULL # Preserve matrix structure row1 &lt;- A[1, , drop = FALSE] dim(row1) # 1 3 #&gt; [1] 1 4 col1 &lt;- A[, 1, drop = FALSE] dim(col1) # 3 1 #&gt; [1] 3 1 When it matters: A &lt;- matrix(1:12, nrow = 3, ncol = 4) B &lt;- matrix(1:3, nrow = 3, ncol = 1) # Extract column from A (becomes vector) A_col &lt;- A[, 1] # Try to multiply A_col %*% B # Error! A_col is vector #&gt; [,1] #&gt; [1,] 14 # Fix: preserve dimensions A_col &lt;- A[, 1, drop = FALSE] A_col %*% t(B) # Works! #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 2 4 6 #&gt; [3,] 3 6 9 11.9 Converting Between Structures üí° Key Insight: Conversions # Vector to matrix vec &lt;- 1:12 mat &lt;- matrix(vec, nrow = 3, ncol = 4) # Matrix to vector as.vector(mat) # Column-major order #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 # Matrix to data frame df &lt;- as.data.frame(mat) class(df) #&gt; [1] &quot;data.frame&quot; # Data frame to matrix mat2 &lt;- as.matrix(df) class(mat2) #&gt; [1] &quot;matrix&quot; &quot;array&quot; # List to matrix (if all same length) lst &lt;- list(a = 1:3, b = 4:6, c = 7:9) mat3 &lt;- do.call(cbind, lst) mat3 #&gt; a b c #&gt; [1,] 1 4 7 #&gt; [2,] 2 5 8 #&gt; [3,] 3 6 9 # Matrix to list (by column) lst2 &lt;- as.list(as.data.frame(mat)) Warning: Type coercion # Data frame with mixed types df_mixed &lt;- data.frame( x = 1:3, y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ) # Converting to matrix coerces to common type as.matrix(df_mixed) # All become character! #&gt; x y #&gt; [1,] &quot;1&quot; &quot;a&quot; #&gt; [2,] &quot;2&quot; &quot;b&quot; #&gt; [3,] &quot;3&quot; &quot;c&quot; 11.10 Summary Key Takeaways: Element-wise operations: Need identical dimensions Matrix multiplication: Inner dimensions must match Singular matrices: Cannot be inverted (det = 0) Filling order: Column-major by default (use byrow = TRUE) drop = FALSE: Preserves matrix structure Type coercion: Converting mixed-type df to matrix coerces all Check dimensions: Always verify before operations Quick Reference: Error Cause Fix non-conformable arrays Different dimensions for +,-,*,/ Match dimensions non-conformable arguments ncol(A) ‚â† nrow(B) for %*% Transpose or reshape computationally singular Matrix not invertible Check det(), use ginv() incorrect number of dimensions Wrong subscripts Match matrix structure Matrix Operations Checklist: # Before operations: dim(A) # Check dimensions det(A) # Check if invertible ncol(A) == nrow(B) # Check for multiplication # Safe extraction: A[i, , drop = FALSE] # Preserve row A[, j, drop = FALSE] # Preserve column # Matrix multiplication: A %*% B # Matrix product A * B # Element-wise (Hadamard) crossprod(A, B) # t(A) %*% B tcrossprod(A, B) # A %*% t(B) Best Practices: # ‚úÖ Good identical(dim(A), dim(B)) # Check before adding ncol(A) == nrow(B) # Check before multiply det(A) != 0 # Check before invert A[i, , drop = FALSE] # Preserve structure # ‚ùå Avoid A + B # Without checking dims solve(A) # Without checking singular A[i, ] # Drops to vector unexpectedly 11.11 Exercises üìù Exercise 1: Matrix Dimension Checker Write a function that checks if two matrices can be: 1. Added/subtracted 2. Multiplied (A %% B) 3. Multiplied (B %% A) Return TRUE/FALSE for each operation. üìù Exercise 2: Safe Matrix Operations Create matrix_op(A, B, op) that: - Checks dimensions before operation - Supports: ‚Äúadd‚Äù, ‚Äúsubtract‚Äù, ‚Äúmultiply‚Äù, ‚Äúdivide‚Äù - Gives clear error messages - Returns result or NULL üìù Exercise 3: Matrix Inversion Check Write safe_invert(A) that: 1. Checks if matrix is square 2. Checks if singular 3. Warns if near-singular 4. Returns inverse or NULL 5. Provides diagnostic information üìù Exercise 4: Matrix Creation Helper Write make_matrix(...) that: - Takes values and shape (nrow, ncol) - Handles different input formats (vector, list, data frame) - Validates dimensions - Allows byrow specification - Returns matrix with informative errors 11.12 Exercise Answers Click to see answers Exercise 1: check_matrix_ops &lt;- function(A, B) { result &lt;- list( can_add = identical(dim(A), dim(B)), can_multiply_AB = ncol(A) == nrow(B), can_multiply_BA = ncol(B) == nrow(A) ) # Add details result$dim_A &lt;- paste(dim(A), collapse = &quot;√ó&quot;) result$dim_B &lt;- paste(dim(B), collapse = &quot;√ó&quot;) if (result$can_multiply_AB) { result$result_dim_AB &lt;- paste(c(nrow(A), ncol(B)), collapse = &quot;√ó&quot;) } if (result$can_multiply_BA) { result$result_dim_BA &lt;- paste(c(nrow(B), ncol(A)), collapse = &quot;√ó&quot;) } class(result) &lt;- &quot;matrix_ops_check&quot; return(result) } print.matrix_ops_check &lt;- function(x, ...) { cat(&quot;Matrix A:&quot;, x$dim_A, &quot;\\n&quot;) cat(&quot;Matrix B:&quot;, x$dim_B, &quot;\\n\\n&quot;) cat(&quot;Can add/subtract:&quot;, x$can_add, &quot;\\n&quot;) cat(&quot;Can multiply A %*% B:&quot;, x$can_multiply_AB) if (x$can_multiply_AB) { cat(&quot; (result:&quot;, x$result_dim_AB, &quot;)&quot;) } cat(&quot;\\n&quot;) cat(&quot;Can multiply B %*% A:&quot;, x$can_multiply_BA) if (x$can_multiply_BA) { cat(&quot; (result:&quot;, x$result_dim_BA, &quot;)&quot;) } cat(&quot;\\n&quot;) } # Test A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) check_matrix_ops(A, B) #&gt; Matrix A: 2√ó3 #&gt; Matrix B: 3√ó2 #&gt; #&gt; Can add/subtract: FALSE #&gt; Can multiply A %*% B: TRUE (result: 2√ó2 ) #&gt; Can multiply B %*% A: TRUE (result: 3√ó3 ) Exercise 2: matrix_op &lt;- function(A, B, op = c(&quot;add&quot;, &quot;subtract&quot;, &quot;multiply&quot;, &quot;divide&quot;)) { op &lt;- match.arg(op) # Validate inputs if (!is.matrix(A) || !is.matrix(B)) { stop(&quot;Both A and B must be matrices&quot;) } # Check dimensions based on operation if (op %in% c(&quot;add&quot;, &quot;subtract&quot;, &quot;divide&quot;)) { if (!identical(dim(A), dim(B))) { stop(&quot;For &quot;, op, &quot;, matrices must have same dimensions. &quot;, &quot;A is &quot;, paste(dim(A), collapse = &quot;√ó&quot;), &quot;, B is &quot;, paste(dim(B), collapse = &quot;√ó&quot;)) } result &lt;- switch(op, add = A + B, subtract = A - B, divide = A / B ) } else if (op == &quot;multiply&quot;) { if (ncol(A) != nrow(B)) { stop(&quot;For multiplication, ncol(A) must equal nrow(B). &quot;, &quot;A is &quot;, paste(dim(A), collapse = &quot;√ó&quot;), &quot;, B is &quot;, paste(dim(B), collapse = &quot;√ó&quot;)) } result &lt;- A %*% B } return(result) } # Test A &lt;- matrix(1:6, nrow = 2, ncol = 3) B &lt;- matrix(1:6, nrow = 3, ncol = 2) matrix_op(A, B, &quot;multiply&quot;) #&gt; [,1] [,2] #&gt; [1,] 22 49 #&gt; [2,] 28 64 Exercise 3: safe_invert &lt;- function(A, tol = 1e-10, warn_threshold = 1e-8) { # Check if matrix if (!is.matrix(A)) { message(&quot;Input is not a matrix&quot;) return(NULL) } # Check if square if (nrow(A) != ncol(A)) { message(&quot;Matrix is not square: &quot;, paste(dim(A), collapse = &quot;√ó&quot;)) return(NULL) } # Calculate determinant d &lt;- det(A) # Check if singular if (abs(d) &lt; tol) { message(&quot;Matrix is singular (det = &quot;, d, &quot;)&quot;) message(&quot;Consider using MASS::ginv() for generalized inverse&quot;) return(NULL) } # Warn if near-singular if (abs(d) &lt; warn_threshold) { warning(&quot;Matrix is near-singular (det = &quot;, d, &quot;). &quot;, &quot;Results may be numerically unstable.&quot;) } # Compute inverse A_inv &lt;- solve(A) # Verify (optional) check &lt;- A %*% A_inv is_identity &lt;- all(abs(check - diag(nrow(A))) &lt; 1e-10) if (!is_identity) { warning(&quot;Inversion may be inaccurate (A %*% A^-1 != I)&quot;) } # Return with diagnostics attr(A_inv, &quot;determinant&quot;) &lt;- d attr(A_inv, &quot;condition_number&quot;) &lt;- kappa(A) return(A_inv) } # Test A &lt;- matrix(c(1, 2, 3, 4), nrow = 2) A_inv &lt;- safe_invert(A) A_inv #&gt; [,1] [,2] #&gt; [1,] -2 1.5 #&gt; [2,] 1 -0.5 #&gt; attr(,&quot;determinant&quot;) #&gt; [1] -2 #&gt; attr(,&quot;condition_number&quot;) #&gt; [1] 18.77778 # Singular B &lt;- matrix(c(1, 2, 2, 4), nrow = 2) safe_invert(B) #&gt; Matrix is singular (det = 0) #&gt; Consider using MASS::ginv() for generalized inverse #&gt; NULL Exercise 4: make_matrix &lt;- function(x, nrow, ncol, byrow = FALSE) { # Handle different input types if (is.matrix(x)) { if (missing(nrow) &amp;&amp; missing(ncol)) { return(x) } x &lt;- as.vector(x) } else if (is.data.frame(x)) { x &lt;- as.matrix(x) if (missing(nrow) &amp;&amp; missing(ncol)) { return(x) } x &lt;- as.vector(x) } else if (is.list(x)) { # Check if all elements same length lens &lt;- lengths(x) if (length(unique(lens)) != 1) { stop(&quot;List elements have different lengths&quot;) } x &lt;- unlist(x) } # Validate dimensions n_elements &lt;- length(x) if (missing(nrow) &amp;&amp; missing(ncol)) { stop(&quot;Must provide nrow, ncol, or both&quot;) } if (missing(nrow)) { nrow &lt;- ceiling(n_elements / ncol) } else if (missing(ncol)) { ncol &lt;- ceiling(n_elements / nrow) } expected_elements &lt;- nrow * ncol if (n_elements != expected_elements) { if (n_elements &lt; expected_elements) { warning(&quot;Data length (&quot;, n_elements, &quot;) is less than matrix size (&quot;, expected_elements, &quot;). Recycling values.&quot;) } else { warning(&quot;Data length (&quot;, n_elements, &quot;) is greater than matrix size (&quot;, expected_elements, &quot;). Truncating values.&quot;) x &lt;- x[1:expected_elements] } } # Create matrix result &lt;- matrix(x, nrow = nrow, ncol = ncol, byrow = byrow) return(result) } # Test make_matrix(1:6, nrow = 2, ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 make_matrix(1:6, nrow = 2, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 make_matrix(list(a = 1:3, b = 4:6), ncol = 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 "],["part-v-factors.html", "Part V: Factors", " Part V: Factors "],["factor-creation-levels.html", "Chapter 12 Factor Creation &amp; Levels 12.1 Introduction 12.2 What Are Factors? 12.3 Factor vs Character 12.4 Error #1: invalid factor level, NA generated 12.5 Error #2: number of levels differs 12.6 Error #3: contrasts can be applied only to factors with 2 or more levels 12.7 Creating Factors Correctly 12.8 Levels vs Labels 12.9 Ordered Factors 12.10 Checking and Modifying Levels 12.11 Common Factor Mistakes 12.12 Summary 12.13 Exercises 12.14 Exercise Answers", " Chapter 12 Factor Creation &amp; Levels What You‚Äôll Learn: What factors are and why they exist Creating factors correctly Understanding levels and labels Ordered vs unordered factors Common factor creation pitfalls Key Errors Covered: 15+ factor errors Difficulty: ‚≠ê‚≠ê Intermediate 12.1 Introduction Factors are R‚Äôs way of representing categorical data, but they‚Äôre confusing: # This looks like it should work... grades &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) grades[1] &lt;- &quot;D&quot; #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;D&quot;): invalid factor level, NA #&gt; generated üü° WARNING Warning message: In `[&lt;-.factor`(`*tmp*`, 1, value = &quot;D&quot;) : invalid factor level, NA generated grades # First element became NA! #&gt; [1] &lt;NA&gt; B C #&gt; Levels: A B C Let‚Äôs understand factors to avoid these surprises. 12.2 What Are Factors? üí° Key Insight: Factors Are Integers in Disguise # Create a factor colors &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;)) colors #&gt; [1] red blue red green #&gt; Levels: blue green red # But underneath, it&#39;s integers! typeof(colors) # &quot;integer&quot; #&gt; [1] &quot;integer&quot; as.integer(colors) # 3 1 3 2 #&gt; [1] 3 1 3 2 # The labels are stored separately levels(colors) #&gt; [1] &quot;blue&quot; &quot;green&quot; &quot;red&quot; # Structure revealed str(colors) #&gt; Factor w/ 3 levels &quot;blue&quot;,&quot;green&quot;,..: 3 1 3 2 Key points: - Factors store data as integers (1, 2, 3, ‚Ä¶) - Each integer maps to a level (label) - Levels are stored once, data stores references - More memory-efficient for repeated values - Used extensively in statistical modeling Why factors exist: 1. Memory efficiency (repeated strings) 2. Statistical modeling (R knows it‚Äôs categorical) 3. Ordering (can be ordered or unordered) 4. Validation (only valid levels allowed) 12.3 Factor vs Character üí° Factor vs Character Comparison # Character vector char_vec &lt;- c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;, &quot;green&quot;) typeof(char_vec) #&gt; [1] &quot;character&quot; class(char_vec) #&gt; [1] &quot;character&quot; # Factor fac_vec &lt;- factor(char_vec) typeof(fac_vec) #&gt; [1] &quot;integer&quot; class(fac_vec) #&gt; [1] &quot;factor&quot; # Memory difference (with many repetitions) x_char &lt;- rep(c(&quot;Category A&quot;, &quot;Category B&quot;), 10000) x_fac &lt;- factor(x_char) object.size(x_char) #&gt; 160176 bytes object.size(x_fac) # Much smaller! #&gt; 80576 bytes # Statistical modeling difference df &lt;- data.frame( group = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;)), value = c(10, 20, 15, 25) ) # R knows &#39;group&#39; is categorical lm(value ~ group, data = df) #&gt; #&gt; Call: #&gt; lm(formula = value ~ group, data = df) #&gt; #&gt; Coefficients: #&gt; (Intercept) groupB #&gt; 12.5 10.0 When to use each: - Character: Text data, unique values, will manipulate as strings - Factor: Categories, repeated values, for modeling/plotting 12.4 Error #1: invalid factor level, NA generated ‚≠ê BEGINNER üî¢ TYPE 12.4.1 The Error sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) sizes[1] &lt;- &quot;extra-large&quot; # Not in levels! #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;extra-large&quot;): invalid factor #&gt; level, NA generated üü° WARNING Warning message: In `[&lt;-.factor`(`*tmp*`, 1, value = &quot;extra-large&quot;) : invalid factor level, NA generated sizes # Became NA! #&gt; [1] &lt;NA&gt; medium large #&gt; Levels: large medium small 12.4.2 What It Means You‚Äôre trying to assign a value that‚Äôs not in the factor‚Äôs levels. R converts it to NA instead. 12.4.3 Why This Happens sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) # Only these levels exist levels(sizes) #&gt; [1] &quot;large&quot; &quot;medium&quot; &quot;small&quot; # Can only assign existing levels sizes[1] &lt;- &quot;medium&quot; # OK sizes #&gt; [1] medium medium large #&gt; Levels: large medium small # New levels not allowed sizes[2] &lt;- &quot;tiny&quot; # Warning, becomes NA #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 2, value = &quot;tiny&quot;): invalid factor level, NA #&gt; generated sizes #&gt; [1] medium &lt;NA&gt; large #&gt; Levels: large medium small 12.4.4 Common Causes 12.4.4.1 Cause 1: Typo in Assignment colors &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) levels(colors) #&gt; [1] &quot;blue&quot; &quot;green&quot; &quot;red&quot; # Typo: &quot;blu&quot; instead of &quot;blue&quot; colors[2] &lt;- &quot;blu&quot; #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 2, value = &quot;blu&quot;): invalid factor level, NA #&gt; generated colors # NA! #&gt; [1] red &lt;NA&gt; green #&gt; Levels: blue green red 12.4.4.2 Cause 2: Case Mismatch sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) # Wrong case sizes[1] &lt;- &quot;Small&quot; # &quot;Small&quot; != &quot;small&quot; #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 1, value = &quot;Small&quot;): invalid factor level, NA #&gt; generated sizes #&gt; [1] &lt;NA&gt; medium large #&gt; Levels: large medium small 12.4.4.3 Cause 3: Adding New Categories responses &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;)) # Try to add new response responses[4] &lt;- &quot;maybe&quot; # &quot;maybe&quot; not in original levels #&gt; Warning in `[&lt;-.factor`(`*tmp*`, 4, value = &quot;maybe&quot;): invalid factor level, NA #&gt; generated responses #&gt; [1] yes no yes &lt;NA&gt; #&gt; Levels: no yes 12.4.4.4 Cause 4: Data Merge Issues # Original data df1 &lt;- data.frame( group = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ) # New data with different level df2 &lt;- data.frame( group = factor(c(&quot;D&quot;, &quot;E&quot;)) ) # Combine combined &lt;- rbind(df1, df2) combined$group # D and E became NA! #&gt; [1] A B C D E #&gt; Levels: A B C D E 12.4.5 Solutions ‚úÖ SOLUTION 1: Add New Level First sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) # Add new level levels(sizes) &lt;- c(levels(sizes), &quot;extra-large&quot;) levels(sizes) #&gt; [1] &quot;large&quot; &quot;medium&quot; &quot;small&quot; &quot;extra-large&quot; # Now assignment works sizes[1] &lt;- &quot;extra-large&quot; sizes #&gt; [1] extra-large medium large #&gt; Levels: large medium small extra-large ‚úÖ SOLUTION 2: Convert to Character, Modify, Convert Back sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) # Convert to character sizes_char &lt;- as.character(sizes) # Modify freely sizes_char[1] &lt;- &quot;extra-large&quot; sizes_char[4] &lt;- &quot;tiny&quot; # Convert back to factor sizes_new &lt;- factor(sizes_char) sizes_new #&gt; [1] extra-large medium large tiny #&gt; Levels: extra-large large medium tiny levels(sizes_new) #&gt; [1] &quot;extra-large&quot; &quot;large&quot; &quot;medium&quot; &quot;tiny&quot; ‚úÖ SOLUTION 3: Specify All Levels Upfront # Specify all possible levels when creating sizes &lt;- factor( c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;), levels = c(&quot;tiny&quot;, &quot;small&quot;, &quot;medium&quot;, &quot;large&quot;, &quot;extra-large&quot;) ) levels(sizes) #&gt; [1] &quot;tiny&quot; &quot;small&quot; &quot;medium&quot; &quot;large&quot; &quot;extra-large&quot; # Now any level can be assigned sizes[1] &lt;- &quot;extra-large&quot; sizes[4] &lt;- &quot;tiny&quot; sizes #&gt; [1] extra-large medium large tiny #&gt; Levels: tiny small medium large extra-large ‚úÖ SOLUTION 4: Use forcats Package (Tidyverse) library(forcats) sizes &lt;- factor(c(&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;)) # Add level dynamically sizes &lt;- fct_expand(sizes, &quot;extra-large&quot;, &quot;tiny&quot;) levels(sizes) #&gt; [1] &quot;large&quot; &quot;medium&quot; &quot;small&quot; &quot;extra-large&quot; &quot;tiny&quot; sizes[1] &lt;- &quot;extra-large&quot; sizes #&gt; [1] extra-large medium large #&gt; Levels: large medium small extra-large tiny ‚ö†Ô∏è Common Pitfall: Silent NA Creation # Create factor status &lt;- factor(c(&quot;active&quot;, &quot;inactive&quot;, &quot;active&quot;)) # Update many values new_values &lt;- c(&quot;active&quot;, &quot;paused&quot;, &quot;inactive&quot;) status &lt;- new_values # Coerces to character! class(status) # Not a factor anymore! #&gt; [1] &quot;character&quot; # Or if forcing to stay factor: status &lt;- factor(c(&quot;active&quot;, &quot;inactive&quot;, &quot;active&quot;)) status[] &lt;- new_values # &quot;paused&quot; becomes NA silently! #&gt; Warning in `[&lt;-.factor`(`*tmp*`, , value = c(&quot;active&quot;, &quot;paused&quot;, &quot;inactive&quot;: #&gt; invalid factor level, NA generated status #&gt; [1] active &lt;NA&gt; inactive #&gt; Levels: active inactive Always check for NAs after factor assignment: if (any(is.na(status))) { warning(&quot;Some values became NA - check factor levels&quot;) } #&gt; Warning: Some values became NA - check factor levels 12.5 Error #2: number of levels differs ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 12.5.1 The Error f1 &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) f2 &lt;- factor(c(&quot;a&quot;, &quot;b&quot;)) c(f1, f2) # Try to combine #&gt; [1] a b c a b #&gt; Levels: a b c üü° WARNING Warning message: In c.factor(f1, f2) : number of levels differs # Result loses factor structure result &lt;- c(f1, f2) class(result) # &quot;integer&quot; not &quot;factor&quot;! #&gt; [1] &quot;factor&quot; 12.5.2 What It Means Combining factors with different levels produces unexpected results. 12.5.3 The Problem f1 &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;)) f2 &lt;- factor(c(&quot;green&quot;, &quot;yellow&quot;)) levels(f1) #&gt; [1] &quot;blue&quot; &quot;red&quot; levels(f2) #&gt; [1] &quot;green&quot; &quot;yellow&quot; # Combine - loses factor structure! combined &lt;- c(f1, f2) combined # Just integers! #&gt; [1] red blue green yellow #&gt; Levels: blue red green yellow class(combined) #&gt; [1] &quot;factor&quot; 12.5.4 Solutions ‚úÖ SOLUTION 1: Convert to Character First f1 &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;)) f2 &lt;- factor(c(&quot;green&quot;, &quot;yellow&quot;)) # Convert both to character combined &lt;- c(as.character(f1), as.character(f2)) combined #&gt; [1] &quot;red&quot; &quot;blue&quot; &quot;green&quot; &quot;yellow&quot; # Convert back to factor combined &lt;- factor(combined) combined #&gt; [1] red blue green yellow #&gt; Levels: blue green red yellow levels(combined) #&gt; [1] &quot;blue&quot; &quot;green&quot; &quot;red&quot; &quot;yellow&quot; ‚úÖ SOLUTION 2: Use Same Levels for Both # Define all levels upfront all_levels &lt;- c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;) f1 &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;), levels = all_levels) f2 &lt;- factor(c(&quot;green&quot;, &quot;yellow&quot;), levels = all_levels) # Now same levels identical(levels(f1), levels(f2)) #&gt; [1] TRUE # Combine works better combined &lt;- c(f1, f2) combined &lt;- factor(combined, levels = all_levels) combined #&gt; [1] red blue green yellow #&gt; Levels: red blue green yellow ‚úÖ SOLUTION 3: Use forcats::fct_c() library(forcats) f1 &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;)) f2 &lt;- factor(c(&quot;green&quot;, &quot;yellow&quot;)) # Smart concatenation combined &lt;- fct_c(f1, f2) combined #&gt; [1] red blue green yellow #&gt; Levels: blue red green yellow levels(combined) #&gt; [1] &quot;blue&quot; &quot;red&quot; &quot;green&quot; &quot;yellow&quot; 12.6 Error #3: contrasts can be applied only to factors with 2 or more levels ‚≠ê‚≠ê INTERMEDIATE üßÆ MATH 12.6.1 The Error # Factor with only one level single_level &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;A&quot;)) levels(single_level) #&gt; [1] &quot;A&quot; # Try to use in model df &lt;- data.frame( group = single_level, value = c(10, 20, 15, 25) ) lm(value ~ group, data = df) #&gt; Error in `contrasts&lt;-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]): contrasts can be applied only to factors with 2 or more levels üî¥ ERROR Error in `contrasts&lt;-`(`*tmp*`, value = contr.treatment(2)) : contrasts can be applied only to factors with 2 or more levels 12.6.2 What It Means Statistical models need at least 2 levels to compare. A single-level factor can‚Äôt be used as a predictor. 12.6.3 Common Causes 12.6.3.1 Cause 1: Accidental Filtering df &lt;- data.frame( treatment = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)), outcome = rnorm(5) ) # Filter to subset df_filtered &lt;- df[df$treatment == &quot;A&quot;, ] df_filtered$treatment # Still a factor, but only one level used #&gt; [1] A A #&gt; Levels: A B C # Try to model lm(outcome ~ treatment, data = df_filtered) #&gt; Error in `contrasts&lt;-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]): contrasts can be applied only to factors with 2 or more levels 12.6.3.2 Cause 2: Data Preparation Gone Wrong # Read data responses &lt;- factor(c(&quot;yes&quot;, &quot;no&quot;, &quot;maybe&quot;, &quot;yes&quot;)) # Remove certain responses clean_responses &lt;- responses[responses != &quot;no&quot; &amp; responses != &quot;maybe&quot;] clean_responses # Only &quot;yes&quot; left #&gt; [1] yes yes #&gt; Levels: maybe no yes df &lt;- data.frame( response = clean_responses, score = c(80, 90) ) lm(score ~ response, data = df) #&gt; Error in `contrasts&lt;-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]): contrasts can be applied only to factors with 2 or more levels 12.6.4 Solutions ‚úÖ SOLUTION 1: Drop Unused Levels df &lt;- data.frame( treatment = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)), outcome = rnorm(5) ) # Filter df_filtered &lt;- df[df$treatment == &quot;A&quot;, ] # Drop unused levels df_filtered$treatment &lt;- droplevels(df_filtered$treatment) levels(df_filtered$treatment) # Only &quot;A&quot; now #&gt; [1] &quot;A&quot; # Model will error (only 1 level) # But at least levels match reality ‚úÖ SOLUTION 2: Check Before Modeling check_factor_for_modeling &lt;- function(f) { # Check if factor if (!is.factor(f)) { stop(&quot;Input is not a factor&quot;) } # Count levels with data level_counts &lt;- table(f) levels_with_data &lt;- sum(level_counts &gt; 0) if (levels_with_data &lt; 2) { stop(&quot;Factor has only &quot;, levels_with_data, &quot; level(s) with data. Need at least 2 for modeling.&quot;) } # Check for unused levels if (nlevels(f) &gt; levels_with_data) { message(&quot;Factor has &quot;, nlevels(f) - levels_with_data, &quot; unused level(s). Consider droplevels().&quot;) } return(TRUE) } # Test single &lt;- factor(c(&quot;A&quot;, &quot;A&quot;)) check_factor_for_modeling(single) #&gt; Error in check_factor_for_modeling(single): Factor has only 1 level(s) with data. Need at least 2 for modeling. ‚úÖ SOLUTION 3: Convert to Character If Needed df &lt;- data.frame( treatment = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)), outcome = rnorm(5) ) df_filtered &lt;- df[df$treatment == &quot;A&quot;, ] # If you don&#39;t need it as a factor, convert df_filtered$treatment &lt;- as.character(df_filtered$treatment) # Or remove from model lm(outcome ~ 1, data = df_filtered) # Intercept-only model #&gt; #&gt; Call: #&gt; lm(formula = outcome ~ 1, data = df_filtered) #&gt; #&gt; Coefficients: #&gt; (Intercept) #&gt; 0.3262 12.7 Creating Factors Correctly üéØ Best Practice: Factor Creation # Method 1: Basic factor sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;)) sizes #&gt; [1] S M L M S #&gt; Levels: L M S # Method 2: Specify levels explicitly sizes &lt;- factor( c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;), levels = c(&quot;XS&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;) ) sizes #&gt; [1] S M L #&gt; Levels: XS S M L XL levels(sizes) # All levels present #&gt; [1] &quot;XS&quot; &quot;S&quot; &quot;M&quot; &quot;L&quot; &quot;XL&quot; # Method 3: With labels (different from levels) sizes &lt;- factor( c(1, 2, 3, 2, 1), levels = 1:5, labels = c(&quot;XS&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;) ) sizes #&gt; [1] XS S M S XS #&gt; Levels: XS S M L XL # Method 4: Ordered factor sizes &lt;- factor( c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;), levels = c(&quot;XS&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;), ordered = TRUE ) sizes #&gt; [1] S M L M S #&gt; Levels: XS &lt; S &lt; M &lt; L &lt; XL class(sizes) # &quot;ordered&quot; &quot;factor&quot; #&gt; [1] &quot;ordered&quot; &quot;factor&quot; # Can now compare sizes[1] &lt; sizes[3] # TRUE (S &lt; L) #&gt; [1] TRUE # Method 5: From numeric ages_binned &lt;- cut( c(15, 25, 35, 45, 55), breaks = c(0, 18, 30, 50, 100), labels = c(&quot;Youth&quot;, &quot;Young Adult&quot;, &quot;Middle Age&quot;, &quot;Senior&quot;) ) ages_binned #&gt; [1] Youth Young Adult Middle Age Middle Age Senior #&gt; Levels: Youth Young Adult Middle Age Senior 12.8 Levels vs Labels üí° Key Insight: Levels vs Labels # Levels: What you have in the data # Labels: What you want to display # Example: Survey responses coded as numbers responses &lt;- c(1, 2, 3, 2, 1, 3) # Wrong: Just convert to factor bad &lt;- factor(responses) bad # Shows 1, 2, 3 #&gt; [1] 1 2 3 2 1 3 #&gt; Levels: 1 2 3 # Right: Provide labels good &lt;- factor( responses, levels = 1:3, labels = c(&quot;Disagree&quot;, &quot;Neutral&quot;, &quot;Agree&quot;) ) good # Shows actual meanings #&gt; [1] Disagree Neutral Agree Neutral Disagree Agree #&gt; Levels: Disagree Neutral Agree # The underlying data is still integers as.integer(good) #&gt; [1] 1 2 3 2 1 3 # But displays with labels print(good) #&gt; [1] Disagree Neutral Agree Neutral Disagree Agree #&gt; Levels: Disagree Neutral Agree levels(good) #&gt; [1] &quot;Disagree&quot; &quot;Neutral&quot; &quot;Agree&quot; Key difference: - levels: Values in your data (what it IS) - labels: Display names (what you WANT TO SHOW) 12.9 Ordered Factors üí° Ordered vs Unordered Factors # Unordered (nominal) colors &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) colors #&gt; [1] red blue green #&gt; Levels: blue green red class(colors) #&gt; [1] &quot;factor&quot; # Can&#39;t compare colors[1] &lt; colors[2] # Not meaningful #&gt; Warning in Ops.factor(colors[1], colors[2]): &#39;&lt;&#39; not meaningful for factors #&gt; [1] NA # Ordered (ordinal) sizes &lt;- ordered(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;), levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes #&gt; [1] S M L M S #&gt; Levels: S &lt; M &lt; L class(sizes) #&gt; [1] &quot;ordered&quot; &quot;factor&quot; # Can compare sizes[1] &lt; sizes[3] # TRUE #&gt; [1] TRUE # Or use factor with ordered = TRUE grades &lt;- factor( c(&quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;), levels = c(&quot;F&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;), ordered = TRUE ) grades #&gt; [1] B A C A #&gt; Levels: F &lt; D &lt; C &lt; B &lt; A grades[1] &lt; grades[2] # TRUE (B &lt; A) #&gt; [1] TRUE When to use ordered: - Size (S &lt; M &lt; L) - Grade (F &lt; D &lt; C &lt; B &lt; A) - Likert scales (Strongly Disagree &lt; ‚Ä¶ &lt; Strongly Agree) - Any natural ordering When NOT to use ordered: - Colors (no natural order) - Categories (no natural order) - Nominal data 12.10 Checking and Modifying Levels üéØ Best Practice: Working with Levels sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;M&quot;, &quot;S&quot;)) # Check levels levels(sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; nlevels(sizes) #&gt; [1] 3 # Check for specific level &quot;XL&quot; %in% levels(sizes) #&gt; [1] FALSE # Add levels levels(sizes) &lt;- c(levels(sizes), &quot;XS&quot;, &quot;XL&quot;) levels(sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XS&quot; &quot;XL&quot; # Rename levels sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) levels(sizes) &lt;- c(&quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;) sizes #&gt; [1] Large Medium Small #&gt; Levels: Small Medium Large # Reorder levels sizes &lt;- factor(c(&quot;L&quot;, &quot;S&quot;, &quot;M&quot;)) sizes &lt;- factor(sizes, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes #&gt; [1] L S M #&gt; Levels: S M L # Drop unused levels sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;), levels = c(&quot;XS&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) levels(sizes) # All 5 levels #&gt; [1] &quot;XS&quot; &quot;S&quot; &quot;M&quot; &quot;L&quot; &quot;XL&quot; sizes &lt;- sizes[sizes != &quot;L&quot;] # Remove L observations levels(sizes) # Still shows L! #&gt; [1] &quot;XS&quot; &quot;S&quot; &quot;M&quot; &quot;L&quot; &quot;XL&quot; sizes &lt;- droplevels(sizes) levels(sizes) # Now only S and M #&gt; [1] &quot;S&quot; &quot;M&quot; # Collapse levels sizes &lt;- factor(c(&quot;XS&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) sizes_collapsed &lt;- fct_collapse(sizes, Small = c(&quot;XS&quot;, &quot;S&quot;), Medium = &quot;M&quot;, Large = c(&quot;L&quot;, &quot;XL&quot;) ) sizes_collapsed #&gt; [1] Small Small Medium Large Large #&gt; Levels: Large Medium Small 12.11 Common Factor Mistakes ‚ö†Ô∏è Pitfall 1: Converting Factor to Numeric # Factor with numeric-looking levels scores &lt;- factor(c(&quot;90&quot;, &quot;85&quot;, &quot;95&quot;, &quot;88&quot;)) scores #&gt; [1] 90 85 95 88 #&gt; Levels: 85 88 90 95 # WRONG: Direct conversion as.numeric(scores) # Gives 4 2 5 3 (factor codes!) #&gt; [1] 3 1 4 2 # RIGHT: Convert through character as.numeric(as.character(scores)) # 90 85 95 88 #&gt; [1] 90 85 95 88 # Or use levels as.numeric(levels(scores))[scores] # 90 85 95 88 #&gt; [1] 90 85 95 88 ‚ö†Ô∏è Pitfall 2: Unexpected Coercion # Combining factor and character fac &lt;- factor(c(&quot;a&quot;, &quot;b&quot;)) char &lt;- c(&quot;c&quot;, &quot;d&quot;) combined &lt;- c(fac, char) class(combined) # &quot;character&quot; (lost factor) #&gt; [1] &quot;character&quot; combined #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;c&quot; &quot;d&quot; # Arithmetic with factors fac &lt;- factor(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) fac + 10 # Error! #&gt; Warning in Ops.factor(fac, 10): &#39;+&#39; not meaningful for factors #&gt; [1] NA NA NA # Convert first as.numeric(as.character(fac)) + 10 #&gt; [1] 11 12 13 ‚ö†Ô∏è Pitfall 3: Factor Subsetting Keeps All Levels sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) levels(sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; # Subset to only S and M sizes_small &lt;- sizes[sizes %in% c(&quot;S&quot;, &quot;M&quot;)] sizes_small #&gt; [1] S M #&gt; Levels: L M S XL # But levels still show L and XL! levels(sizes_small) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; # Drop unused levels sizes_small &lt;- droplevels(sizes_small) levels(sizes_small) #&gt; [1] &quot;M&quot; &quot;S&quot; 12.12 Summary Key Takeaways: Factors are integers with labels - Understanding this prevents confusion Can only assign existing levels - Add level first or convert to character Combining factors is tricky - Use forcats or convert to character Drop unused levels after subsetting with droplevels() Specify levels explicitly when creating factors Ordered factors for data with natural ordering Convert through character when converting factor to numeric Quick Reference: Error/Warning Cause Fix invalid factor level, NA Assigning non-existent level Add level first or use character number of levels differs Combining different factors Use fct_c() or same levels contrasts need 2+ levels Single-level factor in model Check levels before modeling Wrong numeric conversion as.numeric(factor) as.numeric(as.character(factor)) Factor Operations: # Creation factor(x) factor(x, levels = ...) factor(x, levels = ..., labels = ...) ordered(x, levels = ...) # Inspection levels(f) nlevels(f) is.factor(f) is.ordered(f) # Modification levels(f) &lt;- new_levels f &lt;- droplevels(f) f &lt;- factor(f, levels = new_order) # Conversion as.character(f) as.numeric(as.character(f)) # If numeric-like Best Practices: # ‚úÖ Good factor(x, levels = all_possible_levels) # Explicit levels as.character(f) %&gt;% modify() %&gt;% factor() # Modify as character droplevels(f) # After subsetting fct_c(f1, f2) # Combine factors # ‚ùå Avoid as.numeric(factor_with_numbers) # Wrong conversion c(factor1, factor2) # Loses factor structure factor(x) # Without explicit levels f[f %in% subset] without droplevels() # Unused levels remain 12.13 Exercises üìù Exercise 1: Factor Conversion You have: scores &lt;- factor(c(&quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;88&quot;, &quot;92&quot;)) Convert to proper numeric values Bin into letter grades (A: 90-100, B: 80-89, etc.) Create ordered factor of letter grades üìù Exercise 2: Combining Factors You have survey data from two sources: survey1 &lt;- factor(c(&quot;Agree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;)) survey2 &lt;- factor(c(&quot;Strongly Agree&quot;, &quot;Agree&quot;, &quot;Disagree&quot;)) Combine them into one factor with all response levels. üìù Exercise 3: Factor Validation Write validate_factor(f) that checks: 1. If input is a factor 2. If it has at least 2 levels 3. If it has unused levels 4. Returns report of issues found üìù Exercise 4: Safe Factor Assignment Write safe_assign_level(f, index, value) that: 1. Checks if value is in levels 2. Adds level if not present 3. Assigns the value 4. Returns modified factor 5. Warns about any changes made 12.14 Exercise Answers Click to see answers Exercise 1: scores &lt;- factor(c(&quot;85&quot;, &quot;90&quot;, &quot;95&quot;, &quot;88&quot;, &quot;92&quot;)) # 1. Convert to numeric scores_num &lt;- as.numeric(as.character(scores)) scores_num #&gt; [1] 85 90 95 88 92 # 2. Bin into letter grades letter_grades &lt;- cut( scores_num, breaks = c(0, 60, 70, 80, 90, 100), labels = c(&quot;F&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;), include.lowest = TRUE ) letter_grades #&gt; [1] B B A B A #&gt; Levels: F D C B A # 3. Create ordered factor letter_grades_ordered &lt;- ordered( letter_grades, levels = c(&quot;F&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;) ) letter_grades_ordered #&gt; [1] B B A B A #&gt; Levels: F &lt; D &lt; C &lt; B &lt; A # Can now compare letter_grades_ordered[1] &lt; letter_grades_ordered[3] #&gt; [1] TRUE Exercise 2: library(forcats) survey1 &lt;- factor(c(&quot;Agree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;)) survey2 &lt;- factor(c(&quot;Strongly Agree&quot;, &quot;Agree&quot;, &quot;Disagree&quot;)) # Define all possible levels all_levels &lt;- c(&quot;Strongly Disagree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;, &quot;Agree&quot;, &quot;Strongly Agree&quot;) # Recreate with same levels survey1 &lt;- factor(survey1, levels = all_levels) survey2 &lt;- factor(survey2, levels = all_levels) # Combine combined &lt;- fct_c(survey1, survey2) combined #&gt; [1] Agree Disagree Neutral Strongly Agree Agree #&gt; [6] Disagree #&gt; Levels: Strongly Disagree Disagree Neutral Agree Strongly Agree levels(combined) #&gt; [1] &quot;Strongly Disagree&quot; &quot;Disagree&quot; &quot;Neutral&quot; #&gt; [4] &quot;Agree&quot; &quot;Strongly Agree&quot; # Alternative: convert to character first survey1 &lt;- factor(c(&quot;Agree&quot;, &quot;Disagree&quot;, &quot;Neutral&quot;)) survey2 &lt;- factor(c(&quot;Strongly Agree&quot;, &quot;Agree&quot;, &quot;Disagree&quot;)) combined &lt;- c(as.character(survey1), as.character(survey2)) combined &lt;- factor(combined, levels = all_levels) combined #&gt; [1] Agree Disagree Neutral Strongly Agree Agree #&gt; [6] Disagree #&gt; Levels: Strongly Disagree Disagree Neutral Agree Strongly Agree Exercise 3: validate_factor &lt;- function(f) { issues &lt;- list() # Check if factor if (!is.factor(f)) { issues$not_factor &lt;- paste(&quot;Input is&quot;, class(f)[1], &quot;not factor&quot;) return(issues) } # Check number of levels n_levels &lt;- nlevels(f) if (n_levels &lt; 2) { issues$too_few_levels &lt;- paste(&quot;Only&quot;, n_levels, &quot;level(s). Need at least 2 for most analyses.&quot;) } # Check for unused levels used_levels &lt;- unique(as.character(f)) all_levels &lt;- levels(f) unused &lt;- setdiff(all_levels, used_levels) if (length(unused) &gt; 0) { issues$unused_levels &lt;- paste(&quot;Unused levels:&quot;, paste(unused, collapse = &quot;, &quot;)) } # Report if (length(issues) == 0) { message(&quot;‚úì Factor validation passed&quot;) return(invisible(NULL)) } else { message(&quot;Factor validation issues found:&quot;) for (name in names(issues)) { message(&quot; - &quot;, issues[[name]]) } return(invisible(issues)) } } # Test good &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;)) validate_factor(good) #&gt; ‚úì Factor validation passed bad &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) validate_factor(bad) #&gt; Factor validation issues found: #&gt; - Unused levels: B, C Exercise 4: safe_assign_level &lt;- function(f, index, value) { # Validate input if (!is.factor(f)) { stop(&quot;Input must be a factor&quot;) } if (index &lt; 1 || index &gt; length(f)) { stop(&quot;Index out of bounds&quot;) } # Check if value is in levels if (!value %in% levels(f)) { message(&quot;Adding new level: &#39;&quot;, value, &quot;&#39;&quot;) levels(f) &lt;- c(levels(f), value) } # Assign old_value &lt;- as.character(f[index]) f[index] &lt;- value if (old_value != value) { message(&quot;Changed position &quot;, index, &quot; from &#39;&quot;, old_value, &quot;&#39; to &#39;&quot;, value, &quot;&#39;&quot;) } return(f) } # Test sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) # Existing level sizes &lt;- safe_assign_level(sizes, 1, &quot;M&quot;) #&gt; Changed position 1 from &#39;S&#39; to &#39;M&#39; sizes #&gt; [1] M M L #&gt; Levels: L M S # New level sizes &lt;- safe_assign_level(sizes, 2, &quot;XL&quot;) #&gt; Adding new level: &#39;XL&#39; #&gt; Changed position 2 from &#39;M&#39; to &#39;XL&#39; sizes #&gt; [1] M XL L #&gt; Levels: L M S XL levels(sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; "],["factor-operations.html", "Chapter 13 Factor Operations 13.1 Introduction 13.2 Recoding Factors 13.3 Error #1: level sets of factors are different 13.4 Error #2: NAs produced in factor operations 13.5 Collapsing Factor Levels 13.6 Reordering Factors 13.7 Error #3: 'ordered' must be a factor 13.8 Factor Arithmetic Errors 13.9 Useful forcats Functions 13.10 Factor in Data Frames 13.11 Converting Between Types 13.12 Summary 13.13 Exercises 13.14 Exercise Answers", " Chapter 13 Factor Operations What You‚Äôll Learn: Recoding and relabeling factors Grouping and collapsing levels Reordering factors Factor arithmetic issues Common factor operation errors Key Errors Covered: 10+ factor operation errors Difficulty: ‚≠ê‚≠ê Intermediate 13.1 Introduction Working with existing factors requires care: grades &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) grades &gt; &quot;B&quot; # Try to compare #&gt; Warning in Ops.factor(grades, &quot;B&quot;): &#39;&gt;&#39; not meaningful for factors #&gt; [1] NA NA NA NA NA üî¥ ERROR Error in Ops.factor(grades, &quot;B&quot;) : level sets of factors are different Let‚Äôs master factor operations to avoid these errors. 13.2 Recoding Factors üí° Key Insight: Recoding Strategies # Original factor responses &lt;- factor(c(&quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;M&quot;)) responses #&gt; [1] Y N Y N M #&gt; Levels: M N Y # Method 1: Relabel levels directly responses_v1 &lt;- responses levels(responses_v1) &lt;- c(&quot;Maybe&quot;, &quot;No&quot;, &quot;Yes&quot;) # Alphabetical order! responses_v1 #&gt; [1] Yes No Yes No Maybe #&gt; Levels: Maybe No Yes # Method 2: Create mapping library(forcats) responses_v2 &lt;- fct_recode(responses, &quot;Yes&quot; = &quot;Y&quot;, &quot;No&quot; = &quot;N&quot;, &quot;Maybe&quot; = &quot;M&quot; ) responses_v2 #&gt; [1] Yes No Yes No Maybe #&gt; Levels: Maybe No Yes # Method 3: Convert to character, recode, factor responses_v3 &lt;- as.character(responses) responses_v3[responses_v3 == &quot;Y&quot;] &lt;- &quot;Yes&quot; responses_v3[responses_v3 == &quot;N&quot;] &lt;- &quot;No&quot; responses_v3[responses_v3 == &quot;M&quot;] &lt;- &quot;Maybe&quot; responses_v3 &lt;- factor(responses_v3) responses_v3 #&gt; [1] Yes No Yes No Maybe #&gt; Levels: Maybe No Yes # Method 4: Use named vector mapping recode_map &lt;- c(Y = &quot;Yes&quot;, N = &quot;No&quot;, M = &quot;Maybe&quot;) responses_v4 &lt;- factor(recode_map[as.character(responses)]) responses_v4 #&gt; Y N Y N M #&gt; Yes No Yes No Maybe #&gt; Levels: Maybe No Yes 13.3 Error #1: level sets of factors are different ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 13.3.1 The Error sizes1 &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes2 &lt;- factor(c(&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) sizes1 == sizes2 #&gt; Error in Ops.factor(sizes1, sizes2): level sets of factors are different üî¥ ERROR Error in Ops.factor(sizes1, sizes2) : level sets of factors are different 13.3.2 What It Means You‚Äôre comparing factors with different level sets. R doesn‚Äôt know how to match them. 13.3.3 Common Causes 13.3.3.1 Cause 1: Comparing Different Factors color1 &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;)) color2 &lt;- factor(c(&quot;green&quot;, &quot;yellow&quot;)) color1 == color2 # Different levels! #&gt; Error in Ops.factor(color1, color2): level sets of factors are different 13.3.3.2 Cause 2: After Subsetting all_sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Different subsets small_sizes &lt;- all_sizes[1:2] large_sizes &lt;- all_sizes[3:4] # Both still have all levels levels(small_sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; levels(large_sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; # But after droplevels... small_sizes &lt;- droplevels(small_sizes) large_sizes &lt;- droplevels(large_sizes) levels(small_sizes) # S, M #&gt; [1] &quot;M&quot; &quot;S&quot; levels(large_sizes) # L, XL #&gt; [1] &quot;L&quot; &quot;XL&quot; # Now can&#39;t compare small_sizes[1] == large_sizes[1] #&gt; [1] FALSE 13.3.4 Solutions ‚úÖ SOLUTION 1: Convert to Character sizes1 &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes2 &lt;- factor(c(&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Compare as characters as.character(sizes1) == as.character(sizes2) #&gt; [1] FALSE FALSE FALSE ‚úÖ SOLUTION 2: Unify Levels sizes1 &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes2 &lt;- factor(c(&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Find all unique levels all_levels &lt;- union(levels(sizes1), levels(sizes2)) all_levels #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; # Recreate with same levels sizes1 &lt;- factor(sizes1, levels = all_levels) sizes2 &lt;- factor(sizes2, levels = all_levels) # Now can compare sizes1 == sizes2 #&gt; [1] FALSE FALSE FALSE ‚úÖ SOLUTION 3: Use %in% Instead sizes1 &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes2 &lt;- factor(c(&quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Check membership as.character(sizes1) %in% as.character(sizes2) #&gt; [1] FALSE TRUE TRUE 13.4 Error #2: NAs produced in factor operations ‚≠ê BEGINNER üî¢ TYPE 13.4.1 The Warning sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) levels(sizes) &lt;- c(&quot;Small&quot;, &quot;Large&quot;) # Only 2 new names for 3 levels! #&gt; Error in `levels&lt;-.factor`(`*tmp*`, value = c(&quot;Small&quot;, &quot;Large&quot;)): number of levels differs üü° WARNING Warning message: In `levels&lt;-.factor`(`*tmp*`, value = c(&quot;Small&quot;, &quot;Large&quot;)) : longer object length is not a multiple of replacement length sizes # What happened? #&gt; [1] S M L #&gt; Levels: L M S 13.4.2 What It Means When recoding, if you don‚Äôt provide the right number of new level names, unexpected things happen. 13.4.3 The Problem # Original sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) levels(sizes) #&gt; [1] &quot;L&quot; &quot;M&quot; &quot;S&quot; &quot;XL&quot; # Try to simplify to 2 categories levels(sizes) &lt;- c(&quot;Small&quot;, &quot;Large&quot;) #&gt; Error in `levels&lt;-.factor`(`*tmp*`, value = c(&quot;Small&quot;, &quot;Large&quot;)): number of levels differs sizes # Recycled! Not what we wanted #&gt; [1] S M L XL #&gt; Levels: L M S XL 13.4.4 Solutions ‚úÖ SOLUTION 1: Provide All New Names sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # All four mappings levels(sizes) &lt;- c(&quot;Small&quot;, &quot;Medium&quot;, &quot;Large&quot;, &quot;Extra Large&quot;) sizes #&gt; [1] Large Medium Small Extra Large #&gt; Levels: Small Medium Large Extra Large ‚úÖ SOLUTION 2: Use fct_collapse() for Grouping library(forcats) sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Collapse into groups sizes_collapsed &lt;- fct_collapse(sizes, Small = c(&quot;S&quot;, &quot;M&quot;), Large = c(&quot;L&quot;, &quot;XL&quot;) ) sizes_collapsed #&gt; [1] Small Small Large Large #&gt; Levels: Large Small ‚úÖ SOLUTION 3: Use fct_recode() for Precise Mapping sizes &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;XL&quot;)) # Explicit recoding sizes_recoded &lt;- fct_recode(sizes, &quot;Small&quot; = &quot;S&quot;, &quot;Small&quot; = &quot;M&quot;, # Map M to Small too &quot;Large&quot; = &quot;L&quot;, &quot;Large&quot; = &quot;XL&quot; ) sizes_recoded #&gt; [1] Small Small Large Large #&gt; Levels: Large Small 13.5 Collapsing Factor Levels üéØ Best Practice: Grouping Levels library(forcats) # Original detailed categories age_groups &lt;- factor(c(&quot;0-10&quot;, &quot;11-20&quot;, &quot;21-30&quot;, &quot;31-40&quot;, &quot;41-50&quot;, &quot;51-60&quot;, &quot;61-70&quot;, &quot;71+&quot;)) # Method 1: fct_collapse (explicit groups) age_collapsed &lt;- fct_collapse(age_groups, Youth = c(&quot;0-10&quot;, &quot;11-20&quot;), Adult = c(&quot;21-30&quot;, &quot;31-40&quot;, &quot;41-50&quot;), Senior = c(&quot;51-60&quot;, &quot;61-70&quot;, &quot;71+&quot;) ) age_collapsed #&gt; [1] Youth Youth Adult Adult Adult Senior Senior Senior #&gt; Levels: Youth Adult Senior # Method 2: fct_other (keep some, lump rest) top_ages &lt;- fct_other(age_groups, keep = c(&quot;21-30&quot;, &quot;31-40&quot;, &quot;41-50&quot;), other_level = &quot;Other&quot; ) top_ages #&gt; [1] Other Other 21-30 31-40 41-50 Other Other Other #&gt; Levels: 21-30 31-40 41-50 Other # Method 3: fct_lump (keep n most frequent) responses &lt;- factor(c(&quot;A&quot;, &quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)) lumped &lt;- fct_lump(responses, n = 2) # Keep top 2 lumped #&gt; [1] A A A B B Other Other Other #&gt; Levels: A B Other # Method 4: fct_lump_min (minimum count) lumped_min &lt;- fct_lump_min(responses, min = 2) # Keep if appears 2+ times lumped_min #&gt; [1] A A A B B Other Other Other #&gt; Levels: A B Other 13.6 Reordering Factors üí° Key Insight: Factor Ordering library(forcats) # Original (alphabetical by default) grades &lt;- factor(c(&quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;A&quot;, &quot;B&quot;)) grades #&gt; [1] B A C A B #&gt; Levels: A B C levels(grades) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; # Method 1: Specify order explicitly grades &lt;- factor(grades, levels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) levels(grades) #&gt; [1] &quot;C&quot; &quot;B&quot; &quot;A&quot; # Method 2: By frequency grades &lt;- fct_infreq(grades) levels(grades) # Most common first #&gt; [1] &quot;B&quot; &quot;A&quot; &quot;C&quot; # Method 3: By another variable df &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), score = c(95, 85, 90) ) df$name &lt;- factor(df$name) # Order by score df$name &lt;- fct_reorder(df$name, df$score) levels(df$name) # Ordered by score #&gt; [1] &quot;Bob&quot; &quot;Charlie&quot; &quot;Alice&quot; # Method 4: Reverse order grades &lt;- fct_rev(grades) levels(grades) #&gt; [1] &quot;C&quot; &quot;A&quot; &quot;B&quot; # Method 5: Manual reordering grades &lt;- fct_relevel(grades, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;) levels(grades) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 13.7 Error #3: 'ordered' must be a factor ‚≠ê BEGINNER üî¢ TYPE 13.7.1 The Error sizes &lt;- c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;) # Character vector ordered(sizes) # Try to make ordered #&gt; [1] S M L #&gt; Levels: L &lt; M &lt; S üî¥ ERROR Error in ordered(sizes) : argument is not a factor 13.7.2 What It Means The ordered() function requires a factor, not a character vector. 13.7.3 Solutions ‚úÖ SOLUTION 1: Convert to Factor First sizes &lt;- c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;) # Option A: Two steps sizes_fac &lt;- factor(sizes) sizes_ord &lt;- ordered(sizes_fac, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes_ord #&gt; [1] S M L #&gt; Levels: S &lt; M &lt; L # Option B: Direct with levels sizes_ord &lt;- ordered(sizes, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes_ord #&gt; [1] S M L #&gt; Levels: S &lt; M &lt; L ‚úÖ SOLUTION 2: Use factor() with ordered = TRUE sizes &lt;- c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;) # Directly to ordered factor sizes_ord &lt;- factor(sizes, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;), ordered = TRUE) sizes_ord #&gt; [1] S M L #&gt; Levels: S &lt; M &lt; L class(sizes_ord) #&gt; [1] &quot;ordered&quot; &quot;factor&quot; 13.8 Factor Arithmetic Errors ‚ö†Ô∏è Pitfall: You Can‚Äôt Do Math on Factors # Numeric-looking factor numbers &lt;- factor(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;)) # Try arithmetic numbers + 10 #&gt; Warning in Ops.factor(numbers, 10): &#39;+&#39; not meaningful for factors #&gt; [1] NA NA NA NA NA numbers * 2 #&gt; Warning in Ops.factor(numbers, 2): &#39;*&#39; not meaningful for factors #&gt; [1] NA NA NA NA NA mean(numbers) #&gt; Warning in mean.default(numbers): argument is not numeric or logical: returning #&gt; NA #&gt; [1] NA Why: Factors are categorical, not numeric, even if they look like numbers. Solution: # Convert first numbers_numeric &lt;- as.numeric(as.character(numbers)) numbers_numeric + 10 #&gt; [1] 11 12 13 14 15 mean(numbers_numeric) #&gt; [1] 3 ‚ö†Ô∏è Pitfall: Factor Comparison Limitations # Unordered factors can only check equality colors &lt;- factor(c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;)) colors[1] == colors[2] # OK #&gt; [1] FALSE colors[1] &lt; colors[2] # Error! #&gt; Warning in Ops.factor(colors[1], colors[2]): &#39;&lt;&#39; not meaningful for factors #&gt; [1] NA # Ordered factors can be compared sizes &lt;- ordered(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;), levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) sizes[1] &lt; sizes[3] # OK #&gt; [1] TRUE 13.9 Useful forcats Functions üéØ Best Practice: forcats Toolkit library(forcats) # Sample data responses &lt;- factor(c(&quot;Good&quot;, &quot;Bad&quot;, &quot;Good&quot;, &quot;Excellent&quot;, &quot;Bad&quot;, &quot;Good&quot;, &quot;Fair&quot;, &quot;Excellent&quot;)) # 1. Count levels fct_count(responses) #&gt; # A tibble: 4 √ó 2 #&gt; f n #&gt; &lt;fct&gt; &lt;int&gt; #&gt; 1 Bad 2 #&gt; 2 Excellent 2 #&gt; 3 Fair 1 #&gt; 4 Good 3 # 2. Reorder by frequency responses_freq &lt;- fct_infreq(responses) levels(responses_freq) #&gt; [1] &quot;Good&quot; &quot;Bad&quot; &quot;Excellent&quot; &quot;Fair&quot; # 3. Reverse order responses_rev &lt;- fct_rev(responses_freq) levels(responses_rev) #&gt; [1] &quot;Fair&quot; &quot;Excellent&quot; &quot;Bad&quot; &quot;Good&quot; # 4. Recode specific levels responses_clean &lt;- fct_recode(responses, &quot;Very Good&quot; = &quot;Excellent&quot;, &quot;Not Good&quot; = &quot;Bad&quot; ) levels(responses_clean) #&gt; [1] &quot;Not Good&quot; &quot;Very Good&quot; &quot;Fair&quot; &quot;Good&quot; # 5. Lump rare levels responses_lumped &lt;- fct_lump(responses, n = 2, other_level = &quot;Other&quot;) table(responses_lumped) #&gt; responses_lumped #&gt; Bad Excellent Good Other #&gt; 2 2 3 1 # 6. Add new levels responses_expanded &lt;- fct_expand(responses, &quot;Outstanding&quot;) levels(responses_expanded) #&gt; [1] &quot;Bad&quot; &quot;Excellent&quot; &quot;Fair&quot; &quot;Good&quot; &quot;Outstanding&quot; # 7. Drop unused levels sub &lt;- responses[responses %in% c(&quot;Good&quot;, &quot;Bad&quot;)] levels(sub) # Still has all levels #&gt; [1] &quot;Bad&quot; &quot;Excellent&quot; &quot;Fair&quot; &quot;Good&quot; sub &lt;- fct_drop(sub) levels(sub) # Only Good and Bad #&gt; [1] &quot;Bad&quot; &quot;Good&quot; # 8. Explicit ordering responses_ordered &lt;- fct_relevel(responses, &quot;Bad&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Excellent&quot;) levels(responses_ordered) #&gt; [1] &quot;Bad&quot; &quot;Fair&quot; &quot;Good&quot; &quot;Excellent&quot; 13.10 Factor in Data Frames üí° Key Insight: Factors in Data Analysis library(dplyr) # Sample data df &lt;- data.frame( category = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;)), value = c(10, 20, 15, 25, 22, 18) ) # Factors work well with grouping df %&gt;% group_by(category) %&gt;% summarise(mean_value = mean(value)) #&gt; # A tibble: 3 √ó 2 #&gt; category mean_value #&gt; &lt;fct&gt; &lt;dbl&gt; #&gt; 1 A 14.3 #&gt; 2 B 21 #&gt; 3 C 25 # But watch out for unused levels after filtering df_filtered &lt;- df %&gt;% filter(category != &quot;C&quot;) levels(df_filtered$category) # C still there! #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; # Drop unused df_filtered &lt;- df_filtered %&gt;% mutate(category = droplevels(category)) levels(df_filtered$category) # Now just A and B #&gt; [1] &quot;A&quot; &quot;B&quot; # Or use forcats df_filtered &lt;- df %&gt;% filter(category != &quot;C&quot;) %&gt;% mutate(category = fct_drop(category)) 13.11 Converting Between Types üéØ Best Practice: Type Conversions # Factor to character f &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) as.character(f) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Factor to numeric (for numeric-looking factors) f_num &lt;- factor(c(&quot;10&quot;, &quot;20&quot;, &quot;30&quot;)) as.numeric(as.character(f_num)) # Correct #&gt; [1] 10 20 30 # NOT: as.numeric(f_num) # Wrong! Gives 1, 2, 3 # Character to factor ch &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;) factor(ch) #&gt; [1] x y z #&gt; Levels: x y z # Numeric to factor (with labels) nums &lt;- c(1, 2, 3, 2, 1) factor(nums, levels = 1:3, labels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) #&gt; [1] Low Medium High Medium Low #&gt; Levels: Low Medium High # Ordered to unordered ord &lt;- ordered(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;), levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) factor(ord, ordered = FALSE) #&gt; [1] S M L #&gt; Levels: S M L # Unordered to ordered unord &lt;- factor(c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) ordered(unord, levels = c(&quot;S&quot;, &quot;M&quot;, &quot;L&quot;)) #&gt; [1] S M L #&gt; Levels: S &lt; M &lt; L 13.12 Summary Key Takeaways: Can‚Äôt compare factors with different levels - Unify first or convert to character Recoding requires all levels - Use fct_recode() or fct_collapse() Can‚Äôt do arithmetic on factors - Convert to numeric first Unordered factors can‚Äôt use &lt; &gt; - Use ordered() for ordinal data droplevels() after subsetting - Remove unused levels forcats makes factor work easier - Use it! Convert through character when going to numeric Quick Reference: Error Cause Fix level sets are different Comparing different factors Unify levels or convert NAs produced Wrong number of level names Use fct_recode() or provide all names ‚Äòordered‚Äô must be a factor Using ordered() on character Convert to factor first Can‚Äôt do arithmetic Math on factor Convert to numeric Can‚Äôt use &lt; &gt; Unordered factor comparison Make ordered or use character forcats Essential Functions: # Reordering fct_infreq() # By frequency fct_reorder() # By another variable fct_relevel() # Manually fct_rev() # Reverse # Recoding fct_recode() # Explicit mapping fct_collapse() # Group levels fct_lump() # Combine rare levels # Utilities fct_count() # Count levels fct_drop() # Drop unused fct_expand() # Add levels Best Practices: # ‚úÖ Good as.numeric(as.character(f)) # Factor to numeric fct_recode(f, &quot;new&quot; = &quot;old&quot;) # Explicit recoding fct_drop(f) # After subsetting ordered(f, levels = c(...)) # For ordinal data # ‚ùå Avoid as.numeric(f) # Wrong conversion levels(f) &lt;- too_few_names # Will recycle f1 == f2 # Without checking levels factor(x) without levels # Implicit ordering 13.13 Exercises üìù Exercise 1: Factor Recoding You have: grades &lt;- factor(c(&quot;A+&quot;, &quot;A&quot;, &quot;A-&quot;, &quot;B+&quot;, &quot;B&quot;, &quot;B-&quot;, &quot;C+&quot;, &quot;C&quot;)) Collapse to simple letter grades (A, B, C) Convert to ordered factor Create numeric scale (A=4, B=3, C=2) üìù Exercise 2: Survey Data Cleaning You have messy survey responses: responses &lt;- factor(c(&quot;yes&quot;, &quot;Yes&quot;, &quot;YES&quot;, &quot;no&quot;, &quot;No&quot;, &quot;NO&quot;, &quot;maybe&quot;, &quot;Maybe&quot;)) Standardize all to lowercase and create ordered factor: Disagree &lt; Maybe &lt; Agree üìù Exercise 3: Factor Comparison Write safe_compare(f1, f2, op) that: 1. Checks if factors can be compared 2. Unifies levels if needed 3. Performs comparison 4. Returns result with warnings üìù Exercise 4: Factor Summary Write factor_summary(f) that reports: 1. Number of levels 2. Most/least common levels 3. Any unused levels 4. Whether it‚Äôs ordered 5. Suggested recoding (if many levels) 13.14 Exercise Answers Click to see answers Exercise 1: library(forcats) grades &lt;- factor(c(&quot;A+&quot;, &quot;A&quot;, &quot;A-&quot;, &quot;B+&quot;, &quot;B&quot;, &quot;B-&quot;, &quot;C+&quot;, &quot;C&quot;)) # 1. Collapse to letter grades grades_simple &lt;- fct_collapse(grades, A = c(&quot;A+&quot;, &quot;A&quot;, &quot;A-&quot;), B = c(&quot;B+&quot;, &quot;B&quot;, &quot;B-&quot;), C = c(&quot;C+&quot;, &quot;C&quot;) ) grades_simple #&gt; [1] A A A B B B C C #&gt; Levels: A B C # 2. Convert to ordered grades_ordered &lt;- ordered(grades_simple, levels = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;)) grades_ordered #&gt; [1] A A A B B B C C #&gt; Levels: C &lt; B &lt; A # 3. Numeric scale grade_to_numeric &lt;- c(A = 4, B = 3, C = 2) grades_numeric &lt;- grade_to_numeric[as.character(grades_simple)] grades_numeric #&gt; A A A B B B C C #&gt; 4 4 4 3 3 3 2 2 Exercise 2: responses &lt;- factor(c(&quot;yes&quot;, &quot;Yes&quot;, &quot;YES&quot;, &quot;no&quot;, &quot;No&quot;, &quot;NO&quot;, &quot;maybe&quot;, &quot;Maybe&quot;)) # Standardize to lowercase responses_clean &lt;- tolower(as.character(responses)) # Map to agreement scale responses_clean[responses_clean == &quot;yes&quot;] &lt;- &quot;Agree&quot; responses_clean[responses_clean == &quot;no&quot;] &lt;- &quot;Disagree&quot; responses_clean[responses_clean == &quot;maybe&quot;] &lt;- &quot;Maybe&quot; # Create ordered factor responses_ordered &lt;- ordered( responses_clean, levels = c(&quot;Disagree&quot;, &quot;Maybe&quot;, &quot;Agree&quot;) ) responses_ordered #&gt; [1] Agree Agree Agree Disagree Disagree Disagree Maybe Maybe #&gt; Levels: Disagree &lt; Maybe &lt; Agree Exercise 3: safe_compare &lt;- function(f1, f2, op = c(&quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;)) { op &lt;- match.arg(op) # Check if both are factors if (!is.factor(f1) || !is.factor(f2)) { stop(&quot;Both inputs must be factors&quot;) } # Check length if (length(f1) != length(f2)) { warning(&quot;Factors have different lengths: &quot;, length(f1), &quot; vs &quot;, length(f2)) } # Check if levels match if (!identical(levels(f1), levels(f2))) { message(&quot;Factors have different levels. Unifying...&quot;) # Unify levels all_levels &lt;- union(levels(f1), levels(f2)) f1 &lt;- factor(f1, levels = all_levels) f2 &lt;- factor(f2, levels = all_levels) } # Check if ordered (for &lt; &gt; &lt;= &gt;=) if (op %in% c(&quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot;)) { if (!is.ordered(f1) || !is.ordered(f2)) { warning(&quot;Using ordering operators on unordered factors. &quot;, &quot;Converting to ordered.&quot;) f1 &lt;- ordered(f1, levels = levels(f1)) f2 &lt;- ordered(f2, levels = levels(f2)) } } # Perform comparison result &lt;- switch(op, &quot;==&quot; = f1 == f2, &quot;!=&quot; = f1 != f2, &quot;&lt;&quot; = f1 &lt; f2, &quot;&gt;&quot; = f1 &gt; f2, &quot;&lt;=&quot; = f1 &lt;= f2, &quot;&gt;=&quot; = f1 &gt;= f2 ) return(result) } # Test f1 &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) f2 &lt;- factor(c(&quot;B&quot;, &quot;C&quot;, &quot;D&quot;)) safe_compare(f1, f2, &quot;==&quot;) #&gt; Factors have different levels. Unifying... #&gt; [1] FALSE FALSE FALSE Exercise 4: factor_summary &lt;- function(f) { if (!is.factor(f)) { stop(&quot;Input must be a factor&quot;) } # Basic info cat(&quot;Factor Summary\\n&quot;) cat(&quot;==============\\n\\n&quot;) cat(&quot;Type:&quot;, if(is.ordered(f)) &quot;Ordered&quot; else &quot;Unordered&quot;, &quot;\\n&quot;) cat(&quot;Number of levels:&quot;, nlevels(f), &quot;\\n&quot;) cat(&quot;Number of observations:&quot;, length(f), &quot;\\n\\n&quot;) # Level counts level_counts &lt;- table(f) cat(&quot;Level frequencies:\\n&quot;) print(sort(level_counts, decreasing = TRUE)) cat(&quot;\\n&quot;) # Most/least common cat(&quot;Most common:&quot;, names(which.max(level_counts)), &quot;(&quot;, max(level_counts), &quot;times)\\n&quot;) cat(&quot;Least common:&quot;, names(which.min(level_counts)), &quot;(&quot;, min(level_counts), &quot;times)\\n\\n&quot;) # Unused levels used_levels &lt;- levels(f)[levels(f) %in% as.character(f)] unused_levels &lt;- setdiff(levels(f), used_levels) if (length(unused_levels) &gt; 0) { cat(&quot;‚ö† Unused levels:&quot;, paste(unused_levels, collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot; Consider using droplevels()\\n\\n&quot;) } # Suggestions if (nlevels(f) &gt; 10) { cat(&quot;üí° Suggestion: Factor has&quot;, nlevels(f), &quot;levels.\\n&quot;) cat(&quot; Consider grouping rare levels with fct_lump()\\n&quot;) # Find rare levels (&lt; 5% of data) rare &lt;- level_counts &lt; (0.05 * length(f)) if (any(rare)) { cat(&quot; Rare levels:&quot;, paste(names(level_counts)[rare], collapse = &quot;, &quot;), &quot;\\n&quot;) } } invisible(list( n_levels = nlevels(f), counts = level_counts, unused = unused_levels )) } # Test grades &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;)) factor_summary(grades) #&gt; Factor Summary #&gt; ============== #&gt; #&gt; Type: Unordered #&gt; Number of levels: 5 #&gt; Number of observations: 6 #&gt; #&gt; Level frequencies: #&gt; f #&gt; A B C D F #&gt; 3 2 1 0 0 #&gt; #&gt; Most common: A ( 3 times) #&gt; Least common: D ( 0 times) #&gt; #&gt; ‚ö† Unused levels: D, F #&gt; Consider using droplevels() "],["part-vi-strings-characters.html", "Part VI: Strings &amp; Characters", " Part VI: Strings &amp; Characters "],["string-basics.html", "Chapter 14 String Basics &amp; Common Errors 14.1 Introduction 14.2 String Basics 14.3 Error #1: unexpected symbol (quote issues) 14.4 Escape Sequences 14.5 Error #2: argument is not of mode character 14.6 Error #3: invalid multibyte string 14.7 String Creation and Manipulation 14.8 Length vs Number of Characters 14.9 Empty Strings and NA 14.10 Case Conversion 14.11 Whitespace Issues 14.12 String Comparison 14.13 Type Coercion with Strings 14.14 Summary 14.15 Exercises 14.16 Exercise Answers", " Chapter 14 String Basics &amp; Common Errors What You‚Äôll Learn: Character vectors vs strings String creation and encoding Common string errors Quotes and escaping String conversion issues Key Errors Covered: 15+ string errors Difficulty: ‚≠ê‚≠ê Intermediate 14.1 Introduction Strings in R seem simple but have surprising complexity: text &lt;- &quot;He said &quot;Hello&quot;&quot; # Try to include quotes #&gt; Error in parse(text = input): &lt;text&gt;:1:19: unexpected symbol #&gt; 1: text &lt;- &quot;He said &quot;Hello #&gt; ^ üî¥ ERROR Error: unexpected symbol in &quot;text &lt;- &quot;He said &quot;Hello&quot; Let‚Äôs master string handling to avoid these pitfalls. 14.2 String Basics üí° Key Insight: No String Type in R R doesn‚Äôt have a separate ‚Äústring‚Äù type: # What you think of as a &quot;string&quot; text &lt;- &quot;hello&quot; typeof(text) # &quot;character&quot; #&gt; [1] &quot;character&quot; class(text) # &quot;character&quot; #&gt; [1] &quot;character&quot; # It&#39;s a character vector of length 1 length(text) # 1 (one element) #&gt; [1] 1 nchar(text) # 5 (five characters) #&gt; [1] 5 # Multiple strings texts &lt;- c(&quot;hello&quot;, &quot;world&quot;) typeof(texts) # Still &quot;character&quot; #&gt; [1] &quot;character&quot; length(texts) # 2 (two elements) #&gt; [1] 2 nchar(texts) # 5 5 (characters in each) #&gt; [1] 5 5 Key points: - R has ‚Äúcharacter vectors‚Äù, not ‚Äústrings‚Äù - A ‚Äústring‚Äù is a character vector of length 1 - length() = number of elements - nchar() = number of characters in each element 14.3 Error #1: unexpected symbol (quote issues) ‚≠ê BEGINNER üî§ SYNTAX 14.3.1 The Error text &lt;- &quot;She said &quot;yes&quot;&quot; #&gt; Error in parse(text = input): &lt;text&gt;:1:20: unexpected symbol #&gt; 1: text &lt;- &quot;She said &quot;yes #&gt; ^ üî¥ ERROR Error: unexpected symbol in &quot;text &lt;- &quot;She said &quot;yes&quot; 14.3.2 What It Means You‚Äôre trying to include quotes inside a quoted string without escaping them. 14.3.3 The Problem # Double quotes inside double quotes message &lt;- &quot;He said &quot;Hello&quot;&quot; # Single quotes inside single quotes message &lt;- &#39;It&#39;s nice&#39; #&gt; Error in parse(text = input): &lt;text&gt;:2:22: unexpected symbol #&gt; 1: # Double quotes inside double quotes #&gt; 2: message &lt;- &quot;He said &quot;Hello #&gt; ^ 14.3.4 Solutions ‚úÖ SOLUTION 1: Use Different Quotes # Use single quotes outside, double inside message &lt;- &#39;He said &quot;Hello&quot;&#39; message #&gt; [1] &quot;He said \\&quot;Hello\\&quot;&quot; # Or vice versa message &lt;- &quot;It&#39;s nice&quot; message #&gt; [1] &quot;It&#39;s nice&quot; ‚úÖ SOLUTION 2: Escape Quotes # Escape with backslash message &lt;- &quot;He said \\&quot;Hello\\&quot;&quot; message #&gt; [1] &quot;He said \\&quot;Hello\\&quot;&quot; # When printed, quotes show cat(message) #&gt; He said &quot;Hello&quot; # Single quote escaping message &lt;- &#39;It\\&#39;s nice&#39; cat(message) #&gt; It&#39;s nice ‚úÖ SOLUTION 3: Use Raw Strings (R 4.0+) # Raw strings (if available in your R version) if (getRversion() &gt;= &quot;4.0.0&quot;) { message &lt;- r&quot;(He said &quot;Hello&quot; and she said &#39;Hi&#39;)&quot; cat(message) } #&gt; He said &quot;Hello&quot; and she said &#39;Hi&#39; 14.4 Escape Sequences üí° Key Insight: Common Escape Sequences # Newline cat(&quot;Line 1\\nLine 2&quot;) #&gt; Line 1 #&gt; Line 2 # Tab cat(&quot;Col1\\tCol2\\tCol3&quot;) #&gt; Col1 Col2 Col3 # Backslash itself cat(&quot;Path: C:\\\\Users\\\\Documents&quot;) #&gt; Path: C:\\Users\\Documents # Quotes cat(&quot;He said \\&quot;Hello\\&quot;&quot;) #&gt; He said &quot;Hello&quot; cat(&#39;It\\&#39;s working&#39;) #&gt; It&#39;s working # Carriage return cat(&quot;Part 1\\rPart 2&quot;) # Overwrites #&gt; Part 1Part 2 # Unicode cat(&quot;\\u03B1 \\u03B2 \\u03B3&quot;) # Œ± Œ≤ Œ≥ #&gt; Œ± Œ≤ Œ≥ # Hex cat(&quot;\\x48\\x65\\x6C\\x6C\\x6F&quot;) # Hello #&gt; Hello # All escape sequences cat(&quot;Newline:\\nTab:\\tQuote:\\&quot;Backslash:\\\\&quot;) #&gt; Newline: #&gt; Tab: Quote:&quot;Backslash:\\ Common escapes: - \\n - newline - \\t - tab - \\\\ - backslash - \\\" - double quote - \\' - single quote - \\r - carriage return - \\uXXXX - Unicode character - \\xXX - Hex character 14.5 Error #2: argument is not of mode character ‚≠ê BEGINNER üî¢ TYPE 14.5.1 The Error numbers &lt;- c(1, 2, 3, 4, 5) nchar(numbers) #&gt; [1] 1 1 1 1 1 üî¥ ERROR (in some contexts) Error in nchar(numbers) : &#39;nchar()&#39; requires a character vector Actually, nchar() coerces, but other functions don‚Äôt: substr(123, 1, 2) #&gt; [1] &quot;12&quot; üî¥ ERROR Error in substr(123, 1, 2) : argument is not of mode character 14.5.2 What It Means You‚Äôre passing a non-character vector to a function that requires characters. 14.5.3 Common Causes 14.5.3.1 Cause 1: Using Numbers Directly # Try to substring a number substr(12345, 1, 3) #&gt; [1] &quot;123&quot; # Try to split a number strsplit(123, &quot;&quot;) #&gt; Error in strsplit(123, &quot;&quot;): non-character argument 14.5.3.2 Cause 2: After Calculation x &lt;- 10 y &lt;- 20 result &lt;- x + y # Try to manipulate as string substr(result, 1, 1) #&gt; [1] &quot;3&quot; 14.5.3.3 Cause 3: Column Type Issues df &lt;- data.frame(id = 1:5) # Try string operation on numeric column substr(df$id, 1, 1) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; 14.5.4 Solutions ‚úÖ SOLUTION 1: Convert to Character First numbers &lt;- c(1, 2, 3, 4, 5) # Convert numbers_char &lt;- as.character(numbers) nchar(numbers_char) #&gt; [1] 1 1 1 1 1 # Or inline substr(as.character(12345), 1, 3) #&gt; [1] &quot;123&quot; # Extract first digit as.numeric(substr(as.character(12345), 1, 1)) #&gt; [1] 1 ‚úÖ SOLUTION 2: Check Type Before Operation safe_substr &lt;- function(x, start, stop) { if (!is.character(x)) { message(&quot;Converting to character&quot;) x &lt;- as.character(x) } substr(x, start, stop) } # Test safe_substr(12345, 1, 3) #&gt; Converting to character #&gt; [1] &quot;123&quot; safe_substr(&quot;hello&quot;, 1, 3) #&gt; [1] &quot;hel&quot; ‚úÖ SOLUTION 3: Use stringr (Auto-converts) library(stringr) #&gt; Warning: package &#39;stringr&#39; was built under R version 4.5.1 # stringr functions auto-convert str_sub(12345, 1, 3) #&gt; [1] &quot;123&quot; str_length(12345) #&gt; [1] 5 14.6 Error #3: invalid multibyte string ‚≠ê‚≠ê‚≠ê ADVANCED üåê ENCODING 14.6.1 The Error # Try to read file with wrong encoding text &lt;- readLines(&quot;file_with_utf8.txt&quot;, encoding = &quot;latin1&quot;) #&gt; Warning in file(con, &quot;r&quot;): cannot open file &#39;file_with_utf8.txt&#39;: No such file #&gt; or directory #&gt; Error in file(con, &quot;r&quot;): cannot open the connection nchar(text) # May error #&gt; [1] 5 üî¥ ERROR Error in nchar(text) : invalid multibyte string 14.6.2 What It Means The string contains bytes that aren‚Äôt valid in the expected encoding. 14.6.3 Common Causes 14.6.3.1 Cause 1: Reading with Wrong Encoding # File is UTF-8 but reading as different encoding text &lt;- readLines(&quot;utf8_file.txt&quot;, encoding = &quot;latin1&quot;) # Or vice versa text &lt;- readLines(&quot;latin1_file.txt&quot;, encoding = &quot;UTF-8&quot;) 14.6.3.2 Cause 2: Locale Issues # Check current locale Sys.getlocale(&quot;LC_CTYPE&quot;) #&gt; [1] &quot;en_US.UTF-8&quot; # May differ across systems 14.6.3.3 Cause 3: Pasting Invalid Bytes # Create invalid UTF-8 invalid &lt;- rawToChar(as.raw(c(0xFF, 0xFE))) nchar(invalid) #&gt; Error in nchar(invalid): invalid multibyte string, element 1 14.6.4 Solutions ‚úÖ SOLUTION 1: Specify Correct Encoding # Read with correct encoding text &lt;- readLines(&quot;file.txt&quot;, encoding = &quot;UTF-8&quot;) # Or detect encoding library(readr) guess_encoding(&quot;file.txt&quot;) # Then read with detected encoding text &lt;- readLines(&quot;file.txt&quot;, encoding = &quot;detected_encoding&quot;) ‚úÖ SOLUTION 2: Convert Encoding # Sample text (may need real multibyte text) text &lt;- &quot;caf√©&quot; # Check encoding Encoding(text) #&gt; [1] &quot;UTF-8&quot; # Convert if needed text_utf8 &lt;- iconv(text, from = &quot;latin1&quot;, to = &quot;UTF-8&quot;) # Or ensure UTF-8 enc2utf8(text) #&gt; [1] &quot;caf√©&quot; ‚úÖ SOLUTION 3: Clean Invalid Characters clean_string &lt;- function(x) { # Try to convert to UTF-8, replacing invalid iconv(x, to = &quot;UTF-8&quot;, sub = &quot;?&quot;) } # Or remove invalid clean_string_remove &lt;- function(x) { iconv(x, to = &quot;UTF-8&quot;, sub = &quot;&quot;) } ‚ö†Ô∏è Platform Differences Encoding issues often vary by platform: # Windows default: may be Windows-1252 or local encoding Sys.getlocale() # Mac/Linux default: usually UTF-8 Sys.getlocale() # Always specify encoding when reading files: readr::read_csv(&quot;file.csv&quot;, locale = locale(encoding = &quot;UTF-8&quot;)) readLines(&quot;file.txt&quot;, encoding = &quot;UTF-8&quot;) 14.7 String Creation and Manipulation üéØ Best Practice: Creating and Combining Strings # Creating strings single &lt;- &quot;hello&quot; multiple &lt;- c(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;) # Combining strings paste(&quot;hello&quot;, &quot;world&quot;) # Space by default #&gt; [1] &quot;hello world&quot; paste(&quot;hello&quot;, &quot;world&quot;, sep = &quot;&quot;) # No space #&gt; [1] &quot;helloworld&quot; paste0(&quot;hello&quot;, &quot;world&quot;) # paste with sep=&quot;&quot; #&gt; [1] &quot;helloworld&quot; # Collapse vector into one string paste(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), collapse = &quot;, &quot;) #&gt; [1] &quot;a, b, c&quot; # Vector operations (recycling) paste(&quot;File&quot;, 1:5, &quot;.txt&quot;, sep = &quot;&quot;) #&gt; [1] &quot;File1.txt&quot; &quot;File2.txt&quot; &quot;File3.txt&quot; &quot;File4.txt&quot; &quot;File5.txt&quot; # stringr alternatives library(stringr) str_c(&quot;hello&quot;, &quot;world&quot;, sep = &quot; &quot;) #&gt; [1] &quot;hello world&quot; str_c(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), collapse = &quot;, &quot;) #&gt; [1] &quot;a, b, c&quot; # glue for interpolation library(glue) name &lt;- &quot;Alice&quot; age &lt;- 30 glue(&quot;My name is {name} and I am {age} years old&quot;) #&gt; My name is Alice and I am 30 years old 14.8 Length vs Number of Characters ‚ö†Ô∏è Common Confusion: length() vs nchar() # Single string text &lt;- &quot;hello&quot; length(text) # 1 (one element in vector) #&gt; [1] 1 nchar(text) # 5 (five characters) #&gt; [1] 5 # Multiple strings texts &lt;- c(&quot;hi&quot;, &quot;hello&quot;, &quot;hey&quot;) length(texts) # 3 (three elements) #&gt; [1] 3 nchar(texts) # 2 5 3 (characters in each) #&gt; [1] 2 5 3 # Empty string vs NULL empty &lt;- &quot;&quot; length(empty) # 1 (one element) #&gt; [1] 1 nchar(empty) # 0 (no characters) #&gt; [1] 0 nothing &lt;- character(0) length(nothing) # 0 (no elements) #&gt; [1] 0 nchar(nothing) # integer(0) #&gt; integer(0) # Common mistake text &lt;- &quot;hello world&quot; length(text) # 1 (NOT 11!) #&gt; [1] 1 nchar(text) # 11 (including space) #&gt; [1] 11 # To split into characters strsplit(text, &quot;&quot;)[[1]] #&gt; [1] &quot;h&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot; &quot; &quot; &quot;w&quot; &quot;o&quot; &quot;r&quot; &quot;l&quot; &quot;d&quot; length(strsplit(text, &quot;&quot;)[[1]]) # 11 #&gt; [1] 11 14.9 Empty Strings and NA üí° Key Insight: Empty vs NA vs NULL # Empty string (exists but empty) empty &lt;- &quot;&quot; length(empty) # 1 #&gt; [1] 1 nchar(empty) # 0 #&gt; [1] 0 is.na(empty) # FALSE #&gt; [1] FALSE empty == &quot;&quot; # TRUE #&gt; [1] TRUE # NA (missing value) missing &lt;- NA_character_ length(missing) # 1 #&gt; [1] 1 nchar(missing) # NA (can&#39;t count characters of NA) #&gt; [1] NA is.na(missing) # TRUE #&gt; [1] TRUE # NULL (doesn&#39;t exist) nothing &lt;- NULL length(nothing) # 0 #&gt; [1] 0 is.null(nothing) # TRUE #&gt; [1] TRUE # In a vector vec &lt;- c(&quot;hello&quot;, &quot;&quot;, NA, &quot;world&quot;) length(vec) # 4 #&gt; [1] 4 nchar(vec) # 5 0 NA 5 #&gt; [1] 5 0 NA 5 is.na(vec) # FALSE FALSE TRUE FALSE #&gt; [1] FALSE FALSE TRUE FALSE vec == &quot;&quot; # FALSE TRUE NA FALSE (NA propagates!) #&gt; [1] FALSE TRUE NA FALSE # Testing for empty strings safely is_empty &lt;- function(x) { !is.na(x) &amp; x == &quot;&quot; } is_empty(vec) # FALSE TRUE FALSE FALSE #&gt; [1] FALSE TRUE FALSE FALSE 14.10 Case Conversion üéØ Best Practice: Case Operations text &lt;- &quot;Hello World&quot; # Base R toupper(text) #&gt; [1] &quot;HELLO WORLD&quot; tolower(text) #&gt; [1] &quot;hello world&quot; # First letter (no built-in function) capitalize &lt;- function(x) { paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x))) } capitalize(&quot;hello&quot;) #&gt; [1] &quot;Hello&quot; # stringr alternatives library(stringr) str_to_upper(text) #&gt; [1] &quot;HELLO WORLD&quot; str_to_lower(text) #&gt; [1] &quot;hello world&quot; str_to_title(text) # Title Case #&gt; [1] &quot;Hello World&quot; # Handle NAs better text_with_na &lt;- c(&quot;hello&quot;, NA, &quot;world&quot;) toupper(text_with_na) # Preserves NA #&gt; [1] &quot;HELLO&quot; NA &quot;WORLD&quot; str_to_upper(text_with_na) # Also preserves NA #&gt; [1] &quot;HELLO&quot; NA &quot;WORLD&quot; 14.11 Whitespace Issues ‚ö†Ô∏è Common Pitfall: Invisible Whitespace # Strings that look the same text1 &lt;- &quot;hello&quot; text2 &lt;- &quot; hello&quot; text3 &lt;- &quot;hello &quot; text4 &lt;- &quot;hello\\n&quot; # But aren&#39;t equal text1 == text2 # FALSE (leading space) #&gt; [1] FALSE text1 == text3 # FALSE (trailing space) #&gt; [1] FALSE text1 == text4 # FALSE (newline) #&gt; [1] FALSE # Hard to see! print(text2) #&gt; [1] &quot; hello&quot; print(text3) #&gt; [1] &quot;hello &quot; # Better visualization cat(&quot;[&quot;, text1, &quot;]\\n&quot;, sep = &quot;&quot;) #&gt; [hello] cat(&quot;[&quot;, text2, &quot;]\\n&quot;, sep = &quot;&quot;) #&gt; [ hello] cat(&quot;[&quot;, text3, &quot;]\\n&quot;, sep = &quot;&quot;) #&gt; [hello ] # Trim whitespace trimws(text2) # Remove leading/trailing #&gt; [1] &quot;hello&quot; trimws(text3) #&gt; [1] &quot;hello&quot; # stringr library(stringr) str_trim(text2) #&gt; [1] &quot;hello&quot; str_squish(&quot;hello world&quot;) # Remove extra internal spaces too #&gt; [1] &quot;hello world&quot; 14.12 String Comparison üí° Key Insight: String Comparison # Equality &quot;hello&quot; == &quot;hello&quot; # TRUE #&gt; [1] TRUE &quot;hello&quot; == &quot;Hello&quot; # FALSE (case-sensitive) #&gt; [1] FALSE # Lexicographic ordering &quot;a&quot; &lt; &quot;b&quot; # TRUE #&gt; [1] TRUE &quot;apple&quot; &lt; &quot;banana&quot; # TRUE #&gt; [1] TRUE &quot;10&quot; &lt; &quot;2&quot; # TRUE (lexicographic, not numeric!) #&gt; [1] TRUE # Vector comparison c(&quot;a&quot;, &quot;b&quot;) == c(&quot;a&quot;, &quot;c&quot;) # TRUE FALSE #&gt; [1] TRUE FALSE # %in% for membership &quot;apple&quot; %in% c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) # TRUE #&gt; [1] TRUE # Case-insensitive comparison tolower(&quot;Hello&quot;) == tolower(&quot;hello&quot;) # TRUE #&gt; [1] TRUE # Partial matching (base R) grep(&quot;app&quot;, c(&quot;apple&quot;, &quot;banana&quot;, &quot;application&quot;)) # 1 3 #&gt; [1] 1 3 grepl(&quot;app&quot;, c(&quot;apple&quot;, &quot;banana&quot;, &quot;application&quot;)) # TRUE FALSE TRUE #&gt; [1] TRUE FALSE TRUE # stringr library(stringr) str_detect(c(&quot;apple&quot;, &quot;banana&quot;), &quot;app&quot;) # TRUE FALSE #&gt; [1] TRUE FALSE str_which(c(&quot;apple&quot;, &quot;banana&quot;, &quot;app&quot;), &quot;app&quot;) # 1 3 #&gt; [1] 1 3 14.13 Type Coercion with Strings ‚ö†Ô∏è Pitfall: Implicit String Coercion # Combining strings and numbers c(&quot;a&quot;, 1, &quot;b&quot;, 2) # All become character #&gt; [1] &quot;a&quot; &quot;1&quot; &quot;b&quot; &quot;2&quot; # In data frames (old R) df_old &lt;- data.frame( id = 1:3, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), stringsAsFactors = TRUE # Old default ) class(df_old$name) # &quot;factor&quot; (was default in R &lt; 4.0) #&gt; [1] &quot;factor&quot; # Modern R df_new &lt;- data.frame( id = 1:3, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) ) class(df_new$name) # &quot;character&quot; #&gt; [1] &quot;character&quot; # Operations can coerce x &lt;- c(1, 2, 3) y &lt;- paste(x, &quot;items&quot;) y # &quot;1 items&quot; &quot;2 items&quot; &quot;3 items&quot; #&gt; [1] &quot;1 items&quot; &quot;2 items&quot; &quot;3 items&quot; class(y) # &quot;character&quot; #&gt; [1] &quot;character&quot; 14.14 Summary Key Takeaways: No string type - R has character vectors length() vs nchar() - Elements vs characters Escape quotes with \\ or use different quotes Encoding matters - Specify UTF-8 when reading files Empty vs NA vs NULL - Three different concepts Convert to character before string operations Whitespace is invisible - Use trimws() or str_trim() Quick Reference: Error Cause Fix unexpected symbol Quotes not escaped Use \\\" or different quotes not of mode character Non-character input as.character() first invalid multibyte string Encoding mismatch Specify correct encoding Wrong comparison Case or whitespace tolower() and trimws() Essential Functions: # Creation c(), paste(), paste0(), sprintf() # Inspection length(), nchar(), Encoding() # Manipulation substr(), substring(), strsplit() toupper(), tolower(), trimws() # Comparison ==, %in%, grep(), grepl() # Conversion as.character(), toString() # stringr equivalents (better) str_c(), str_length(), str_sub() str_to_upper(), str_to_lower() str_trim(), str_squish() str_detect(), str_which() Best Practices: # ‚úÖ Good text &lt;- &#39;He said &quot;Hello&quot;&#39; # Different quotes readLines(&quot;file.txt&quot;, encoding = &quot;UTF-8&quot;) # Explicit encoding trimws(text) # Clean whitespace as.character(x) before string ops # Convert first # ‚ùå Avoid text &lt;- &quot;He said &quot;Hello&quot;&quot; # Unescaped quotes readLines(&quot;file.txt&quot;) # Platform-dependent encoding Assuming no whitespace # Invisible characters String operations on numbers # Type mismatch 14.15 Exercises üìù Exercise 1: Quote Handling Create strings containing: 1. Double quotes inside single quotes 2. Single quotes inside double quotes 3. Both quote types in one string 4. A file path with backslashes üìù Exercise 2: Length vs Characters You have: texts &lt;- c(\"hi\", \"hello\", \"hey\") Find number of elements Find characters in each Find total characters Find longest string üìù Exercise 3: Clean Text Write clean_text(x) that: 1. Trims whitespace 2. Converts to consistent case 3. Removes or replaces NAs 4. Reports what was changed üìù Exercise 4: Safe String Operations Write safe_substr(x, start, stop) that: 1. Converts to character if needed 2. Handles NAs appropriately 3. Handles out-of-bounds indices 4. Returns character vector 14.16 Exercise Answers Click to see answers Exercise 1: # 1. Double quotes inside single quotes text1 &lt;- &#39;She said &quot;Hello&quot;&#39; cat(text1) #&gt; She said &quot;Hello&quot; # 2. Single quotes inside double quotes text2 &lt;- &quot;It&#39;s a nice day&quot; cat(text2) #&gt; It&#39;s a nice day # 3. Both quote types text3 &lt;- &quot;She said \\&quot;It&#39;s nice\\&quot;&quot; # Escape double quotes cat(text3) #&gt; She said &quot;It&#39;s nice&quot; # Alternative with single outside text3_alt &lt;- &#39;She said &quot;It\\&#39;s nice&quot;&#39; # Escape single quote cat(text3_alt) #&gt; She said &quot;It&#39;s nice&quot; # 4. File path with backslashes path &lt;- &quot;C:\\\\Users\\\\Documents\\\\file.txt&quot; cat(path) #&gt; C:\\Users\\Documents\\file.txt # Or use forward slashes (works on all platforms) path_alt &lt;- &quot;C:/Users/Documents/file.txt&quot; Exercise 2: texts &lt;- c(&quot;hi&quot;, &quot;hello&quot;, &quot;hey&quot;) # 1. Number of elements num_elements &lt;- length(texts) num_elements #&gt; [1] 3 # 2. Characters in each chars_each &lt;- nchar(texts) chars_each #&gt; [1] 2 5 3 # 3. Total characters total_chars &lt;- sum(nchar(texts)) total_chars #&gt; [1] 10 # 4. Longest string longest &lt;- texts[which.max(nchar(texts))] longest #&gt; [1] &quot;hello&quot; # Or get length of longest max_length &lt;- max(nchar(texts)) max_length #&gt; [1] 5 # Complete analysis analyze_strings &lt;- function(x) { list( n_elements = length(x), chars_each = nchar(x), total_chars = sum(nchar(x)), avg_chars = mean(nchar(x)), longest = x[which.max(nchar(x))], shortest = x[which.min(nchar(x))] ) } analyze_strings(texts) #&gt; $n_elements #&gt; [1] 3 #&gt; #&gt; $chars_each #&gt; [1] 2 5 3 #&gt; #&gt; $total_chars #&gt; [1] 10 #&gt; #&gt; $avg_chars #&gt; [1] 3.333333 #&gt; #&gt; $longest #&gt; [1] &quot;hello&quot; #&gt; #&gt; $shortest #&gt; [1] &quot;hi&quot; Exercise 3: clean_text &lt;- function(x, trim = TRUE, case = c(&quot;lower&quot;, &quot;upper&quot;, &quot;none&quot;), na_action = c(&quot;keep&quot;, &quot;remove&quot;, &quot;replace&quot;), na_replacement = &quot;&quot;, report = TRUE) { case &lt;- match.arg(case) na_action &lt;- match.arg(na_action) original &lt;- x changes &lt;- list() # Handle NAs n_na &lt;- sum(is.na(x)) if (n_na &gt; 0) { if (na_action == &quot;remove&quot;) { x &lt;- x[!is.na(x)] changes$na &lt;- paste(&quot;Removed&quot;, n_na, &quot;NAs&quot;) } else if (na_action == &quot;replace&quot;) { x[is.na(x)] &lt;- na_replacement changes$na &lt;- paste(&quot;Replaced&quot;, n_na, &quot;NAs with&quot;, shQuote(na_replacement)) } else { changes$na &lt;- paste(&quot;Kept&quot;, n_na, &quot;NAs&quot;) } } # Trim whitespace if (trim) { had_whitespace &lt;- x != trimws(x) &amp; !is.na(x) if (any(had_whitespace)) { x &lt;- trimws(x) changes$whitespace &lt;- paste(&quot;Trimmed whitespace from&quot;, sum(had_whitespace), &quot;strings&quot;) } } # Case conversion if (case == &quot;lower&quot;) { x &lt;- tolower(x) changes$case &lt;- &quot;Converted to lowercase&quot; } else if (case == &quot;upper&quot;) { x &lt;- toupper(x) changes$case &lt;- &quot;Converted to uppercase&quot; } # Report if (report &amp;&amp; length(changes) &gt; 0) { message(&quot;Text cleaning applied:&quot;) for (change in changes) { message(&quot; - &quot;, change) } } return(x) } # Test messy &lt;- c(&quot; Hello &quot;, &quot;WORLD&quot;, NA, &quot; Test &quot;) clean_text(messy, case = &quot;lower&quot;, na_action = &quot;replace&quot;, na_replacement = &quot;[missing]&quot;) #&gt; Text cleaning applied: #&gt; - Replaced 1 NAs with &#39;[missing]&#39; #&gt; - Trimmed whitespace from 2 strings #&gt; - Converted to lowercase #&gt; [1] &quot;hello&quot; &quot;world&quot; &quot;[missing]&quot; &quot;test&quot; Exercise 4: safe_substr &lt;- function(x, start, stop) { # Convert to character if needed if (!is.character(x)) { message(&quot;Converting input to character&quot;) x &lt;- as.character(x) } # Validate indices if (start &lt; 1) { warning(&quot;start &lt; 1, setting to 1&quot;) start &lt;- 1 } if (stop &lt; start) { warning(&quot;stop &lt; start, returning empty strings&quot;) return(rep(&quot;&quot;, length(x))) } # Handle each element result &lt;- character(length(x)) for (i in seq_along(x)) { if (is.na(x[i])) { result[i] &lt;- NA_character_ next } # Get length len &lt;- nchar(x[i]) # Adjust stop if beyond length actual_stop &lt;- min(stop, len) if (start &gt; len) { result[i] &lt;- &quot;&quot; } else { result[i] &lt;- substr(x[i], start, actual_stop) } } return(result) } # Test safe_substr(c(&quot;hello&quot;, &quot;world&quot;, NA, &quot;R&quot;), 1, 3) #&gt; [1] &quot;hel&quot; &quot;wor&quot; NA &quot;R&quot; safe_substr(12345, 1, 3) # Auto-converts #&gt; Converting input to character #&gt; [1] &quot;123&quot; safe_substr(&quot;short&quot;, 1, 100) # Beyond length #&gt; [1] &quot;short&quot; safe_substr(&quot;test&quot;, 10, 20) # Start beyond length #&gt; [1] &quot;&quot; "],["string-pattern-matching.html", "Chapter 15 String Pattern Matching 15.1 Introduction 15.2 Pattern Matching Basics 15.3 Error #1: invalid regular expression 15.4 Regular Expression Special Characters 15.5 Error #2: Pattern Matches Everything/Nothing 15.6 stringr: Modern String Operations 15.7 Common Regex Patterns 15.8 Replacement Operations 15.9 Splitting Strings 15.10 Error #3: 'replacement' is not a character vector 15.11 Case-Insensitive Matching 15.12 Unicode and Locales 15.13 Extracting Patterns 15.14 Debugging Regex 15.15 Summary 15.16 Exercises 15.17 Exercise Answers", " Chapter 15 String Pattern Matching What You‚Äôll Learn: Regular expressions basics grep family functions Pattern matching errors Replacement operations Common regex pitfalls Key Errors Covered: 12+ pattern matching errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 15.1 Introduction Pattern matching in strings is powerful but error-prone: # Try to match a pattern text &lt;- c(&quot;file1.txt&quot;, &quot;file2.csv&quot;, &quot;file3.txt&quot;) grep(&quot;.&quot;, text) # Expect to find the dots #&gt; [1] 1 2 3 # But . in regex means &quot;any character&quot;! grep(&quot;.&quot;, text) # Matches everything! #&gt; [1] 1 2 3 Let‚Äôs master pattern matching and avoid regex pitfalls. 15.2 Pattern Matching Basics üí° Key Insight: grep Family Functions texts &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;apricot&quot;, &quot;cherry&quot;) # grep: return indices of matches grep(&quot;ap&quot;, texts) #&gt; [1] 1 3 texts[grep(&quot;ap&quot;, texts)] #&gt; [1] &quot;apple&quot; &quot;apricot&quot; # grepl: return logical vector grepl(&quot;ap&quot;, texts) #&gt; [1] TRUE FALSE TRUE FALSE # sub: replace first match sub(&quot;a&quot;, &quot;X&quot;, texts) #&gt; [1] &quot;Xpple&quot; &quot;bXnana&quot; &quot;Xpricot&quot; &quot;cherry&quot; # gsub: replace all matches gsub(&quot;a&quot;, &quot;X&quot;, texts) #&gt; [1] &quot;Xpple&quot; &quot;bXnXnX&quot; &quot;Xpricot&quot; &quot;cherry&quot; # regexpr: position of first match regexpr(&quot;a&quot;, texts) #&gt; [1] 1 2 1 -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 1 1 -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE # gregexpr: positions of all matches gregexpr(&quot;a&quot;, texts) #&gt; [[1]] #&gt; [1] 1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[2]] #&gt; [1] 2 4 6 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 1 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[3]] #&gt; [1] 1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] 1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE #&gt; #&gt; [[4]] #&gt; [1] -1 #&gt; attr(,&quot;match.length&quot;) #&gt; [1] -1 #&gt; attr(,&quot;index.type&quot;) #&gt; [1] &quot;chars&quot; #&gt; attr(,&quot;useBytes&quot;) #&gt; [1] TRUE Key differences: - grep() ‚Üí indices - grepl() ‚Üí TRUE/FALSE - sub() ‚Üí replace first - gsub() ‚Üí replace all - *expr() ‚Üí positions 15.3 Error #1: invalid regular expression ‚≠ê‚≠ê‚≠ê ADVANCED üî§ SYNTAX 15.3.1 The Error # Unmatched bracket grep(&quot;[abc&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; Warning in grep(&quot;[abc&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): TRE pattern compilation error #&gt; &#39;Missing &#39;]&#39;&#39; #&gt; Error in grep(&quot;[abc&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)): invalid regular expression &#39;[abc&#39;, reason &#39;Missing &#39;]&#39;&#39; üî¥ ERROR Error in grep(&quot;[abc&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) : invalid regular expression &#39;[abc&#39;, reason &#39;Missing &#39;]&#39;&#39; 15.3.2 What It Means Your regular expression has invalid syntax. 15.3.3 Common Invalid Patterns # Unmatched brackets grep(&quot;[abc&quot;, &quot;test&quot;) #&gt; Warning in grep(&quot;[abc&quot;, &quot;test&quot;): TRE pattern compilation error &#39;Missing &#39;]&#39;&#39; #&gt; Error in grep(&quot;[abc&quot;, &quot;test&quot;): invalid regular expression &#39;[abc&#39;, reason &#39;Missing &#39;]&#39;&#39; grep(&quot;abc]&quot;, &quot;test&quot;) #&gt; integer(0) # Unmatched parentheses grep(&quot;(abc&quot;, &quot;test&quot;) #&gt; Warning in grep(&quot;(abc&quot;, &quot;test&quot;): TRE pattern compilation error &#39;Missing &#39;)&#39;&#39; #&gt; Error in grep(&quot;(abc&quot;, &quot;test&quot;): invalid regular expression &#39;(abc&#39;, reason &#39;Missing &#39;)&#39;&#39; grep(&quot;abc)&quot;, &quot;test&quot;) #&gt; integer(0) # Invalid repetition grep(&quot;a{2,1}&quot;, &quot;test&quot;) # max &lt; min #&gt; Warning in grep(&quot;a{2,1}&quot;, &quot;test&quot;): TRE pattern compilation error &#39;Invalid #&gt; contents of {}&#39; #&gt; Error in grep(&quot;a{2,1}&quot;, &quot;test&quot;): invalid regular expression &#39;a{2,1}&#39;, reason &#39;Invalid contents of {}&#39; # Trailing backslash grep(&quot;test\\\\&quot;, &quot;test&quot;) #&gt; Warning in grep(&quot;test\\\\&quot;, &quot;test&quot;): TRE pattern compilation error &#39;Trailing #&gt; backslash&#39; #&gt; Error in grep(&quot;test\\\\&quot;, &quot;test&quot;): invalid regular expression &#39;test\\&#39;, reason &#39;Trailing backslash&#39; # Invalid escape grep(&quot;\\\\k&quot;, &quot;test&quot;) # \\k not valid #&gt; integer(0) 15.3.4 Solutions ‚úÖ SOLUTION 1: Escape Special Characters # To match literal special characters, escape them special_chars &lt;- c(&quot;.&quot;, &quot;*&quot;, &quot;+&quot;, &quot;?&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;, &quot;{&quot;, &quot;}&quot;, &quot;^&quot;, &quot;$&quot;, &quot;|&quot;, &quot;\\\\&quot;) # Match literal dot grep(&quot;\\\\.&quot;, c(&quot;file.txt&quot;, &quot;file_txt&quot;)) #&gt; [1] 1 # Match literal bracket grep(&quot;\\\\[&quot;, c(&quot;[test]&quot;, &quot;test&quot;)) #&gt; [1] 1 # Match literal backslash grep(&quot;\\\\\\\\&quot;, c(&quot;C:\\\\path&quot;, &quot;C:/path&quot;)) #&gt; [1] 1 ‚úÖ SOLUTION 2: Use fixed = TRUE for Literals # When you want literal matching, not regex grep(&quot;.&quot;, c(&quot;file.txt&quot;, &quot;file_txt&quot;), fixed = TRUE) #&gt; [1] 1 # Works with all special characters grep(&quot;[abc]&quot;, c(&quot;[abc]&quot;, &quot;abc&quot;), fixed = TRUE) #&gt; [1] 1 # Much simpler for file extensions grep(&quot;.txt&quot;, c(&quot;file.txt&quot;, &quot;file.csv&quot;), fixed = TRUE) #&gt; [1] 1 ‚úÖ SOLUTION 3: Validate Pattern First is_valid_regex &lt;- function(pattern) { tryCatch({ grep(pattern, &quot;test&quot;) TRUE }, error = function(e) { message(&quot;Invalid regex: &quot;, e$message) FALSE }) } # Test is_valid_regex(&quot;[abc&quot;) # FALSE #&gt; Warning in grep(pattern, &quot;test&quot;): TRE pattern compilation error &#39;Missing &#39;]&#39;&#39; #&gt; Invalid regex: invalid regular expression &#39;[abc&#39;, reason &#39;Missing &#39;]&#39;&#39; #&gt; [1] FALSE is_valid_regex(&quot;[abc]&quot;) # TRUE #&gt; [1] TRUE 15.4 Regular Expression Special Characters üí° Key Insight: Regex Special Characters texts &lt;- c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;aXc&quot;, &quot;ac&quot;, &quot;abbc&quot;) # . = any single character grep(&quot;a.c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;a.c&quot; &quot;a*c&quot; &quot;aXc&quot; # * = zero or more of previous grep(&quot;ab*c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;ac&quot; &quot;abbc&quot; # + = one or more of previous grep(&quot;ab+c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abbc&quot; # ? = zero or one of previous grep(&quot;ab?c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;ac&quot; # ^ = start of string grep(&quot;^a&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;a.c&quot; &quot;a*c&quot; &quot;aXc&quot; &quot;ac&quot; &quot;abbc&quot; # $ = end of string grep(&quot;c$&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;a.c&quot; &quot;a*c&quot; &quot;aXc&quot; &quot;ac&quot; &quot;abbc&quot; # [abc] = any of a, b, or c grep(&quot;a[bX]c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;aXc&quot; # [^abc] = anything except a, b, or c grep(&quot;a[^b]c&quot;, texts, value = TRUE) #&gt; [1] &quot;a.c&quot; &quot;a*c&quot; &quot;aXc&quot; # | = or grep(&quot;a|c&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;a.c&quot; &quot;a*c&quot; &quot;aXc&quot; &quot;ac&quot; &quot;abbc&quot; # {n} = exactly n grep(&quot;b{2}&quot;, texts, value = TRUE) #&gt; [1] &quot;abbc&quot; # {n,} = n or more grep(&quot;b{1,}&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abbc&quot; # {n,m} = between n and m grep(&quot;b{1,2}&quot;, texts, value = TRUE) #&gt; [1] &quot;abc&quot; &quot;abbc&quot; To match literal special characters, escape with \\\\: # Match literal dot grep(&quot;\\\\.&quot;, c(&quot;a.b&quot;, &quot;aXb&quot;), value = TRUE) #&gt; [1] &quot;a.b&quot; # Match literal asterisk grep(&quot;\\\\*&quot;, c(&quot;a*b&quot;, &quot;aXb&quot;), value = TRUE) #&gt; [1] &quot;a*b&quot; 15.5 Error #2: Pattern Matches Everything/Nothing ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 15.5.1 The Problem # Want to find files with dots files &lt;- c(&quot;file1.txt&quot;, &quot;file2.csv&quot;, &quot;README&quot;) # But . matches any character! grep(&quot;.&quot;, files) # Matches all 3! #&gt; [1] 1 2 3 # Want to find emails emails &lt;- c(&quot;test@email.com&quot;, &quot;notanemail&quot;, &quot;another@test.org&quot;) # But simple pattern matches too much grep(&quot;@&quot;, emails, value = TRUE) # OK so far... #&gt; [1] &quot;test@email.com&quot; &quot;another@test.org&quot; grep(&quot;.*@.*&quot;, emails, value = TRUE) # Also matches all! #&gt; [1] &quot;test@email.com&quot; &quot;another@test.org&quot; 15.5.2 Common Pattern Mistakes texts &lt;- c(&quot;abc&quot;, &quot;def&quot;, &quot;xyz&quot;) # .* matches everything (zero or more any character) grep(&quot;.*&quot;, texts) # All match! #&gt; [1] 1 2 3 # Wrong escaping grep(&quot;.&quot;, texts) # All match (. is any character) #&gt; [1] 1 2 3 grep(&quot;\\\\.&quot;, texts) # None match (no literal dots) #&gt; integer(0) # Too greedy text &lt;- &quot;value=123&amp;other=456&quot; sub(&quot;=.*&quot;, &quot;&quot;, text) # Removes too much! &quot;value&quot; #&gt; [1] &quot;value&quot; 15.5.3 Solutions ‚úÖ SOLUTION 1: Be Specific files &lt;- c(&quot;file1.txt&quot;, &quot;file2.csv&quot;, &quot;README&quot;) # Match literal dot grep(&quot;\\\\.&quot;, files, value = TRUE) #&gt; [1] &quot;file1.txt&quot; &quot;file2.csv&quot; # Match specific extension grep(&quot;\\\\.txt$&quot;, files, value = TRUE) #&gt; [1] &quot;file1.txt&quot; # Match email pattern emails &lt;- c(&quot;test@email.com&quot;, &quot;notanemail&quot;, &quot;another@test.org&quot;) grep(&quot;[A-Za-z0-9.]+@[A-Za-z0-9.]+\\\\.[A-Za-z]{2,}&quot;, emails, value = TRUE) #&gt; [1] &quot;test@email.com&quot; &quot;another@test.org&quot; ‚úÖ SOLUTION 2: Use Anchors texts &lt;- c(&quot;apple&quot;, &quot;pineapple&quot;, &quot;application&quot;) # Without anchor: matches all grep(&quot;app&quot;, texts, value = TRUE) #&gt; [1] &quot;apple&quot; &quot;pineapple&quot; &quot;application&quot; # With ^: only at start grep(&quot;^app&quot;, texts, value = TRUE) #&gt; [1] &quot;apple&quot; &quot;application&quot; # With $: only at end grep(&quot;app$&quot;, texts, value = TRUE) #&gt; character(0) # Exact match grep(&quot;^apple$&quot;, texts, value = TRUE) #&gt; [1] &quot;apple&quot; ‚úÖ SOLUTION 3: Use Non-greedy Matching text &lt;- &quot;value=123&amp;other=456&quot; # Greedy: takes everything sub(&quot;=.*&amp;&quot;, &quot;=X&amp;&quot;, text) # &quot;value=X&amp;other=456&quot; #&gt; [1] &quot;value=X&amp;other=456&quot; # Non-greedy (in Perl regex): *? or +? sub(&quot;=.*?&amp;&quot;, &quot;=X&amp;&quot;, text, perl = TRUE) # &quot;value=X&amp;other=456&quot; #&gt; [1] &quot;value=X&amp;other=456&quot; # Alternative: use negated character class sub(&quot;=[^&amp;]*&amp;&quot;, &quot;=X&amp;&quot;, text) # &quot;value=X&amp;other=456&quot; #&gt; [1] &quot;value=X&amp;other=456&quot; 15.6 stringr: Modern String Operations üéØ Best Practice: Use stringr library(stringr) texts &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;apricot&quot;) # Detect pattern (like grepl) str_detect(texts, &quot;ap&quot;) #&gt; [1] TRUE FALSE TRUE # Which match (like grep) str_which(texts, &quot;ap&quot;) #&gt; [1] 1 3 # Extract matches str_subset(texts, &quot;ap&quot;) #&gt; [1] &quot;apple&quot; &quot;apricot&quot; # Count matches str_count(texts, &quot;a&quot;) #&gt; [1] 1 3 1 # Extract pattern str_extract(texts, &quot;ap&quot;) #&gt; [1] &quot;ap&quot; NA &quot;ap&quot; str_extract_all(texts, &quot;a&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;a&quot; # Replace str_replace(texts, &quot;a&quot;, &quot;X&quot;) # First match #&gt; [1] &quot;Xpple&quot; &quot;bXnana&quot; &quot;Xpricot&quot; str_replace_all(texts, &quot;a&quot;, &quot;X&quot;) # All matches #&gt; [1] &quot;Xpple&quot; &quot;bXnXnX&quot; &quot;Xpricot&quot; # Remove pattern str_remove(texts, &quot;ap&quot;) # First match #&gt; [1] &quot;ple&quot; &quot;banana&quot; &quot;ricot&quot; str_remove_all(texts, &quot;a&quot;) # All matches #&gt; [1] &quot;pple&quot; &quot;bnn&quot; &quot;pricot&quot; # Split str_split(&quot;a-b-c&quot;, &quot;-&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; str_split(&quot;a-b-c&quot;, &quot;-&quot;, simplify = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Better error messages str_detect(texts, &quot;[invalid&quot;) # Clearer error #&gt; Error in stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)): Missing closing bracket on a bracket expression. (U_REGEX_MISSING_CLOSE_BRACKET, context=`[invalid`) 15.7 Common Regex Patterns üéØ Best Practice: Useful Patterns library(stringr) # Digits texts &lt;- c(&quot;abc123&quot;, &quot;def456&quot;, &quot;xyz&quot;) str_extract_all(texts, &quot;\\\\d+&quot;) # One or more digits #&gt; [[1]] #&gt; [1] &quot;123&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;456&quot; #&gt; #&gt; [[3]] #&gt; character(0) # Non-digits str_extract_all(texts, &quot;\\\\D+&quot;) # One or more non-digits #&gt; [[1]] #&gt; [1] &quot;abc&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;def&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;xyz&quot; # Word characters (letters, digits, underscore) str_extract_all(&quot;hello_world123&quot;, &quot;\\\\w+&quot;) #&gt; [[1]] #&gt; [1] &quot;hello_world123&quot; # Whitespace str_detect(&quot;hello world&quot;, &quot;\\\\s&quot;) #&gt; [1] TRUE # Email (simple) email_pattern &lt;- &quot;[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}&quot; str_detect(&quot;test@email.com&quot;, email_pattern) #&gt; [1] TRUE # Phone (US) phone_pattern &lt;- &quot;\\\\d{3}-\\\\d{3}-\\\\d{4}&quot; str_detect(&quot;123-456-7890&quot;, phone_pattern) #&gt; [1] TRUE # URL (simple) url_pattern &lt;- &quot;https?://[A-Za-z0-9.-]+&quot; str_extract(&quot;Visit http://example.com&quot;, url_pattern) #&gt; [1] &quot;http://example.com&quot; # Extract numbers text &lt;- &quot;Price: $19.99&quot; str_extract(text, &quot;\\\\d+\\\\.?\\\\d*&quot;) #&gt; [1] &quot;19.99&quot; # Extract words text &lt;- &quot;hello world, how are you?&quot; str_extract_all(text, &quot;\\\\w+&quot;) #&gt; [[1]] #&gt; [1] &quot;hello&quot; &quot;world&quot; &quot;how&quot; &quot;are&quot; &quot;you&quot; 15.8 Replacement Operations üí° Key Insight: Replacement Strategies library(stringr) texts &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;apricot&quot;) # Simple replacement str_replace(texts, &quot;a&quot;, &quot;X&quot;) # First &#39;a&#39; #&gt; [1] &quot;Xpple&quot; &quot;bXnana&quot; &quot;Xpricot&quot; str_replace_all(texts, &quot;a&quot;, &quot;X&quot;) # All &#39;a&#39;s #&gt; [1] &quot;Xpple&quot; &quot;bXnXnX&quot; &quot;Xpricot&quot; # Using captured groups str_replace(&quot;John Smith&quot;, &quot;(\\\\w+) (\\\\w+)&quot;, &quot;\\\\2, \\\\1&quot;) #&gt; [1] &quot;Smith, John&quot; # Multiple replacements text &lt;- &quot;I have 3 cats and 2 dogs&quot; str_replace_all(text, c(&quot;cats&quot; = &quot;birds&quot;, &quot;dogs&quot; = &quot;fish&quot;)) #&gt; [1] &quot;I have 3 birds and 2 fish&quot; # Conditional replacement str_replace_all(&quot;hello&quot;, &quot;l+&quot;, &quot;L&quot;) # Multiple l&#39;s to one L #&gt; [1] &quot;heLo&quot; # Remove pattern str_remove(&quot;Price: $19.99&quot;, &quot;\\\\$&quot;) #&gt; [1] &quot;Price: 19.99&quot; str_remove_all(&quot;a-b-c-d&quot;, &quot;-&quot;) #&gt; [1] &quot;abcd&quot; # Case-insensitive str_replace(&quot;Hello&quot;, regex(&quot;hello&quot;, ignore_case = TRUE), &quot;Hi&quot;) #&gt; [1] &quot;Hi&quot; 15.9 Splitting Strings ‚ö†Ô∏è Common Pitfall: strsplit() Returns List text &lt;- &quot;a,b,c&quot; # Returns a LIST result &lt;- strsplit(text, &quot;,&quot;) class(result) # &quot;list&quot; #&gt; [1] &quot;list&quot; result # List of 1 element #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # To get vector, extract first element result[[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # With multiple strings texts &lt;- c(&quot;a,b,c&quot;, &quot;d,e,f&quot;) result &lt;- strsplit(texts, &quot;,&quot;) result # List of 2 elements #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;d&quot; &quot;e&quot; &quot;f&quot; # To get all values as vector unlist(result) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; # stringr alternative (also returns list) str_split(text, &quot;,&quot;) #&gt; [[1]] #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # But can simplify str_split(text, &quot;,&quot;, simplify = TRUE) # Matrix #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; # Or use specific extraction str_split_fixed(text, &quot;,&quot;, n = 3) # Fixed number of pieces #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; 15.10 Error #3: 'replacement' is not a character vector ‚≠ê BEGINNER üî¢ TYPE 15.10.1 The Error texts &lt;- c(&quot;price: 10&quot;, &quot;price: 20&quot;) sub(&quot;price: &quot;, 100, texts) #&gt; [1] &quot;10010&quot; &quot;10020&quot; üî¥ ERROR Error in sub(&quot;price: &quot;, 100, texts) : invalid &#39;replacement&#39; argument 15.10.2 What It Means The replacement value must be a character string, not numeric. 15.10.3 Solutions ‚úÖ SOLUTION: Convert Replacement to Character texts &lt;- c(&quot;price: 10&quot;, &quot;price: 20&quot;) # Convert to character sub(&quot;price: &quot;, as.character(100), texts) #&gt; [1] &quot;10010&quot; &quot;10020&quot; # Or use paste sub(&quot;price: &quot;, paste0(&quot;$&quot;, 100), texts) #&gt; [1] &quot;$10010&quot; &quot;$10020&quot; # With stringr (auto-converts) library(stringr) str_replace(texts, &quot;price: &quot;, 100) # Auto-converts #&gt; Error in `str_replace()`: #&gt; ! `replacement` must be a character vector, not the number 100. 15.11 Case-Insensitive Matching üéØ Best Practice: Ignore Case texts &lt;- c(&quot;Apple&quot;, &quot;banana&quot;, &quot;CHERRY&quot;) # Base R: use ignore.case grep(&quot;apple&quot;, texts, ignore.case = TRUE, value = TRUE) #&gt; [1] &quot;Apple&quot; # Or convert to same case first grep(&quot;apple&quot;, tolower(texts), value = TRUE) #&gt; [1] &quot;apple&quot; # stringr: use regex() with ignore_case library(stringr) str_subset(texts, regex(&quot;apple&quot;, ignore_case = TRUE)) #&gt; [1] &quot;Apple&quot; # In replacement str_replace(texts, regex(&quot;apple&quot;, ignore_case = TRUE), &quot;Orange&quot;) #&gt; [1] &quot;Orange&quot; &quot;banana&quot; &quot;CHERRY&quot; 15.12 Unicode and Locales ‚ö†Ô∏è Platform Issue: Locale-Dependent Matching # Character classes depend on locale texts &lt;- c(&quot;caf√©&quot;, &quot;na√Øve&quot;, &quot;r√©sum√©&quot;) # May behave differently on different systems grep(&quot;[[:alpha:]]+&quot;, texts, value = TRUE) #&gt; [1] &quot;caf√©&quot; &quot;na√Øve&quot; &quot;r√©sum√©&quot; # Safer: specify UTF-8 Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;en_US.UTF-8&quot;) #&gt; [1] &quot;en_US.UTF-8&quot; # Or use Unicode escapes grep(&quot;caf\\\\u00e9&quot;, texts, value = TRUE) #&gt; character(0) # stringr handles Unicode better library(stringr) str_detect(texts, &quot;√©&quot;) # More consistent across platforms #&gt; [1] TRUE FALSE TRUE 15.13 Extracting Patterns üéØ Best Practice: Pattern Extraction library(stringr) # Extract all numbers text &lt;- &quot;I have 3 cats, 2 dogs, and 15 fish&quot; str_extract_all(text, &quot;\\\\d+&quot;) #&gt; [[1]] #&gt; [1] &quot;3&quot; &quot;2&quot; &quot;15&quot; # Extract email addresses text &lt;- &quot;Contact: john@example.com or jane@test.org&quot; str_extract_all(text, &quot;[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}&quot;) #&gt; [[1]] #&gt; [1] &quot;john@example.com&quot; &quot;jane@test.org&quot; # Extract with groups text &lt;- &quot;John Smith, Age: 30&quot; str_match(text, &quot;(\\\\w+) (\\\\w+), Age: (\\\\d+)&quot;) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] &quot;John Smith, Age: 30&quot; &quot;John&quot; &quot;Smith&quot; &quot;30&quot; # Named groups (requires stringr) str_match(text, &quot;(?&lt;first&gt;\\\\w+) (?&lt;last&gt;\\\\w+), Age: (?&lt;age&gt;\\\\d+)&quot;) #&gt; first last age #&gt; [1,] &quot;John Smith, Age: 30&quot; &quot;John&quot; &quot;Smith&quot; &quot;30&quot; # Extract between delimiters text &lt;- &quot;The value is [123] and the code is [ABC]&quot; str_extract_all(text, &quot;\\\\[([^\\\\]]+)\\\\]&quot;) #&gt; [[1]] #&gt; [1] &quot;[123]&quot; &quot;[ABC]&quot; str_match_all(text, &quot;\\\\[([^\\\\]]+)\\\\]&quot;) #&gt; [[1]] #&gt; [,1] [,2] #&gt; [1,] &quot;[123]&quot; &quot;123&quot; #&gt; [2,] &quot;[ABC]&quot; &quot;ABC&quot; 15.14 Debugging Regex üéØ Best Practice: Test and Debug Patterns # Test patterns incrementally text &lt;- &quot;test@email.com&quot; # Build up pattern piece by piece str_detect(text, &quot;\\\\w+&quot;) # Any word chars #&gt; [1] TRUE str_detect(text, &quot;\\\\w+@&quot;) # Word chars + @ #&gt; [1] TRUE str_detect(text, &quot;\\\\w+@\\\\w+&quot;) # Add domain start #&gt; [1] TRUE str_detect(text, &quot;\\\\w+@\\\\w+\\\\.&quot;) # Add dot #&gt; [1] TRUE str_detect(text, &quot;\\\\w+@\\\\w+\\\\.\\\\w+&quot;) # Add extension #&gt; [1] TRUE # Use str_view() to visualize (if available) # str_view(text, &quot;\\\\w+@\\\\w+\\\\.\\\\w+&quot;) # Test on multiple examples test_cases &lt;- c( &quot;valid@email.com&quot;, &quot;invalid&quot;, &quot;no@domain&quot;, &quot;missing.at.sign.com&quot; ) pattern &lt;- &quot;\\\\w+@\\\\w+\\\\.\\\\w+&quot; data.frame( text = test_cases, matches = str_detect(test_cases, pattern) ) #&gt; text matches #&gt; 1 valid@email.com TRUE #&gt; 2 invalid FALSE #&gt; 3 no@domain FALSE #&gt; 4 missing.at.sign.com FALSE 15.15 Summary Key Takeaways: Escape special characters - Use \\\\ or fixed = TRUE . matches any character - Use \\\\. for literal dot Use anchors - ^ for start, $ for end stringr is easier - Better errors and consistency Test patterns incrementally - Build complex patterns step by step strsplit() returns list - Extract with [[1]] or use simplify = TRUE Replacement must be character - Convert numbers with as.character() Quick Reference: Error Cause Fix invalid regular expression Syntax error in pattern Check brackets, escape specials Matches everything/nothing Wrong pattern Test incrementally, use anchors replacement not character Numeric replacement as.character() first Different results by platform Locale/encoding Use stringr, specify UTF-8 Essential Patterns: # Special characters . # Any character * # Zero or more + # One or more ? # Zero or one ^ # Start of string $ # End of string | # Or [] # Character class () # Group # Character classes \\\\d # Digit \\\\D # Non-digit \\\\w # Word character \\\\W # Non-word \\\\s # Whitespace \\\\S # Non-whitespace # Quantifiers {n} # Exactly n {n,} # n or more {n,m} # Between n and m grep Family: grep(pattern, x) # Indices grepl(pattern, x) # Logical sub(pattern, repl, x) # Replace first gsub(pattern, repl, x) # Replace all # stringr alternatives (recommended) str_detect(x, pattern) str_which(x, pattern) str_subset(x, pattern) str_replace(x, pattern, replacement) str_replace_all(x, pattern, replacement) str_extract(x, pattern) str_extract_all(x, pattern) Best Practices: # ‚úÖ Good grep(&quot;\\\\.&quot;, files) # Escape special chars str_detect(text, &quot;^pattern$&quot;) # Use anchors str_replace_all(text, &quot;a&quot;, &quot;X&quot;) # Use stringr fixed = TRUE # For literal matching # ‚ùå Avoid grep(&quot;.&quot;, files) # Matches everything grep(unvalidated_pattern, text) # No error checking sub() with unescaped specials # Unexpected matches Platform-dependent locale assumptions # Inconsistent results 15.16 Exercises üìù Exercise 1: Pattern Building Build patterns to match: 1. Valid email addresses 2. Phone numbers (format: XXX-XXX-XXXX) 3. Dates (format: YYYY-MM-DD) 4. URLs starting with http:// or https:// üìù Exercise 2: Text Extraction From: \"Price: $19.99, Quantity: 5 units\" Extract: 1. The price (numeric only) 2. The quantity (number only) 3. Both in a named vector üìù Exercise 3: Safe Pattern Matching Write safe_grep(pattern, x) that: 1. Validates pattern first 2. Provides helpful errors 3. Returns indices with option for values 4. Handles empty inputs üìù Exercise 4: Text Cleaning Write clean_identifiers(x) that: 1. Removes special characters 2. Converts spaces to underscores 3. Converts to lowercase 4. Ensures valid R variable names 15.17 Exercise Answers Click to see answers Exercise 1: library(stringr) # 1. Email pattern email_pattern &lt;- &quot;[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}&quot; test_emails &lt;- c( &quot;valid@email.com&quot;, &quot;also.valid@test.co.uk&quot;, &quot;invalid&quot;, &quot;missing@domain&quot; ) str_subset(test_emails, email_pattern) #&gt; [1] &quot;valid@email.com&quot; &quot;also.valid@test.co.uk&quot; # 2. Phone pattern (XXX-XXX-XXXX) phone_pattern &lt;- &quot;\\\\d{3}-\\\\d{3}-\\\\d{4}&quot; test_phones &lt;- c( &quot;123-456-7890&quot;, &quot;555-1234&quot;, &quot;not a phone&quot;, &quot;123-456-789&quot; ) str_subset(test_phones, phone_pattern) #&gt; [1] &quot;123-456-7890&quot; # 3. Date pattern (YYYY-MM-DD) date_pattern &lt;- &quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot; test_dates &lt;- c( &quot;2024-01-15&quot;, &quot;2024-1-5&quot;, &quot;not a date&quot;, &quot;2024/01/15&quot; ) str_subset(test_dates, date_pattern) #&gt; [1] &quot;2024-01-15&quot; # 4. URL pattern url_pattern &lt;- &quot;https?://[A-Za-z0-9.-]+(/[A-Za-z0-9._~:/?#\\\\[\\\\]@!$&amp;&#39;()*+,;=-]*)?&quot; test_urls &lt;- c( &quot;http://example.com&quot;, &quot;https://test.org/path&quot;, &quot;not a url&quot;, &quot;ftp://wrong.com&quot; ) str_subset(test_urls, url_pattern) #&gt; [1] &quot;http://example.com&quot; &quot;https://test.org/path&quot; Exercise 2: text &lt;- &quot;Price: $19.99, Quantity: 5 units&quot; # 1. Extract price price &lt;- str_extract(text, &quot;\\\\d+\\\\.\\\\d+&quot;) as.numeric(price) #&gt; [1] 19.99 # 2. Extract quantity quantity &lt;- str_extract(text, &quot;Quantity: (\\\\d+)&quot;) quantity &lt;- str_extract(quantity, &quot;\\\\d+&quot;) as.numeric(quantity) #&gt; [1] 5 # 3. Both in named vector extract_both &lt;- function(text) { price &lt;- as.numeric(str_extract(text, &quot;(?&lt;=\\\\$)\\\\d+\\\\.\\\\d+&quot;)) quantity &lt;- as.numeric(str_extract(text, &quot;(?&lt;=Quantity: )\\\\d+&quot;)) c(price = price, quantity = quantity) } extract_both(text) #&gt; price quantity #&gt; 19.99 5.00 # Alternative: using str_match with groups pattern &lt;- &quot;Price: \\\\$(\\\\d+\\\\.\\\\d+), Quantity: (\\\\d+)&quot; matches &lt;- str_match(text, pattern) c( price = as.numeric(matches[, 2]), quantity = as.numeric(matches[, 3]) ) #&gt; price quantity #&gt; 19.99 5.00 Exercise 3: safe_grep &lt;- function(pattern, x, value = FALSE, ignore.case = FALSE) { # Validate inputs if (length(x) == 0) { message(&quot;Input vector is empty&quot;) return(if (value) character(0) else integer(0)) } if (!is.character(x)) { message(&quot;Converting input to character&quot;) x &lt;- as.character(x) } # Validate pattern pattern_valid &lt;- tryCatch({ grep(pattern, &quot;test&quot;) TRUE }, error = function(e) { FALSE }) if (!pattern_valid) { stop(&quot;Invalid regular expression pattern: &#39;&quot;, pattern, &quot;&#39;\\n&quot;, &quot;Check for:\\n&quot;, &quot; - Unmatched brackets: [ ] ( )\\n&quot;, &quot; - Invalid escapes\\n&quot;, &quot; - Unescaped special characters: . * + ? ^ $&quot;) } # Perform grep result &lt;- grep(pattern, x, value = value, ignore.case = ignore.case) # Report n_matches &lt;- if (value) length(result) else length(result) message(&quot;Found &quot;, n_matches, &quot; match(es) out of &quot;, length(x), &quot; elements&quot;) return(result) } # Test safe_grep(&quot;ap&quot;, c(&quot;apple&quot;, &quot;banana&quot;, &quot;apricot&quot;)) #&gt; Found 2 match(es) out of 3 elements #&gt; [1] 1 3 safe_grep(&quot;ap&quot;, c(&quot;apple&quot;, &quot;banana&quot;, &quot;apricot&quot;), value = TRUE) #&gt; Found 2 match(es) out of 3 elements #&gt; [1] &quot;apple&quot; &quot;apricot&quot; safe_grep(&quot;[invalid&quot;, c(&quot;test&quot;)) # Clear error #&gt; Warning in grep(pattern, &quot;test&quot;): TRE pattern compilation error &#39;Missing &#39;]&#39;&#39; #&gt; Error in safe_grep(&quot;[invalid&quot;, c(&quot;test&quot;)): Invalid regular expression pattern: &#39;[invalid&#39; #&gt; Check for: #&gt; - Unmatched brackets: [ ] ( ) #&gt; - Invalid escapes #&gt; - Unescaped special characters: . * + ? ^ $ Exercise 4: clean_identifiers &lt;- function(x) { library(stringr) # Convert to character if needed if (!is.character(x)) { x &lt;- as.character(x) } # Remove leading/trailing whitespace x &lt;- str_trim(x) # Convert to lowercase x &lt;- str_to_lower(x) # Replace spaces with underscores x &lt;- str_replace_all(x, &quot;\\\\s+&quot;, &quot;_&quot;) # Remove non-alphanumeric except underscore x &lt;- str_replace_all(x, &quot;[^a-z0-9_]&quot;, &quot;&quot;) # Ensure doesn&#39;t start with number x &lt;- str_replace(x, &quot;^(\\\\d)&quot;, &quot;x\\\\1&quot;) # Ensure not empty x[x == &quot;&quot;] &lt;- &quot;var&quot; # Ensure unique x &lt;- make.names(x, unique = TRUE) return(x) } # Test messy &lt;- c(&quot;My Variable!&quot;, &quot;123 Start&quot;, &quot;test@#$&quot;, &quot; spaces &quot;, &quot;&quot;) clean_identifiers(messy) #&gt; [1] &quot;my_variable&quot; &quot;x123_start&quot; &quot;test&quot; &quot;spaces&quot; &quot;var&quot; "],["part-vii-functions-programming.html", "Part VII: Functions &amp; Programming", " Part VII: Functions &amp; Programming "],["function-creation.html", "Chapter 16 Function Creation &amp; Errors 16.1 Introduction 16.2 Function Basics 16.3 Error #1: could not find function 16.4 Error #2: argument \"x\" is missing, with no default 16.5 Error #3: unused argument 16.6 Return Values 16.7 Error #4: object of type 'closure' is not subsettable 16.8 Function Arguments: ‚Ä¶ (Dots) 16.9 Argument Matching 16.10 Common Function Patterns 16.11 Documentation 16.12 Summary 16.13 Exercises 16.14 Exercise Answers", " Chapter 16 Function Creation &amp; Errors What You‚Äôll Learn: Creating functions in R Function arguments and defaults Return values Common function creation errors Function documentation Key Errors Covered: 18+ function errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 16.1 Introduction Functions are fundamental to R programming, but creating them has pitfalls: # Try to create a function my_function &lt;- function(x) { result &lt;- x * 2 # Forget to return! } my_function(5) # Returns NULL! Let‚Äôs master function creation to avoid these issues. 16.2 Function Basics üí° Key Insight: Functions Are Objects # Functions are first-class objects my_func &lt;- function(x) { x * 2 } # It&#39;s an object class(my_func) #&gt; [1] &quot;function&quot; typeof(my_func) #&gt; [1] &quot;closure&quot; # Can be passed around apply_func &lt;- function(f, value) { f(value) } apply_func(my_func, 5) #&gt; [1] 10 # Can be stored in lists func_list &lt;- list( double = function(x) x * 2, triple = function(x) x * 3 ) func_list$double(5) #&gt; [1] 10 # Can be returned from functions make_multiplier &lt;- function(n) { function(x) x * n } times_4 &lt;- make_multiplier(4) times_4(5) #&gt; [1] 20 Key points: - Functions are objects like any other - Can be assigned to variables - Can be passed as arguments - Can be returned from functions - Can be anonymous (unnamed) 16.3 Error #1: could not find function ‚≠ê BEGINNER üîç SCOPE 16.3.1 The Error # Typo in function name maen(c(1, 2, 3)) #&gt; Error in maen(c(1, 2, 3)): could not find function &quot;maen&quot; üî¥ ERROR Error in maen(c(1, 2, 3)) : could not find function &quot;maen&quot; 16.3.2 What It Means R can‚Äôt find a function with that name in the current environment or loaded packages. 16.3.3 Common Causes 16.3.3.1 Cause 1: Typo # Spelling mistakes summry(mtcars) #&gt; Error in summry(mtcars): could not find function &quot;summry&quot; lenght(1:10) #&gt; Error in lenght(1:10): could not find function &quot;lenght&quot; subsett(mtcars, mpg &gt; 20) #&gt; Error in subsett(mtcars, mpg &gt; 20): could not find function &quot;subsett&quot; 16.3.3.2 Cause 2: Package Not Loaded # Function from package not loaded ggplot(mtcars, aes(x = mpg, y = hp)) # ggplot2 not loaded #&gt; Error in ggplot(mtcars, aes(x = mpg, y = hp)): could not find function &quot;ggplot&quot; 16.3.3.3 Cause 3: Function Not Created Yet # Calling before definition result &lt;- calculate_total(10, 20) #&gt; Error in calculate_total(10, 20): could not find function &quot;calculate_total&quot; calculate_total &lt;- function(a, b) { a + b } 16.3.3.4 Cause 4: Wrong Scope # Function created in different environment { local_func &lt;- function(x) x * 2 } local_func(5) # No longer accessible #&gt; [1] 10 16.3.4 Solutions ‚úÖ SOLUTION 1: Check Spelling # Use tab completion in RStudio # Type first few letters and press Tab # Check available functions apropos(&quot;mean&quot;) # Find functions with &quot;mean&quot; in name #&gt; [1] &quot;.colMeans&quot; &quot;.rowMeans&quot; &quot;colMeans&quot; &quot;cummean&quot; #&gt; [5] &quot;group_means&quot; &quot;kmeans&quot; &quot;mean&quot; &quot;mean_val&quot; #&gt; [9] &quot;mean.Date&quot; &quot;mean.default&quot; &quot;mean.difftime&quot; &quot;mean.POSIXct&quot; #&gt; [13] &quot;mean.POSIXlt&quot; &quot;robust_mean&quot; &quot;rowMeans&quot; &quot;weighted.mean&quot; # Search help ??mean ‚úÖ SOLUTION 2: Load Required Package # Check if function is in a package help.search(&quot;ggplot&quot;) # Load package library(ggplot2) #&gt; Warning: package &#39;ggplot2&#39; was built under R version 4.5.1 # Or use package::function syntax ggplot2::ggplot(mtcars, aes(x = mpg, y = hp)) ‚úÖ SOLUTION 3: Check Function Exists safe_call &lt;- function(func_name, ...) { if (!exists(func_name, mode = &quot;function&quot;)) { stop(&quot;Function &#39;&quot;, func_name, &quot;&#39; not found. &quot;, &quot;Did you mean: &quot;, paste(apropos(func_name), collapse = &quot;, &quot;)) } do.call(func_name, list(...)) } # Test safe_call(&quot;mean&quot;, c(1, 2, 3)) #&gt; [1] 2 safe_call(&quot;maen&quot;, c(1, 2, 3)) # Helpful error #&gt; Error in safe_call(&quot;maen&quot;, c(1, 2, 3)): Function &#39;maen&#39; not found. Did you mean: 16.4 Error #2: argument \"x\" is missing, with no default ‚≠ê BEGINNER üìã ARGS 16.4.1 The Error my_func &lt;- function(x, y) { x + y } my_func(5) # Missing y! #&gt; Error in my_func(5): argument &quot;y&quot; is missing, with no default üî¥ ERROR Error in my_func(5) : argument &quot;y&quot; is missing, with no default 16.4.2 What It Means You‚Äôre calling a function without providing all required arguments. 16.4.3 Understanding Arguments # Required arguments (no default) func1 &lt;- function(x, y) { x + y } func1(5, 10) # Must provide both #&gt; [1] 15 func1(5) # Error! #&gt; Error in func1(5): argument &quot;y&quot; is missing, with no default # Optional arguments (with default) func2 &lt;- function(x, y = 10) { x + y } func2(5, 20) # Can override default #&gt; [1] 25 func2(5) # Uses default y = 10 #&gt; [1] 15 # All optional func3 &lt;- function(x = 5, y = 10) { x + y } func3() # Uses all defaults #&gt; [1] 15 func3(8) # Override x, use default y #&gt; [1] 18 func3(8, 12) # Override both #&gt; [1] 20 16.4.4 Solutions ‚úÖ SOLUTION 1: Provide All Required Arguments my_func &lt;- function(x, y) { x + y } # Call with all arguments my_func(5, 10) #&gt; [1] 15 # Named arguments (order doesn&#39;t matter) my_func(y = 10, x = 5) #&gt; [1] 15 ‚úÖ SOLUTION 2: Add Default Values # Make some/all arguments optional my_func &lt;- function(x, y = 0) { x + y } my_func(5) # Works, y defaults to 0 #&gt; [1] 5 my_func(5, 10) # Can still override #&gt; [1] 15 # Can use NULL as default my_func2 &lt;- function(x, y = NULL) { if (is.null(y)) { y &lt;- x # Default to same as x } x + y } my_func2(5) #&gt; [1] 10 my_func2(5, 3) #&gt; [1] 8 ‚úÖ SOLUTION 3: Check Arguments my_func &lt;- function(x, y) { # Check if arguments provided if (missing(x)) { stop(&quot;Argument &#39;x&#39; is required&quot;) } if (missing(y)) { message(&quot;Argument &#39;y&#39; not provided, using default of 0&quot;) y &lt;- 0 } x + y } my_func(5) # Warning but works #&gt; Argument &#39;y&#39; not provided, using default of 0 #&gt; [1] 5 my_func(5, 3) #&gt; [1] 8 my_func() # Clear error about x #&gt; Error in my_func(): Argument &#39;x&#39; is required 16.5 Error #3: unused argument ‚≠ê BEGINNER üìã ARGS 16.5.1 The Error my_func &lt;- function(x, y) { x + y } my_func(5, 10, 15) # Too many arguments! #&gt; Error in my_func(5, 10, 15): unused argument (15) üî¥ ERROR Error in my_func(5, 10, 15) : unused argument (15) 16.5.2 What It Means You‚Äôre passing more arguments than the function accepts. 16.5.3 Common Causes 16.5.3.1 Cause 1: Extra Arguments mean(c(1, 2, NA), na.rm = TRUE, extra = &quot;oops&quot;) #&gt; [1] 1.5 16.5.3.2 Cause 2: Wrong Argument Name mean(c(1, 2, NA), remove_na = TRUE) # It&#39;s na.rm not remove_na #&gt; [1] NA 16.5.3.3 Cause 3: Positional Confusion # substr expects (x, start, stop) substr(&quot;hello&quot;, 1, 3, &quot;extra&quot;) #&gt; Error in substr(&quot;hello&quot;, 1, 3, &quot;extra&quot;): unused argument (&quot;extra&quot;) 16.5.4 Solutions ‚úÖ SOLUTION 1: Remove Extra Arguments # Check function signature args(mean) #&gt; function (x, ...) #&gt; NULL # Provide correct arguments only mean(c(1, 2, NA), na.rm = TRUE) #&gt; [1] 1.5 ‚úÖ SOLUTION 2: Use ‚Ä¶ to Accept Extra Arguments # Allow any number of additional arguments my_func &lt;- function(x, y, ...) { result &lt;- x + y # Can pass ... to other functions extra_args &lt;- list(...) if (length(extra_args) &gt; 0) { message(&quot;Ignoring extra arguments: &quot;, paste(names(extra_args), collapse = &quot;, &quot;)) } result } my_func(5, 10) # Works #&gt; [1] 15 my_func(5, 10, z = 15) # Works, ignores z #&gt; Ignoring extra arguments: z #&gt; [1] 15 my_func(5, 10, 15, 20) # Works, ignores unnamed extras #&gt; Ignoring extra arguments: #&gt; [1] 15 ‚úÖ SOLUTION 3: Validate Arguments my_func &lt;- function(x, y) { # Capture call call &lt;- match.call() # Check for unexpected arguments valid_args &lt;- c(&quot;x&quot;, &quot;y&quot;) provided_args &lt;- names(call)[-1] # Remove function name invalid &lt;- setdiff(provided_args, valid_args) if (length(invalid) &gt; 0) { stop(&quot;Unexpected arguments: &quot;, paste(invalid, collapse = &quot;, &quot;), &quot;\\nValid arguments are: &quot;, paste(valid_args, collapse = &quot;, &quot;)) } x + y } my_func(5, 10) #&gt; [1] 15 my_func(5, 10, z = 15) # Helpful error #&gt; Error in my_func(5, 10, z = 15): unused argument (z = 15) 16.6 Return Values üí° Key Insight: Return Values # Implicit return (last expression) func1 &lt;- function(x) { x * 2 } func1(5) # Returns 10 #&gt; [1] 10 # Explicit return func2 &lt;- function(x) { return(x * 2) } func2(5) # Returns 10 #&gt; [1] 10 # Early return func3 &lt;- function(x) { if (x &lt; 0) { return(0) # Exit early } x * 2 } func3(-5) # Returns 0 #&gt; [1] 0 func3(5) # Returns 10 #&gt; [1] 10 # No return (returns NULL) func4 &lt;- function(x) { result &lt;- x * 2 # Forgot to return or print result } func4(5) # Returns NULL invisibly # Multiple values (use list) func5 &lt;- function(x) { list( original = x, doubled = x * 2, squared = x^2 ) } func5(5) #&gt; $original #&gt; [1] 5 #&gt; #&gt; $doubled #&gt; [1] 10 #&gt; #&gt; $squared #&gt; [1] 25 # Return NULL explicitly func6 &lt;- function(x) { if (x &lt; 0) { return(NULL) } x * 2 } func6(-5) # NULL #&gt; NULL func6(5) # 10 #&gt; [1] 10 Best practices: - Last expression is returned automatically - Use return() for early exits - Use invisible() for functions with side effects - Return lists for multiple values 16.7 Error #4: object of type 'closure' is not subsettable ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 16.7.1 The Error my_func &lt;- function(x) x * 2 # Try to subset a function my_func[1] #&gt; Error in my_func[1]: object of type &#39;closure&#39; is not subsettable üî¥ ERROR Error in my_func[1] : object of type &#39;closure&#39; is not subsettable 16.7.2 What It Means You‚Äôre trying to subset a function as if it were a vector or list. ‚ÄúClosure‚Äù is R‚Äôs internal name for functions. 16.7.3 Common Causes 16.7.3.1 Cause 1: Name Collision # Accidentally named data same as function mean &lt;- function(x) sum(x) / length(x) # Later, try to use mean as data mean[1] # Error! mean is now a function #&gt; Error in mean[1]: object of type &#39;closure&#39; is not subsettable 16.7.3.2 Cause 2: Forgot to Call Function data &lt;- c(1, 2, 3, 4, 5) # Forgot parentheses result &lt;- mean # Assigns the function, not result result[1] # Error! #&gt; Error in result[1]: object of type &#39;closure&#39; is not subsettable 16.7.3.3 Cause 3: Wrong Object my_list &lt;- list(a = 1, b = 2) my_func &lt;- function(x) x * 2 # Accidentally use function instead of list my_func$a #&gt; Error in my_func$a: object of type &#39;closure&#39; is not subsettable 16.7.4 Solutions ‚úÖ SOLUTION 1: Check Object Type my_func &lt;- function(x) x * 2 # Check what it is is.function(my_func) #&gt; [1] TRUE class(my_func) #&gt; [1] &quot;function&quot; # If you need to subset, make sure you&#39;re using the right object ‚úÖ SOLUTION 2: Call Function Properly # Call the function result &lt;- mean(c(1, 2, 3, 4, 5)) result #&gt; [1] 3 # Now can use result result #&gt; [1] 3 ‚úÖ SOLUTION 3: Avoid Name Collisions # Don&#39;t overwrite common function names # Bad # mean &lt;- my_data # Good my_mean_value &lt;- mean(my_data) #&gt; Error: object &#39;my_data&#39; not found # If you accidentally overwrote mean &lt;- function(x) sum(x) / length(x) # Restore rm(mean) # Remove your version mean(c(1, 2, 3)) # Uses base::mean again #&gt; [1] 2 16.8 Function Arguments: ‚Ä¶ (Dots) üí° Key Insight: The ‚Ä¶ Argument # ... captures any additional arguments my_plot &lt;- function(x, y, ...) { plot(x, y, ...) # Pass ... to another function } # Can pass any plot arguments my_plot(1:10, 1:10, col = &quot;red&quot;, pch = 16, main = &quot;Test&quot;) # Access ... contents my_func &lt;- function(...) { args &lt;- list(...) cat(&quot;Received&quot;, length(args), &quot;arguments\\n&quot;) args } my_func(a = 1, b = 2, c = 3) #&gt; Received 3 arguments #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 2 #&gt; #&gt; $c #&gt; [1] 3 # Extract specific arguments from ... my_func2 &lt;- function(x, ...) { dots &lt;- list(...) # Get specific argument if (&quot;multiplier&quot; %in% names(dots)) { mult &lt;- dots$multiplier } else { mult &lt;- 1 } x * mult } my_func2(5) #&gt; [1] 5 my_func2(5, multiplier = 3) #&gt; [1] 15 # Common use: wrapper functions my_mean &lt;- function(..., na.rm = FALSE) { # Add custom behavior message(&quot;Calculating mean...&quot;) # Pass to base function mean(..., na.rm = na.rm) } my_mean(c(1, 2, NA, 4), na.rm = TRUE) #&gt; Calculating mean... #&gt; [1] 2.333333 When to use ‚Ä¶: - Wrapper functions (pass args to another function) - Flexible functions (accept varying arguments) - Methods (S3/S4 generics often use ‚Ä¶) Caution: - Arguments after ‚Ä¶ must be named explicitly - Easy to make typos that go unnoticed 16.9 Argument Matching üí° Key Insight: How R Matches Arguments my_func &lt;- function(first, second, third) { cat(&quot;first:&quot;, first, &quot;\\n&quot;) cat(&quot;second:&quot;, second, &quot;\\n&quot;) cat(&quot;third:&quot;, third, &quot;\\n&quot;) } # 1. Exact name match my_func(first = 1, second = 2, third = 3) #&gt; first: 1 #&gt; second: 2 #&gt; third: 3 # 2. Partial name match (not recommended!) my_func(f = 1, s = 2, t = 3) #&gt; Warning in my_func(f = 1, s = 2, t = 3): partial argument match of &#39;f&#39; to #&gt; &#39;first&#39; #&gt; Warning in my_func(f = 1, s = 2, t = 3): partial argument match of &#39;s&#39; to #&gt; &#39;second&#39; #&gt; Warning in my_func(f = 1, s = 2, t = 3): partial argument match of &#39;t&#39; to #&gt; &#39;third&#39; #&gt; first: 1 #&gt; second: 2 #&gt; third: 3 # 3. Positional match my_func(1, 2, 3) #&gt; first: 1 #&gt; second: 2 #&gt; third: 3 # 4. Mixed (named don&#39;t need to be in order) my_func(third = 3, first = 1, second = 2) #&gt; first: 1 #&gt; second: 2 #&gt; third: 3 my_func(1, third = 3, second = 2) #&gt; first: 1 #&gt; second: 2 #&gt; third: 3 # Order of matching: # 1. Exact name matches # 2. Partial name matches # 3. Positional matches Best practices: - Use exact names for clarity - Avoid partial matching (can cause confusion) - Use names for all arguments after the first few - Named arguments can be in any order 16.10 Common Function Patterns üéØ Best Practice: Function Patterns # 1. Validate inputs safe_divide &lt;- function(x, y) { # Check types if (!is.numeric(x) || !is.numeric(y)) { stop(&quot;Both x and y must be numeric&quot;) } # Check values if (any(y == 0)) { stop(&quot;Cannot divide by zero&quot;) } x / y } safe_divide(10, 2) #&gt; [1] 5 safe_divide(10, 0) #&gt; Error in safe_divide(10, 0): Cannot divide by zero # 2. Provide informative messages verbose_mean &lt;- function(x, na.rm = FALSE, verbose = TRUE) { if (verbose) { message(&quot;Calculating mean of &quot;, length(x), &quot; values&quot;) if (na.rm) { message(&quot;Removing NA values&quot;) } } mean(x, na.rm = na.rm) } verbose_mean(c(1, 2, NA, 4), na.rm = TRUE) #&gt; Calculating mean of 4 values #&gt; Removing NA values #&gt; [1] 2.333333 # 3. Handle edge cases robust_max &lt;- function(x) { if (length(x) == 0) { return(NULL) } if (all(is.na(x))) { return(NA) } max(x, na.rm = TRUE) } robust_max(numeric(0)) #&gt; NULL robust_max(c(NA, NA)) #&gt; [1] NA robust_max(c(1, 2, NA, 3)) #&gt; [1] 3 # 4. Return useful objects detailed_summary &lt;- function(x) { result &lt;- list( mean = mean(x, na.rm = TRUE), median = median(x, na.rm = TRUE), sd = sd(x, na.rm = TRUE), n = length(x), n_missing = sum(is.na(x)) ) class(result) &lt;- &quot;detailed_summary&quot; result } summary_obj &lt;- detailed_summary(c(1, 2, NA, 4, 5)) summary_obj #&gt; $mean #&gt; [1] 3 #&gt; #&gt; $median #&gt; [1] 3 #&gt; #&gt; $sd #&gt; [1] 1.825742 #&gt; #&gt; $n #&gt; [1] 5 #&gt; #&gt; $n_missing #&gt; [1] 1 #&gt; #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;detailed_summary&quot; # 5. Use ... appropriately flexible_plot &lt;- function(x, y, type = &quot;p&quot;, ...) { # Set defaults defaults &lt;- list( pch = 16, col = &quot;blue&quot; ) # Override with ... args &lt;- modifyList(defaults, list(...)) # Call plot do.call(plot, c(list(x = x, y = y, type = type), args)) } flexible_plot(1:10, 1:10, col = &quot;red&quot;, main = &quot;Test&quot;) 16.11 Documentation üéØ Best Practice: Document Your Functions #&#39; Calculate the area of a circle #&#39; #&#39; @param radius Numeric. The radius of the circle. #&#39; @param units Character. The units of measurement (default: &quot;cm&quot;). #&#39; @return Numeric. The area of the circle. #&#39; @examples #&#39; circle_area(5) #&#39; circle_area(10, units = &quot;inches&quot;) #&#39; @export circle_area &lt;- function(radius, units = &quot;cm&quot;) { if (!is.numeric(radius) || radius &lt; 0) { stop(&quot;radius must be a non-negative number&quot;) } area &lt;- pi * radius^2 structure( area, units = units, class = c(&quot;circle_area&quot;, &quot;numeric&quot;) ) } # In-function comments calculate_price &lt;- function(base_price, tax_rate = 0.1, discount = 0) { # Validate inputs if (base_price &lt; 0) stop(&quot;base_price cannot be negative&quot;) if (tax_rate &lt; 0 || tax_rate &gt; 1) stop(&quot;tax_rate must be between 0 and 1&quot;) if (discount &lt; 0 || discount &gt; 1) stop(&quot;discount must be between 0 and 1&quot;) # Apply discount discounted_price &lt;- base_price * (1 - discount) # Add tax final_price &lt;- discounted_price * (1 + tax_rate) # Return itemized result list( base_price = base_price, discount = discount, discounted_price = discounted_price, tax = discounted_price * tax_rate, final_price = final_price ) } 16.12 Summary Key Takeaways: Functions are objects - Can be assigned, passed, returned could not find function - Check spelling, loading, scope Provide required arguments - Or add defaults Don‚Äôt pass extra arguments - Unless function uses ‚Ä¶ Last expression is returned - Or use return() explicitly closure not subsettable - You‚Äôre trying to subset a function Use ‚Ä¶ for flexibility - Pass extra args to other functions Validate inputs - Check types and values Quick Reference: Error Cause Fix could not find function Typo, not loaded, not defined Check spelling, load package argument missing Required arg not provided Provide arg or add default unused argument Too many args Remove extra or use ‚Ä¶ closure not subsettable Subsetting a function Call function or use right object Function Creation: # Basic function my_func &lt;- function(x, y) { x + y } # With defaults my_func &lt;- function(x, y = 0) { x + y } # With ... my_func &lt;- function(x, ...) { # Do something other_func(x, ...) } # With validation my_func &lt;- function(x) { if (!is.numeric(x)) stop(&quot;x must be numeric&quot;) x * 2 } # Return values my_func &lt;- function(x) { list(result = x * 2, original = x) } Best Practices: # ‚úÖ Good function(x, y = 0) # Sensible defaults if (!is.numeric(x)) stop() # Validate inputs return(list(a = 1, b = 2)) # Multiple values in list Use descriptive names # clear_cache() not cc() # ‚ùå Avoid function(x) # No defaults when optional No input validation # Causes cryptic errors later mean &lt;- my_data # Overwriting function names function(x, y, z, a, b, c) # Too many arguments 16.13 Exercises üìù Exercise 1: Safe Division Function Write safe_divide(x, y) that: 1. Checks both are numeric 2. Handles division by zero 3. Works with vectors 4. Returns informative errors üìù Exercise 2: Flexible Summary Write my_summary(x, ...) that: 1. Calculates mean, median, sd 2. Accepts ‚Ä¶ for additional stats 3. Handles NA values 4. Returns named list üìù Exercise 3: Argument Validator Write validate_args(func, ...) that: 1. Checks if function exists 2. Validates argument types 3. Checks required args provided 4. Returns TRUE/FALSE with messages üìù Exercise 4: Function Factory Write make_adder(n) that returns a function that adds n to its argument. Example: add_5 &lt;- make_adder(5) add_5(10) # Should return 15 16.14 Exercise Answers Click to see answers Exercise 1: safe_divide &lt;- function(x, y) { # Check types if (!is.numeric(x)) { stop(&quot;x must be numeric, got &quot;, class(x)[1]) } if (!is.numeric(y)) { stop(&quot;y must be numeric, got &quot;, class(y)[1]) } # Check for zero if (any(y == 0)) { warning(&quot;Division by zero detected, returning Inf/-Inf&quot;) # R handles this naturally, but we warn } # Check lengths match or can recycle if (length(x) != length(y) &amp;&amp; length(x) != 1 &amp;&amp; length(y) != 1) { if (max(length(x), length(y)) %% min(length(x), length(y)) != 0) { warning(&quot;Lengths not compatible for recycling: &quot;, length(x), &quot; and &quot;, length(y)) } } result &lt;- x / y result } # Test safe_divide(10, 2) #&gt; [1] 5 safe_divide(c(10, 20, 30), c(2, 4, 5)) #&gt; [1] 5 5 6 safe_divide(10, 0) # Warning #&gt; Warning in safe_divide(10, 0): Division by zero detected, returning Inf/-Inf #&gt; [1] Inf safe_divide(&quot;10&quot;, 2) # Error #&gt; Error in safe_divide(&quot;10&quot;, 2): x must be numeric, got character Exercise 2: my_summary &lt;- function(x, ..., na.rm = TRUE) { # Base statistics result &lt;- list( n = length(x), n_missing = sum(is.na(x)), mean = mean(x, na.rm = na.rm), median = median(x, na.rm = na.rm), sd = sd(x, na.rm = na.rm), min = min(x, na.rm = na.rm), max = max(x, na.rm = na.rm) ) # Additional statistics from ... extra_stats &lt;- list(...) for (stat_name in names(extra_stats)) { stat_func &lt;- extra_stats[[stat_name]] if (is.function(stat_func)) { result[[stat_name]] &lt;- stat_func(x, na.rm = na.rm) } } class(result) &lt;- &quot;my_summary&quot; result } # Print method print.my_summary &lt;- function(x, ...) { cat(&quot;Summary Statistics\\n&quot;) cat(&quot;==================\\n&quot;) for (name in names(x)) { cat(sprintf(&quot;%-12s: %s\\n&quot;, name, format(x[[name]], digits = 3))) } invisible(x) } # Test data &lt;- c(1, 2, NA, 4, 5, 6, 7, 8, 9, 10) my_summary(data) #&gt; Summary Statistics #&gt; ================== #&gt; n : 10 #&gt; n_missing : 1 #&gt; mean : 5.78 #&gt; median : 6 #&gt; sd : 3.07 #&gt; min : 1 #&gt; max : 10 # With extra stats my_summary(data, IQR = IQR, mad = mad) #&gt; Summary Statistics #&gt; ================== #&gt; n : 10 #&gt; n_missing : 1 #&gt; mean : 5.78 #&gt; median : 6 #&gt; sd : 3.07 #&gt; min : 1 #&gt; max : 10 #&gt; IQR : 4 #&gt; mad : 2.97 Exercise 3: validate_args &lt;- function(func_name, ...) { # Check function exists if (!exists(func_name, mode = &quot;function&quot;)) { message(&quot;‚úó Function &#39;&quot;, func_name, &quot;&#39; not found&quot;) return(FALSE) } func &lt;- get(func_name, mode = &quot;function&quot;) func_args &lt;- formals(func) # Get provided arguments provided &lt;- list(...) # Check required arguments (those without defaults) required_args &lt;- names(func_args)[sapply(func_args, function(x) class(x) == &quot;name&quot;)] missing_required &lt;- setdiff(required_args, names(provided)) if (length(missing_required) &gt; 0) { message(&quot;‚úó Missing required arguments: &quot;, paste(missing_required, collapse = &quot;, &quot;)) return(FALSE) } # Check for unexpected arguments if (!&quot;...&quot; %in% names(func_args)) { unexpected &lt;- setdiff(names(provided), names(func_args)) if (length(unexpected) &gt; 0) { message(&quot;‚úó Unexpected arguments: &quot;, paste(unexpected, collapse = &quot;, &quot;)) return(FALSE) } } # Check argument types (basic) for (arg_name in names(provided)) { arg_value &lt;- provided[[arg_name]] # Could add more sophisticated type checking here } message(&quot;‚úì All validations passed for &#39;&quot;, func_name, &quot;&#39;&quot;) return(TRUE) } # Test validate_args(&quot;mean&quot;, x = c(1, 2, 3), na.rm = TRUE) #&gt; ‚úó Missing required arguments: ... #&gt; [1] FALSE validate_args(&quot;mean&quot;, na.rm = TRUE) # Missing x #&gt; ‚úó Missing required arguments: x, ... #&gt; [1] FALSE validate_args(&quot;mean&quot;, x = c(1, 2, 3), invalid = TRUE) # Extra arg #&gt; ‚úó Missing required arguments: ... #&gt; [1] FALSE Exercise 4: make_adder &lt;- function(n) { # Return a function that adds n function(x) { x + n } } # Test add_5 &lt;- make_adder(5) add_5(10) #&gt; [1] 15 add_100 &lt;- make_adder(100) add_100(50) #&gt; [1] 150 # Multiple uses add_5(1:10) #&gt; [1] 6 7 8 9 10 11 12 13 14 15 # Each function retains its own n add_5(5) #&gt; [1] 10 add_100(5) #&gt; [1] 105 # More advanced: with validation make_adder_safe &lt;- function(n) { if (!is.numeric(n) || length(n) != 1) { stop(&quot;n must be a single numeric value&quot;) } function(x) { if (!is.numeric(x)) { stop(&quot;x must be numeric&quot;) } x + n } } add_3 &lt;- make_adder_safe(3) add_3(10) #&gt; [1] 13 "],["scoping-environments.html", "Chapter 17 Scoping &amp; Environments 17.1 Introduction 17.2 Environment Basics 17.3 Error #1: object not found (scoping) 17.4 Lexical Scoping 17.5 Error #2: Unexpected Value from Outer Scope 17.6 Global Assignment: &lt;&lt;- 17.7 Environments in Functions 17.8 Common Scoping Patterns 17.9 Search Path 17.10 Debugging Scope Issues 17.11 Summary 17.12 Exercises 17.13 Exercise Answers", " Chapter 17 Scoping &amp; Environments What You‚Äôll Learn: How R finds objects Lexical scoping rules Environment hierarchy Common scoping errors Global vs local variables Key Errors Covered: 12+ scoping errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 17.1 Introduction Scoping determines how R finds objects, and it‚Äôs often surprising: x &lt;- 10 my_func &lt;- function() { x # Where does this x come from? } my_func() # Returns 10! #&gt; [1] 10 Let‚Äôs understand scoping to avoid confusion. 17.2 Environment Basics üí° Key Insight: Environments Are Like Named Lists # Create an environment my_env &lt;- new.env() # Add objects my_env$x &lt;- 10 my_env$y &lt;- 20 # Access objects my_env$x #&gt; [1] 10 # List contents ls(my_env) #&gt; [1] &quot;x&quot; &quot;y&quot; # Every function has an environment f &lt;- function() { x &lt;- 5 environment() } f_env &lt;- f() ls(f_env) #&gt; [1] &quot;x&quot; # Current environment environment() # Usually global environment #&gt; &lt;environment: R_GlobalEnv&gt; # Parent environment parent.env(my_env) #&gt; &lt;environment: R_GlobalEnv&gt; Key points: - Environments contain named objects - Every function creates a new environment - Environments have parents - R searches up the chain 17.3 Error #1: object not found (scoping) ‚≠ê‚≠ê INTERMEDIATE üîç SCOPE 17.3.1 The Error my_func &lt;- function() { y &lt;- 20 } my_func() y # Where is y? #&gt; [1] &quot;1 items&quot; &quot;2 items&quot; &quot;3 items&quot; üî¥ ERROR Error in eval(expr, envir, enclos) : object &#39;y&#39; not found 17.3.2 What It Means The object was created in a function‚Äôs environment and isn‚Äôt accessible outside. 17.3.3 Understanding Scope # Global scope x &lt;- 10 func1 &lt;- function() { # Function scope y &lt;- 20 # Can see global x cat(&quot;x:&quot;, x, &quot;\\n&quot;) # Can see local y cat(&quot;y:&quot;, y, &quot;\\n&quot;) } func1() #&gt; x: 10 #&gt; y: 20 # x exists globally x #&gt; [1] 10 # y doesn&#39;t (was in function scope) exists(&quot;y&quot;) # FALSE #&gt; [1] TRUE # Example 2: Nested functions outer_func &lt;- function() { z &lt;- 30 inner_func &lt;- function() { # Can see z from parent environment z } inner_func() } outer_func() #&gt; [1] 30 # z doesn&#39;t exist here exists(&quot;z&quot;) # FALSE #&gt; [1] TRUE 17.3.4 Common Causes 17.3.4.1 Cause 1: Expecting Function to Modify Global x &lt;- 10 # This doesn&#39;t modify global x! add_ten &lt;- function() { x &lt;- x + 10 x # Returns 20 } add_ten() # Returns 20 #&gt; [1] 20 x # Still 10! #&gt; [1] 10 17.3.4.2 Cause 2: Variables Only Exist in Loop Scope for (i in 1:5) { temp &lt;- i * 2 } # temp still exists (for loop doesn&#39;t create new scope in R) temp #&gt; [1] 10 # But function scope is different func &lt;- function() { for (i in 1:5) { temp2 &lt;- i * 2 } } func() temp2 # Doesn&#39;t exist #&gt; Error: object &#39;temp2&#39; not found 17.3.5 Solutions ‚úÖ SOLUTION 1: Return Values x &lt;- 10 # Return the new value add_ten &lt;- function(val) { val + 10 } # Assign result x &lt;- add_ten(x) x # Now 20 #&gt; [1] 20 ‚úÖ SOLUTION 2: Use &lt;&lt;- for Global Assignment (Caution!) x &lt;- 10 # Modifies global x add_ten_global &lt;- function() { x &lt;&lt;- x + 10 } add_ten_global() x # Now 20 #&gt; [1] 20 # ‚ö†Ô∏è Use sparingly! Can cause confusion ‚úÖ SOLUTION 3: Pass and Return Explicitly # Best practice: explicit in and out process_data &lt;- function(data, operation) { # Do something result &lt;- data * operation # Return explicitly return(result) } my_data &lt;- 100 my_data &lt;- process_data(my_data, 2) my_data #&gt; [1] 200 17.4 Lexical Scoping üí° Key Insight: Lexical Scoping R uses lexical (static) scoping: where a function was defined matters, not where it‚Äôs called. x &lt;- 10 func1 &lt;- function() { x # Uses x from where function was defined } func2 &lt;- function() { x &lt;- 20 # Different x func1() # What does this return? } func2() # Returns 10 (not 20!) #&gt; [1] 10 # Why? func1 looks for x where it was defined (global env) # Not where it was called (inside func2) # Example 2: Function factories make_multiplier &lt;- function(n) { function(x) { x * n # n from make_multiplier&#39;s environment } } times_3 &lt;- make_multiplier(3) times_5 &lt;- make_multiplier(5) times_3(10) # 30 #&gt; [1] 30 times_5(10) # 50 #&gt; [1] 50 # Each function remembers its own n! Key rule: R looks for variables in: 1. Current environment 2. Parent environment (where function was defined) 3. Parent‚Äôs parent, etc. 4. Eventually global environment 5. Loaded packages 17.5 Error #2: Unexpected Value from Outer Scope ‚≠ê‚≠ê‚≠ê ADVANCED üîç SCOPE 17.5.1 The Problem x &lt;- 999 # Global x calculate &lt;- function(a, b) { # Forgot to define x, uses global! a + b + x } calculate(1, 2) # Returns 1002 (not 3!) #&gt; [1] 1002 17.5.2 What Happened The function used a global variable unintentionally. 17.5.3 Solutions ‚úÖ SOLUTION 1: Explicit Parameters # Make all inputs explicit calculate &lt;- function(a, b, x = 0) { a + b + x } calculate(1, 2) # Uses default x = 0 #&gt; [1] 3 calculate(1, 2, 10) # Uses provided x #&gt; [1] 13 ‚úÖ SOLUTION 2: Check for Undefined Variables # Development tool check_function_variables &lt;- function(func) { # Get function body body_expr &lt;- body(func) # Get all variable names (simplified) all_vars &lt;- all.names(body_expr) # Get formal arguments args &lt;- names(formals(func)) # Find variables not in arguments external &lt;- setdiff(all_vars, c(args, &quot;function&quot;, &quot;{&quot;, &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;)) if (length(external) &gt; 0) { message(&quot;Potentially external variables: &quot;, paste(external, collapse = &quot;, &quot;)) } } x &lt;- 999 calculate &lt;- function(a, b) { a + b + x } check_function_variables(calculate) # Warns about x #&gt; Potentially external variables: x ‚úÖ SOLUTION 3: Use Local Functions # Keep related functions together calculator &lt;- local({ # Private variable default_offset &lt;- 0 # Public functions list( add = function(a, b) a + b + default_offset, set_offset = function(value) default_offset &lt;&lt;- value ) }) calculator$add(5, 10) #&gt; [1] 15 calculator$set_offset(100) calculator$add(5, 10) #&gt; [1] 115 17.6 Global Assignment: &lt;&lt;- ‚ö†Ô∏è Pitfall: Global Assignment counter &lt;- 0 # Bad: modifies global increment_bad &lt;- function() { counter &lt;&lt;- counter + 1 } increment_bad() counter # 1 #&gt; [1] 1 increment_bad() counter # 2 #&gt; [1] 2 # Problem: Hard to track where changes happen # Can cause bugs in large programs # Better: Use closures make_counter &lt;- function() { count &lt;- 0 list( increment = function() { count &lt;&lt;- count + 1 # OK here (modifying enclosing env) count }, get = function() count, reset = function() count &lt;&lt;- 0 ) } counter_obj &lt;- make_counter() counter_obj$increment() #&gt; [1] 1 counter_obj$increment() #&gt; [1] 2 counter_obj$get() #&gt; [1] 2 counter_obj$reset() counter_obj$get() #&gt; [1] 0 When to use &lt;&lt;-: - Inside closures/function factories - For memoization - When you truly need state When NOT to use &lt;&lt;-: - In regular functions (use return values instead) - When you can pass arguments - In package functions (very rarely appropriate) 17.7 Environments in Functions üí° Key Insight: Function Environments # Each function call creates new environment create_accumulator &lt;- function() { sum &lt;- 0 function(x) { sum &lt;&lt;- sum + x sum } } # Create two independent accumulators acc1 &lt;- create_accumulator() acc2 &lt;- create_accumulator() # Each has its own sum! acc1(5) # 5 #&gt; [1] 5 acc1(10) # 15 #&gt; [1] 15 acc2(3) # 3 #&gt; [1] 3 acc2(7) # 10 #&gt; [1] 10 acc1(0) # 15 (independent) #&gt; [1] 15 acc2(0) # 10 (independent) #&gt; [1] 10 # Inspect environments environment(acc1) #&gt; &lt;environment: 0x7fcd8d6c92e0&gt; environment(acc2) #&gt; &lt;environment: 0x7fcd8d662a58&gt; # Different! # Get value from environment get(&quot;sum&quot;, environment(acc1)) #&gt; [1] 15 get(&quot;sum&quot;, environment(acc2)) #&gt; [1] 10 17.8 Common Scoping Patterns üéØ Best Practice: Scoping Patterns # 1. Function factories make_power &lt;- function(n) { function(x) { x ^ n } } square &lt;- make_power(2) cube &lt;- make_power(3) square(5) #&gt; [1] 25 cube(5) #&gt; [1] 125 # 2. Memoization (caching results) fib_memo &lt;- local({ cache &lt;- list() function(n) { if (n &lt;= 1) return(n) # Check cache key &lt;- as.character(n) if (!is.null(cache[[key]])) { return(cache[[key]]) } # Calculate and cache result &lt;- fib_memo(n - 1) + fib_memo(n - 2) cache[[key]] &lt;&lt;- result result } }) system.time(fib_memo(30)) #&gt; user system elapsed #&gt; 0 0 0 system.time(fib_memo(30)) # Much faster (cached) #&gt; user system elapsed #&gt; 0 0 0 # 3. Private variables create_account &lt;- function(initial_balance = 0) { balance &lt;- initial_balance # Private list( deposit = function(amount) { if (amount &lt;= 0) stop(&quot;Amount must be positive&quot;) balance &lt;&lt;- balance + amount invisible(balance) }, withdraw = function(amount) { if (amount &gt; balance) stop(&quot;Insufficient funds&quot;) balance &lt;&lt;- balance - amount invisible(balance) }, get_balance = function() { balance } ) } account &lt;- create_account(100) account$deposit(50) account$withdraw(30) account$get_balance() #&gt; [1] 120 # Can&#39;t access balance directly # account$balance # NULL (not accessible) # 4. Package-like namespacing my_package &lt;- local({ # Private function helper &lt;- function(x) { x * 2 } # Public functions list( public_func1 = function(x) { helper(x) + 1 }, public_func2 = function(x) { helper(x) - 1 } ) }) my_package$public_func1(5) # Works #&gt; [1] 11 # my_package$helper(5) # NULL (private) 17.9 Search Path üí° Key Insight: Search Path # Where R looks for objects search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:ggplot2&quot; &quot;package:glue&quot; #&gt; [4] &quot;package:stringr&quot; &quot;package:forcats&quot; &quot;package:MASS&quot; #&gt; [7] &quot;package:tibble&quot; &quot;package:purrr&quot; &quot;package:dplyr&quot; #&gt; [10] &quot;package:lubridate&quot; &quot;package:readr&quot; &quot;package:tidyr&quot; #&gt; [13] &quot;tools:rstudio&quot; &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [16] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; #&gt; [19] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; # Order matters! # 1. Global environment # 2. Loaded packages (in order) # 3. Base packages # Example: name conflicts library(dplyr) # Both have filter() # Which one gets used? filter # Shows dplyr::filter #&gt; function (.data, ..., .by = NULL, .preserve = FALSE) #&gt; { #&gt; check_by_typo(...) #&gt; by &lt;- enquo(.by) #&gt; if (!quo_is_null(by) &amp;&amp; !is_false(.preserve)) { #&gt; abort(&quot;Can&#39;t supply both `.by` and `.preserve`.&quot;) #&gt; } #&gt; UseMethod(&quot;filter&quot;) #&gt; } #&gt; &lt;bytecode: 0x7fcd8df256c0&gt; #&gt; &lt;environment: namespace:dplyr&gt; # Use package::function to be explicit stats::filter # Base R version #&gt; function (x, filter, method = c(&quot;convolution&quot;, &quot;recursive&quot;), #&gt; sides = 2L, circular = FALSE, init = NULL) #&gt; { #&gt; method &lt;- match.arg(method) #&gt; x &lt;- as.ts(x) #&gt; storage.mode(x) &lt;- &quot;double&quot; #&gt; xtsp &lt;- tsp(x) #&gt; n &lt;- as.integer(NROW(x)) #&gt; if (is.na(n)) #&gt; stop(gettextf(&quot;invalid value of %s&quot;, &quot;NROW(x)&quot;), domain = NA) #&gt; nser &lt;- NCOL(x) #&gt; filter &lt;- as.double(filter) #&gt; nfilt &lt;- as.integer(length(filter)) #&gt; if (is.na(nfilt)) #&gt; stop(gettextf(&quot;invalid value of %s&quot;, &quot;length(filter)&quot;), #&gt; domain = NA) #&gt; if (anyNA(filter)) #&gt; stop(&quot;missing values in &#39;filter&#39;&quot;) #&gt; if (method == &quot;convolution&quot;) { #&gt; if (nfilt &gt; n) #&gt; stop(&quot;&#39;filter&#39; is longer than time series&quot;) #&gt; sides &lt;- as.integer(sides) #&gt; if (is.na(sides) || (sides != 1L &amp;&amp; sides != 2L)) #&gt; stop(&quot;argument &#39;sides&#39; must be 1 or 2&quot;) #&gt; circular &lt;- as.logical(circular) #&gt; if (is.na(circular)) #&gt; stop(&quot;&#39;circular&#39; must be logical and not NA&quot;) #&gt; if (is.matrix(x)) { #&gt; y &lt;- matrix(NA, n, nser) #&gt; for (i in seq_len(nser)) y[, i] &lt;- .Call(C_cfilter, #&gt; x[, i], filter, sides, circular) #&gt; } #&gt; else y &lt;- .Call(C_cfilter, x, filter, sides, circular) #&gt; } #&gt; else { #&gt; if (missing(init)) { #&gt; init &lt;- matrix(0, nfilt, nser) #&gt; } #&gt; else { #&gt; ni &lt;- NROW(init) #&gt; if (ni != nfilt) #&gt; stop(&quot;length of &#39;init&#39; must equal length of &#39;filter&#39;&quot;) #&gt; if (NCOL(init) != 1L &amp;&amp; NCOL(init) != nser) { #&gt; stop(sprintf(ngettext(nser, &quot;&#39;init&#39; must have %d column&quot;, #&gt; &quot;&#39;init&#39; must have 1 or %d columns&quot;, domain = &quot;R-stats&quot;), #&gt; nser), domain = NA) #&gt; } #&gt; if (!is.matrix(init)) #&gt; dim(init) &lt;- c(nfilt, nser) #&gt; } #&gt; ind &lt;- seq_len(nfilt) #&gt; if (is.matrix(x)) { #&gt; y &lt;- matrix(NA, n, nser) #&gt; for (i in seq_len(nser)) y[, i] &lt;- .Call(C_rfilter, #&gt; x[, i], filter, c(rev(init[, i]), double(n)))[-ind] #&gt; } #&gt; else y &lt;- .Call(C_rfilter, x, filter, c(rev(init[, 1L]), #&gt; double(n)))[-ind] #&gt; } #&gt; tsp(y) &lt;- xtsp #&gt; class(y) &lt;- if (nser &gt; 1L) #&gt; c(&quot;mts&quot;, &quot;ts&quot;) #&gt; else &quot;ts&quot; #&gt; y #&gt; } #&gt; &lt;bytecode: 0x7fcdcd847ea8&gt; #&gt; &lt;environment: namespace:stats&gt; dplyr::filter # dplyr version #&gt; function (.data, ..., .by = NULL, .preserve = FALSE) #&gt; { #&gt; check_by_typo(...) #&gt; by &lt;- enquo(.by) #&gt; if (!quo_is_null(by) &amp;&amp; !is_false(.preserve)) { #&gt; abort(&quot;Can&#39;t supply both `.by` and `.preserve`.&quot;) #&gt; } #&gt; UseMethod(&quot;filter&quot;) #&gt; } #&gt; &lt;bytecode: 0x7fcd8df256c0&gt; #&gt; &lt;environment: namespace:dplyr&gt; # Check where function comes from find(&quot;filter&quot;) #&gt; [1] &quot;package:dplyr&quot; &quot;package:stats&quot; 17.10 Debugging Scope Issues üéØ Best Practice: Debug Scoping # 1. Check where you are debug_env &lt;- function() { cat(&quot;Current environment:\\n&quot;) print(environment()) cat(&quot;\\nParent environment:\\n&quot;) print(parent.env(environment())) cat(&quot;\\nObjects in current env:\\n&quot;) print(ls()) } my_func &lt;- function(x) { y &lt;- 10 debug_env() } my_func(5) #&gt; Current environment: #&gt; &lt;environment: 0x7fcd7b8e1aa8&gt; #&gt; #&gt; Parent environment: #&gt; &lt;environment: R_GlobalEnv&gt; #&gt; #&gt; Objects in current env: #&gt; character(0) # 2. Trace variable lookups where_is &lt;- function(name) { env &lt;- parent.frame() while (!identical(env, emptyenv())) { if (exists(name, envir = env, inherits = FALSE)) { return(environmentName(env)) } env &lt;- parent.env(env) } &quot;Not found&quot; } x &lt;- 10 test_func &lt;- function() { where_is(&quot;x&quot;) } test_func() #&gt; [1] &quot;R_GlobalEnv&quot; # 3. List all variables in scope ls.all &lt;- function() { # Get all environments in search path envs &lt;- search() for (env_name in envs) { env &lt;- as.environment(env_name) objs &lt;- ls(env) if (length(objs) &gt; 0) { cat(&quot;\\n&quot;, env_name, &quot;:\\n&quot;, sep = &quot;&quot;) cat(&quot; &quot;, paste(head(objs, 10), collapse = &quot;, &quot;), &quot;\\n&quot;) if (length(objs) &gt; 10) { cat(&quot; ... and&quot;, length(objs) - 10, &quot;more\\n&quot;) } } } } # ls.all() # Lists everything 17.11 Summary Key Takeaways: Lexical scoping - Functions use variables from where they‚Äôre defined Function environments - Each call creates new environment Search path - R looks up through parent environments Local before global - Local variables shadow global ones &lt;&lt;- for parent environment - Use cautiously Return values preferred - Better than global modification Closures retain environment - Function factories work because of this Quick Reference: Error Cause Fix object not found Variable in wrong scope Return from function or use &lt;&lt;- Unexpected value Using unintended global Make parameters explicit Function modifies global Using &lt;&lt;- unintentionally Use return values Name conflicts Same name in multiple packages Use package::function Scoping Rules: # R looks for variables in order: 1. Current environment 2. Parent environment (where defined, not called) 3. Parent&#39;s parent 4. ... up to global environment 5. Loaded packages 6. Base package # Assignment x &lt;- value # Creates in current environment x &lt;&lt;- value # Creates in first parent with x, or global # Accessing x # Searches up environments get(&quot;x&quot;) # Same as above exists(&quot;x&quot;) # Check if exists Best Practices: # ‚úÖ Good function(x, y) { x + y } # Explicit parameters result &lt;- my_func(data) # Return and assign make_counter &lt;- function() { } # Closures for state # ‚ùå Avoid function() { global_var + 5 } # Implicit global use my_func &lt;- function() { x &lt;&lt;- 5 } # Modifying global Assuming variable exists # Check with exists() 17.12 Exercises üìù Exercise 1: Scope Exploration Predict the output: x &lt;- 10 func1 &lt;- function() { x &lt;- 20 func2() } func2 &lt;- function() { x } func1() # What does this return? üìù Exercise 2: Counter Implementation Create a counter using closures: 1. increment() - adds 1 2. decrement() - subtracts 1 3. get() - returns current value 4. reset() - sets to 0 üìù Exercise 3: Function Factory Write make_scaler(center, scale) that returns a function that: 1. Subtracts center from input 2. Divides by scale 3. Use with built-in datasets üìù Exercise 4: Environment Inspector Write inspect_scope() that: 1. Shows current environment 2. Lists parent environments 3. Shows variables at each level 4. Identifies potential conflicts 17.13 Exercise Answers Click to see answers Exercise 1: x &lt;- 10 func1 &lt;- function() { x &lt;- 20 # Local x in func1 func2() } func2 &lt;- function() { x # Looks for x where func2 was defined (global) } func1() # Returns 10 (not 20!) #&gt; [1] 10 # Why? Lexical scoping: # func2 was defined in global environment # So it looks for x in global environment (x = 10) # NOT where it was called (inside func1 with x = 20) Exercise 2: make_counter &lt;- function(initial = 0) { count &lt;- initial list( increment = function() { count &lt;&lt;- count + 1 invisible(count) }, decrement = function() { count &lt;&lt;- count - 1 invisible(count) }, get = function() { count }, reset = function() { count &lt;&lt;- initial invisible(count) } ) } # Test counter &lt;- make_counter(10) counter$increment() counter$increment() counter$get() # 12 #&gt; [1] 12 counter$decrement() counter$get() # 11 #&gt; [1] 11 counter$reset() counter$get() # 10 #&gt; [1] 10 # Create multiple independent counters counter1 &lt;- make_counter(0) counter2 &lt;- make_counter(100) counter1$increment() counter2$decrement() counter1$get() # 1 #&gt; [1] 1 counter2$get() # 99 #&gt; [1] 99 Exercise 3: make_scaler &lt;- function(center = 0, scale = 1) { # Validate inputs if (!is.numeric(center) || length(center) != 1) { stop(&quot;center must be a single numeric value&quot;) } if (!is.numeric(scale) || length(scale) != 1 || scale == 0) { stop(&quot;scale must be a single non-zero numeric value&quot;) } # Return scaling function function(x) { if (!is.numeric(x)) { stop(&quot;x must be numeric&quot;) } (x - center) / scale } } # Test with mtcars mpg_mean &lt;- mean(mtcars$mpg) mpg_sd &lt;- sd(mtcars$mpg) standardize_mpg &lt;- make_scaler(mpg_mean, mpg_sd) # Standardize mpg mpg_scaled &lt;- standardize_mpg(mtcars$mpg) # Check: should have mean ‚âà 0, sd ‚âà 1 mean(mpg_scaled) #&gt; [1] 7.112366e-17 sd(mpg_scaled) #&gt; [1] 1 # Create different scalers scale_0_1 &lt;- make_scaler( center = min(mtcars$hp), scale = max(mtcars$hp) - min(mtcars$hp) ) hp_scaled &lt;- scale_0_1(mtcars$hp) range(hp_scaled) # Should be 0 to 1 #&gt; [1] 0 1 Exercise 4: inspect_scope &lt;- function() { # Get calling environment env &lt;- parent.frame() cat(&quot;=== Environment Inspection ===\\n\\n&quot;) level &lt;- 0 while (!identical(env, emptyenv())) { # Environment name env_name &lt;- environmentName(env) if (env_name == &quot;&quot;) { env_name &lt;- paste0(&quot;&lt;anonymous &quot;, level, &quot;&gt;&quot;) } cat(&quot;Level&quot;, level, &quot;:&quot;, env_name, &quot;\\n&quot;) # List objects objs &lt;- ls(env, all.names = FALSE) if (length(objs) &gt; 0) { cat(&quot; Objects:&quot;, paste(head(objs, 5), collapse = &quot;, &quot;)) if (length(objs) &gt; 5) { cat(&quot; ... +&quot;, length(objs) - 5, &quot;more&quot;) } cat(&quot;\\n&quot;) # Check for conflicts with parent parent_env &lt;- parent.env(env) if (!identical(parent_env, emptyenv())) { parent_objs &lt;- ls(parent_env, all.names = FALSE) conflicts &lt;- intersect(objs, parent_objs) if (length(conflicts) &gt; 0) { cat(&quot; ‚ö† Shadows parent objects:&quot;, paste(conflicts, collapse = &quot;, &quot;), &quot;\\n&quot;) } } } else { cat(&quot; (empty)\\n&quot;) } cat(&quot;\\n&quot;) # Move to parent env &lt;- parent.env(env) level &lt;- level + 1 # Stop at global or after reasonable depth if (level &gt; 10) { cat(&quot;... (stopping after 10 levels)\\n&quot;) break } } } # Test test_function &lt;- function() { local_var &lt;- 123 x &lt;- &quot;local x&quot; # Shadows global x if it exists inspect_scope() } x &lt;- &quot;global x&quot; test_function() #&gt; === Environment Inspection === #&gt; #&gt; Level 0 : &lt;anonymous 0&gt; #&gt; Objects: local_var, x #&gt; ‚ö† Shadows parent objects: x #&gt; #&gt; Level 1 : R_GlobalEnv #&gt; Objects: a, A, A_col, A_inv, A_sub ... + 461 more #&gt; ‚ö† Shadows parent objects: element #&gt; #&gt; Level 2 : package:ggplot2 #&gt; Objects: %+%, %+replace%, add_gg, aes, aes_ ... + 644 more #&gt; #&gt; Level 3 : package:glue #&gt; Objects: as_glue, backtick, double_quote, glue, glue_col ... + 11 more #&gt; #&gt; Level 4 : package:stringr #&gt; Objects: %&gt;%, boundary, coll, fixed, fruit ... + 57 more #&gt; ‚ö† Shadows parent objects: %&gt;% #&gt; #&gt; Level 5 : package:forcats #&gt; Objects: %&gt;%, as_factor, fct, fct_anon, fct_c ... + 35 more #&gt; #&gt; Level 6 : package:MASS #&gt; Objects: abbey, accdeaths, addterm, Aids2, Animals ... + 159 more #&gt; #&gt; Level 7 : package:tibble #&gt; Objects: %&gt;%, add_case, add_column, add_row, as_data_frame ... + 40 more #&gt; ‚ö† Shadows parent objects: %&gt;% #&gt; #&gt; Level 8 : package:purrr #&gt; Objects: %@%, %&gt;%, %||%, accumulate, accumulate_right ... + 186 more #&gt; ‚ö† Shadows parent objects: %&gt;% #&gt; #&gt; Level 9 : package:dplyr #&gt; Objects: %&gt;%, across, add_count, add_count_, add_row ... + 292 more #&gt; ‚ö† Shadows parent objects: intersect, setdiff, union #&gt; #&gt; Level 10 : package:lubridate #&gt; Objects: %--%, %m-%, %m+%, %within%, add_with_rollback ... + 158 more #&gt; #&gt; ... (stopping after 10 levels) "],["control-flow.html", "Chapter 18 Control Flow 18.1 Introduction 18.2 if/else Basics 18.3 Error #1: the condition has length &gt; 1 18.4 Error #2: argument is of length zero 18.5 for Loops 18.6 Error #3: object not found in loops 18.7 while Loops 18.8 break and next 18.9 repeat Loops 18.10 switch Statement 18.11 Common Loop Patterns 18.12 Vectorization vs Loops 18.13 ifelse() Details 18.14 Summary 18.15 Exercises 18.16 Exercise Answers", " Chapter 18 Control Flow What You‚Äôll Learn: if/else statements for, while, repeat loops break and next switch statements Common control flow errors Key Errors Covered: 15+ control flow errors Difficulty: ‚≠ê‚≠ê Intermediate 18.1 Introduction Control flow directs code execution, but has pitfalls: x &lt;- 5 # Looks okay... if (x &gt; 3 &amp; x &lt; 10) { print(&quot;In range&quot;) } #&gt; [1] &quot;In range&quot; # Works, but what about this? x &lt;- c(5, 15) if (x &gt; 3 &amp; x &lt; 10) { # Warning! print(&quot;In range&quot;) } #&gt; Error in if (x &gt; 3 &amp; x &lt; 10) {: the condition has length &gt; 1 Let‚Äôs master control flow to avoid these issues. 18.2 if/else Basics üí° Key Insight: if Requires Single Logical # Correct: single TRUE/FALSE if (TRUE) { print(&quot;Yes&quot;) } #&gt; [1] &quot;Yes&quot; if (5 &gt; 3) { print(&quot;Five is greater&quot;) } #&gt; [1] &quot;Five is greater&quot; # With else x &lt;- 10 if (x &gt; 5) { print(&quot;Large&quot;) } else { print(&quot;Small&quot;) } #&gt; [1] &quot;Large&quot; # else if x &lt;- 5 if (x &gt; 10) { print(&quot;Large&quot;) } else if (x &gt; 5) { print(&quot;Medium&quot;) } else { print(&quot;Small&quot;) } #&gt; [1] &quot;Small&quot; # ifelse for vectors (different!) x &lt;- c(3, 7, 12) ifelse(x &gt; 5, &quot;Large&quot;, &quot;Small&quot;) #&gt; [1] &quot;Small&quot; &quot;Large&quot; &quot;Large&quot; Key points: - if needs single logical value - ifelse() is vectorized (for vectors) - if can have else and else if - Braces {} recommended even for single lines 18.3 Error #1: the condition has length &gt; 1 ‚≠ê BEGINNER üß† LOGIC 18.3.1 The Error x &lt;- c(5, 15) if (x &gt; 10) { print(&quot;Greater than 10&quot;) } #&gt; Error in if (x &gt; 10) {: the condition has length &gt; 1 üî¥ ERROR (R &gt;= 4.2) Error in if (x &gt; 10) { : the condition has length &gt; 1 In older R versions, this gives a warning and uses only the first element. 18.3.2 What It Means You‚Äôre using a vector in if when it expects a single TRUE/FALSE. 18.3.3 Common Causes 18.3.3.1 Cause 1: Testing Vector ages &lt;- c(15, 25, 35) if (ages &gt;= 18) { print(&quot;All adults&quot;) } #&gt; Error in if (ages &gt;= 18) {: the condition has length &gt; 1 18.3.3.2 Cause 2: Multiple Conditions x &lt;- 5 y &lt;- 10 # Wrong: creates vector of length 2 if (c(x &gt; 3, y &gt; 8)) { print(&quot;Both true&quot;) } #&gt; Error in if (c(x &gt; 3, y &gt; 8)) {: the condition has length &gt; 1 18.3.3.3 Cause 3: Using | instead of || x &lt;- c(5, 15) # &amp; and | are vectorized x &gt; 3 &amp; x &lt; 10 # Vector of 2 elements #&gt; [1] TRUE FALSE # &amp;&amp; and || use only first element x &gt; 3 &amp;&amp; x &lt; 10 # Single logical (from first element) #&gt; Error in x &gt; 3 &amp;&amp; x &lt; 10: &#39;length = 2&#39; in coercion to &#39;logical(1)&#39; 18.3.4 Solutions ‚úÖ SOLUTION 1: Use &amp;&amp; or || for Scalar Conditions x &lt;- 5 y &lt;- 10 # Logical AND if (x &gt; 3 &amp;&amp; y &gt; 8) { print(&quot;Both conditions true&quot;) } #&gt; [1] &quot;Both conditions true&quot; # Logical OR if (x &lt; 3 || y &gt; 8) { print(&quot;At least one true&quot;) } #&gt; [1] &quot;At least one true&quot; ‚úÖ SOLUTION 2: Use all() or any() for Vectors ages &lt;- c(15, 25, 35) # Check if all are adults if (all(ages &gt;= 18)) { print(&quot;All adults&quot;) } else { print(&quot;Some minors&quot;) } #&gt; [1] &quot;Some minors&quot; # Check if any are adults if (any(ages &gt;= 18)) { print(&quot;At least one adult&quot;) } #&gt; [1] &quot;At least one adult&quot; ‚úÖ SOLUTION 3: Use ifelse() for Vectorized Operations ages &lt;- c(15, 25, 35) # Vectorized: returns vector status &lt;- ifelse(ages &gt;= 18, &quot;Adult&quot;, &quot;Minor&quot;) status #&gt; [1] &quot;Minor&quot; &quot;Adult&quot; &quot;Adult&quot; # Or with dplyr::case_when (cleaner for multiple conditions) library(dplyr) case_when( ages &lt; 13 ~ &quot;Child&quot;, ages &lt; 18 ~ &quot;Teen&quot;, ages &lt; 65 ~ &quot;Adult&quot;, TRUE ~ &quot;Senior&quot; ) #&gt; [1] &quot;Teen&quot; &quot;Adult&quot; &quot;Adult&quot; ‚ö†Ô∏è Common Pitfall: &amp; vs &amp;&amp; and | vs || # For if statements (scalar) x &lt;- 5 y &lt;- 10 # Use &amp;&amp; and || (short-circuit evaluation) if (x &gt; 3 &amp;&amp; y &gt; 8) { print(&quot;Both true&quot;) } #&gt; [1] &quot;Both true&quot; # For vectors v1 &lt;- c(TRUE, FALSE, TRUE) v2 &lt;- c(TRUE, TRUE, FALSE) # Use &amp; and | (element-wise) v1 &amp; v2 #&gt; [1] TRUE FALSE FALSE v1 | v2 #&gt; [1] TRUE TRUE TRUE # Never use &amp;&amp; or || on vectors in if! Key difference: - &amp; and |: Vectorized, return vector - &amp;&amp; and ||: Scalar, return single value, short-circuit 18.4 Error #2: argument is of length zero ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 18.4.1 The Error x &lt;- numeric(0) # Empty vector if (x &gt; 5) { print(&quot;Greater&quot;) } #&gt; Error in if (x &gt; 5) {: argument is of length zero üî¥ ERROR Error in if (x &gt; 5) { : argument is of length zero 18.4.2 What It Means You‚Äôre testing an empty vector in if. 18.4.3 Common Causes 18.4.3.1 Cause 1: Empty Result from Operation data &lt;- c(1, 2, 3, 4) filtered &lt;- data[data &gt; 10] # Empty! if (filtered &gt; 0) { print(&quot;Has values&quot;) } #&gt; Error in if (filtered &gt; 0) {: argument is of length zero 18.4.3.2 Cause 2: Missing Data value &lt;- NA result &lt;- value[!is.na(value)] # Empty if all NA if (length(result) &gt; 0) { # Good # ... } if (result &gt; 0) { # Bad! Error if empty # ... } #&gt; Error in if (result &gt; 0) {: argument is of length zero 18.4.4 Solutions ‚úÖ SOLUTION 1: Check Length First x &lt;- numeric(0) if (length(x) &gt; 0 &amp;&amp; x[1] &gt; 5) { print(&quot;First element greater than 5&quot;) } # Or more robustly safe_check &lt;- function(x, threshold) { if (length(x) == 0) { return(FALSE) } x[1] &gt; threshold } if (safe_check(x, 5)) { print(&quot;Greater&quot;) } ‚úÖ SOLUTION 2: Provide Default x &lt;- numeric(0) # Use default if empty value &lt;- if (length(x) &gt; 0) x[1] else 0 if (value &gt; 5) { print(&quot;Greater&quot;) } ‚úÖ SOLUTION 3: Use any() or all() x &lt;- numeric(0) # any() and all() handle empty vectors any(x &gt; 5) # FALSE (no elements satisfy condition) #&gt; [1] FALSE all(x &gt; 5) # TRUE (all zero elements satisfy condition!) #&gt; [1] TRUE if (any(x &gt; 5)) { print(&quot;At least one greater&quot;) } 18.5 for Loops üí° Key Insight: for Loop Patterns # 1. Loop over vector for (i in 1:5) { print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # 2. Loop over elements fruits &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for (fruit in fruits) { print(fruit) } #&gt; [1] &quot;apple&quot; #&gt; [1] &quot;banana&quot; #&gt; [1] &quot;cherry&quot; # 3. Loop with indices for (i in seq_along(fruits)) { cat(i, &quot;:&quot;, fruits[i], &quot;\\n&quot;) } #&gt; 1 : apple #&gt; 2 : banana #&gt; 3 : cherry # 4. Nested loops for (i in 1:3) { for (j in 1:2) { cat(&quot;(&quot;, i, &quot;,&quot;, j, &quot;) &quot;) } cat(&quot;\\n&quot;) } #&gt; ( 1 , 1 ) ( 1 , 2 ) #&gt; ( 2 , 1 ) ( 2 , 2 ) #&gt; ( 3 , 1 ) ( 3 , 2 ) # 5. Pre-allocate results (important for performance!) n &lt;- 1000 result &lt;- numeric(n) # Pre-allocate for (i in 1:n) { result[i] &lt;- i^2 } Best practices: - Use seq_along() instead of 1:length() - Pre-allocate result vectors - Consider vectorization instead - Use for for side effects (plots, files) 18.6 Error #3: object not found in loops ‚≠ê BEGINNER üîç SCOPE 18.6.1 The Error # Empty vector values &lt;- numeric(0) for (i in 1:length(values)) { print(values[i]) } #&gt; [1] NA #&gt; numeric(0) üî¥ ERROR Error in 1:length(values) : argument of length 0 Wait, that‚Äôs different. Let me show the real issue: # This actually works (badly) values &lt;- numeric(0) for (i in 1:length(values)) { # 1:0 creates c(1, 0) print(i) } #&gt; [1] 1 #&gt; [1] 0 18.6.2 The Real Problem # 1:length() is dangerous with empty vectors values &lt;- numeric(0) 1:length(values) # c(1, 0) - not what you want! #&gt; [1] 1 0 # Safer: seq_along() seq_along(values) # integer(0) - correct! #&gt; integer(0) 18.6.3 Solutions ‚úÖ SOLUTION 1: Use seq_along() values &lt;- numeric(0) # Safe with empty vectors for (i in seq_along(values)) { print(values[i]) } # Doesn&#39;t iterate (correct behavior) # Works with non-empty too values &lt;- c(10, 20, 30) for (i in seq_along(values)) { print(values[i]) } #&gt; [1] 10 #&gt; [1] 20 #&gt; [1] 30 ‚úÖ SOLUTION 2: Check Length First values &lt;- numeric(0) if (length(values) &gt; 0) { for (i in 1:length(values)) { print(values[i]) } } else { message(&quot;No values to process&quot;) } #&gt; No values to process ‚úÖ SOLUTION 3: Use seq_len() n &lt;- 0 # seq_len() handles zero correctly for (i in seq_len(n)) { print(i) } # Doesn&#39;t iterate n &lt;- 5 for (i in seq_len(n)) { print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # Iterates 1 to 5 18.7 while Loops üí° Key Insight: while vs for # for: known number of iterations for (i in 1:5) { print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # while: iterate until condition false count &lt;- 1 while (count &lt;= 5) { print(count) count &lt;- count + 1 } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # while with break count &lt;- 1 while (TRUE) { print(count) count &lt;- count + 1 if (count &gt; 5) break } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # Infinite loop danger! # while (TRUE) { # # Never breaks! # } When to use while: - Unknown number of iterations - Convergence checking - Reading until end - Waiting for condition 18.8 break and next üí° Key Insight: Loop Control # break: exit loop immediately for (i in 1:10) { if (i &gt; 5) break print(i) } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # Prints 1-5, then stops # next: skip to next iteration for (i in 1:10) { if (i %% 2 == 0) next # Skip even numbers print(i) } #&gt; [1] 1 #&gt; [1] 3 #&gt; [1] 5 #&gt; [1] 7 #&gt; [1] 9 # Prints only odd numbers # Combined for (i in 1:20) { if (i &gt; 15) break # Stop at 15 if (i %% 2 == 0) next # Skip evens print(i) } #&gt; [1] 1 #&gt; [1] 3 #&gt; [1] 5 #&gt; [1] 7 #&gt; [1] 9 #&gt; [1] 11 #&gt; [1] 13 #&gt; [1] 15 # Prints odd numbers up to 15 # In nested loops for (i in 1:3) { for (j in 1:3) { if (i == j) next # Skip diagonal cat(&quot;(&quot;, i, &quot;,&quot;, j, &quot;) &quot;) } cat(&quot;\\n&quot;) } #&gt; ( 1 , 2 ) ( 1 , 3 ) #&gt; ( 2 , 1 ) ( 2 , 3 ) #&gt; ( 3 , 1 ) ( 3 , 2 ) 18.9 repeat Loops üí° Key Insight: repeat Loop # repeat: infinite loop with break count &lt;- 0 repeat { count &lt;- count + 1 print(count) if (count &gt;= 5) break } #&gt; [1] 1 #&gt; [1] 2 #&gt; [1] 3 #&gt; [1] 4 #&gt; [1] 5 # Common pattern: read until done # repeat { # line &lt;- readLines(connection, n = 1) # if (length(line) == 0) break # process(line) # } # Convergence checking tolerance &lt;- 0.001 value &lt;- 10 repeat { old_value &lt;- value value &lt;- value / 2 + 1 if (abs(value - old_value) &lt; tolerance) { break } } cat(&quot;Converged to:&quot;, value, &quot;\\n&quot;) #&gt; Converged to: 2.000977 18.10 switch Statement üéØ Best Practice: switch() # Cleaner than multiple if/else operation &lt;- &quot;add&quot; result &lt;- switch(operation, add = 10 + 5, subtract = 10 - 5, multiply = 10 * 5, divide = 10 / 5, &quot;Unknown operation&quot; # Default ) result #&gt; [1] 15 # With functions calculate &lt;- function(op, x, y) { switch(op, &quot;+&quot; = x + y, &quot;-&quot; = x - y, &quot;*&quot; = x * y, &quot;/&quot; = x / y, stop(&quot;Unknown operation: &quot;, op) ) } calculate(&quot;+&quot;, 10, 5) #&gt; [1] 15 calculate(&quot;*&quot;, 10, 5) #&gt; [1] 50 # Numeric switch (uses position) type &lt;- 2 switch(type, &quot;First&quot;, # 1 &quot;Second&quot;, # 2 &quot;Third&quot; # 3 ) #&gt; [1] &quot;Second&quot; # Multiple cases to same result grade &lt;- &quot;B&quot; message &lt;- switch(grade, &quot;A&quot; = , &quot;B&quot; = &quot;Good job!&quot;, &quot;C&quot; = , &quot;D&quot; = &quot;Need improvement&quot;, &quot;F&quot; = &quot;Failed&quot;, &quot;Invalid grade&quot; ) message #&gt; [1] &quot;Good job!&quot; 18.11 Common Loop Patterns üéØ Best Practice: Loop Patterns # 1. Accumulation total &lt;- 0 for (i in 1:10) { total &lt;- total + i } total #&gt; [1] 55 # Better: use sum() sum(1:10) #&gt; [1] 55 # 2. Building a result vector n &lt;- 5 squares &lt;- numeric(n) # Pre-allocate! for (i in 1:n) { squares[i] &lt;- i^2 } squares #&gt; [1] 1 4 9 16 25 # Better: vectorize (1:5)^2 #&gt; [1] 1 4 9 16 25 # 3. Processing with indices data &lt;- c(10, 20, 30, 40) for (i in seq_along(data)) { cat(&quot;Element&quot;, i, &quot;is&quot;, data[i], &quot;\\n&quot;) } #&gt; Element 1 is 10 #&gt; Element 2 is 20 #&gt; Element 3 is 30 #&gt; Element 4 is 40 # 4. Conditional accumulation values &lt;- c(1, 5, 3, 8, 2, 9, 4) count &lt;- 0 for (val in values) { if (val &gt; 5) { count &lt;- count + 1 } } count #&gt; [1] 2 # Better: use sum() sum(values &gt; 5) #&gt; [1] 2 # 5. Early exit find_first &lt;- function(x, threshold) { for (i in seq_along(x)) { if (x[i] &gt; threshold) { return(i) } } return(NA) } find_first(c(1, 3, 7, 2, 9), 5) #&gt; [1] 3 # 6. Nested iteration matrix_data &lt;- matrix(1:9, nrow = 3) for (i in 1:nrow(matrix_data)) { for (j in 1:ncol(matrix_data)) { cat(matrix_data[i, j], &quot; &quot;) } cat(&quot;\\n&quot;) } #&gt; 1 4 7 #&gt; 2 5 8 #&gt; 3 6 9 # Better: often use apply family or vectorization 18.12 Vectorization vs Loops ‚ö†Ô∏è Performance: Vectorization Usually Better n &lt;- 10000 # Loop (slow) system.time({ result &lt;- numeric(n) for (i in 1:n) { result[i] &lt;- sqrt(i) } }) #&gt; user system elapsed #&gt; 0.003 0.000 0.002 # Vectorized (fast) system.time({ result &lt;- sqrt(1:n) }) #&gt; user system elapsed #&gt; 0 0 0 # When to use loops: # 1. Sequential dependencies fibonacci &lt;- function(n) { fib &lt;- numeric(n) fib[1] &lt;- 1 fib[2] &lt;- 1 for (i in 3:n) { fib[i] &lt;- fib[i-1] + fib[i-2] # Depends on previous } fib } # 2. Side effects (printing, plotting, file I/O) for (i in 1:3) { plot(1:10, main = paste(&quot;Plot&quot;, i)) Sys.sleep(0.1) } # 3. Complex logic that can&#39;t be vectorized # 4. Early termination conditions 18.13 ifelse() Details üí° Key Insight: ifelse() Behavior # Basic ifelse x &lt;- c(1, 5, 3, 8, 2) ifelse(x &gt; 4, &quot;High&quot;, &quot;Low&quot;) #&gt; [1] &quot;Low&quot; &quot;High&quot; &quot;Low&quot; &quot;High&quot; &quot;Low&quot; # Nested ifelse ifelse(x &lt; 3, &quot;Low&quot;, ifelse(x &lt; 7, &quot;Medium&quot;, &quot;High&quot;)) #&gt; [1] &quot;Low&quot; &quot;Medium&quot; &quot;Medium&quot; &quot;High&quot; &quot;Low&quot; # With NAs x_na &lt;- c(1, 5, NA, 8, 2) ifelse(x_na &gt; 4, &quot;High&quot;, &quot;Low&quot;) # NA stays NA #&gt; [1] &quot;Low&quot; &quot;High&quot; NA &quot;High&quot; &quot;Low&quot; # Type coercion in ifelse ifelse(c(TRUE, FALSE, TRUE), 1, &quot;No&quot;) # Coerces to character! #&gt; [1] &quot;1&quot; &quot;No&quot; &quot;1&quot; # More control with dplyr::case_when library(dplyr) case_when( x &lt; 3 ~ &quot;Low&quot;, x &lt; 7 ~ &quot;Medium&quot;, TRUE ~ &quot;High&quot; # Default ) #&gt; [1] &quot;Low&quot; &quot;Medium&quot; &quot;Medium&quot; &quot;High&quot; &quot;Low&quot; # Maintains types better case_when( c(TRUE, FALSE, TRUE) ~ 1L, TRUE ~ NA_integer_ ) #&gt; [1] 1 NA 1 Prefer case_when() for: - Multiple conditions - Type preservation - Clearer code 18.14 Summary Key Takeaways: if needs single logical - Use &amp;&amp;/|| not &amp;/| Check length first - Avoid length-zero errors Use seq_along() - Not 1:length() in loops Pre-allocate vectors - Important for performance break exits loop - next skips iteration Vectorize when possible - Usually faster than loops ifelse() is vectorized - Different from if Use case_when() - Cleaner than nested ifelse Quick Reference: Error Cause Fix condition has length &gt; 1 Vector in if Use all(), any(), or &amp;&amp;/|| argument is of length zero Empty vector in if Check length() first Infinite loop No break condition Add break or fix condition Wrong 1:length() Empty vector Use seq_along() Control Flow: # if/else if (condition) { # code } else if (other_condition) { # code } else { # code } # ifelse (vectorized) ifelse(test, yes, no) # for loop for (i in seq_along(x)) { # code } # while loop while (condition) { # code } # repeat loop repeat { # code if (condition) break } # switch switch(value, case1 = result1, case2 = result2, default ) Best Practices: # ‚úÖ Good if (length(x) &gt; 0 &amp;&amp; x[1] &gt; 5) # Check length for (i in seq_along(x)) # Safe indexing result &lt;- numeric(n); for... # Pre-allocate result &lt;- sqrt(x) # Vectorize when possible # ‚ùå Avoid if (x &gt; 5) # Vector in if for (i in 1:length(x)) # Fails on empty for... result &lt;- c(result, new) # Growing vector (slow) for (i in 1:n) result[i] &lt;- x[i]^2 # Loop when vectorization works 18.15 Exercises üìù Exercise 1: Safe Condition Checker Write safe_if(condition, true_val, false_val) that: 1. Checks if condition is single logical 2. Handles NA in condition 3. Returns appropriate value 4. Gives helpful errors üìù Exercise 2: Loop Converter Convert this loop to vectorized code: x &lt;- 1:1000 result &lt;- numeric(length(x)) for (i in seq_along(x)) { if (x[i] %% 2 == 0) { result[i] &lt;- x[i]^2 } else { result[i] &lt;- x[i]^3 } } üìù Exercise 3: Find First Write find_first(x, condition) that: 1. Finds first element satisfying condition 2. Returns index and value 3. Handles case where none match 4. Uses early exit for efficiency üìù Exercise 4: Grade Classifier Write classify_grade(score) using switch() that: 1. Converts numeric score to letter grade 2. Handles vectorized input 3. Validates input range (0-100) 4. Returns appropriate grade 18.16 Exercise Answers Click to see answers Exercise 1: safe_if &lt;- function(condition, true_val, false_val) { # Check if condition is logical if (!is.logical(condition)) { stop(&quot;Condition must be logical, got &quot;, class(condition)[1]) } # Check length if (length(condition) == 0) { stop(&quot;Condition has length zero&quot;) } if (length(condition) &gt; 1) { warning(&quot;Condition has length &quot;, length(condition), &quot;, using first element only&quot;) condition &lt;- condition[1] } # Handle NA if (is.na(condition)) { warning(&quot;Condition is NA, returning NA&quot;) return(NA) } # Return appropriate value if (condition) { true_val } else { false_val } } # Test safe_if(TRUE, &quot;yes&quot;, &quot;no&quot;) #&gt; [1] &quot;yes&quot; safe_if(5 &gt; 3, &quot;greater&quot;, &quot;less&quot;) #&gt; [1] &quot;greater&quot; safe_if(NA, &quot;yes&quot;, &quot;no&quot;) # Warning #&gt; Warning in safe_if(NA, &quot;yes&quot;, &quot;no&quot;): Condition is NA, returning NA #&gt; [1] NA safe_if(c(TRUE, FALSE), &quot;yes&quot;, &quot;no&quot;) # Warning #&gt; Warning in safe_if(c(TRUE, FALSE), &quot;yes&quot;, &quot;no&quot;): Condition has length 2, using #&gt; first element only #&gt; [1] &quot;yes&quot; safe_if(&quot;not logical&quot;, &quot;yes&quot;, &quot;no&quot;) # Error #&gt; Error in safe_if(&quot;not logical&quot;, &quot;yes&quot;, &quot;no&quot;): Condition must be logical, got character Exercise 2: # Original loop x &lt;- 1:1000 result_loop &lt;- numeric(length(x)) for (i in seq_along(x)) { if (x[i] %% 2 == 0) { result_loop[i] &lt;- x[i]^2 } else { result_loop[i] &lt;- x[i]^3 } } # Vectorized version 1: ifelse result_vec1 &lt;- ifelse(x %% 2 == 0, x^2, x^3) # Vectorized version 2: case_when library(dplyr) result_vec2 &lt;- case_when( x %% 2 == 0 ~ x^2, TRUE ~ x^3 ) # Vectorized version 3: logical indexing result_vec3 &lt;- numeric(length(x)) even &lt;- x %% 2 == 0 result_vec3[even] &lt;- x[even]^2 result_vec3[!even] &lt;- x[!even]^3 # Verify all give same result all.equal(result_loop, result_vec1) #&gt; [1] TRUE all.equal(result_loop, result_vec2) #&gt; [1] TRUE all.equal(result_loop, result_vec3) #&gt; [1] TRUE # Compare performance library(microbenchmark) microbenchmark( loop = { result &lt;- numeric(length(x)) for (i in seq_along(x)) { if (x[i] %% 2 == 0) result[i] &lt;- x[i]^2 else result[i] &lt;- x[i]^3 } }, ifelse = ifelse(x %% 2 == 0, x^2, x^3), case_when = case_when(x %% 2 == 0 ~ x^2, TRUE ~ x^3), logical_index = { result &lt;- numeric(length(x)) even &lt;- x %% 2 == 0 result[even] &lt;- x[even]^2 result[!even] &lt;- x[!even]^3 }, times = 100 ) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; loop 3582.400 3982.5385 4847.38519 4207.4805 4432.590 17419.146 100 #&gt; ifelse 45.779 52.6240 59.59907 55.7985 62.616 138.753 100 #&gt; case_when 220.946 257.0350 323.58414 296.5870 385.736 707.064 100 #&gt; logical_index 34.785 40.3275 47.51908 44.3135 48.028 217.959 100 Exercise 3: find_first &lt;- function(x, condition) { # Validate inputs if (!is.function(condition)) { stop(&quot;condition must be a function&quot;) } if (length(x) == 0) { return(list(index = NA, value = NA, found = FALSE)) } # Search with early exit for (i in seq_along(x)) { if (condition(x[i])) { return(list( index = i, value = x[i], found = TRUE )) } } # None found list(index = NA, value = NA, found = FALSE) } # Test data &lt;- c(1, 3, 5, 8, 2, 9, 4) # Find first &gt; 5 find_first(data, function(x) x &gt; 5) #&gt; $index #&gt; [1] 4 #&gt; #&gt; $value #&gt; [1] 8 #&gt; #&gt; $found #&gt; [1] TRUE # Find first even find_first(data, function(x) x %% 2 == 0) #&gt; $index #&gt; [1] 4 #&gt; #&gt; $value #&gt; [1] 8 #&gt; #&gt; $found #&gt; [1] TRUE # Find first &gt; 100 (none) find_first(data, function(x) x &gt; 100) #&gt; $index #&gt; [1] NA #&gt; #&gt; $value #&gt; [1] NA #&gt; #&gt; $found #&gt; [1] FALSE # Empty vector find_first(numeric(0), function(x) x &gt; 5) #&gt; $index #&gt; [1] NA #&gt; #&gt; $value #&gt; [1] NA #&gt; #&gt; $found #&gt; [1] FALSE # More complex condition find_first(c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;), function(x) nchar(x) &gt; 5) #&gt; $index #&gt; [1] 2 #&gt; #&gt; $value #&gt; [1] &quot;banana&quot; #&gt; #&gt; $found #&gt; [1] TRUE Exercise 4: classify_grade &lt;- function(score) { # Validate input if (!is.numeric(score)) { stop(&quot;Score must be numeric&quot;) } # Vectorized function sapply(score, function(s) { # Check range if (is.na(s)) { return(NA_character_) } if (s &lt; 0 || s &gt; 100) { warning(&quot;Score &quot;, s, &quot; is out of range (0-100)&quot;) return(&quot;Invalid&quot;) } # Classify using switch on integer ranges grade_num &lt;- cut(s, breaks = c(-Inf, 60, 70, 80, 90, Inf), labels = FALSE) switch(grade_num, &quot;F&quot;, # 1: 0-59 &quot;D&quot;, # 2: 60-69 &quot;C&quot;, # 3: 70-79 &quot;B&quot;, # 4: 80-89 &quot;A&quot; # 5: 90-100 ) }) } # Test classify_grade(85) #&gt; [1] &quot;B&quot; classify_grade(c(45, 65, 75, 85, 95)) #&gt; [1] &quot;F&quot; &quot;D&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; classify_grade(c(95, NA, 105, 65)) #&gt; Warning in FUN(X[[i]], ...): Score 105 is out of range (0-100) #&gt; [1] &quot;A&quot; NA &quot;Invalid&quot; &quot;D&quot; # More detailed version with +/- classify_grade_detailed &lt;- function(score) { sapply(score, function(s) { if (is.na(s)) return(NA_character_) if (s &lt; 0 || s &gt; 100) return(&quot;Invalid&quot;) if (s &gt;= 97) return(&quot;A+&quot;) if (s &gt;= 93) return(&quot;A&quot;) if (s &gt;= 90) return(&quot;A-&quot;) if (s &gt;= 87) return(&quot;B+&quot;) if (s &gt;= 83) return(&quot;B&quot;) if (s &gt;= 80) return(&quot;B-&quot;) if (s &gt;= 77) return(&quot;C+&quot;) if (s &gt;= 73) return(&quot;C&quot;) if (s &gt;= 70) return(&quot;C-&quot;) if (s &gt;= 67) return(&quot;D+&quot;) if (s &gt;= 63) return(&quot;D&quot;) if (s &gt;= 60) return(&quot;D-&quot;) return(&quot;F&quot;) }) } classify_grade_detailed(c(98, 88, 78, 68, 58)) #&gt; [1] &quot;A+&quot; &quot;B+&quot; &quot;C+&quot; &quot;D+&quot; &quot;F&quot; "],["error-handling.html", "Chapter 19 Error Handling 19.1 Introduction 19.2 Error Basics 19.3 try() 19.4 tryCatch() 19.5 Custom Errors 19.6 Defensive Programming 19.7 Assertions 19.8 Warnings and Suppression 19.9 Error Recovery 19.10 on.exit() 19.11 Debugging Strategies 19.12 Summary 19.13 Exercises 19.14 Exercise Answers", " Chapter 19 Error Handling What You‚Äôll Learn: try() and tryCatch() Creating custom errors Warning and message handling Defensive programming Debugging strategies Key Errors Covered: 12+ error handling patterns Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 19.1 Introduction Error handling lets you gracefully handle problems: # Without error handling result &lt;- log(&quot;not a number&quot;) #&gt; Error in log(&quot;not a number&quot;): non-numeric argument to mathematical function # With error handling result &lt;- try(log(&quot;not a number&quot;), silent = TRUE) if (inherits(result, &quot;try-error&quot;)) { cat(&quot;Error occurred, using default value\\n&quot;) result &lt;- NA } #&gt; Error occurred, using default value result #&gt; [1] NA Let‚Äôs master error handling for robust code. 19.2 Error Basics üí° Key Insight: Errors, Warnings, Messages # Error: stops execution stop(&quot;This is an error&quot;) #&gt; Error: This is an error # Warning: continues execution warning(&quot;This is a warning&quot;) #&gt; Warning: This is a warning cat(&quot;Execution continues\\n&quot;) #&gt; Execution continues # Message: informational message(&quot;This is a message&quot;) #&gt; This is a message cat(&quot;Execution continues\\n&quot;) #&gt; Execution continues # Creating conditions # Error error_func &lt;- function(x) { if (x &lt; 0) { stop(&quot;x must be non-negative&quot;) } sqrt(x) } error_func(-5) #&gt; Error in error_func(-5): x must be non-negative # Warning warn_func &lt;- function(x) { if (x &lt; 0) { warning(&quot;x is negative, taking absolute value&quot;) x &lt;- abs(x) } sqrt(x) } warn_func(-5) #&gt; Warning in warn_func(-5): x is negative, taking absolute value #&gt; [1] 2.236068 # Message message_func &lt;- function(x) { message(&quot;Calculating square root of &quot;, x) sqrt(x) } message_func(25) #&gt; Calculating square root of 25 #&gt; [1] 5 19.3 try() üí° Key Insight: try() Basics # Without try: error stops everything safe_log &lt;- function(x) { result &lt;- try(log(x), silent = TRUE) if (inherits(result, &quot;try-error&quot;)) { return(NA) } result } # Test safe_log(10) # Works #&gt; [1] 2.302585 safe_log(&quot;text&quot;) # Returns NA instead of error #&gt; [1] NA # Process multiple values values &lt;- list(10, &quot;text&quot;, 100, &quot;more text&quot;, 50) results &lt;- lapply(values, safe_log) results #&gt; [[1]] #&gt; [1] 2.302585 #&gt; #&gt; [[2]] #&gt; [1] NA #&gt; #&gt; [[3]] #&gt; [1] 4.60517 #&gt; #&gt; [[4]] #&gt; [1] NA #&gt; #&gt; [[5]] #&gt; [1] 3.912023 # Or with verbose errors results_verbose &lt;- lapply(values, function(x) { try(log(x), silent = FALSE) }) #&gt; Error in log(x) : non-numeric argument to mathematical function #&gt; Error in log(x) : non-numeric argument to mathematical function When to use try(): - Simple error catching - Don‚Äôt need to distinguish error types - Want to return special value on error - Processing multiple items 19.4 tryCatch() üí° Key Insight: tryCatch() for Full Control # Full control over errors, warnings, messages safe_divide &lt;- function(x, y) { tryCatch( { # Try this code if (y == 0) stop(&quot;Division by zero&quot;) x / y }, error = function(e) { # Handle error message(&quot;Error: &quot;, e$message) return(Inf) }, warning = function(w) { # Handle warning message(&quot;Warning: &quot;, w$message) }, finally = { # Always runs (cleanup) message(&quot;Division attempted&quot;) } ) } safe_divide(10, 2) #&gt; Division attempted #&gt; [1] 5 safe_divide(10, 0) #&gt; Error: Division by zero #&gt; Division attempted #&gt; [1] Inf # More complex example read_data_safe &lt;- function(file) { tryCatch( { data &lt;- read.csv(file) message(&quot;Successfully read &quot;, nrow(data), &quot; rows&quot;) data }, error = function(e) { if (grepl(&quot;cannot open&quot;, e$message)) { stop(&quot;File not found: &quot;, file) } else if (grepl(&quot;more columns&quot;, e$message)) { stop(&quot;File format error in: &quot;, file) } else { stop(&quot;Unknown error reading: &quot;, file, &quot;\\n&quot;, e$message) } } ) } # Example with warnings sqrt_checked &lt;- function(x) { tryCatch( { if (!is.numeric(x)) { stop(&quot;Input must be numeric&quot;) } if (any(x &lt; 0)) { warning(&quot;Negative values detected, taking absolute value&quot;) x &lt;- abs(x) } sqrt(x) }, error = function(e) { message(&quot;Error: &quot;, e$message) return(rep(NA, length(x))) }, warning = function(w) { message(&quot;Warning caught: &quot;, w$message) # Re-signal the warning warning(w) } ) } sqrt_checked(c(4, -9, 16)) #&gt; Warning caught: Negative values detected, taking absolute value #&gt; Warning in doTryCatch(return(expr), name, parentenv, handler): Negative values #&gt; detected, taking absolute value tryCatch() handlers: - error: catches errors - warning: catches warnings - message: catches messages - finally: always runs (cleanup) 19.5 Custom Errors üéØ Best Practice: Custom Error Classes # Create custom error class validation_error &lt;- function(message, field = NULL) { structure( list(message = message, field = field), class = c(&quot;validation_error&quot;, &quot;error&quot;, &quot;condition&quot;) ) } # Function using custom errors validate_age &lt;- function(age) { if (!is.numeric(age)) { stop(validation_error( &quot;Age must be numeric&quot;, field = &quot;age&quot; )) } if (age &lt; 0) { stop(validation_error( &quot;Age cannot be negative&quot;, field = &quot;age&quot; )) } if (age &gt; 150) { stop(validation_error( &quot;Age seems unrealistic&quot;, field = &quot;age&quot; )) } TRUE } # Catch and handle custom errors process_age &lt;- function(age) { tryCatch( { validate_age(age) message(&quot;Valid age: &quot;, age) }, validation_error = function(e) { message(&quot;Validation failed for field &#39;&quot;, e$field, &quot;&#39;: &quot;, e$message) }, error = function(e) { message(&quot;Other error: &quot;, e$message) } ) } process_age(25) #&gt; Valid age: 25 process_age(-5) #&gt; Validation failed for field &#39;age&#39;: Age cannot be negative process_age(&quot;invalid&quot;) #&gt; Validation failed for field &#39;age&#39;: Age must be numeric # Multiple custom error types value_error &lt;- function(message, value = NULL) { structure( list(message = message, value = value), class = c(&quot;value_error&quot;, &quot;error&quot;, &quot;condition&quot;) ) } type_error &lt;- function(message, expected = NULL, got = NULL) { structure( list(message = message, expected = expected, got = got), class = c(&quot;type_error&quot;, &quot;error&quot;, &quot;condition&quot;) ) } # Function with multiple error types safe_calculate &lt;- function(x, y, op) { # Type checking if (!is.numeric(x) || !is.numeric(y)) { stop(type_error( &quot;Inputs must be numeric&quot;, expected = &quot;numeric&quot;, got = c(class(x)[1], class(y)[1]) )) } # Value checking if (op == &quot;/&quot; &amp;&amp; y == 0) { stop(value_error( &quot;Cannot divide by zero&quot;, value = y )) } # Calculate switch(op, &quot;+&quot; = x + y, &quot;-&quot; = x - y, &quot;*&quot; = x * y, &quot;/&quot; = x / y, stop(&quot;Unknown operation: &quot;, op) ) } # Handle different error types calculate_safe &lt;- function(x, y, op) { tryCatch( safe_calculate(x, y, op), type_error = function(e) { message(&quot;Type error: expected &quot;, e$expected, &quot;, got &quot;, paste(e$got, collapse = &quot;, &quot;)) NA }, value_error = function(e) { message(&quot;Value error: &quot;, e$message) Inf }, error = function(e) { message(&quot;Other error: &quot;, e$message) NA } ) } calculate_safe(10, 5, &quot;+&quot;) #&gt; [1] 15 calculate_safe(&quot;10&quot;, 5, &quot;+&quot;) #&gt; Type error: expected numeric, got character, numeric #&gt; [1] NA calculate_safe(10, 0, &quot;/&quot;) #&gt; Value error: Cannot divide by zero #&gt; [1] Inf 19.6 Defensive Programming üéØ Best Practice: Input Validation # Comprehensive validation calculate_mean &lt;- function(x, na.rm = FALSE, trim = 0) { # Check x exists and is not NULL if (missing(x)) { stop(&quot;Argument &#39;x&#39; is missing with no default&quot;) } if (is.null(x)) { stop(&quot;Argument &#39;x&#39; cannot be NULL&quot;) } # Check x type if (!is.numeric(x)) { stop(&quot;Argument &#39;x&#39; must be numeric, got &quot;, class(x)[1]) } # Check x length if (length(x) == 0) { warning(&quot;x has length 0, returning NA&quot;) return(NA_real_) } # Check na.rm type if (!is.logical(na.rm) || length(na.rm) != 1) { stop(&quot;Argument &#39;na.rm&#39; must be a single logical value&quot;) } # Check trim if (!is.numeric(trim) || length(trim) != 1) { stop(&quot;Argument &#39;trim&#39; must be a single numeric value&quot;) } if (trim &lt; 0 || trim &gt;= 0.5) { stop(&quot;Argument &#39;trim&#39; must be in [0, 0.5)&quot;) } # All validated, proceed mean(x, na.rm = na.rm, trim = trim) } # Test calculate_mean(1:10) #&gt; [1] 5.5 calculate_mean(c(1, 2, NA, 4), na.rm = TRUE) #&gt; [1] 2.333333 calculate_mean(&quot;not numeric&quot;) #&gt; Error in calculate_mean(&quot;not numeric&quot;): Argument &#39;x&#39; must be numeric, got character calculate_mean(1:10, na.rm = &quot;yes&quot;) #&gt; Error in calculate_mean(1:10, na.rm = &quot;yes&quot;): Argument &#39;na.rm&#39; must be a single logical value calculate_mean(1:10, trim = 0.6) #&gt; Error in calculate_mean(1:10, trim = 0.6): Argument &#39;trim&#39; must be in [0, 0.5) # Reusable validators is_single_numeric &lt;- function(x, name = &quot;argument&quot;) { if (!is.numeric(x) || length(x) != 1) { stop(name, &quot; must be a single numeric value&quot;) } TRUE } is_single_logical &lt;- function(x, name = &quot;argument&quot;) { if (!is.logical(x) || length(x) != 1) { stop(name, &quot; must be a single logical value&quot;) } TRUE } is_probability &lt;- function(x, name = &quot;argument&quot;) { is_single_numeric(x, name) if (x &lt; 0 || x &gt; 1) { stop(name, &quot; must be between 0 and 1&quot;) } TRUE } # Using validators sample_with_prob &lt;- function(x, size, prob) { is_probability(prob, &quot;prob&quot;) is_single_numeric(size, &quot;size&quot;) # ... rest of function } 19.7 Assertions üéØ Best Practice: Assertions # Simple assertions assert_that &lt;- function(condition, message = &quot;Assertion failed&quot;) { if (!condition) { stop(message, call. = FALSE) } invisible(TRUE) } # Usage calculate_discount &lt;- function(price, discount_pct) { assert_that(is.numeric(price), &quot;price must be numeric&quot;) assert_that(price &gt; 0, &quot;price must be positive&quot;) assert_that(is.numeric(discount_pct), &quot;discount_pct must be numeric&quot;) assert_that(discount_pct &gt;= 0 &amp;&amp; discount_pct &lt;= 100, &quot;discount_pct must be between 0 and 100&quot;) price * (1 - discount_pct / 100) } calculate_discount(100, 20) #&gt; [1] 80 calculate_discount(-100, 20) #&gt; Error: price must be positive calculate_discount(100, 150) #&gt; Error: discount_pct must be between 0 and 100 # Using assertthat package (if available) if (requireNamespace(&quot;assertthat&quot;, quietly = TRUE)) { library(assertthat) validate_input &lt;- function(x) { assert_that(is.numeric(x)) assert_that(length(x) &gt; 0) assert_that(all(!is.na(x))) } } #&gt; #&gt; Attaching package: &#39;assertthat&#39; #&gt; The following object is masked _by_ &#39;.GlobalEnv&#39;: #&gt; #&gt; assert_that #&gt; The following object is masked from &#39;package:tibble&#39;: #&gt; #&gt; has_name # Stopifnot (base R) calculate_ratio &lt;- function(x, y) { stopifnot( &quot;x must be numeric&quot; = is.numeric(x), &quot;y must be numeric&quot; = is.numeric(y), &quot;y cannot be zero&quot; = all(y != 0) ) x / y } calculate_ratio(10, 5) #&gt; [1] 2 calculate_ratio(10, 0) #&gt; Error in calculate_ratio(10, 0): y cannot be zero 19.8 Warnings and Suppression üí° Key Insight: Warning Control # Generate warning careful_sqrt &lt;- function(x) { if (any(x &lt; 0)) { warning(&quot;Negative values found, returning NaN for those&quot;) } sqrt(x) } careful_sqrt(c(4, -9, 16)) #&gt; Warning in careful_sqrt(c(4, -9, 16)): Negative values found, returning NaN for #&gt; those #&gt; Warning in sqrt(x): NaNs produced #&gt; [1] 2 NaN 4 # Suppress warnings suppressWarnings({ result &lt;- careful_sqrt(c(4, -9, 16)) }) result #&gt; [1] 2 NaN 4 # Capture warnings result &lt;- withCallingHandlers( careful_sqrt(c(4, -9, 16)), warning = function(w) { message(&quot;Caught warning: &quot;, w$message) } ) #&gt; Caught warning: Negative values found, returning NaN for those #&gt; Warning in careful_sqrt(c(4, -9, 16)): Negative values found, returning NaN for #&gt; those #&gt; Caught warning: NaNs produced #&gt; Warning in sqrt(x): NaNs produced # Turn warnings into errors options(warn = 2) # Warnings become errors careful_sqrt(c(4, -9, 16)) # Now errors! #&gt; Error in careful_sqrt(c(4, -9, 16)): (converted from warning) Negative values found, returning NaN for those options(warn = 0) # Reset to default # Suppress specific warnings suppressWarnings( log(-1), # Would warn: NaNs produced classes = &quot;warning&quot; ) #&gt; [1] NaN # Count warnings warn_count &lt;- 0 withCallingHandlers( { for (i in -5:5) { log(i) } }, warning = function(w) { warn_count &lt;&lt;- warn_count + 1 invokeRestart(&quot;muffleWarning&quot;) } ) cat(&quot;Warnings generated:&quot;, warn_count, &quot;\\n&quot;) #&gt; Warnings generated: 5 19.9 Error Recovery üéØ Best Practice: Graceful Failure # Provide defaults on error read_config &lt;- function(file, default = list()) { tryCatch( { config &lt;- read.csv(file) message(&quot;Loaded configuration from &quot;, file) config }, error = function(e) { warning(&quot;Could not read config file, using defaults: &quot;, e$message) default } ) } # Retry logic retry &lt;- function(expr, max_attempts = 3, wait = 1) { for (attempt in 1:max_attempts) { result &lt;- try(expr, silent = TRUE) if (!inherits(result, &quot;try-error&quot;)) { return(result) } if (attempt &lt; max_attempts) { message(&quot;Attempt &quot;, attempt, &quot; failed, retrying...&quot;) Sys.sleep(wait) } } stop(&quot;All &quot;, max_attempts, &quot; attempts failed&quot;) } # Simulate flaky function flaky_function &lt;- function() { if (runif(1) &lt; 0.7) { # 70% failure rate stop(&quot;Random failure&quot;) } &quot;Success!&quot; } # Use with retry # result &lt;- retry(flaky_function(), max_attempts = 5) # Fallback chain with_fallbacks &lt;- function(...) { funcs &lt;- list(...) for (i in seq_along(funcs)) { result &lt;- try(funcs[[i]](), silent = TRUE) if (!inherits(result, &quot;try-error&quot;)) { if (i &gt; 1) { message(&quot;Used fallback #&quot;, i) } return(result) } } stop(&quot;All fallback options failed&quot;) } # Example get_data &lt;- function() { with_fallbacks( function() { # Primary: read from file read.csv(&quot;data.csv&quot;) }, function() { # Fallback 1: read from backup read.csv(&quot;data_backup.csv&quot;) }, function() { # Fallback 2: use default data.frame(x = 1:10, y = 11:20) } ) } 19.10 on.exit() üí° Key Insight: Cleanup with on.exit() # Ensure cleanup happens write_temp_file &lt;- function(data) { temp_file &lt;- tempfile() # Ensure file is deleted even if error occurs on.exit(unlink(temp_file)) # Write data writeLines(data, temp_file) # Process (might error) processed &lt;- toupper(readLines(temp_file)) processed # temp_file automatically deleted here } write_temp_file(c(&quot;hello&quot;, &quot;world&quot;)) #&gt; [1] &quot;HELLO&quot; &quot;WORLD&quot; # Multiple cleanups complex_function &lt;- function() { conn &lt;- file(&quot;temp.txt&quot;, &quot;w&quot;) on.exit(close(conn), add = TRUE) old_wd &lt;- getwd() on.exit(setwd(old_wd), add = TRUE) old_par &lt;- par(mfrow = c(1, 1)) on.exit(par(old_par), add = TRUE) # Do work... # All cleanup happens automatically } # Conditional cleanup read_with_progress &lt;- function(file, show_progress = TRUE) { if (show_progress) { pb &lt;- txtProgressBar(max = 100, style = 3) on.exit(close(pb)) } # Read file... # Progress bar closed automatically if created } 19.11 Debugging Strategies üéØ Best Practice: Debugging Techniques # 1. Print debugging my_func &lt;- function(x, y) { cat(&quot;x =&quot;, x, &quot;\\n&quot;) cat(&quot;y =&quot;, y, &quot;\\n&quot;) result &lt;- x + y cat(&quot;result =&quot;, result, &quot;\\n&quot;) result } # 2. Browser debugging my_func_debug &lt;- function(x, y) { browser() # Pauses execution here result &lt;- x + y result } # 3. Conditional browser my_func_conditional &lt;- function(x, y) { result &lt;- x + y if (result &lt; 0) { browser() # Only pause if negative } result } # 4. Debug function debug(my_func) # Next call will enter debugger my_func(5, 10) undebug(my_func) # 5. Recover on error options(error = recover) # Enter debugger on error # ... run code ... options(error = NULL) # Reset # 6. Traceback tryCatch( { # Code that errors }, error = function(e) { cat(&quot;Error occurred:\\n&quot;) print(e) cat(&quot;\\nTraceback:\\n&quot;) print(sys.calls()) } ) 19.12 Summary Key Takeaways: try() for simple cases - Returns special object on error tryCatch() for full control - Handle errors, warnings, messages Custom error classes - Better error handling Validate inputs early - Defensive programming Use assertions - Make assumptions explicit on.exit() for cleanup - Ensures cleanup happens Debug systematically - browser(), debug(), traceback() Quick Reference: Function Purpose When to Use try() Simple error catching Don‚Äôt need error details tryCatch() Full error handling Need to handle differently stop() Raise error Invalid input/state warning() Non-fatal issue Questionable but proceeding message() Information Status updates on.exit() Cleanup Files, connections, state Error Handling: # try() result &lt;- try(risky_operation(), silent = TRUE) if (inherits(result, &quot;try-error&quot;)) { # Handle error } # tryCatch() tryCatch( { # Code that might error }, error = function(e) { # Handle error }, warning = function(w) { # Handle warning }, finally = { # Cleanup (always runs) } ) # Custom errors my_error &lt;- function(msg) { structure( list(message = msg), class = c(&quot;my_error&quot;, &quot;error&quot;, &quot;condition&quot;) ) } # Validation stopifnot( &quot;x must be positive&quot; = x &gt; 0, &quot;y must be numeric&quot; = is.numeric(y) ) # Cleanup on.exit(cleanup(), add = TRUE) Best Practices: # ‚úÖ Good tryCatch(expr, error = function(e) ...) # Explicit handling stopifnot(&quot;msg&quot; = condition) # Named conditions on.exit(cleanup(), add = TRUE) # Always cleanup Validate inputs early # Fail fast # ‚ùå Avoid try(expr, silent = TRUE) without check # Ignoring errors stop() without informative message # Unclear errors No input validation # Unclear failures Cleanup without on.exit() # May not run 19.13 Exercises üìù Exercise 1: Safe File Reader Write read_file_safe(file, default) that: 1. Tries to read the file 2. Returns default on error 3. Logs what happened 4. Handles missing file vs corrupt file differently üìù Exercise 2: Retry with Backoff Write retry_with_backoff(expr, max_attempts, initial_wait) that: 1. Retries failed operations 2. Doubles wait time after each failure 3. Returns result or final error 4. Logs attempts üìù Exercise 3: Input Validator Write validate_data_frame(df, required_cols, col_types) that: 1. Checks df is data frame 2. Verifies required columns present 3. Validates column types 4. Returns informative errors üìù Exercise 4: Transaction Pattern Write with_transaction(expr) that: 1. Sets up state before expr 2. Runs expr 3. Commits if successful 4. Rolls back if error 5. Always cleans up 19.14 Exercise Answers Click to see answers Exercise 1: read_file_safe &lt;- function(file, default = NULL, verbose = TRUE) { tryCatch( { # Check file exists if (!file.exists(file)) { stop(&quot;File not found: &quot;, file, call. = FALSE) } # Try to read data &lt;- readLines(file) if (verbose) { message(&quot;Successfully read &quot;, length(data), &quot; lines from &quot;, file) } data }, error = function(e) { # Classify error if (grepl(&quot;File not found&quot;, e$message)) { if (verbose) { warning(&quot;File does not exist: &quot;, file, &quot;, using default&quot;) } } else if (grepl(&quot;cannot open&quot;, e$message)) { if (verbose) { warning(&quot;Cannot open file: &quot;, file, &quot;, using default&quot;) } } else { if (verbose) { warning(&quot;Error reading file: &quot;, e$message, &quot;, using default&quot;) } } default } ) } # Test read_file_safe(&quot;nonexistent.txt&quot;, default = c(&quot;default&quot;, &quot;content&quot;)) #&gt; Warning in value[[3L]](cond): File does not exist: nonexistent.txt, using #&gt; default #&gt; [1] &quot;default&quot; &quot;content&quot; # Create test file writeLines(c(&quot;line 1&quot;, &quot;line 2&quot;), &quot;test.txt&quot;) read_file_safe(&quot;test.txt&quot;) #&gt; Successfully read 2 lines from test.txt #&gt; [1] &quot;line 1&quot; &quot;line 2&quot; unlink(&quot;test.txt&quot;) Exercise 2: retry_with_backoff &lt;- function(expr, max_attempts = 3, initial_wait = 1, verbose = TRUE) { wait_time &lt;- initial_wait for (attempt in 1:max_attempts) { result &lt;- try(expr, silent = TRUE) if (!inherits(result, &quot;try-error&quot;)) { if (verbose &amp;&amp; attempt &gt; 1) { message(&quot;Succeeded on attempt &quot;, attempt) } return(result) } # Failed error_msg &lt;- attr(result, &quot;condition&quot;)$message if (attempt &lt; max_attempts) { if (verbose) { message(&quot;Attempt &quot;, attempt, &quot;/&quot;, max_attempts, &quot; failed: &quot;, error_msg) message(&quot;Waiting &quot;, wait_time, &quot; seconds before retry...&quot;) } Sys.sleep(wait_time) wait_time &lt;- wait_time * 2 # Exponential backoff } else { stop(&quot;All &quot;, max_attempts, &quot; attempts failed. Last error: &quot;, error_msg) } } } # Test with flaky function attempt_counter &lt;- 0 flaky_operation &lt;- function() { attempt_counter &lt;&lt;- attempt_counter + 1 if (attempt_counter &lt; 3) { stop(&quot;Temporary failure&quot;) } &quot;Success!&quot; } attempt_counter &lt;- 0 result &lt;- retry_with_backoff( flaky_operation(), max_attempts = 5, initial_wait = 0.1 ) #&gt; Attempt 1/5 failed: Temporary failure #&gt; Waiting 0.1 seconds before retry... #&gt; Warning in doTryCatch(return(expr), name, parentenv, handler): restarting #&gt; interrupted promise evaluation #&gt; Attempt 2/5 failed: Temporary failure #&gt; Waiting 0.2 seconds before retry... #&gt; Warning in doTryCatch(return(expr), name, parentenv, handler): restarting #&gt; interrupted promise evaluation #&gt; Succeeded on attempt 3 result #&gt; [1] &quot;Success!&quot; Exercise 3: validate_data_frame &lt;- function(df, required_cols = NULL, col_types = NULL) { errors &lt;- character() # Check is data frame if (!is.data.frame(df)) { stop(&quot;Input must be a data frame, got &quot;, class(df)[1]) } # Check required columns if (!is.null(required_cols)) { missing_cols &lt;- setdiff(required_cols, names(df)) if (length(missing_cols) &gt; 0) { errors &lt;- c(errors, paste(&quot;Missing required columns:&quot;, paste(missing_cols, collapse = &quot;, &quot;)) ) } } # Check column types if (!is.null(col_types)) { for (col_name in names(col_types)) { expected_type &lt;- col_types[[col_name]] if (!col_name %in% names(df)) { errors &lt;- c(errors, paste(&quot;Column&quot;, col_name, &quot;not found for type checking&quot;) ) next } actual_type &lt;- class(df[[col_name]])[1] if (actual_type != expected_type) { errors &lt;- c(errors, paste(&quot;Column&quot;, col_name, &quot;has type&quot;, actual_type, &quot;but expected&quot;, expected_type) ) } } } # Report errors if (length(errors) &gt; 0) { stop(&quot;Data frame validation failed:\\n &quot;, paste(errors, collapse = &quot;\\n &quot;), call. = FALSE) } invisible(TRUE) } # Test df_good &lt;- data.frame( id = 1:5, name = letters[1:5], value = rnorm(5) ) validate_data_frame( df_good, required_cols = c(&quot;id&quot;, &quot;name&quot;), col_types = list(id = &quot;integer&quot;, name = &quot;character&quot;) ) df_bad &lt;- data.frame( id = letters[1:5], # Wrong type value = rnorm(5) ) validate_data_frame( df_bad, required_cols = c(&quot;id&quot;, &quot;name&quot;), # Missing name col_types = list(id = &quot;integer&quot;) # Wrong type ) #&gt; Error: Data frame validation failed: #&gt; Missing required columns: name #&gt; Column id has type character but expected integer Exercise 4: with_transaction &lt;- function(expr, setup = NULL, commit = NULL, rollback = NULL, cleanup = NULL) { # Setup state &lt;- NULL if (!is.null(setup)) { message(&quot;Setting up transaction...&quot;) state &lt;- setup() } # Ensure cleanup happens on.exit({ if (!is.null(cleanup)) { message(&quot;Cleaning up...&quot;) cleanup(state) } }) # Try operation result &lt;- tryCatch( { message(&quot;Executing transaction...&quot;) result &lt;- expr # Commit on success if (!is.null(commit)) { message(&quot;Committing transaction...&quot;) commit(state, result) } result }, error = function(e) { # Rollback on error if (!is.null(rollback)) { message(&quot;Error occurred, rolling back...&quot;) rollback(state) } stop(&quot;Transaction failed: &quot;, e$message, call. = FALSE) } ) result } # Example: Simulated database transaction db_transaction_example &lt;- function() { with_transaction( expr = { # Simulate operations message(&quot; Writing records...&quot;) Sys.sleep(0.1) # Simulate error if (runif(1) &lt; 0.3) { stop(&quot;Simulated database error&quot;) } message(&quot; Updates complete&quot;) list(rows_affected = 10) }, setup = function() { message(&quot; Opening connection&quot;) list(conn = &quot;connection_object&quot;) }, commit = function(state, result) { message(&quot; Committing changes&quot;) }, rollback = function(state) { message(&quot; Rolling back changes&quot;) }, cleanup = function(state) { message(&quot; Closing connection&quot;) } ) } # Try running (may succeed or fail) # db_transaction_example() "],["part-viii-data-manipulation-dplyr-tidyr.html", "Part VIII: Data Manipulation (dplyr &amp; tidyr)", " Part VIII: Data Manipulation (dplyr &amp; tidyr) "],["dplyr-intro.html", "Chapter 20 Introduction to dplyr 20.1 Introduction 20.2 dplyr Basics 20.3 The Pipe Operator 20.4 Error #1: object not found with pipes 20.5 filter() Basics 20.6 Error #2: Using = instead of == 20.7 select() Basics 20.8 Error #3: unused argument in select 20.9 mutate() Basics 20.10 Error #4: object not found in mutate 20.11 arrange() Basics 20.12 summarize() Basics 20.13 Common Patterns 20.14 Error #5: Forgetting to assign or print 20.15 Debugging dplyr Chains 20.16 Summary 20.17 Exercises 20.18 Exercise Answers", " Chapter 20 Introduction to dplyr What You‚Äôll Learn: dplyr basics and philosophy The pipe operator (%&gt;% and |&gt;) Core dplyr verbs Common dplyr errors Tidy evaluation basics Key Errors Covered: 20+ dplyr errors Difficulty: ‚≠ê‚≠ê Intermediate 20.1 Introduction dplyr revolutionized R data manipulation: library(dplyr) # Try to filter mtcars %&gt;% filter(mpg &gt; 20) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Works! But errors are common... mtcars %&gt;% filter(mpg &gt; 20 &amp; cyl = 4) # Oops! #&gt; Error in parse(text = input): &lt;text&gt;:2:34: unexpected &#39;=&#39; #&gt; 1: # Works! But errors are common... #&gt; 2: mtcars %&gt;% filter(mpg &gt; 20 &amp; cyl = #&gt; ^ Let‚Äôs master dplyr to avoid these pitfalls. 20.2 dplyr Basics üí° Key Insight: The dplyr Philosophy library(dplyr) # Core verbs (functions) # 1. filter() - keep rows # 2. select() - keep columns # 3. mutate() - create/modify columns # 4. arrange() - sort rows # 5. summarize() - aggregate data # 6. group_by() - group for operations # Each returns a data frame # Easy to chain with pipe # Example data head(mtcars) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 Key principles: - Each function does one thing well - First argument is always data - Returns a data frame - Works with pipes - NSE (non-standard evaluation) for column names 20.3 The Pipe Operator üí° Key Insight: Pipe Operators # Traditional nesting (hard to read) result &lt;- arrange( filter( select(mtcars, mpg, cyl, hp), mpg &gt; 20 ), desc(hp) ) #&gt; Error in select(mtcars, mpg, cyl, hp): unused arguments (mpg, cyl, hp) # With magrittr pipe %&gt;% result &lt;- mtcars %&gt;% select(mpg, cyl, hp) %&gt;% filter(mpg &gt; 20) %&gt;% arrange(desc(hp)) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Native pipe |&gt; (R &gt;= 4.1) result &lt;- mtcars |&gt; select(mpg, cyl, hp) |&gt; filter(mpg &gt; 20) |&gt; arrange(desc(hp)) #&gt; Error in select(mtcars, mpg, cyl, hp): unused arguments (mpg, cyl, hp) result #&gt; [1] &quot;Success!&quot; # How pipe works # x %&gt;% f(y) becomes f(x, y) # x %&gt;% f(y) %&gt;% g(z) becomes g(f(x, y), z) # Pipe sends left side as first argument to right side mtcars %&gt;% head(3) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 # Same as: head(mtcars, 3) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 Differences between %&gt;% and |&gt;: - %&gt;% from magrittr (more flexible) - |&gt; native R (R &gt;= 4.1, faster) - %&gt;% has more features (., shortcuts) - |&gt; simpler, no package needed 20.4 Error #1: object not found with pipes ‚≠ê BEGINNER üîç SCOPE 20.4.1 The Error library(dplyr) mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) %&gt;% arrange(horsepower) # Wrong column name! #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) üî¥ ERROR Error in arrange(): ! Can&#39;t subset columns that don&#39;t exist. ‚úñ Column `horsepower` doesn&#39;t exist. 20.4.2 What It Means You‚Äôre referencing a column that doesn‚Äôt exist in the data. 20.4.3 Common Causes 20.4.3.1 Cause 1: Typo in Column Name mtcars %&gt;% select(mpgg, cyl) # Typo: mpgg instead of mpg #&gt; Error in select(., mpgg, cyl): unused arguments (mpgg, cyl) 20.4.3.2 Cause 2: Column Already Removed mtcars %&gt;% select(mpg, cyl) %&gt;% filter(hp &gt; 100) # hp not in selected columns! #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) 20.4.3.3 Cause 3: Wrong Dataset # Expecting different columns iris %&gt;% select(mpg, cyl) # iris doesn&#39;t have these columns #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) 20.4.4 Solutions ‚úÖ SOLUTION 1: Check Column Names # Before piping, check what you have names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; # Or with glimpse glimpse(mtcars) #&gt; Rows: 32 #&gt; Columns: 11 #&gt; $ mpg &lt;dbl&gt; 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2, 17.8,‚Ä¶ #&gt; $ cyl &lt;dbl&gt; 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8,‚Ä¶ #&gt; $ disp &lt;dbl&gt; 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7, 140.8, 16‚Ä¶ #&gt; $ hp &lt;dbl&gt; 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180, 180, 180‚Ä¶ #&gt; $ drat &lt;dbl&gt; 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92, 3.92,‚Ä¶ #&gt; $ wt &lt;dbl&gt; 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190, 3.150, 3.‚Ä¶ #&gt; $ qsec &lt;dbl&gt; 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00, 22.90, 18‚Ä¶ #&gt; $ vs &lt;dbl&gt; 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,‚Ä¶ #&gt; $ am &lt;dbl&gt; 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,‚Ä¶ #&gt; $ gear &lt;dbl&gt; 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4, 4, 3, 3,‚Ä¶ #&gt; $ carb &lt;dbl&gt; 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2, 1, 1, 2,‚Ä¶ # In pipe chain mtcars %&gt;% names() #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; ‚úÖ SOLUTION 2: Order Operations Correctly # Filter before selecting mtcars %&gt;% filter(hp &gt; 100) %&gt;% # Use hp while it exists select(mpg, cyl) # Then select subset #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) # Or keep needed columns mtcars %&gt;% select(mpg, cyl, hp) %&gt;% # Keep hp filter(hp &gt; 100) # Now can use it #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) ‚úÖ SOLUTION 3: Use Column Existence Check safe_filter &lt;- function(data, ...) { # Check if columns exist expr &lt;- rlang::enexpr(...) cols_used &lt;- all.vars(expr) missing_cols &lt;- setdiff(cols_used, names(data)) if (length(missing_cols) &gt; 0) { stop(&quot;Columns not found: &quot;, paste(missing_cols, collapse = &quot;, &quot;)) } filter(data, ...) } # Will give helpful error # mtcars %&gt;% safe_filter(horsepower &gt; 100) 20.5 filter() Basics üí° Key Insight: filter() Patterns # Keep rows where condition is TRUE mtcars %&gt;% filter(mpg &gt; 20) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Multiple conditions (AND) mtcars %&gt;% filter(mpg &gt; 20, cyl == 4) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 2 rows ] # Same as mtcars %&gt;% filter(mpg &gt; 20 &amp; cyl == 4) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 2 rows ] # OR condition mtcars %&gt;% filter(mpg &gt; 25 | hp &gt; 200) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Camaro Z28 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 4 rows ] # Complex conditions mtcars %&gt;% filter(mpg &gt; 20 &amp; (cyl == 4 | cyl == 6)) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Using %in% mtcars %&gt;% filter(cyl %in% c(4, 6)) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 9 rows ] # Negation mtcars %&gt;% filter(!(cyl %in% c(4, 6))) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Or mtcars %&gt;% filter(!cyl %in% c(4, 6)) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 #&gt; Lincoln Continental 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 #&gt; Chrysler Imperial 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 #&gt; Dodge Challenger 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Filter with string operations mtcars %&gt;% rownames_to_column(&quot;car&quot;) %&gt;% filter(grepl(&quot;Merc&quot;, car)) #&gt; car mpg cyl disp hp drat wt qsec vs am gear carb #&gt; 1 Merc 240D 24.4 4 146.7 62 3.69 3.19 20.0 1 0 4 2 #&gt; 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 #&gt; 3 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 #&gt; 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 #&gt; 5 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 #&gt; 6 Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 #&gt; 7 Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.0 0 0 3 3 # Remove NAs data_with_na &lt;- tibble(x = c(1, 2, NA, 4)) data_with_na %&gt;% filter(!is.na(x)) #&gt; # A tibble: 3 √ó 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 #&gt; 2 2 #&gt; 3 4 20.6 Error #2: Using = instead of == ‚≠ê BEGINNER üî§ SYNTAX 20.6.1 The Error mtcars %&gt;% filter(cyl = 4) # Wrong: = is assignment #&gt; Error in `filter()`: #&gt; ! We detected a named input. #&gt; ‚Ñπ This usually means that you&#39;ve used `=` instead of `==`. #&gt; ‚Ñπ Did you mean `cyl == 4`? üî¥ ERROR Error in filter(): ! We detected a named input. ‚Ñπ This usually means that you&#39;ve used `=` instead of `==`. ‚Ñπ Did you mean `cyl == 4`? 20.6.2 What It Means You used assignment (=) instead of comparison (==). 20.6.3 Solutions ‚úÖ SOLUTION: Use == for Comparison # Correct: use == mtcars %&gt;% filter(cyl == 4) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 #&gt; Porsche 914-2 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 2 rows ] # Other comparison operators mtcars %&gt;% filter(mpg &gt; 20) # Greater than #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] mtcars %&gt;% filter(mpg &gt;= 20) # Greater or equal #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] mtcars %&gt;% filter(mpg &lt; 20) # Less than #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.84 0 0 3 4 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 17.98 0 0 3 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 9 rows ] mtcars %&gt;% filter(mpg &lt;= 20) # Less or equal #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.44 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.46 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.57 15.84 0 0 3 4 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.44 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.44 18.90 1 0 4 4 #&gt; Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.40 0 0 3 3 #&gt; Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.60 0 0 3 3 #&gt; Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18.00 0 0 3 3 #&gt; Cadillac Fleetwood 10.4 8 472.0 205 2.93 5.25 17.98 0 0 3 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 9 rows ] mtcars %&gt;% filter(mpg != 4) # Not equal #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 23 rows ] # For NA, use is.na() data_with_na &lt;- tibble(x = c(1, NA, 3)) data_with_na %&gt;% filter(is.na(x)) # Keep NAs #&gt; # A tibble: 1 √ó 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 NA data_with_na %&gt;% filter(!is.na(x)) # Remove NAs #&gt; # A tibble: 2 √ó 1 #&gt; x #&gt; &lt;dbl&gt; #&gt; 1 1 #&gt; 2 3 20.7 select() Basics üí° Key Insight: select() Patterns # Select specific columns mtcars %&gt;% select(mpg, cyl, hp) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Select range mtcars %&gt;% select(mpg:hp) #&gt; Error in select(., mpg:hp): unused argument (mpg:hp) # Select by position mtcars %&gt;% select(1:3) #&gt; Error in select(., 1:3): unused argument (1:3) # Exclude columns mtcars %&gt;% select(-mpg, -cyl) #&gt; Error in select(., -mpg, -cyl): unused arguments (-mpg, -cyl) # Exclude range mtcars %&gt;% select(-(mpg:disp)) #&gt; Error in select(., -(mpg:disp)): unused argument (-(mpg:disp)) # Helper functions # starts_with() iris %&gt;% select(starts_with(&quot;Sepal&quot;)) #&gt; Error in select(., starts_with(&quot;Sepal&quot;)): unused argument (starts_with(&quot;Sepal&quot;)) # ends_with() iris %&gt;% select(ends_with(&quot;Width&quot;)) #&gt; Error in select(., ends_with(&quot;Width&quot;)): unused argument (ends_with(&quot;Width&quot;)) # contains() iris %&gt;% select(contains(&quot;etal&quot;)) #&gt; Error in select(., contains(&quot;etal&quot;)): unused argument (contains(&quot;etal&quot;)) # matches() - regex mtcars %&gt;% select(matches(&quot;^d&quot;)) # Starts with &#39;d&#39; #&gt; Error in select(., matches(&quot;^d&quot;)): unused argument (matches(&quot;^d&quot;)) # everything() - all remaining mtcars %&gt;% select(mpg, cyl, everything()) #&gt; Error in select(., mpg, cyl, everything()): unused arguments (mpg, cyl, everything()) # where() - by condition mtcars %&gt;% select(where(is.numeric)) #&gt; Error in select(., where(is.numeric)): unused argument (where(is.numeric)) # Rename while selecting mtcars %&gt;% select(miles_per_gallon = mpg, cylinders = cyl) #&gt; Error in select(., miles_per_gallon = mpg, cylinders = cyl): unused arguments (miles_per_gallon = mpg, cylinders = cyl) # Just rename (keep all) mtcars %&gt;% rename(miles_per_gallon = mpg) #&gt; miles_per_gallon cyl disp hp drat wt qsec vs am gear #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 #&gt; Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 #&gt; Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 #&gt; carb #&gt; Mazda RX4 4 #&gt; Mazda RX4 Wag 4 #&gt; Datsun 710 1 #&gt; Hornet 4 Drive 1 #&gt; Hornet Sportabout 2 #&gt; Valiant 1 #&gt; Duster 360 4 #&gt; Merc 240D 2 #&gt; Merc 230 2 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 23 rows ] 20.8 Error #3: unused argument in select ‚≠ê‚≠ê INTERMEDIATE üìã ARGS 20.8.1 The Error mtcars %&gt;% select(mpg, cyl, cyl == 4) # Can&#39;t filter in select! #&gt; Error in select(., mpg, cyl, cyl == 4): unused arguments (mpg, cyl, cyl == 4) üî¥ ERROR Error in select(): ! Can&#39;t subset columns with `cyl == 4`. ‚úñ `cyl == 4` must be numeric or character, not `logical`. 20.8.2 What It Means You‚Äôre trying to use filter logic in select, or using wrong syntax. 20.8.3 Common Causes # Trying to filter in select mtcars %&gt;% select(mpg, cyl &gt; 4) #&gt; Error in select(., mpg, cyl &gt; 4): unused arguments (mpg, cyl &gt; 4) # Wrong helper syntax mtcars %&gt;% select(starts_with(Sepal)) # Missing quotes #&gt; Error in select(., starts_with(Sepal)): unused argument (starts_with(Sepal)) 20.8.4 Solutions ‚úÖ SOLUTION: Separate select and filter # Correct: separate operations mtcars %&gt;% select(mpg, cyl, hp) %&gt;% filter(cyl == 4) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Or filter first mtcars %&gt;% filter(cyl == 4) %&gt;% select(mpg, cyl, hp) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Use quotes with helpers iris %&gt;% select(starts_with(&quot;Sepal&quot;)) #&gt; Error in select(., starts_with(&quot;Sepal&quot;)): unused argument (starts_with(&quot;Sepal&quot;)) 20.9 mutate() Basics üí° Key Insight: mutate() Patterns # Create new column mtcars %&gt;% mutate(mpg_per_cyl = mpg / cyl) %&gt;% select(mpg, cyl, mpg_per_cyl) #&gt; Error in select(., mpg, cyl, mpg_per_cyl): unused arguments (mpg, cyl, mpg_per_cyl) # Multiple new columns mtcars %&gt;% mutate( kpl = mpg * 0.425, wt_kg = wt * 453.592 ) %&gt;% select(mpg, kpl, wt, wt_kg) #&gt; Error in select(., mpg, kpl, wt, wt_kg): unused arguments (mpg, kpl, wt, wt_kg) # Modify existing column mtcars %&gt;% mutate(hp = hp * 0.746) %&gt;% # Convert to kW select(hp) #&gt; Error in select(., hp): unused argument (hp) # Use newly created columns mtcars %&gt;% mutate( hp_per_cyl = hp / cyl, hp_ratio = hp_per_cyl / mean(hp_per_cyl) ) %&gt;% select(hp, cyl, hp_per_cyl, hp_ratio) #&gt; Error in select(., hp, cyl, hp_per_cyl, hp_ratio): unused arguments (hp, cyl, hp_per_cyl, hp_ratio) # Conditional creation mtcars %&gt;% mutate( efficiency = case_when( mpg &gt; 25 ~ &quot;High&quot;, mpg &gt; 20 ~ &quot;Medium&quot;, TRUE ~ &quot;Low&quot; ) ) %&gt;% select(mpg, efficiency) #&gt; Error in select(., mpg, efficiency): unused arguments (mpg, efficiency) # With ifelse mtcars %&gt;% mutate( heavy = ifelse(wt &gt; 3.5, &quot;Heavy&quot;, &quot;Light&quot;) ) %&gt;% select(wt, heavy) #&gt; Error in select(., wt, heavy): unused arguments (wt, heavy) # Keep only new columns with transmute() mtcars %&gt;% transmute( car = rownames(mtcars), kpl = mpg * 0.425 ) #&gt; car kpl #&gt; Mazda RX4 Mazda RX4 8.9250 #&gt; Mazda RX4 Wag Mazda RX4 Wag 8.9250 #&gt; Datsun 710 Datsun 710 9.6900 #&gt; Hornet 4 Drive Hornet 4 Drive 9.0950 #&gt; Hornet Sportabout Hornet Sportabout 7.9475 #&gt; Valiant Valiant 7.6925 #&gt; Duster 360 Duster 360 6.0775 #&gt; Merc 240D Merc 240D 10.3700 #&gt; Merc 230 Merc 230 9.6900 #&gt; Merc 280 Merc 280 8.1600 #&gt; Merc 280C Merc 280C 7.5650 #&gt; Merc 450SE Merc 450SE 6.9700 #&gt; Merc 450SL Merc 450SL 7.3525 #&gt; Merc 450SLC Merc 450SLC 6.4600 #&gt; Cadillac Fleetwood Cadillac Fleetwood 4.4200 #&gt; Lincoln Continental Lincoln Continental 4.4200 #&gt; Chrysler Imperial Chrysler Imperial 6.2475 #&gt; Fiat 128 Fiat 128 13.7700 #&gt; Honda Civic Honda Civic 12.9200 #&gt; Toyota Corolla Toyota Corolla 14.4075 #&gt; Toyota Corona Toyota Corona 9.1375 #&gt; Dodge Challenger Dodge Challenger 6.5875 #&gt; AMC Javelin AMC Javelin 6.4600 #&gt; Camaro Z28 Camaro Z28 5.6525 #&gt; Pontiac Firebird Pontiac Firebird 8.1600 #&gt; Fiat X1-9 Fiat X1-9 11.6025 #&gt; Porsche 914-2 Porsche 914-2 11.0500 #&gt; Lotus Europa Lotus Europa 12.9200 #&gt; Ford Pantera L Ford Pantera L 6.7150 #&gt; Ferrari Dino Ferrari Dino 8.3725 #&gt; Maserati Bora Maserati Bora 6.3750 #&gt; Volvo 142E Volvo 142E 9.0950 20.10 Error #4: object not found in mutate ‚≠ê‚≠ê INTERMEDIATE üîç SCOPE 20.10.1 The Error mpg_threshold &lt;- 20 mtcars %&gt;% mutate(efficient = mpg &gt; mpg_treshold) # Typo! #&gt; Error in `mutate()`: #&gt; ‚Ñπ In argument: `efficient = mpg &gt; mpg_treshold`. #&gt; Caused by error: #&gt; ! object &#39;mpg_treshold&#39; not found üî¥ ERROR Error in mutate(): ! object &#39;mpg_treshold&#39; not found 20.10.2 What It Means Referenced an object or column that doesn‚Äôt exist. 20.10.3 Common Causes # Typo in external variable threshold &lt;- 20 mtcars %&gt;% mutate(high = mpg &gt; threshhold) #&gt; Error in `mutate()`: #&gt; ‚Ñπ In argument: `high = mpg &gt; threshhold`. #&gt; Caused by error: #&gt; ! object &#39;threshhold&#39; not found # Typo in column name mtcars %&gt;% mutate(power_ratio = horsepower / wt) #&gt; Error in `mutate()`: #&gt; ‚Ñπ In argument: `power_ratio = horsepower/wt`. #&gt; Caused by error: #&gt; ! object &#39;horsepower&#39; not found # Using column before creating it mtcars %&gt;% mutate( mpg_ratio = mpg_scaled / mean(mpg_scaled), mpg_scaled = mpg / mean(mpg) ) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 #&gt; mpg_ratio mpg_scaled #&gt; Mazda RX4 2.121443e+15 1.0452636 #&gt; Mazda RX4 Wag 2.121443e+15 1.0452636 #&gt; Datsun 710 6.320589e+15 1.1348577 #&gt; Hornet 4 Drive 3.054587e+15 1.0651734 #&gt; Hornet Sportabout -3.244132e+15 0.9307824 #&gt; Valiant -4.643847e+15 0.9009177 #&gt; Duster 360 -1.350871e+16 0.7117748 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 25 rows ] 20.10.4 Solutions ‚úÖ SOLUTION 1: Check Names Carefully # Check column names names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; # Check variable exists threshold &lt;- 20 exists(&quot;threshold&quot;) #&gt; [1] TRUE # Correct usage mtcars %&gt;% mutate(efficient = mpg &gt; threshold) %&gt;% select(mpg, efficient) #&gt; Error in select(., mpg, efficient): unused arguments (mpg, efficient) ‚úÖ SOLUTION 2: Order Operations # Create columns in right order mtcars %&gt;% mutate( mpg_scaled = mpg / mean(mpg), mpg_ratio = mpg_scaled / mean(mpg_scaled) ) %&gt;% select(mpg, mpg_scaled, mpg_ratio) #&gt; Error in select(., mpg, mpg_scaled, mpg_ratio): unused arguments (mpg, mpg_scaled, mpg_ratio) ‚úÖ SOLUTION 3: Use .data pronoun # Explicit about column reference mtcars %&gt;% mutate(power_ratio = .data$hp / .data$wt) %&gt;% select(hp, wt, power_ratio) #&gt; Error in select(., hp, wt, power_ratio): unused arguments (hp, wt, power_ratio) # Useful in functions calculate_ratio &lt;- function(data, num_col, denom_col) { data %&gt;% mutate(ratio = .data[[num_col]] / .data[[denom_col]]) } calculate_ratio(mtcars, &quot;hp&quot;, &quot;wt&quot;) %&gt;% select(hp, wt, ratio) #&gt; Error in select(., hp, wt, ratio): unused arguments (hp, wt, ratio) 20.11 arrange() Basics üí° Key Insight: arrange() Patterns # Sort ascending (default) mtcars %&gt;% arrange(mpg) %&gt;% select(mpg, cyl, hp) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Sort descending mtcars %&gt;% arrange(desc(mpg)) %&gt;% select(mpg, cyl, hp) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Multiple columns mtcars %&gt;% arrange(cyl, desc(mpg)) %&gt;% select(cyl, mpg, hp) #&gt; Error in select(., cyl, mpg, hp): unused arguments (cyl, mpg, hp) # With NA handling data_with_na &lt;- tibble( x = c(3, 1, NA, 2), y = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) data_with_na %&gt;% arrange(x) # NAs last by default #&gt; # A tibble: 4 √ó 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 b #&gt; 2 2 d #&gt; 3 3 a #&gt; 4 NA c # NAs first data_with_na %&gt;% arrange(desc(is.na(x)), x) #&gt; # A tibble: 4 √ó 2 #&gt; x y #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 NA c #&gt; 2 1 b #&gt; 3 2 d #&gt; 4 3 a 20.12 summarize() Basics üí° Key Insight: summarize() Patterns # Single summary mtcars %&gt;% summarize(avg_mpg = mean(mpg)) #&gt; avg_mpg #&gt; 1 20.09062 # Multiple summaries mtcars %&gt;% summarize( avg_mpg = mean(mpg), sd_mpg = sd(mpg), min_mpg = min(mpg), max_mpg = max(mpg), n = n() ) #&gt; avg_mpg sd_mpg min_mpg max_mpg n #&gt; 1 20.09062 6.026948 10.4 33.9 32 # With grouping (next chapter covers in detail) mtcars %&gt;% group_by(cyl) %&gt;% summarize( avg_mpg = mean(mpg), count = n() ) #&gt; # A tibble: 3 √ó 3 #&gt; cyl avg_mpg count #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 26.7 11 #&gt; 2 6 19.7 7 #&gt; 3 8 15.1 14 # Useful summary functions mtcars %&gt;% summarize( mean = mean(mpg), median = median(mpg), sd = sd(mpg), min = min(mpg), max = max(mpg), q25 = quantile(mpg, 0.25), q75 = quantile(mpg, 0.75), n = n(), n_distinct = n_distinct(cyl) ) #&gt; mean median sd min max q25 q75 n n_distinct #&gt; 1 20.09062 19.2 6.026948 10.4 33.9 15.425 22.8 32 3 20.13 Common Patterns üéØ Best Practice: Common dplyr Workflows # 1. Filter ‚Üí Select ‚Üí Arrange mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) %&gt;% arrange(desc(mpg)) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # 2. Create variables ‚Üí Summarize mtcars %&gt;% mutate(hp_per_cyl = hp / cyl) %&gt;% summarize( avg_hp_per_cyl = mean(hp_per_cyl), max_hp_per_cyl = max(hp_per_cyl) ) #&gt; avg_hp_per_cyl max_hp_per_cyl #&gt; 1 23.0013 41.875 # 3. Group ‚Üí Summarize ‚Üí Arrange mtcars %&gt;% group_by(cyl) %&gt;% summarize( avg_mpg = mean(mpg), count = n() ) %&gt;% arrange(desc(avg_mpg)) #&gt; # A tibble: 3 √ó 3 #&gt; cyl avg_mpg count #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 26.7 11 #&gt; 2 6 19.7 7 #&gt; 3 8 15.1 14 # 4. Top N mtcars %&gt;% arrange(desc(mpg)) %&gt;% slice_head(n = 5) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 # 5. Distinct values mtcars %&gt;% distinct(cyl, gear) #&gt; cyl gear #&gt; Mazda RX4 6 4 #&gt; Datsun 710 4 4 #&gt; Hornet 4 Drive 6 3 #&gt; Hornet Sportabout 8 3 #&gt; Toyota Corona 4 3 #&gt; Porsche 914-2 4 5 #&gt; Ford Pantera L 8 5 #&gt; Ferrari Dino 6 5 # 6. Count mtcars %&gt;% count(cyl, sort = TRUE) #&gt; cyl n #&gt; 1 8 14 #&gt; 2 4 11 #&gt; 3 6 7 # 7. Add row numbers mtcars %&gt;% mutate(row_id = row_number()) %&gt;% select(row_id, everything()) #&gt; Error in select(., row_id, everything()): unused arguments (row_id, everything()) 20.14 Error #5: Forgetting to assign or print ‚≠ê BEGINNER üí° USAGE 20.14.1 The Problem # Doesn&#39;t save result! mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl) #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) # Original unchanged head(mtcars, 2) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21 6 160 110 3.9 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 20.14.2 What It Means dplyr doesn‚Äôt modify in place - must assign result. 20.14.3 Solutions ‚úÖ SOLUTION 1: Assign Result # Save to new variable high_mpg &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl) #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) head(high_mpg, 3) #&gt; Error: object &#39;high_mpg&#39; not found # Or overwrite (careful!) mtcars_filtered &lt;- mtcars %&gt;% filter(mpg &gt; 20) ‚úÖ SOLUTION 2: Just Print (for exploration) # Print automatically (no assignment) mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl) #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) # Explicit print mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl) %&gt;% print() #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) 20.15 Debugging dplyr Chains üéØ Best Practice: Debug Pipe Chains # 1. Run step by step # Start here mtcars %&gt;% filter(mpg &gt; 20) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Add next step mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Continue... mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) %&gt;% arrange(desc(hp)) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # 2. Check intermediate results mtcars %&gt;% filter(mpg &gt; 20) %&gt;% {cat(&quot;After filter:&quot;, nrow(.), &quot;rows\\n&quot;); .} %&gt;% select(mpg, cyl, hp) %&gt;% {cat(&quot;After select:&quot;, ncol(.), &quot;cols\\n&quot;); .} %&gt;% arrange(desc(hp)) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # 3. Use View() in RStudio # mtcars %&gt;% # filter(mpg &gt; 20) %&gt;% # View() # 4. Print at each step debug_pipe &lt;- function(data, label = NULL) { if (!is.null(label)) { cat(&quot;\\n===&quot;, label, &quot;===\\n&quot;) } print(head(data, 3)) data } mtcars %&gt;% filter(mpg &gt; 20) %&gt;% debug_pipe(&quot;After filter&quot;) %&gt;% select(mpg, cyl, hp) %&gt;% debug_pipe(&quot;After select&quot;) #&gt; #&gt; === After select === #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) 20.16 Summary Key Takeaways: dplyr philosophy - Simple verbs, chainable with pipes Pipe operator - %&gt;% or |&gt; makes code readable filter() uses == - Not = for comparison Check column names - Use names() or glimpse() Order matters - Can‚Äôt use columns after removing them Assign results - dplyr doesn‚Äôt modify in place Debug step-by-step - Run pipes incrementally Quick Reference: Error Cause Fix object not found Column doesn‚Äôt exist Check names, order operations Using = not == Assignment in filter Use == for comparison unused argument Wrong function usage Check function signature Result not saved No assignment Assign with &lt;- Core Verbs: # filter() - keep rows data %&gt;% filter(condition) # select() - keep columns data %&gt;% select(col1, col2) # mutate() - create columns data %&gt;% mutate(new_col = expression) # arrange() - sort rows data %&gt;% arrange(col) data %&gt;% arrange(desc(col)) # summarize() - aggregate data %&gt;% summarize(stat = function(col)) # Common helpers starts_with(&quot;prefix&quot;) ends_with(&quot;suffix&quot;) contains(&quot;text&quot;) where(is.numeric) everything() Best Practices: # ‚úÖ Good data %&gt;% filter(col == value) # Use == data %&gt;% select(col1, col2) # Select then filter if needed names(data) # Check before selecting result &lt;- data %&gt;% ... # Assign result # ‚ùå Avoid data %&gt;% filter(col = value) # Using = data %&gt;% select(col) %&gt;% # Then try to use removed col filter(other_col &gt; 5) data %&gt;% filter(...) # no assign # Result lost 20.17 Exercises üìù Exercise 1: Basic Pipeline Use mtcars to: 1. Filter cars with mpg &gt; 20 2. Select mpg, cyl, hp, wt 3. Create hp_per_ton = hp / wt 4. Arrange by hp_per_ton descending 5. Show top 5 üìù Exercise 2: Error Fixing Fix these errors: # Error 1 mtcars %&gt;% filter(cyl = 6) # Error 2 mtcars %&gt;% select(mpg, cyl) %&gt;% filter(hp &gt; 100) # Error 3 mtcars %&gt;% mutate(ratio = mpg_per_cyl / wt) %&gt;% mutate(mpg_per_cyl = mpg / cyl) üìù Exercise 3: Safe Select Write safe_select(data, ...) that: 1. Checks columns exist before selecting 2. Gives helpful error if not found 3. Suggests similar names 4. Works with select helpers üìù Exercise 4: Summary Report Create function summarize_by_group(data, group_col, value_col) that: 1. Groups by specified column 2. Summarizes mean, median, sd, min, max 3. Counts observations 4. Returns sorted by mean descending 20.18 Exercise Answers Click to see answers Exercise 1: result &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp, wt) %&gt;% mutate(hp_per_ton = hp / wt) %&gt;% arrange(desc(hp_per_ton)) %&gt;% slice_head(n = 5) #&gt; Error in select(., mpg, cyl, hp, wt): unused arguments (mpg, cyl, hp, wt) result #&gt; [1] &quot;Success!&quot; # Alternative: use top_n (deprecated but still works) mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp, wt) %&gt;% mutate(hp_per_ton = hp / wt) %&gt;% slice_max(hp_per_ton, n = 5) #&gt; Error in select(., mpg, cyl, hp, wt): unused arguments (mpg, cyl, hp, wt) Exercise 2: # Error 1: Use == not = mtcars %&gt;% filter(cyl == 6) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 #&gt; Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 #&gt; Merc 280C 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 #&gt; Ferrari Dino 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 # Error 2: Keep hp column or filter before select # Option A: Select hp too mtcars %&gt;% select(mpg, cyl, hp) %&gt;% filter(hp &gt; 100) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Option B: Filter first mtcars %&gt;% filter(hp &gt; 100) %&gt;% select(mpg, cyl) #&gt; Error in select(., mpg, cyl): unused arguments (mpg, cyl) # Error 3: Create mpg_per_cyl before using it mtcars %&gt;% mutate(mpg_per_cyl = mpg / cyl) %&gt;% mutate(ratio = mpg_per_cyl / wt) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 #&gt; mpg_per_cyl ratio #&gt; Mazda RX4 3.500000 1.3358779 #&gt; Mazda RX4 Wag 3.500000 1.2173913 #&gt; Datsun 710 5.700000 2.4568966 #&gt; Hornet 4 Drive 3.566667 1.1093831 #&gt; Hornet Sportabout 2.337500 0.6795058 #&gt; Valiant 3.016667 0.8718690 #&gt; Duster 360 1.787500 0.5007003 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 25 rows ] # Or in one mutate mtcars %&gt;% mutate( mpg_per_cyl = mpg / cyl, ratio = mpg_per_cyl / wt ) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 #&gt; mpg_per_cyl ratio #&gt; Mazda RX4 3.500000 1.3358779 #&gt; Mazda RX4 Wag 3.500000 1.2173913 #&gt; Datsun 710 5.700000 2.4568966 #&gt; Hornet 4 Drive 3.566667 1.1093831 #&gt; Hornet Sportabout 2.337500 0.6795058 #&gt; Valiant 3.016667 0.8718690 #&gt; Duster 360 1.787500 0.5007003 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 25 rows ] Exercise 3: safe_select &lt;- function(data, ...) { # Capture expressions cols &lt;- rlang::enquos(...) # Get all column names in data data_cols &lt;- names(data) # Evaluate each selection for (col_expr in cols) { col_name &lt;- rlang::as_name(col_expr) # Skip if it&#39;s a helper function call if (grepl(&quot;^(starts_with|ends_with|contains|matches|everything|where)&quot;, col_name)) { next } # Check if column exists if (!col_name %in% data_cols) { # Find similar names similar &lt;- agrep(col_name, data_cols, max.distance = 0.3, value = TRUE) error_msg &lt;- paste0(&quot;Column &#39;&quot;, col_name, &quot;&#39; not found in data.&quot;) if (length(similar) &gt; 0) { error_msg &lt;- paste0(error_msg, &quot;\\nDid you mean: &quot;, paste(similar, collapse = &quot;, &quot;), &quot;?&quot;) } error_msg &lt;- paste0(error_msg, &quot;\\nAvailable columns: &quot;, paste(data_cols, collapse = &quot;, &quot;)) stop(error_msg, call. = FALSE) } } # If all checks pass, do the select select(data, !!!cols) } # Test safe_select(mtcars, mpg, cyl, hp) #&gt; Error in select(data, !!!cols): unused argument (!!!cols) safe_select(mtcars, mpg, horsepower) # Helpful error #&gt; Error: Column &#39;horsepower&#39; not found in data. #&gt; Available columns: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb Exercise 4: summarize_by_group &lt;- function(data, group_col, value_col) { # Use across for flexible column selection data %&gt;% group_by(across({{ group_col }})) %&gt;% summarize( n = n(), mean = mean({{ value_col }}, na.rm = TRUE), median = median({{ value_col }}, na.rm = TRUE), sd = sd({{ value_col }}, na.rm = TRUE), min = min({{ value_col }}, na.rm = TRUE), max = max({{ value_col }}, na.rm = TRUE), .groups = &quot;drop&quot; ) %&gt;% arrange(desc(mean)) } # Test summarize_by_group(mtcars, cyl, mpg) #&gt; # A tibble: 3 √ó 7 #&gt; cyl n mean median sd min max #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11 26.7 26 4.51 21.4 33.9 #&gt; 2 6 7 19.7 19.7 1.45 17.8 21.4 #&gt; 3 8 14 15.1 15.2 2.56 10.4 19.2 summarize_by_group(mtcars, gear, hp) #&gt; # A tibble: 3 √ó 7 #&gt; gear n mean median sd min max #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 5 5 196. 175 103. 91 335 #&gt; 2 3 15 176. 180 47.7 97 245 #&gt; 3 4 12 89.5 94 25.9 52 123 # With iris summarize_by_group(iris, Species, Sepal.Length) #&gt; # A tibble: 3 √ó 7 #&gt; Species n mean median sd min max #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 virginica 50 6.59 6.5 0.636 4.9 7.9 #&gt; 2 versicolor 50 5.94 5.9 0.516 4.9 7 #&gt; 3 setosa 50 5.01 5 0.352 4.3 5.8 "],["dplyr-grouping.html", "Chapter 21 Grouping &amp; Summarizing 21.1 Introduction 21.2 group_by() Basics 21.3 Error #1: Forgetting Data is Grouped 21.4 summarize() with Groups 21.5 Error #2: must be length 1, not ... 21.6 mutate() with Groups 21.7 filter() with Groups 21.8 Multiple Grouping Variables 21.9 Error #3: Unexpected Grouping After summarize() 21.10 Window Functions 21.11 count() and add_count() 21.12 across() for Multiple Columns 21.13 Common Pitfalls 21.14 Summary 21.15 Exercises 21.16 Exercise Answers", " Chapter 21 Grouping &amp; Summarizing What You‚Äôll Learn: group_by() mechanics Grouped operations summarize() with groups Common grouping errors Multiple grouping variables Ungrouping data Key Errors Covered: 18+ grouping errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 21.1 Introduction Grouping is one of dplyr‚Äôs most powerful features: library(dplyr) # Without grouping mtcars %&gt;% summarize(avg_mpg = mean(mpg)) #&gt; avg_mpg #&gt; 1 20.09062 # With grouping mtcars %&gt;% group_by(cyl) %&gt;% summarize(avg_mpg = mean(mpg)) #&gt; # A tibble: 3 √ó 2 #&gt; cyl avg_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 But grouping has surprising behaviors. Let‚Äôs master it! 21.2 group_by() Basics üí° Key Insight: group_by() Creates Invisible Groups # Create grouped data grouped_data &lt;- mtcars %&gt;% group_by(cyl) # Looks the same when printed head(grouped_data, 3) #&gt; # A tibble: 3 √ó 11 #&gt; # Groups: cyl [2] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 # But it&#39;s grouped! class(grouped_data) #&gt; [1] &quot;grouped_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; groups(grouped_data) #&gt; [[1]] #&gt; cyl # Check if grouped is_grouped_df(grouped_data) #&gt; [1] TRUE # See grouping variables group_vars(grouped_data) #&gt; [1] &quot;cyl&quot; # Count groups n_groups(grouped_data) #&gt; [1] 3 # Subsequent operations work within groups grouped_data %&gt;% summarize(avg_mpg = mean(mpg)) #&gt; # A tibble: 3 √ó 2 #&gt; cyl avg_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 Key insight: Grouping doesn‚Äôt change data, just how operations apply! 21.3 Error #1: Forgetting Data is Grouped ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 21.3.1 The Problem # Group the data cars_grouped &lt;- mtcars %&gt;% group_by(cyl) # Later in code... expecting ungrouped behavior cars_grouped %&gt;% mutate(rank = row_number()) # Ranks within groups! #&gt; # A tibble: 32 √ó 12 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb rank #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 1 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 2 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 1 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 3 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 1 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 4 #&gt; 7 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 2 #&gt; 8 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 2 #&gt; 9 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 3 #&gt; 10 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 5 #&gt; # ‚Ñπ 22 more rows 21.3.2 What Happened row_number() operated within each group, not across all data. 21.3.3 Common Causes # Expecting overall statistics mtcars %&gt;% group_by(cyl) %&gt;% mutate( overall_mean = mean(mpg) # Actually group means! ) %&gt;% select(cyl, mpg, overall_mean) #&gt; Error in select(., cyl, mpg, overall_mean): unused arguments (cyl, mpg, overall_mean) # Expecting all rows mtcars %&gt;% group_by(cyl) %&gt;% slice(1) # Gets first row of EACH group, not overall first #&gt; # A tibble: 3 √ó 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 #&gt; 2 21 6 160 110 3.9 2.62 16.5 0 1 4 4 #&gt; 3 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 # Filtering mtcars %&gt;% group_by(cyl) %&gt;% filter(mpg == max(mpg)) # Max within each group #&gt; # A tibble: 3 √ó 11 #&gt; # Groups: cyl [3] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 #&gt; 2 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 #&gt; 3 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 21.3.4 Solutions ‚úÖ SOLUTION 1: Ungroup When Done # Ungroup explicitly result &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarize(avg_mpg = mean(mpg)) %&gt;% ungroup() # Remove grouping # Now operations are ungrouped result %&gt;% mutate(rank = row_number()) # Ranks across all rows #&gt; # A tibble: 3 √ó 3 #&gt; cyl avg_mpg rank #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 26.7 1 #&gt; 2 6 19.7 2 #&gt; 3 8 15.1 3 ‚úÖ SOLUTION 2: Check Grouping Status # Always check if data is grouped check_grouping &lt;- function(data) { if (is_grouped_df(data)) { message(&quot;Data is grouped by: &quot;, paste(group_vars(data), collapse = &quot;, &quot;)) } else { message(&quot;Data is not grouped&quot;) } invisible(data) } mtcars %&gt;% group_by(cyl) %&gt;% check_grouping() %&gt;% summarize(avg_mpg = mean(mpg)) %&gt;% check_grouping() #&gt; Data is grouped by: cyl #&gt; Data is not grouped ‚úÖ SOLUTION 3: Use .groups Argument # Control grouping in summarize mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( avg_mpg = mean(mpg), .groups = &quot;drop&quot; # Ungroup completely ) #&gt; # A tibble: 8 √ó 3 #&gt; cyl gear avg_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 3 21.5 #&gt; 2 4 4 26.9 #&gt; 3 4 5 28.2 #&gt; 4 6 3 19.8 #&gt; 5 6 4 19.8 #&gt; 6 6 5 19.7 #&gt; 7 8 3 15.0 #&gt; 8 8 5 15.4 # Keep some grouping mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( avg_mpg = mean(mpg), .groups = &quot;drop_last&quot; # Keep cyl grouping ) %&gt;% group_vars() #&gt; [1] &quot;cyl&quot; # Keep all groups mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( avg_mpg = mean(mpg), .groups = &quot;keep&quot; ) %&gt;% group_vars() #&gt; [1] &quot;cyl&quot; &quot;gear&quot; 21.4 summarize() with Groups üí° Key Insight: summarize() Reduces Groups # Single grouping variable mtcars %&gt;% group_by(cyl) %&gt;% summarize( n = n(), avg_mpg = mean(mpg), sd_mpg = sd(mpg) ) #&gt; # A tibble: 3 √ó 4 #&gt; cyl n avg_mpg sd_mpg #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11 26.7 4.51 #&gt; 2 6 7 19.7 1.45 #&gt; 3 8 14 15.1 2.56 # Multiple grouping variables mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( n = n(), avg_mpg = mean(mpg), .groups = &quot;drop&quot; ) #&gt; # A tibble: 8 √ó 4 #&gt; cyl gear n avg_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 4 3 1 21.5 #&gt; 2 4 4 8 26.9 #&gt; 3 4 5 2 28.2 #&gt; 4 6 3 2 19.8 #&gt; 5 6 4 4 19.8 #&gt; 6 6 5 1 19.7 #&gt; 7 8 3 12 15.0 #&gt; 8 8 5 2 15.4 # Useful summary functions mtcars %&gt;% group_by(cyl) %&gt;% summarize( count = n(), # Number of observations n_distinct = n_distinct(gear), # Unique values mean = mean(mpg), median = median(mpg), sd = sd(mpg), min = min(mpg), max = max(mpg), first = first(mpg), # First value last = last(mpg), # Last value nth = nth(mpg, 2) # Nth value ) #&gt; # A tibble: 3 √ó 11 #&gt; cyl count n_distinct mean median sd min max first last nth #&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11 3 26.7 26 4.51 21.4 33.9 22.8 21.4 24.4 #&gt; 2 6 7 3 19.7 19.7 1.45 17.8 21.4 21 19.7 21 #&gt; 3 8 14 2 15.1 15.2 2.56 10.4 19.2 18.7 15 14.3 # Multiple values from same column mtcars %&gt;% group_by(cyl) %&gt;% summarize( mpg_stats = list(summary(mpg)) # List column ) #&gt; # A tibble: 3 √ó 2 #&gt; cyl mpg_stats #&gt; &lt;dbl&gt; &lt;list&gt; #&gt; 1 4 &lt;smmryDfl [6]&gt; #&gt; 2 6 &lt;smmryDfl [6]&gt; #&gt; 3 8 &lt;smmryDfl [6]&gt; 21.5 Error #2: must be length 1, not ... ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 21.5.1 The Error mtcars %&gt;% group_by(cyl) %&gt;% summarize( top_mpg = head(mpg, 3) # Returns multiple values! ) #&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #&gt; dplyr 1.1.0. #&gt; ‚Ñπ Please use `reframe()` instead. #&gt; ‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()` #&gt; always returns an ungrouped data frame and adjust accordingly. #&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #&gt; generated. #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. #&gt; # A tibble: 9 √ó 2 #&gt; # Groups: cyl [3] #&gt; cyl top_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 22.8 #&gt; 2 4 24.4 #&gt; 3 4 22.8 #&gt; 4 6 21 #&gt; 5 6 21 #&gt; 6 6 21.4 #&gt; 7 8 18.7 #&gt; 8 8 14.3 #&gt; 9 8 16.4 üî¥ ERROR Error in summarize(): ! `top_mpg` must be size 1, not 3. 21.5.2 What It Means summarize() expects functions that return a single value per group, not vectors. 21.5.3 Common Causes # Functions returning multiple values mtcars %&gt;% group_by(cyl) %&gt;% summarize(all_mpg = mpg) # All values, not one #&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #&gt; dplyr 1.1.0. #&gt; ‚Ñπ Please use `reframe()` instead. #&gt; ‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()` #&gt; always returns an ungrouped data frame and adjust accordingly. #&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #&gt; generated. #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. #&gt; # A tibble: 32 √ó 2 #&gt; # Groups: cyl [3] #&gt; cyl all_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 22.8 #&gt; 2 4 24.4 #&gt; 3 4 22.8 #&gt; 4 4 32.4 #&gt; 5 4 30.4 #&gt; 6 4 33.9 #&gt; 7 4 21.5 #&gt; 8 4 27.3 #&gt; 9 4 26 #&gt; 10 4 30.4 #&gt; # ‚Ñπ 22 more rows mtcars %&gt;% group_by(cyl) %&gt;% summarize(quantiles = quantile(mpg)) # Returns 5 values #&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #&gt; dplyr 1.1.0. #&gt; ‚Ñπ Please use `reframe()` instead. #&gt; ‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()` #&gt; always returns an ungrouped data frame and adjust accordingly. #&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #&gt; generated. #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. #&gt; # A tibble: 15 √ó 2 #&gt; # Groups: cyl [3] #&gt; cyl quantiles #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 #&gt; 2 4 22.8 #&gt; 3 4 26 #&gt; 4 4 30.4 #&gt; 5 4 33.9 #&gt; 6 6 17.8 #&gt; 7 6 18.6 #&gt; 8 6 19.7 #&gt; 9 6 21 #&gt; 10 6 21.4 #&gt; 11 8 10.4 #&gt; 12 8 14.4 #&gt; 13 8 15.2 #&gt; 14 8 16.2 #&gt; 15 8 19.2 mtcars %&gt;% group_by(cyl) %&gt;% summarize(range = range(mpg)) # Returns 2 values #&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated in #&gt; dplyr 1.1.0. #&gt; ‚Ñπ Please use `reframe()` instead. #&gt; ‚Ñπ When switching from `summarise()` to `reframe()`, remember that `reframe()` #&gt; always returns an ungrouped data frame and adjust accordingly. #&gt; Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #&gt; generated. #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. #&gt; # A tibble: 6 √ó 2 #&gt; # Groups: cyl [3] #&gt; cyl range #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 #&gt; 2 4 33.9 #&gt; 3 6 17.8 #&gt; 4 6 21.4 #&gt; 5 8 10.4 #&gt; 6 8 19.2 21.5.4 Solutions ‚úÖ SOLUTION 1: Use Single-Value Functions # Functions that return one value mtcars %&gt;% group_by(cyl) %&gt;% summarize( mean_mpg = mean(mpg), max_mpg = max(mpg), min_mpg = min(mpg), n_obs = n() ) #&gt; # A tibble: 3 √ó 5 #&gt; cyl mean_mpg max_mpg min_mpg n_obs #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 26.7 33.9 21.4 11 #&gt; 2 6 19.7 21.4 17.8 7 #&gt; 3 8 15.1 19.2 10.4 14 # For ranges, get separately mtcars %&gt;% group_by(cyl) %&gt;% summarize( min_mpg = min(mpg), max_mpg = max(mpg) ) #&gt; # A tibble: 3 √ó 3 #&gt; cyl min_mpg max_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 33.9 #&gt; 2 6 17.8 21.4 #&gt; 3 8 10.4 19.2 ‚úÖ SOLUTION 2: Use reframe() for Multiple Rows # reframe() allows multiple rows per group (dplyr &gt;= 1.1.0) if (packageVersion(&quot;dplyr&quot;) &gt;= &quot;1.1.0&quot;) { mtcars %&gt;% group_by(cyl) %&gt;% reframe( top_3_mpg = head(sort(mpg, decreasing = TRUE), 3) ) } #&gt; # A tibble: 9 √ó 2 #&gt; cyl top_3_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 33.9 #&gt; 2 4 32.4 #&gt; 3 4 30.4 #&gt; 4 6 21.4 #&gt; 5 6 21 #&gt; 6 6 21 #&gt; 7 8 19.2 #&gt; 8 8 18.7 #&gt; 9 8 17.3 # For older dplyr, use summarize with list mtcars %&gt;% group_by(cyl) %&gt;% summarize( top_3_mpg = list(head(sort(mpg, decreasing = TRUE), 3)) ) %&gt;% tidyr::unnest(top_3_mpg) #&gt; # A tibble: 9 √ó 2 #&gt; cyl top_3_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 33.9 #&gt; 2 4 32.4 #&gt; 3 4 30.4 #&gt; 4 6 21.4 #&gt; 5 6 21 #&gt; 6 6 21 #&gt; 7 8 19.2 #&gt; 8 8 18.7 #&gt; 9 8 17.3 ‚úÖ SOLUTION 3: Use slice() Instead # Get top N rows per group with slice mtcars %&gt;% group_by(cyl) %&gt;% slice_max(mpg, n = 3) %&gt;% select(cyl, mpg) #&gt; Error in select(., cyl, mpg): unused arguments (cyl, mpg) # Or with arrange and slice mtcars %&gt;% group_by(cyl) %&gt;% arrange(desc(mpg)) %&gt;% slice(1:3) %&gt;% select(cyl, mpg) #&gt; Error in select(., cyl, mpg): unused arguments (cyl, mpg) 21.6 mutate() with Groups üí° Key Insight: mutate() Keeps All Rows # mutate() operates within groups but keeps all rows mtcars %&gt;% group_by(cyl) %&gt;% mutate( group_mean = mean(mpg), deviation = mpg - group_mean ) %&gt;% select(cyl, mpg, group_mean, deviation) %&gt;% arrange(cyl, mpg) #&gt; Error in select(., cyl, mpg, group_mean, deviation): unused arguments (cyl, mpg, group_mean, deviation) # Ranking within groups mtcars %&gt;% group_by(cyl) %&gt;% mutate( mpg_rank = rank(desc(mpg)), mpg_dense_rank = dense_rank(desc(mpg)), mpg_row_number = row_number(desc(mpg)) ) %&gt;% select(cyl, mpg, mpg_rank, mpg_dense_rank, mpg_row_number) %&gt;% arrange(cyl, desc(mpg)) #&gt; Error in select(., cyl, mpg, mpg_rank, mpg_dense_rank, mpg_row_number): unused arguments (cyl, mpg, mpg_rank, mpg_dense_rank, mpg_row_number) # Cumulative operations within groups mtcars %&gt;% group_by(cyl) %&gt;% arrange(mpg) %&gt;% mutate( cumsum_mpg = cumsum(mpg), cummax_mpg = cummax(mpg) ) %&gt;% select(cyl, mpg, cumsum_mpg, cummax_mpg) #&gt; Error in select(., cyl, mpg, cumsum_mpg, cummax_mpg): unused arguments (cyl, mpg, cumsum_mpg, cummax_mpg) # Lead and lag within groups mtcars %&gt;% group_by(cyl) %&gt;% arrange(mpg) %&gt;% mutate( prev_mpg = lag(mpg), next_mpg = lead(mpg), diff_from_prev = mpg - lag(mpg) ) %&gt;% select(cyl, mpg, prev_mpg, next_mpg, diff_from_prev) #&gt; Error in select(., cyl, mpg, prev_mpg, next_mpg, diff_from_prev): unused arguments (cyl, mpg, prev_mpg, next_mpg, diff_from_prev) 21.7 filter() with Groups üí° Key Insight: filter() with Groups # Filter based on group statistics mtcars %&gt;% group_by(cyl) %&gt;% filter(mpg &gt; mean(mpg)) %&gt;% select(cyl, mpg) %&gt;% arrange(cyl, mpg) #&gt; Error in select(., cyl, mpg): unused arguments (cyl, mpg) # Keep only groups meeting criteria mtcars %&gt;% group_by(cyl) %&gt;% filter(n() &gt;= 10) %&gt;% # Only groups with 10+ observations select(cyl) %&gt;% distinct() #&gt; Error in select(., cyl): unused argument (cyl) # Top N per group mtcars %&gt;% group_by(cyl) %&gt;% filter(rank(desc(mpg)) &lt;= 2) %&gt;% select(cyl, mpg) %&gt;% arrange(cyl, desc(mpg)) #&gt; Error in select(., cyl, mpg): unused arguments (cyl, mpg) # Filter by group condition mtcars %&gt;% group_by(cyl) %&gt;% filter(mean(mpg) &gt; 20) %&gt;% # Only groups with avg mpg &gt; 20 select(cyl, mpg) #&gt; Error in select(., cyl, mpg): unused arguments (cyl, mpg) 21.8 Multiple Grouping Variables üí° Key Insight: Multiple Groups # Group by multiple variables mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( n = n(), avg_mpg = mean(mpg), .groups = &quot;drop&quot; ) #&gt; # A tibble: 8 √ó 4 #&gt; cyl gear n avg_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 4 3 1 21.5 #&gt; 2 4 4 8 26.9 #&gt; 3 4 5 2 28.2 #&gt; 4 6 3 2 19.8 #&gt; 5 6 4 4 19.8 #&gt; 6 6 5 1 19.7 #&gt; 7 8 3 12 15.0 #&gt; 8 8 5 2 15.4 # Order matters for operations mtcars %&gt;% group_by(cyl, gear) %&gt;% mutate( rank_in_cyl_gear = row_number(desc(mpg)) ) %&gt;% select(cyl, gear, mpg, rank_in_cyl_gear) %&gt;% arrange(cyl, gear, desc(mpg)) #&gt; Error in select(., cyl, gear, mpg, rank_in_cyl_gear): unused arguments (cyl, gear, mpg, rank_in_cyl_gear) # Count combinations mtcars %&gt;% count(cyl, gear) #&gt; cyl gear n #&gt; 1 4 3 1 #&gt; 2 4 4 8 #&gt; 3 4 5 2 #&gt; 4 6 3 2 #&gt; 5 6 4 4 #&gt; 6 6 5 1 #&gt; 7 8 3 12 #&gt; 8 8 5 2 # Or with group_by + summarize mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(n = n(), .groups = &quot;drop&quot;) #&gt; # A tibble: 8 √ó 3 #&gt; cyl gear n #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 3 1 #&gt; 2 4 4 8 #&gt; 3 4 5 2 #&gt; 4 6 3 2 #&gt; 5 6 4 4 #&gt; 6 6 5 1 #&gt; 7 8 3 12 #&gt; 8 8 5 2 21.9 Error #3: Unexpected Grouping After summarize() ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 21.9.1 The Problem # Summarize with multiple groups result &lt;- mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg)) # Message about grouping #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. # Still grouped! is_grouped_df(result) #&gt; [1] TRUE group_vars(result) #&gt; [1] &quot;cyl&quot; # Next operation uses this grouping result %&gt;% mutate(rank = row_number()) # Within cyl groups! #&gt; # A tibble: 8 √ó 4 #&gt; # Groups: cyl [3] #&gt; cyl gear avg_mpg rank #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 3 21.5 1 #&gt; 2 4 4 26.9 2 #&gt; 3 4 5 28.2 3 #&gt; 4 6 3 19.8 1 #&gt; 5 6 4 19.8 2 #&gt; 6 6 5 19.7 3 #&gt; 7 8 3 15.0 1 #&gt; 8 8 5 15.4 2 21.9.2 What Happened By default, summarize() drops the last grouping variable but keeps others. 21.9.3 Solutions ‚úÖ SOLUTION 1: Use .groups = ‚Äúdrop‚Äù # Ungroup completely result &lt;- mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize( avg_mpg = mean(mpg), .groups = &quot;drop&quot; ) is_grouped_df(result) #&gt; [1] FALSE ‚úÖ SOLUTION 2: Explicit ungroup() result &lt;- mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg)) %&gt;% ungroup() #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. is_grouped_df(result) #&gt; [1] FALSE ‚úÖ SOLUTION 3: Understand .groups Options # .groups = &quot;drop_last&quot; (default) mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg), .groups = &quot;drop_last&quot;) %&gt;% group_vars() # Still has cyl #&gt; [1] &quot;cyl&quot; # .groups = &quot;keep&quot; mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg), .groups = &quot;keep&quot;) %&gt;% group_vars() # Has both cyl and gear #&gt; [1] &quot;cyl&quot; &quot;gear&quot; # .groups = &quot;drop&quot; mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg), .groups = &quot;drop&quot;) %&gt;% group_vars() # No groups #&gt; character(0) # .groups = &quot;rowwise&quot; mtcars %&gt;% group_by(cyl, gear) %&gt;% summarize(avg_mpg = mean(mpg), .groups = &quot;rowwise&quot;) %&gt;% class() #&gt; [1] &quot;rowwise_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; 21.10 Window Functions üéØ Best Practice: Window Functions with Groups # Ranking functions mtcars %&gt;% group_by(cyl) %&gt;% mutate( rank = rank(desc(mpg)), # Ties get average rank dense_rank = dense_rank(desc(mpg)), # Ties get same rank, no gaps row_number = row_number(desc(mpg)), # Ties broken arbitrarily percent_rank = percent_rank(desc(mpg)), # Percentile cume_dist = cume_dist(desc(mpg)) # Cumulative distribution ) %&gt;% select(cyl, mpg, rank, dense_rank, row_number, percent_rank, cume_dist) %&gt;% arrange(cyl, desc(mpg)) #&gt; Error in select(., cyl, mpg, rank, dense_rank, row_number, percent_rank, : unused arguments (cyl, mpg, rank, dense_rank, row_number, percent_rank, cume_dist) # Lead and lag mtcars %&gt;% group_by(cyl) %&gt;% arrange(mpg) %&gt;% mutate( prev_value = lag(mpg, 1), # Previous value next_value = lead(mpg, 1), # Next value prev_2 = lag(mpg, 2), # 2 rows back change = mpg - lag(mpg, 1) # Change from previous ) %&gt;% select(cyl, mpg, prev_value, next_value, change) #&gt; Error in select(., cyl, mpg, prev_value, next_value, change): unused arguments (cyl, mpg, prev_value, next_value, change) # Cumulative functions mtcars %&gt;% group_by(cyl) %&gt;% arrange(mpg) %&gt;% mutate( cumsum = cumsum(mpg), cummean = cummean(mpg), cummin = cummin(mpg), cummax = cummax(mpg) ) %&gt;% select(cyl, mpg, cumsum, cummean, cummin, cummax) #&gt; Error in select(., cyl, mpg, cumsum, cummean, cummin, cummax): unused arguments (cyl, mpg, cumsum, cummean, cummin, cummax) # Offset functions mtcars %&gt;% group_by(cyl) %&gt;% arrange(mpg) %&gt;% mutate( first_val = first(mpg), last_val = last(mpg), nth_val = nth(mpg, 3) ) %&gt;% select(cyl, mpg, first_val, last_val, nth_val) #&gt; Error in select(., cyl, mpg, first_val, last_val, nth_val): unused arguments (cyl, mpg, first_val, last_val, nth_val) 21.11 count() and add_count() üí° Key Insight: Counting Shortcuts # count() is shortcut for group_by + summarize + ungroup mtcars %&gt;% count(cyl) #&gt; cyl n #&gt; 1 4 11 #&gt; 2 6 7 #&gt; 3 8 14 # Equivalent to: mtcars %&gt;% group_by(cyl) %&gt;% summarize(n = n()) %&gt;% ungroup() #&gt; # A tibble: 3 √ó 2 #&gt; cyl n #&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 11 #&gt; 2 6 7 #&gt; 3 8 14 # Multiple variables mtcars %&gt;% count(cyl, gear) #&gt; cyl gear n #&gt; 1 4 3 1 #&gt; 2 4 4 8 #&gt; 3 4 5 2 #&gt; 4 6 3 2 #&gt; 5 6 4 4 #&gt; 6 6 5 1 #&gt; 7 8 3 12 #&gt; 8 8 5 2 # With sorting mtcars %&gt;% count(cyl, sort = TRUE) #&gt; cyl n #&gt; 1 8 14 #&gt; 2 4 11 #&gt; 3 6 7 # With weights mtcars %&gt;% count(cyl, wt = mpg) # Sum of mpg instead of count #&gt; cyl n #&gt; 1 4 293.3 #&gt; 2 6 138.2 #&gt; 3 8 211.4 # add_count() keeps all rows mtcars %&gt;% add_count(cyl) %&gt;% select(cyl, n, everything()) #&gt; Error in select(., cyl, n, everything()): unused arguments (cyl, n, everything()) # Name the count column mtcars %&gt;% add_count(cyl, name = &quot;n_per_cyl&quot;) %&gt;% select(cyl, n_per_cyl, mpg) #&gt; Error in select(., cyl, n_per_cyl, mpg): unused arguments (cyl, n_per_cyl, mpg) 21.12 across() for Multiple Columns üéØ Best Practice: across() for Multiple Columns # Summarize multiple columns mtcars %&gt;% group_by(cyl) %&gt;% summarize( across(c(mpg, hp, wt), mean), .groups = &quot;drop&quot; ) #&gt; # A tibble: 3 √ó 4 #&gt; cyl mpg hp wt #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 82.6 2.29 #&gt; 2 6 19.7 122. 3.12 #&gt; 3 8 15.1 209. 4.00 # With named functions mtcars %&gt;% group_by(cyl) %&gt;% summarize( across(c(mpg, hp, wt), list(mean = mean, sd = sd), .names = &quot;{.col}_{.fn}&quot;), .groups = &quot;drop&quot; ) #&gt; # A tibble: 3 √ó 7 #&gt; cyl mpg_mean mpg_sd hp_mean hp_sd wt_mean wt_sd #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 4.51 82.6 20.9 2.29 0.570 #&gt; 2 6 19.7 1.45 122. 24.3 3.12 0.356 #&gt; 3 8 15.1 2.56 209. 51.0 4.00 0.759 # Using selection helpers mtcars %&gt;% group_by(cyl) %&gt;% summarize( across(where(is.numeric), mean), .groups = &quot;drop&quot; ) #&gt; # A tibble: 3 √ó 11 #&gt; cyl mpg disp hp drat wt qsec vs am gear carb #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 105. 82.6 4.07 2.29 19.1 0.909 0.727 4.09 1.55 #&gt; 2 6 19.7 183. 122. 3.59 3.12 18.0 0.571 0.429 3.86 3.43 #&gt; 3 8 15.1 353. 209. 3.23 4.00 16.8 0 0.143 3.29 3.5 # In mutate mtcars %&gt;% group_by(cyl) %&gt;% mutate( across(c(mpg, hp), ~ . - mean(.), .names = &quot;{.col}_centered&quot;) ) %&gt;% select(cyl, mpg, mpg_centered, hp, hp_centered) #&gt; Error in select(., cyl, mpg, mpg_centered, hp, hp_centered): unused arguments (cyl, mpg, mpg_centered, hp, hp_centered) # Multiple functions mtcars %&gt;% group_by(cyl) %&gt;% summarize( across(c(mpg, hp), list(min = min, max = max, mean = mean)), .groups = &quot;drop&quot; ) #&gt; # A tibble: 3 √ó 7 #&gt; cyl mpg_min mpg_max mpg_mean hp_min hp_max hp_mean #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 21.4 33.9 26.7 52 113 82.6 #&gt; 2 6 17.8 21.4 19.7 105 175 122. #&gt; 3 8 10.4 19.2 15.1 150 335 209. 21.13 Common Pitfalls ‚ö†Ô∏è Common Grouping Pitfalls # Pitfall 1: Forgetting to ungroup bad &lt;- mtcars %&gt;% group_by(cyl) %&gt;% mutate(mpg_scaled = mpg / mean(mpg)) # Still grouped! good &lt;- mtcars %&gt;% group_by(cyl) %&gt;% mutate(mpg_scaled = mpg / mean(mpg)) %&gt;% ungroup() # Pitfall 2: Summarizing already summarized data mtcars %&gt;% group_by(cyl) %&gt;% summarize(avg_mpg = mean(mpg)) %&gt;% summarize(overall_avg = mean(avg_mpg)) # Wrong! Treats groups equally #&gt; # A tibble: 1 √ó 1 #&gt; overall_avg #&gt; &lt;dbl&gt; #&gt; 1 20.5 # Correct: weight by group size mtcars %&gt;% group_by(cyl) %&gt;% summarize( avg_mpg = mean(mpg), n = n(), .groups = &quot;drop&quot; ) %&gt;% summarize(overall_avg = sum(avg_mpg * n) / sum(n)) #&gt; # A tibble: 1 √ó 1 #&gt; overall_avg #&gt; &lt;dbl&gt; #&gt; 1 20.1 # Pitfall 3: Group order affecting row_number set.seed(123) df &lt;- tibble( group = rep(c(&quot;A&quot;, &quot;B&quot;), each = 3), value = sample(1:6) ) # Different results! df %&gt;% group_by(group) %&gt;% mutate(rn = row_number()) #&gt; # A tibble: 6 √ó 3 #&gt; # Groups: group [2] #&gt; group value rn #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 A 3 1 #&gt; 2 A 6 2 #&gt; 3 A 2 3 #&gt; 4 B 4 1 #&gt; 5 B 5 2 #&gt; 6 B 1 3 df %&gt;% arrange(value) %&gt;% group_by(group) %&gt;% mutate(rn = row_number()) #&gt; # A tibble: 6 √ó 3 #&gt; # Groups: group [2] #&gt; group value rn #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 B 1 1 #&gt; 2 A 2 1 #&gt; 3 A 3 2 #&gt; 4 B 4 2 #&gt; 5 B 5 3 #&gt; 6 A 6 3 # Pitfall 4: Comparing grouped vs ungrouped mtcars %&gt;% group_by(cyl) %&gt;% filter(mpg == max(mpg)) %&gt;% # Max within each cyl nrow() #&gt; [1] 3 mtcars %&gt;% filter(mpg == max(mpg)) %&gt;% # Overall max nrow() #&gt; [1] 1 21.14 Summary Key Takeaways: group_by() is invisible - Data looks same but behaves differently Always ungroup - Use ungroup() or .groups = \"drop\" summarize() reduces groups - Drops last group by default mutate() keeps all rows - Operations within groups Window functions - Work great with groups Check grouping status - Use group_vars() or is_grouped_df() across() for multiple columns - Apply same operation to many columns Quick Reference: Error Cause Fix Unexpected grouped behavior Forgot data is grouped Check with group_vars(), use ungroup() must be size 1 summarize() with vector Use single-value function or reframe() Wrong statistics Operating on groups Ungroup or use different operation Grouping Operations: # Basic grouping data %&gt;% group_by(col) # Multiple groups data %&gt;% group_by(col1, col2) # Ungroup data %&gt;% ungroup() # Check grouping group_vars(data) is_grouped_df(data) n_groups(data) # Summarize with groups data %&gt;% group_by(col) %&gt;% summarize(stat = mean(value), .groups = &quot;drop&quot;) # Mutate with groups (keeps all rows) data %&gt;% group_by(col) %&gt;% mutate(group_mean = mean(value)) # Filter with groups data %&gt;% group_by(col) %&gt;% filter(value &gt; mean(value)) # Count data %&gt;% count(col) data %&gt;% add_count(col) # across for multiple columns data %&gt;% group_by(col) %&gt;% summarize(across(where(is.numeric), mean)) Best Practices: # ‚úÖ Good data %&gt;% group_by(col) %&gt;% summarize(stat = mean(x), .groups = &quot;drop&quot;) # Explicit ungrouping data %&gt;% group_by(col) %&gt;% ... %&gt;% ungroup() # Ungroup at end Always check: group_vars(data) # Verify grouping # ‚ùå Avoid data %&gt;% group_by(col) %&gt;% summarize(...) # No .groups argument Leave data grouped # Causes confusion later Assume data is/isn&#39;t grouped # Always check 21.15 Exercises üìù Exercise 1: Group Statistics Using mtcars: 1. Group by cyl 2. Calculate mean, median, sd of mpg per group 3. Add count and min/max mpg 4. Sort by mean mpg descending 5. Ensure result is ungrouped üìù Exercise 2: Window Functions Using mtcars: 1. Group by cyl 2. Add rank of mpg within each cyl 3. Add difference from group mean 4. Add percentile within group 5. Keep only top 2 per group üìù Exercise 3: Group Detector Write check_grouped_operations(data) that: 1. Checks if data is grouped 2. Shows what grouping variables exist 3. Warns about potential issues 4. Suggests when to ungroup üìù Exercise 4: Grouped Summary Report Write grouped_summary(data, group_vars, summary_vars) that: 1. Groups by specified columns 2. Summarizes multiple statistics for each summary variable 3. Includes count and percentage of total 4. Returns ungrouped, sorted result 21.16 Exercise Answers Click to see answers Exercise 1: result &lt;- mtcars %&gt;% group_by(cyl) %&gt;% summarize( count = n(), mean_mpg = mean(mpg), median_mpg = median(mpg), sd_mpg = sd(mpg), min_mpg = min(mpg), max_mpg = max(mpg), .groups = &quot;drop&quot; ) %&gt;% arrange(desc(mean_mpg)) result #&gt; # A tibble: 3 √ó 7 #&gt; cyl count mean_mpg median_mpg sd_mpg min_mpg max_mpg #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11 26.7 26 4.51 21.4 33.9 #&gt; 2 6 7 19.7 19.7 1.45 17.8 21.4 #&gt; 3 8 14 15.1 15.2 2.56 10.4 19.2 # Verify it&#39;s ungrouped is_grouped_df(result) #&gt; [1] FALSE Exercise 2: result &lt;- mtcars %&gt;% group_by(cyl) %&gt;% mutate( mpg_rank = rank(desc(mpg)), deviation_from_mean = mpg - mean(mpg), percentile = percent_rank(mpg) ) %&gt;% filter(mpg_rank &lt;= 2) %&gt;% select(cyl, mpg, mpg_rank, deviation_from_mean, percentile) %&gt;% arrange(cyl, mpg_rank) %&gt;% ungroup() #&gt; Error in select(., cyl, mpg, mpg_rank, deviation_from_mean, percentile): unused arguments (cyl, mpg, mpg_rank, deviation_from_mean, percentile) result #&gt; # A tibble: 3 √ó 7 #&gt; cyl count mean_mpg median_mpg sd_mpg min_mpg max_mpg #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11 26.7 26 4.51 21.4 33.9 #&gt; 2 6 7 19.7 19.7 1.45 17.8 21.4 #&gt; 3 8 14 15.1 15.2 2.56 10.4 19.2 Exercise 3: check_grouped_operations &lt;- function(data, warn_threshold = 3) { cat(&quot;=== Grouping Analysis ===\\n\\n&quot;) # Check if grouped if (!is_grouped_df(data)) { cat(&quot;‚úì Data is NOT grouped\\n&quot;) return(invisible(data)) } # Get grouping info grp_vars &lt;- group_vars(data) n_grps &lt;- n_groups(data) cat(&quot;‚ö† Data IS grouped\\n&quot;) cat(&quot;Grouping variables:&quot;, paste(grp_vars, collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot;Number of groups:&quot;, n_grps, &quot;\\n\\n&quot;) # Group sizes grp_sizes &lt;- data %&gt;% summarize(n = n(), .groups = &quot;drop&quot;) %&gt;% pull(n) cat(&quot;Group size summary:\\n&quot;) cat(&quot; Min:&quot;, min(grp_sizes), &quot;\\n&quot;) cat(&quot; Max:&quot;, max(grp_sizes), &quot;\\n&quot;) cat(&quot; Mean:&quot;, round(mean(grp_sizes), 1), &quot;\\n\\n&quot;) # Warnings if (length(grp_vars) &gt; warn_threshold) { warning(&quot;Many grouping variables (&quot;, length(grp_vars), &quot;) may lead to many small groups&quot;) } if (any(grp_sizes == 1)) { warning(&quot;Some groups have only 1 observation&quot;) } # Suggestions cat(&quot;Suggestions:\\n&quot;) cat(&quot; - Use ungroup() when done with grouped operations\\n&quot;) cat(&quot; - Or use .groups = &#39;drop&#39; in summarize()\\n&quot;) cat(&quot; - Check grouping with group_vars() before operations\\n&quot;) invisible(data) } # Test mtcars %&gt;% group_by(cyl) %&gt;% check_grouped_operations() #&gt; === Grouping Analysis === #&gt; #&gt; ‚ö† Data IS grouped #&gt; Grouping variables: cyl #&gt; Number of groups: 3 #&gt; #&gt; Group size summary: #&gt; Min: 7 #&gt; Max: 14 #&gt; Mean: 10.7 #&gt; #&gt; Suggestions: #&gt; - Use ungroup() when done with grouped operations #&gt; - Or use .groups = &#39;drop&#39; in summarize() #&gt; - Check grouping with group_vars() before operations mtcars %&gt;% group_by(cyl, gear, carb) %&gt;% check_grouped_operations() #&gt; === Grouping Analysis === #&gt; #&gt; ‚ö† Data IS grouped #&gt; Grouping variables: cyl, gear, carb #&gt; Number of groups: 12 #&gt; #&gt; Group size summary: #&gt; Min: 1 #&gt; Max: 5 #&gt; Mean: 2.7 #&gt; Warning in check_grouped_operations(.): Some groups have only 1 observation #&gt; Suggestions: #&gt; - Use ungroup() when done with grouped operations #&gt; - Or use .groups = &#39;drop&#39; in summarize() #&gt; - Check grouping with group_vars() before operations Exercise 4: grouped_summary &lt;- function(data, group_vars, summary_vars) { # Get total count for percentages total_n &lt;- nrow(data) # Create summary result &lt;- data %&gt;% group_by(across(all_of(group_vars))) %&gt;% summarize( count = n(), pct_of_total = n() / total_n * 100, across( all_of(summary_vars), list( mean = ~mean(., na.rm = TRUE), median = ~median(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE), min = ~min(., na.rm = TRUE), max = ~max(., na.rm = TRUE) ), .names = &quot;{.col}_{.fn}&quot; ), .groups = &quot;drop&quot; ) %&gt;% arrange(desc(count)) result } # Test grouped_summary( mtcars, group_vars = c(&quot;cyl&quot;), summary_vars = c(&quot;mpg&quot;, &quot;hp&quot;) ) #&gt; # A tibble: 3 √ó 13 #&gt; cyl count pct_of_total mpg_mean mpg_median mpg_sd mpg_min mpg_max hp_mean #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 8 14 43.8 15.1 15.2 2.56 10.4 19.2 209. #&gt; 2 4 11 34.4 26.7 26 4.51 21.4 33.9 82.6 #&gt; 3 6 7 21.9 19.7 19.7 1.45 17.8 21.4 122. #&gt; # ‚Ñπ 4 more variables: hp_median &lt;dbl&gt;, hp_sd &lt;dbl&gt;, hp_min &lt;dbl&gt;, hp_max &lt;dbl&gt; grouped_summary( mtcars, group_vars = c(&quot;cyl&quot;, &quot;gear&quot;), summary_vars = c(&quot;mpg&quot;, &quot;hp&quot;, &quot;wt&quot;) ) #&gt; # A tibble: 8 √ó 19 #&gt; cyl gear count pct_of_total mpg_mean mpg_median mpg_sd mpg_min mpg_max #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 8 3 12 37.5 15.0 15.2 2.77 10.4 19.2 #&gt; 2 4 4 8 25 26.9 25.8 4.81 21.4 33.9 #&gt; 3 6 4 4 12.5 19.8 20.1 1.55 17.8 21 #&gt; 4 4 5 2 6.25 28.2 28.2 3.11 26 30.4 #&gt; 5 6 3 2 6.25 19.8 19.8 2.33 18.1 21.4 #&gt; 6 8 5 2 6.25 15.4 15.4 0.566 15 15.8 #&gt; 7 4 3 1 3.12 21.5 21.5 NA 21.5 21.5 #&gt; 8 6 5 1 3.12 19.7 19.7 NA 19.7 19.7 #&gt; # ‚Ñπ 10 more variables: hp_mean &lt;dbl&gt;, hp_median &lt;dbl&gt;, hp_sd &lt;dbl&gt;, #&gt; # hp_min &lt;dbl&gt;, hp_max &lt;dbl&gt;, wt_mean &lt;dbl&gt;, wt_median &lt;dbl&gt;, wt_sd &lt;dbl&gt;, #&gt; # wt_min &lt;dbl&gt;, wt_max &lt;dbl&gt; # With iris grouped_summary( iris, group_vars = &quot;Species&quot;, summary_vars = c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Petal.Length&quot;) ) #&gt; # A tibble: 3 √ó 18 #&gt; Species count pct_of_total Sepal.Length_mean Sepal.Length_median #&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 setosa 50 33.3 5.01 5 #&gt; 2 versicolor 50 33.3 5.94 5.9 #&gt; 3 virginica 50 33.3 6.59 6.5 #&gt; # ‚Ñπ 13 more variables: Sepal.Length_sd &lt;dbl&gt;, Sepal.Length_min &lt;dbl&gt;, #&gt; # Sepal.Length_max &lt;dbl&gt;, Sepal.Width_mean &lt;dbl&gt;, Sepal.Width_median &lt;dbl&gt;, #&gt; # Sepal.Width_sd &lt;dbl&gt;, Sepal.Width_min &lt;dbl&gt;, Sepal.Width_max &lt;dbl&gt;, #&gt; # Petal.Length_mean &lt;dbl&gt;, Petal.Length_median &lt;dbl&gt;, Petal.Length_sd &lt;dbl&gt;, #&gt; # Petal.Length_min &lt;dbl&gt;, Petal.Length_max &lt;dbl&gt; "],["dplyr-joins.html", "Chapter 22 Joins &amp; Merging 22.1 Introduction 22.2 Join Types 22.3 Error #1: by must be supplied 22.4 Error #2: Duplicate keys creating many rows 22.5 Multiple Key Joins 22.6 Error #3: Unexpected NA values after join 22.7 Filtering Joins 22.8 Error #4: Column name conflicts 22.9 Common Join Patterns 22.10 Checking Join Results 22.11 Summary 22.12 Exercises 22.13 Exercise Answers", " Chapter 22 Joins &amp; Merging What You‚Äôll Learn: Types of joins (inner, left, right, full) Join keys and matching Common join errors Multiple key joins Handling duplicates Anti and semi joins Key Errors Covered: 20+ join errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 22.1 Introduction Joining combines data from multiple sources: library(dplyr) # Two related datasets customers &lt;- tibble( id = 1:3, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) ) orders &lt;- tibble( order_id = 1:4, customer_id = c(1, 1, 2, 4), amount = c(100, 150, 200, 75) ) # Join them customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 4 √ó 4 #&gt; id name order_id amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 Alice 1 100 #&gt; 2 1 Alice 2 150 #&gt; 3 2 Bob 3 200 #&gt; 4 3 Charlie NA NA But joins have many pitfalls. Let‚Äôs master them! 22.2 Join Types üí° Key Insight: Four Main Join Types # Sample data band_members #&gt; # A tibble: 3 √ó 2 #&gt; name band #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mick Stones #&gt; 2 John Beatles #&gt; 3 Paul Beatles band_instruments #&gt; # A tibble: 3 √ó 2 #&gt; name plays #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John guitar #&gt; 2 Paul bass #&gt; 3 Keith guitar # inner_join: Only matching rows band_members %&gt;% inner_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 2 √ó 3 #&gt; name band plays #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John Beatles guitar #&gt; 2 Paul Beatles bass # left_join: All from left, matching from right band_members %&gt;% left_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 3 √ó 3 #&gt; name band plays #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mick Stones &lt;NA&gt; #&gt; 2 John Beatles guitar #&gt; 3 Paul Beatles bass # right_join: All from right, matching from left band_members %&gt;% right_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 3 √ó 3 #&gt; name band plays #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John Beatles guitar #&gt; 2 Paul Beatles bass #&gt; 3 Keith &lt;NA&gt; guitar # full_join: All rows from both band_members %&gt;% full_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 4 √ó 3 #&gt; name band plays #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mick Stones &lt;NA&gt; #&gt; 2 John Beatles guitar #&gt; 3 Paul Beatles bass #&gt; 4 Keith &lt;NA&gt; guitar Visual representation: - inner_join: ‚à© (intersection) - left_join: ‚Üê (left + intersection) - right_join: ‚Üí (right + intersection) - full_join: ‚à™ (union, all rows) 22.3 Error #1: by must be supplied ‚≠ê BEGINNER üìã ARGS 22.3.1 The Error df1 &lt;- tibble(id = 1:3, x = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) df2 &lt;- tibble(identifier = 1:3, y = c(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)) df1 %&gt;% left_join(df2) #&gt; Error in `left_join()`: #&gt; ! `by` must be supplied when `x` and `y` have no common variables. #&gt; ‚Ñπ Use `cross_join()` to perform a cross-join. üî¥ ERROR (dplyr &gt;= 1.1.0) Error in left_join(): ! `by` must be supplied when `x` and `y` have no common variables. 22.3.2 What It Means The two datasets have no columns with the same name, so dplyr doesn‚Äôt know how to join them. 22.3.3 Common Causes # Different column names for same concept customers &lt;- tibble(customer_id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200)) customers %&gt;% left_join(orders) # No common columns! #&gt; Error in `left_join()`: #&gt; ! `by` must be supplied when `x` and `y` have no common variables. #&gt; ‚Ñπ Use `cross_join()` to perform a cross-join. # Typo in column name df1 &lt;- tibble(id = 1:3, x = &quot;a&quot;) df2 &lt;- tibble(ID = 1:3, y = &quot;b&quot;) # Different case! df1 %&gt;% left_join(df2) #&gt; Error in `left_join()`: #&gt; ! `by` must be supplied when `x` and `y` have no common variables. #&gt; ‚Ñπ Use `cross_join()` to perform a cross-join. 22.3.4 Solutions ‚úÖ SOLUTION 1: Specify Join Keys # Use by argument with named vector customers &lt;- tibble(customer_id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200)) customers %&gt;% left_join(orders, by = c(&quot;customer_id&quot; = &quot;cust_id&quot;)) #&gt; # A tibble: 4 √ó 3 #&gt; customer_id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 1 A 150 #&gt; 3 2 B 200 #&gt; 4 3 C NA # Multiple keys df1 &lt;- tibble(id = 1:3, type = &quot;A&quot;, x = 1:3) df2 &lt;- tibble(id = 1:3, type = &quot;A&quot;, y = 4:6) df1 %&gt;% left_join(df2, by = c(&quot;id&quot;, &quot;type&quot;)) #&gt; # A tibble: 3 √ó 4 #&gt; id type x y #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 A 1 4 #&gt; 2 2 A 2 5 #&gt; 3 3 A 3 6 # Or with different names df1 &lt;- tibble(id1 = 1:3, type1 = &quot;A&quot;, x = 1:3) df2 &lt;- tibble(id2 = 1:3, type2 = &quot;A&quot;, y = 4:6) df1 %&gt;% left_join(df2, by = c(&quot;id1&quot; = &quot;id2&quot;, &quot;type1&quot; = &quot;type2&quot;)) #&gt; # A tibble: 3 √ó 4 #&gt; id1 type1 x y #&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 A 1 4 #&gt; 2 2 A 2 5 #&gt; 3 3 A 3 6 ‚úÖ SOLUTION 2: Rename Columns First customers &lt;- tibble(customer_id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200)) # Rename to match orders_renamed &lt;- orders %&gt;% rename(customer_id = cust_id) customers %&gt;% left_join(orders_renamed, by = &quot;customer_id&quot;) #&gt; # A tibble: 4 √ó 3 #&gt; customer_id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 1 A 150 #&gt; 3 2 B 200 #&gt; 4 3 C NA ‚úÖ SOLUTION 3: Use join_by() (dplyr &gt;= 1.1.0) # Modern syntax (if available) if (packageVersion(&quot;dplyr&quot;) &gt;= &quot;1.1.0&quot;) { customers %&gt;% left_join(orders, join_by(customer_id == cust_id)) } #&gt; # A tibble: 4 √ó 3 #&gt; customer_id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 1 A 150 #&gt; 3 2 B 200 #&gt; 4 3 C NA 22.4 Error #2: Duplicate keys creating many rows ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 22.4.1 The Problem # Data with duplicates customers &lt;- tibble( id = c(1, 1, 2), # Duplicate id 1! name = c(&quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;) ) orders &lt;- tibble( customer_id = c(1, 1, 2), # Duplicate id 1! amount = c(100, 150, 200) ) # Join creates cartesian product result &lt;- customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; Warning in left_join(., orders, by = c(id = &quot;customer_id&quot;)): Detected an unexpected many-to-many relationship between `x` and `y`. #&gt; ‚Ñπ Row 1 of `x` matches multiple rows in `y`. #&gt; ‚Ñπ Row 1 of `y` matches multiple rows in `x`. #&gt; ‚Ñπ If a many-to-many relationship is expected, set `relationship = #&gt; &quot;many-to-many&quot;` to silence this warning. result #&gt; # A tibble: 5 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 1 Alice 100 #&gt; 4 1 Alice 150 #&gt; 5 2 Bob 200 nrow(result) # 5 rows from 3 + 3! #&gt; [1] 5 22.4.2 What Happened When both tables have duplicate keys, you get all combinations (cartesian product). 22.4.3 Common Causes # Many-to-many relationship students &lt;- tibble( student_id = c(1, 1, 2, 2), course = c(&quot;Math&quot;, &quot;English&quot;, &quot;Math&quot;, &quot;Science&quot;) ) grades &lt;- tibble( student_id = c(1, 1, 2, 2), grade = c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;B&quot;) ) # Which grade goes with which course? students %&gt;% left_join(grades, by = &quot;student_id&quot;) # Ambiguous! #&gt; Warning in left_join(., grades, by = &quot;student_id&quot;): Detected an unexpected many-to-many relationship between `x` and `y`. #&gt; ‚Ñπ Row 1 of `x` matches multiple rows in `y`. #&gt; ‚Ñπ Row 1 of `y` matches multiple rows in `x`. #&gt; ‚Ñπ If a many-to-many relationship is expected, set `relationship = #&gt; &quot;many-to-many&quot;` to silence this warning. #&gt; # A tibble: 8 √ó 3 #&gt; student_id course grade #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Math A #&gt; 2 1 Math B #&gt; 3 1 English A #&gt; 4 1 English B #&gt; 5 2 Math A #&gt; 6 2 Math B #&gt; 7 2 Science A #&gt; 8 2 Science B 22.4.4 Solutions ‚úÖ SOLUTION 1: Remove Duplicates Before Join customers &lt;- tibble( id = c(1, 1, 2), name = c(&quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;) ) # Keep unique customers customers_unique &lt;- customers %&gt;% distinct(id, .keep_all = TRUE) customers_unique %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 3 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 ‚úÖ SOLUTION 2: Check for Duplicates check_join_keys &lt;- function(data, key_cols) { dups &lt;- data %&gt;% group_by(across(all_of(key_cols))) %&gt;% filter(n() &gt; 1) %&gt;% ungroup() if (nrow(dups) &gt; 0) { warning(&quot;Duplicate keys found:\\n&quot;) print(dups) return(FALSE) } message(&quot;No duplicate keys&quot;) return(TRUE) } check_join_keys(customers, &quot;id&quot;) #&gt; Warning in check_join_keys(customers, &quot;id&quot;): Duplicate keys found: #&gt; # A tibble: 2 √ó 2 #&gt; id name #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 Alice #&gt; 2 1 Alice #&gt; [1] FALSE check_join_keys(customers_unique, &quot;id&quot;) #&gt; No duplicate keys #&gt; [1] TRUE ‚úÖ SOLUTION 3: Aggregate Before Join # If duplicates make sense (e.g., multiple orders) orders_summary &lt;- orders %&gt;% group_by(customer_id) %&gt;% summarize( total_orders = n(), total_amount = sum(amount), .groups = &quot;drop&quot; ) customers_unique %&gt;% left_join(orders_summary, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 2 √ó 4 #&gt; id name total_orders total_amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 Alice 2 250 #&gt; 2 2 Bob 1 200 ‚úÖ SOLUTION 4: Use relationship argument (dplyr &gt;= 1.1.0) # Specify expected relationship if (packageVersion(&quot;dplyr&quot;) &gt;= &quot;1.1.0&quot;) { # This will error if relationship is wrong # customers %&gt;% # left_join(orders, # by = c(&quot;id&quot; = &quot;customer_id&quot;), # relationship = &quot;one-to-one&quot;) # Specify many-to-one customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;), relationship = &quot;many-to-one&quot;) } #&gt; Error in `left_join()`: #&gt; ! Each row in `x` must match at most 1 row in `y`. #&gt; ‚Ñπ Row 1 of `x` matches multiple rows in `y`. 22.5 Multiple Key Joins üí° Key Insight: Joining on Multiple Columns # Data with composite keys sales &lt;- tibble( store = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), product = c(&quot;X&quot;, &quot;Y&quot;, &quot;X&quot;, &quot;Y&quot;), quantity = c(10, 20, 15, 25) ) prices &lt;- tibble( store = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), product = c(&quot;X&quot;, &quot;Y&quot;, &quot;X&quot;, &quot;Y&quot;), price = c(5.00, 7.50, 4.50, 8.00) ) # Join on both store and product sales %&gt;% left_join(prices, by = c(&quot;store&quot;, &quot;product&quot;)) %&gt;% mutate(revenue = quantity * price) #&gt; # A tibble: 4 √ó 5 #&gt; store product quantity price revenue #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A X 10 5 50 #&gt; 2 A Y 20 7.5 150 #&gt; 3 B X 15 4.5 67.5 #&gt; 4 B Y 25 8 200 # With different names prices2 &lt;- tibble( location = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), item = c(&quot;X&quot;, &quot;Y&quot;, &quot;X&quot;, &quot;Y&quot;), price = c(5.00, 7.50, 4.50, 8.00) ) sales %&gt;% left_join(prices2, by = c(&quot;store&quot; = &quot;location&quot;, &quot;product&quot; = &quot;item&quot;)) #&gt; # A tibble: 4 √ó 4 #&gt; store product quantity price #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A X 10 5 #&gt; 2 A Y 20 7.5 #&gt; 3 B X 15 4.5 #&gt; 4 B Y 25 8 22.6 Error #3: Unexpected NA values after join ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 22.6.1 The Problem customers &lt;- tibble( id = 1:4, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;) ) orders &lt;- tibble( customer_id = c(1, 1, 2, 5), # Customer 5 doesn&#39;t exist! amount = c(100, 150, 200, 75) ) # Left join result &lt;- customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) result #&gt; # A tibble: 5 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 #&gt; 4 3 Charlie NA #&gt; 5 4 David NA # Charlie and David have no orders (NA in amount) 22.6.2 What Happened Left join keeps all rows from left table. Unmatched rows get NA in right table columns. 22.6.3 Understanding NA Sources # Right join - unmatched from right get NA in left columns result_right &lt;- customers %&gt;% right_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) result_right #&gt; # A tibble: 4 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 #&gt; 4 5 &lt;NA&gt; 75 # Customer 5 order has NA in name # Inner join - no NAs (only matching rows) result_inner &lt;- customers %&gt;% inner_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) result_inner #&gt; # A tibble: 3 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 22.6.4 Solutions ‚úÖ SOLUTION 1: Choose Right Join Type # If you want only matching rows customers %&gt;% inner_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 3 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 # If you want all customers (even without orders) customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 5 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 #&gt; 4 3 Charlie NA #&gt; 5 4 David NA # If you want all orders (even with unknown customers) customers %&gt;% right_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 4 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 #&gt; 4 5 &lt;NA&gt; 75 ‚úÖ SOLUTION 2: Fill NAs After Join customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) %&gt;% mutate( amount = replace_na(amount, 0), order_count = if_else(is.na(amount), 0L, 1L) ) #&gt; # A tibble: 5 √ó 4 #&gt; id name amount order_count #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 1 Alice 100 1 #&gt; 2 1 Alice 150 1 #&gt; 3 2 Bob 200 1 #&gt; 4 3 Charlie 0 1 #&gt; 5 4 David 0 1 # Or with tidyr library(tidyr) customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) %&gt;% replace_na(list(amount = 0)) #&gt; # A tibble: 5 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Alice 100 #&gt; 2 1 Alice 150 #&gt; 3 2 Bob 200 #&gt; 4 3 Charlie 0 #&gt; 5 4 David 0 ‚úÖ SOLUTION 3: Check for Unmatched Rows # Find unmatched customers customers %&gt;% anti_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 2 √ó 2 #&gt; id name #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 3 Charlie #&gt; 2 4 David # Find unmatched orders orders %&gt;% anti_join(customers, by = c(&quot;customer_id&quot; = &quot;id&quot;)) #&gt; # A tibble: 1 √ó 2 #&gt; customer_id amount #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 5 75 22.7 Filtering Joins üí° Key Insight: semi_join() and anti_join() # semi_join: Keep rows in x that have match in y # Like inner_join but doesn&#39;t add columns from y band_members %&gt;% semi_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 2 √ó 2 #&gt; name band #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 John Beatles #&gt; 2 Paul Beatles # anti_join: Keep rows in x that DON&#39;T have match in y band_members %&gt;% anti_join(band_instruments, by = &quot;name&quot;) #&gt; # A tibble: 1 √ó 2 #&gt; name band #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Mick Stones # Practical use: find missing data customers &lt;- tibble(id = 1:5, name = letters[1:5]) orders &lt;- tibble(customer_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75)) # Customers with no orders customers %&gt;% anti_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 2 √ó 2 #&gt; id name #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 4 d #&gt; 2 5 e # Customers with orders customers %&gt;% semi_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 3 √ó 2 #&gt; id name #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c 22.8 Error #4: Column name conflicts ‚≠ê BEGINNER üè∑Ô∏è NAMING 22.8.1 The Problem df1 &lt;- tibble( id = 1:3, value = c(10, 20, 30) ) df2 &lt;- tibble( id = 1:3, value = c(100, 200, 300) ) # Both have &#39;value&#39; column result &lt;- df1 %&gt;% left_join(df2, by = &quot;id&quot;) result #&gt; # A tibble: 3 √ó 3 #&gt; id value.x value.y #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 100 #&gt; 2 2 20 200 #&gt; 3 3 30 300 # Creates value.x and value.y 22.8.2 What Happened Columns with same name (not in join key) get suffixes. 22.8.3 Solutions ‚úÖ SOLUTION 1: Use suffix argument df1 %&gt;% left_join(df2, by = &quot;id&quot;, suffix = c(&quot;_left&quot;, &quot;_right&quot;)) #&gt; # A tibble: 3 √ó 3 #&gt; id value_left value_right #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 100 #&gt; 2 2 20 200 #&gt; 3 3 30 300 # Or more descriptive df1 %&gt;% left_join(df2, by = &quot;id&quot;, suffix = c(&quot;_original&quot;, &quot;_new&quot;)) #&gt; # A tibble: 3 √ó 3 #&gt; id value_original value_new #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 100 #&gt; 2 2 20 200 #&gt; 3 3 30 300 ‚úÖ SOLUTION 2: Rename Before Join df1 %&gt;% rename(value1 = value) %&gt;% left_join( df2 %&gt;% rename(value2 = value), by = &quot;id&quot; ) #&gt; # A tibble: 3 √ó 3 #&gt; id value1 value2 #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 100 #&gt; 2 2 20 200 #&gt; 3 3 30 300 ‚úÖ SOLUTION 3: Select Columns First # Only keep needed columns from each df1 %&gt;% left_join( df2 %&gt;% select(id, value2 = value), by = &quot;id&quot; ) #&gt; Error in select(., id, value2 = value): unused arguments (id, value2 = value) 22.9 Common Join Patterns üéØ Best Practice: Common Join Patterns # 1. Lookup table (add descriptions) products &lt;- tibble( product_id = 1:3, quantity = c(10, 20, 15) ) product_info &lt;- tibble( product_id = 1:3, name = c(&quot;Widget&quot;, &quot;Gadget&quot;, &quot;Doohickey&quot;), price = c(9.99, 19.99, 14.99) ) products %&gt;% left_join(product_info, by = &quot;product_id&quot;) #&gt; # A tibble: 3 √ó 4 #&gt; product_id quantity name price #&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 10 Widget 9.99 #&gt; 2 2 20 Gadget 20.0 #&gt; 3 3 15 Doohickey 15.0 # 2. Aggregate then join orders &lt;- tibble( customer_id = c(1, 1, 2, 2, 3), amount = c(100, 150, 200, 75, 300) ) customers &lt;- tibble( id = 1:3, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;) ) order_summary &lt;- orders %&gt;% group_by(customer_id) %&gt;% summarize( total_orders = n(), total_spent = sum(amount), avg_order = mean(amount), .groups = &quot;drop&quot; ) customers %&gt;% left_join(order_summary, by = c(&quot;id&quot; = &quot;customer_id&quot;)) #&gt; # A tibble: 3 √ó 5 #&gt; id name total_orders total_spent avg_order #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 Alice 2 250 125 #&gt; 2 2 Bob 2 275 138. #&gt; 3 3 Charlie 1 300 300 # 3. Multiple joins students &lt;- tibble(id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) math_grades &lt;- tibble(student_id = 1:3, math = c(85, 90, 78)) english_grades &lt;- tibble(student_id = 1:3, english = c(88, 92, 85)) students %&gt;% left_join(math_grades, by = c(&quot;id&quot; = &quot;student_id&quot;)) %&gt;% left_join(english_grades, by = c(&quot;id&quot; = &quot;student_id&quot;)) #&gt; # A tibble: 3 √ó 4 #&gt; id name math english #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 A 85 88 #&gt; 2 2 B 90 92 #&gt; 3 3 C 78 85 # 4. Self join employees &lt;- tibble( id = 1:4, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;David&quot;), manager_id = c(NA, 1, 1, 2) ) employees %&gt;% left_join( employees %&gt;% select(id, manager_name = name), by = c(&quot;manager_id&quot; = &quot;id&quot;) ) #&gt; Error in select(., id, manager_name = name): unused arguments (id, manager_name = name) # 5. Rolling join (closest match) events &lt;- tibble( time = c(1, 3, 5, 7), event = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;) ) measurements &lt;- tibble( time = c(0, 2, 4, 6, 8), value = c(10, 20, 30, 40, 50) ) # Nearest match (simplified example) events %&gt;% left_join(measurements, by = &quot;time&quot;) # Only exact matches #&gt; # A tibble: 4 √ó 3 #&gt; time event value #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A NA #&gt; 2 3 B NA #&gt; 3 5 C NA #&gt; 4 7 D NA 22.10 Checking Join Results üéØ Best Practice: Validate Joins validate_join &lt;- function(original, joined, join_type = &quot;left&quot;) { cat(&quot;=== Join Validation ===\\n\\n&quot;) # Row count check cat(&quot;Original rows:&quot;, nrow(original), &quot;\\n&quot;) cat(&quot;Joined rows:&quot;, nrow(joined), &quot;\\n&quot;) if (join_type == &quot;inner&quot;) { if (nrow(joined) &gt; nrow(original)) { warning(&quot;Inner join resulted in MORE rows - duplicates in join key?&quot;) } } else if (join_type == &quot;left&quot;) { if (nrow(joined) &lt; nrow(original)) { warning(&quot;Left join resulted in FEWER rows - this shouldn&#39;t happen!&quot;) } else if (nrow(joined) &gt; nrow(original)) { warning(&quot;Left join resulted in MORE rows - duplicates in right table?&quot;) } } # NA check na_cols &lt;- names(joined)[colSums(is.na(joined)) &gt; 0] if (length(na_cols) &gt; 0) { cat(&quot;\\nColumns with NAs:\\n&quot;) for (col in na_cols) { n_na &lt;- sum(is.na(joined[[col]])) cat(&quot; &quot;, col, &quot;:&quot;, n_na, &quot;NAs\\n&quot;) } } # Duplicate check in key columns cat(&quot;\\n&quot;) } # Test customers &lt;- tibble(id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(customer_id = c(1, 1, 2, 4), amount = c(100, 150, 200, 75)) result &lt;- customers %&gt;% left_join(orders, by = c(&quot;id&quot; = &quot;customer_id&quot;)) validate_join(customers, result, &quot;left&quot;) #&gt; === Join Validation === #&gt; #&gt; Original rows: 3 #&gt; Joined rows: 4 #&gt; Warning in validate_join(customers, result, &quot;left&quot;): Left join resulted in MORE #&gt; rows - duplicates in right table? #&gt; #&gt; Columns with NAs: #&gt; amount : 1 NAs 22.11 Summary Key Takeaways: Four main joins - inner, left, right, full Specify by argument - When column names differ Watch for duplicates - Can create many rows Left join creates NAs - For unmatched rows Use filtering joins - semi_join(), anti_join() Check join results - Validate row counts and NAs Name conflicts - Use suffix or rename Quick Reference: Error Cause Fix by must be supplied No common columns Use by = c(\"x\" = \"y\") Too many rows Duplicate keys Check for duplicates, aggregate Unexpected NAs Unmatched rows Use right join type, fill NAs Column conflicts Same name, not in key Use suffix argument Join Types: # Mutating joins (add columns) inner_join(x, y, by = &quot;key&quot;) # Only matching left_join(x, y, by = &quot;key&quot;) # All x, matching y right_join(x, y, by = &quot;key&quot;) # Matching x, all y full_join(x, y, by = &quot;key&quot;) # All rows # Filtering joins (filter rows) semi_join(x, y, by = &quot;key&quot;) # x rows that match y anti_join(x, y, by = &quot;key&quot;) # x rows that don&#39;t match y # Different column names left_join(x, y, by = c(&quot;x_id&quot; = &quot;y_id&quot;)) # Multiple keys left_join(x, y, by = c(&quot;id&quot;, &quot;type&quot;)) # Handle name conflicts left_join(x, y, by = &quot;id&quot;, suffix = c(&quot;_x&quot;, &quot;_y&quot;)) Best Practices: # ‚úÖ Good left_join(x, y, by = &quot;key&quot;) # Explicit by Check for duplicates before join # Avoid cartesian Validate row counts after join # Catch issues Use appropriate join type # inner vs left vs full # ‚ùå Avoid left_join(x, y) # No by (relies on names) Join without checking duplicates # Surprise row explosion Ignore NAs after join # May indicate issues Always use left_join # Sometimes inner is right 22.12 Exercises üìù Exercise 1: Basic Joins Given: products &lt;- tibble(id = 1:5, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)) sales &lt;- tibble(product_id = c(1, 2, 2, 3, 6), amount = c(100, 150, 200, 75, 50)) Inner join - only products with sales Left join - all products, add sales Find products with no sales Find sales for unknown products üìù Exercise 2: Duplicate Handling Given data with duplicates: customers &lt;- tibble(id = c(1, 1, 2, 3), name = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(cust_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75)) Identify the duplicates Remove them appropriately Perform safe join Validate result üìù Exercise 3: Safe Join Function Write safe_join(x, y, by, type) that: 1. Checks for duplicate keys 2. Validates join will work 3. Performs join 4. Checks result makes sense 5. Returns result with metadata üìù Exercise 4: Multiple Table Join Join three tables efficiently: students &lt;- tibble(id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) courses &lt;- tibble(student_id = c(1, 1, 2, 3), course = c(&quot;Math&quot;, &quot;Eng&quot;, &quot;Math&quot;, &quot;Sci&quot;)) grades &lt;- tibble(student_id = c(1, 1, 2, 3), course = c(&quot;Math&quot;, &quot;Eng&quot;, &quot;Math&quot;, &quot;Sci&quot;), grade = c(85, 90, 78, 92)) 22.13 Exercise Answers Click to see answers Exercise 1: products &lt;- tibble(id = 1:5, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;)) sales &lt;- tibble(product_id = c(1, 2, 2, 3, 6), amount = c(100, 150, 200, 75, 50)) # 1. Inner join - only products with sales products_with_sales &lt;- products %&gt;% inner_join(sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) products_with_sales #&gt; # A tibble: 4 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 2 B 150 #&gt; 3 2 B 200 #&gt; 4 3 C 75 # 2. Left join - all products, add sales all_products &lt;- products %&gt;% left_join(sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) all_products #&gt; # A tibble: 6 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 2 B 150 #&gt; 3 2 B 200 #&gt; 4 3 C 75 #&gt; 5 4 D NA #&gt; 6 5 E NA # 3. Find products with no sales no_sales &lt;- products %&gt;% anti_join(sales, by = c(&quot;id&quot; = &quot;product_id&quot;)) no_sales #&gt; # A tibble: 2 √ó 2 #&gt; id name #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 4 D #&gt; 2 5 E # 4. Find sales for unknown products unknown_products &lt;- sales %&gt;% anti_join(products, by = c(&quot;product_id&quot; = &quot;id&quot;)) unknown_products #&gt; # A tibble: 1 √ó 2 #&gt; product_id amount #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 6 50 Exercise 2: customers &lt;- tibble(id = c(1, 1, 2, 3), name = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(cust_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75)) # 1. Identify duplicates cat(&quot;Duplicate customers:\\n&quot;) #&gt; Duplicate customers: customers %&gt;% group_by(id) %&gt;% filter(n() &gt; 1) #&gt; # A tibble: 2 √ó 2 #&gt; # Groups: id [1] #&gt; id name #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 A #&gt; 2 1 A cat(&quot;\\nDuplicate orders:\\n&quot;) #&gt; #&gt; Duplicate orders: orders %&gt;% group_by(cust_id) %&gt;% filter(n() &gt; 1) #&gt; # A tibble: 2 √ó 2 #&gt; # Groups: cust_id [1] #&gt; cust_id amount #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2 150 #&gt; 2 2 200 # 2. Remove duplicates customers_unique &lt;- customers %&gt;% distinct(id, .keep_all = TRUE) # Orders: multiple per customer is expected, so aggregate orders_summary &lt;- orders %&gt;% group_by(cust_id) %&gt;% summarize( n_orders = n(), total_amount = sum(amount), avg_amount = mean(amount), .groups = &quot;drop&quot; ) # 3. Perform safe join result &lt;- customers_unique %&gt;% left_join(orders_summary, by = c(&quot;id&quot; = &quot;cust_id&quot;)) # 4. Validate cat(&quot;\\nValidation:\\n&quot;) #&gt; #&gt; Validation: cat(&quot;Original customers:&quot;, nrow(customers_unique), &quot;\\n&quot;) #&gt; Original customers: 3 cat(&quot;Result rows:&quot;, nrow(result), &quot;\\n&quot;) #&gt; Result rows: 3 cat(&quot;Should be equal:&quot;, nrow(customers_unique) == nrow(result), &quot;\\n&quot;) #&gt; Should be equal: TRUE result #&gt; # A tibble: 3 √ó 5 #&gt; id name n_orders total_amount avg_amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 A 1 100 100 #&gt; 2 2 B 2 350 175 #&gt; 3 3 C 1 75 75 Exercise 3: safe_join &lt;- function(x, y, by, type = &quot;left&quot;) { # Validate inputs if (!type %in% c(&quot;inner&quot;, &quot;left&quot;, &quot;right&quot;, &quot;full&quot;)) { stop(&quot;type must be inner, left, right, or full&quot;) } # Extract key columns if (is.character(by)) { x_keys &lt;- if (is.null(names(by))) by else names(by) y_keys &lt;- if (is.null(names(by))) by else unname(by) } else { stop(&quot;by must be a character vector&quot;) } # Check keys exist if (!all(x_keys %in% names(x))) { stop(&quot;Some keys not found in x: &quot;, paste(setdiff(x_keys, names(x)), collapse = &quot;, &quot;)) } if (!all(y_keys %in% names(y))) { stop(&quot;Some keys not found in y: &quot;, paste(setdiff(y_keys, names(y)), collapse = &quot;, &quot;)) } # Check for duplicates x_dups &lt;- x %&gt;% group_by(across(all_of(x_keys))) %&gt;% filter(n() &gt; 1) %&gt;% nrow() y_dups &lt;- y %&gt;% group_by(across(all_of(y_keys))) %&gt;% filter(n() &gt; 1) %&gt;% nrow() if (x_dups &gt; 0) { warning(&quot;x has &quot;, x_dups, &quot; duplicate key rows&quot;) } if (y_dups &gt; 0) { warning(&quot;y has &quot;, y_dups, &quot; duplicate key rows&quot;) } # Perform join result &lt;- switch(type, inner = inner_join(x, y, by = by), left = left_join(x, y, by = by), right = right_join(x, y, by = by), full = full_join(x, y, by = by) ) # Validate result metadata &lt;- list( type = type, x_rows = nrow(x), y_rows = nrow(y), result_rows = nrow(result), x_duplicates = x_dups, y_duplicates = y_dups, na_columns = names(result)[colSums(is.na(result)) &gt; 0] ) # Check expectations if (type == &quot;left&quot; &amp;&amp; nrow(result) &lt; nrow(x)) { warning(&quot;Left join resulted in fewer rows than x!&quot;) } if (type == &quot;inner&quot; &amp;&amp; nrow(result) &gt; min(nrow(x), nrow(y))) { warning(&quot;Inner join resulted in more rows than either input - check for duplicates&quot;) } # Return with metadata attr(result, &quot;join_metadata&quot;) &lt;- metadata result } # Test customers &lt;- tibble(id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) orders &lt;- tibble(customer_id = c(1, 1, 2, 4), amount = c(100, 150, 200, 75)) result &lt;- safe_join(customers, orders, by = c(&quot;id&quot; = &quot;customer_id&quot;), type = &quot;left&quot;) #&gt; Warning in safe_join(customers, orders, by = c(id = &quot;customer_id&quot;), type = #&gt; &quot;left&quot;): y has 2 duplicate key rows result #&gt; # A tibble: 4 √ó 3 #&gt; id name amount #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A 100 #&gt; 2 1 A 150 #&gt; 3 2 B 200 #&gt; 4 3 C NA attr(result, &quot;join_metadata&quot;) #&gt; $type #&gt; [1] &quot;left&quot; #&gt; #&gt; $x_rows #&gt; [1] 3 #&gt; #&gt; $y_rows #&gt; [1] 4 #&gt; #&gt; $result_rows #&gt; [1] 4 #&gt; #&gt; $x_duplicates #&gt; [1] 0 #&gt; #&gt; $y_duplicates #&gt; [1] 2 #&gt; #&gt; $na_columns #&gt; [1] &quot;amount&quot; Exercise 4: students &lt;- tibble(id = 1:3, name = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) courses &lt;- tibble( student_id = c(1, 1, 2, 3), course = c(&quot;Math&quot;, &quot;Eng&quot;, &quot;Math&quot;, &quot;Sci&quot;) ) grades &lt;- tibble( student_id = c(1, 1, 2, 3), course = c(&quot;Math&quot;, &quot;Eng&quot;, &quot;Math&quot;, &quot;Sci&quot;), grade = c(85, 90, 78, 92) ) # Method 1: Chain joins result1 &lt;- students %&gt;% left_join(courses, by = c(&quot;id&quot; = &quot;student_id&quot;)) %&gt;% left_join(grades, by = c(&quot;id&quot; = &quot;student_id&quot;, &quot;course&quot; = &quot;course&quot;)) result1 #&gt; # A tibble: 4 √ó 4 #&gt; id name course grade #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A Math 85 #&gt; 2 1 A Eng 90 #&gt; 3 2 B Math 78 #&gt; 4 3 C Sci 92 # Method 2: Join courses and grades first result2 &lt;- students %&gt;% left_join( courses %&gt;% left_join(grades, by = c(&quot;student_id&quot;, &quot;course&quot;)), by = c(&quot;id&quot; = &quot;student_id&quot;) ) result2 #&gt; # A tibble: 4 √ó 4 #&gt; id name course grade #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 A Math 85 #&gt; 2 1 A Eng 90 #&gt; 3 2 B Math 78 #&gt; 4 3 C Sci 92 # Method 3: Using reduce (for many tables) library(purrr) tables &lt;- list( students, courses, grades ) keys &lt;- list( c(&quot;id&quot; = &quot;student_id&quot;), c(&quot;id&quot; = &quot;student_id&quot;, &quot;course&quot; = &quot;course&quot;) ) # This is complex - usually method 1 or 2 is better # Showing for completeness # Summary by student summary_result &lt;- students %&gt;% left_join( courses %&gt;% left_join(grades, by = c(&quot;student_id&quot;, &quot;course&quot;)) %&gt;% group_by(student_id) %&gt;% summarize( n_courses = n(), avg_grade = mean(grade, na.rm = TRUE), courses = paste(course, collapse = &quot;, &quot;), .groups = &quot;drop&quot; ), by = c(&quot;id&quot; = &quot;student_id&quot;) ) summary_result #&gt; # A tibble: 3 √ó 5 #&gt; id name n_courses avg_grade courses #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 A 2 87.5 Math, Eng #&gt; 2 2 B 1 78 Math #&gt; 3 3 C 1 92 Sci "],["tidyr-intro.html", "Chapter 23 Introduction to tidyr 23.1 Introduction 23.2 Tidy Data Principles 23.3 pivot_longer() Basics 23.4 Error #1: cols must select at least one column 23.5 pivot_wider() Basics 23.6 Error #2: Values are not uniquely identified 23.7 separate() and unite() 23.8 fill() for Missing Values 23.9 complete() for Implicit Missing Values 23.10 Common Patterns 23.11 Summary 23.12 Exercises 23.13 Exercise Answers", " Chapter 23 Introduction to tidyr What You‚Äôll Learn: Tidy data principles Wide vs long format pivot_longer() and pivot_wider() Common reshaping errors When to reshape data Key Errors Covered: 15+ tidyr errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 23.1 Introduction tidyr helps reshape data between wide and long formats: library(tidyr) library(dplyr) # Wide format wide_data &lt;- tibble( id = 1:3, time_1 = c(10, 20, 30), time_2 = c(15, 25, 35), time_3 = c(20, 30, 40) ) # Convert to long format long_data &lt;- wide_data %&gt;% pivot_longer( cols = starts_with(&quot;time&quot;), names_to = &quot;time&quot;, values_to = &quot;value&quot; ) long_data #&gt; # A tibble: 9 √ó 3 #&gt; id time value #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 time_1 10 #&gt; 2 1 time_2 15 #&gt; 3 1 time_3 20 #&gt; 4 2 time_1 20 #&gt; 5 2 time_2 25 #&gt; 6 2 time_3 30 #&gt; 7 3 time_1 30 #&gt; 8 3 time_2 35 #&gt; 9 3 time_3 40 Let‚Äôs master reshaping! 23.2 Tidy Data Principles üí° Key Insight: What is Tidy Data? # Tidy data rules: # 1. Each variable is a column # 2. Each observation is a row # 3. Each type of observational unit is a table # Example: UNTIDY (wide format) untidy &lt;- tibble( person = c(&quot;Alice&quot;, &quot;Bob&quot;), age = c(25, 30), income_2020 = c(50000, 60000), income_2021 = c(52000, 62000), income_2022 = c(54000, 64000) ) untidy #&gt; # A tibble: 2 √ó 5 #&gt; person age income_2020 income_2021 income_2022 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alice 25 50000 52000 54000 #&gt; 2 Bob 30 60000 62000 64000 # TIDY (long format) tidy &lt;- untidy %&gt;% pivot_longer( cols = starts_with(&quot;income&quot;), names_to = &quot;year&quot;, names_prefix = &quot;income_&quot;, values_to = &quot;income&quot; ) tidy #&gt; # A tibble: 6 √ó 4 #&gt; person age year income #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alice 25 2020 50000 #&gt; 2 Alice 25 2021 52000 #&gt; 3 Alice 25 2022 54000 #&gt; 4 Bob 30 2020 60000 #&gt; 5 Bob 30 2021 62000 #&gt; 6 Bob 30 2022 64000 # Now year is a variable, each row is person-year observation Why tidy data? - Works naturally with dplyr and ggplot2 - Easy to filter, group, and summarize - Consistent structure for analysis 23.3 pivot_longer() Basics üí° Key Insight: Wide to Long with pivot_longer() # Basic pivot_longer wide &lt;- tibble( id = 1:3, q1 = c(5, 3, 4), q2 = c(4, 5, 3), q3 = c(3, 4, 5) ) wide %&gt;% pivot_longer( cols = q1:q3, # Columns to pivot names_to = &quot;quarter&quot;, # New column for names values_to = &quot;score&quot; # New column for values ) #&gt; # A tibble: 9 √ó 3 #&gt; id quarter score #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 q1 5 #&gt; 2 1 q2 4 #&gt; 3 1 q3 3 #&gt; 4 2 q1 3 #&gt; 5 2 q2 5 #&gt; 6 2 q3 4 #&gt; 7 3 q1 4 #&gt; 8 3 q2 3 #&gt; 9 3 q3 5 # Using selection helpers wide %&gt;% pivot_longer( cols = starts_with(&quot;q&quot;), names_to = &quot;quarter&quot;, values_to = &quot;score&quot; ) #&gt; # A tibble: 9 √ó 3 #&gt; id quarter score #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 q1 5 #&gt; 2 1 q2 4 #&gt; 3 1 q3 3 #&gt; 4 2 q1 3 #&gt; 5 2 q2 5 #&gt; 6 2 q3 4 #&gt; 7 3 q1 4 #&gt; 8 3 q2 3 #&gt; 9 3 q3 5 # Keep some columns wide %&gt;% pivot_longer( cols = -id, # All except id names_to = &quot;quarter&quot;, values_to = &quot;score&quot; ) #&gt; # A tibble: 9 √ó 3 #&gt; id quarter score #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 q1 5 #&gt; 2 1 q2 4 #&gt; 3 1 q3 3 #&gt; 4 2 q1 3 #&gt; 5 2 q2 5 #&gt; 6 2 q3 4 #&gt; 7 3 q1 4 #&gt; 8 3 q2 3 #&gt; 9 3 q3 5 # Multiple value types data &lt;- tibble( id = 1:2, x_value = c(10, 20), x_error = c(1, 2), y_value = c(30, 40), y_error = c(3, 4) ) data %&gt;% pivot_longer( cols = -id, names_to = c(&quot;variable&quot;, &quot;.value&quot;), names_sep = &quot;_&quot; ) #&gt; # A tibble: 4 √ó 4 #&gt; id variable value error #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 x 10 1 #&gt; 2 1 y 30 3 #&gt; 3 2 x 20 2 #&gt; 4 2 y 40 4 23.4 Error #1: cols must select at least one column ‚≠ê BEGINNER üìã ARGS 23.4.1 The Error data &lt;- tibble( id = 1:3, value = c(10, 20, 30) ) data %&gt;% pivot_longer( cols = starts_with(&quot;time&quot;), # No columns match! names_to = &quot;time&quot;, values_to = &quot;measurement&quot; ) #&gt; Error in `pivot_longer()`: #&gt; ! `cols` must select at least one column. üî¥ ERROR Error in pivot_longer(): ! `cols` must select at least one column. 23.4.2 What It Means The column selection didn‚Äôt match any columns. 23.4.3 Solutions ‚úÖ SOLUTION 1: Check Column Names # Verify columns exist names(data) #&gt; [1] &quot;id&quot; &quot;value&quot; # Use correct selection data_wide &lt;- tibble( id = 1:3, time_1 = c(10, 20, 30), time_2 = c(15, 25, 35) ) data_wide %&gt;% pivot_longer( cols = starts_with(&quot;time&quot;), names_to = &quot;time&quot;, values_to = &quot;value&quot; ) #&gt; # A tibble: 6 √ó 3 #&gt; id time value #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 time_1 10 #&gt; 2 1 time_2 15 #&gt; 3 2 time_1 20 #&gt; 4 2 time_2 25 #&gt; 5 3 time_1 30 #&gt; 6 3 time_2 35 ‚úÖ SOLUTION 2: Use Flexible Selection # Select all numeric columns data_wide %&gt;% pivot_longer( cols = where(is.numeric), names_to = &quot;variable&quot;, values_to = &quot;value&quot; ) #&gt; # A tibble: 9 √ó 2 #&gt; variable value #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 id 1 #&gt; 2 time_1 10 #&gt; 3 time_2 15 #&gt; 4 id 2 #&gt; 5 time_1 20 #&gt; 6 time_2 25 #&gt; 7 id 3 #&gt; 8 time_1 30 #&gt; 9 time_2 35 # Or exclude specific columns data_wide %&gt;% pivot_longer( cols = -id, names_to = &quot;variable&quot;, values_to = &quot;value&quot; ) #&gt; # A tibble: 6 √ó 3 #&gt; id variable value #&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 time_1 10 #&gt; 2 1 time_2 15 #&gt; 3 2 time_1 20 #&gt; 4 2 time_2 25 #&gt; 5 3 time_1 30 #&gt; 6 3 time_2 35 23.5 pivot_wider() Basics üí° Key Insight: Long to Wide with pivot_wider() # Basic pivot_wider long &lt;- tibble( id = rep(1:3, each = 2), time = rep(c(&quot;before&quot;, &quot;after&quot;), 3), value = c(10, 15, 20, 25, 30, 35) ) long %&gt;% pivot_wider( names_from = time, # Column to get names from values_from = value # Column to get values from ) #&gt; # A tibble: 3 √ó 3 #&gt; id before after #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 15 #&gt; 2 2 20 25 #&gt; 3 3 30 35 # Multiple value columns long_multi &lt;- tibble( id = rep(1:2, each = 2), time = rep(c(&quot;t1&quot;, &quot;t2&quot;), 2), score = c(10, 15, 20, 25), error = c(1, 2, 3, 4) ) long_multi %&gt;% pivot_wider( names_from = time, values_from = c(score, error) ) #&gt; # A tibble: 2 √ó 5 #&gt; id score_t1 score_t2 error_t1 error_t2 #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 15 1 2 #&gt; 2 2 20 25 3 4 # With name formatting long %&gt;% pivot_wider( names_from = time, values_from = value, names_prefix = &quot;time_&quot; ) #&gt; # A tibble: 3 √ó 3 #&gt; id time_before time_after #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 15 #&gt; 2 2 20 25 #&gt; 3 3 30 35 23.6 Error #2: Values are not uniquely identified ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 23.6.1 The Error # Data with duplicates data &lt;- tibble( id = c(1, 1, 2, 2), time = c(&quot;before&quot;, &quot;before&quot;, &quot;before&quot;, &quot;after&quot;), value = c(10, 15, 20, 25) ) data %&gt;% pivot_wider( names_from = time, values_from = value ) #&gt; Warning: Values from `value` are not uniquely identified; output will contain list-cols. #&gt; ‚Ä¢ Use `values_fn = list` to suppress this warning. #&gt; ‚Ä¢ Use `values_fn = {summary_fun}` to summarise duplicates. #&gt; ‚Ä¢ Use the following dplyr code to identify duplicates. #&gt; {data} |&gt; #&gt; dplyr::summarise(n = dplyr::n(), .by = c(id, time)) |&gt; #&gt; dplyr::filter(n &gt; 1L) #&gt; # A tibble: 2 √ó 3 #&gt; id before after #&gt; &lt;dbl&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 1 &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 2 &lt;dbl [1]&gt; &lt;dbl [1]&gt; üî¥ WARNING/ERROR Warning: Values from `value` are not uniquely identified; output will contain list-cols. 23.6.2 What It Means Multiple values exist for same id-time combination. Can‚Äôt decide which to use. 23.6.3 Common Causes # Multiple measurements per combination measurements &lt;- tibble( person = c(&quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Bob&quot;), test = c(&quot;test1&quot;, &quot;test1&quot;, &quot;test2&quot;, &quot;test2&quot;), score = c(85, 87, 90, 92) # Two scores for Alice-test1 ) measurements %&gt;% pivot_wider( names_from = test, values_from = score ) #&gt; Warning: Values from `score` are not uniquely identified; output will contain list-cols. #&gt; ‚Ä¢ Use `values_fn = list` to suppress this warning. #&gt; ‚Ä¢ Use `values_fn = {summary_fun}` to summarise duplicates. #&gt; ‚Ä¢ Use the following dplyr code to identify duplicates. #&gt; {data} |&gt; #&gt; dplyr::summarise(n = dplyr::n(), .by = c(person, test)) |&gt; #&gt; dplyr::filter(n &gt; 1L) #&gt; # A tibble: 2 √ó 3 #&gt; person test1 test2 #&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 Alice &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 Bob &lt;NULL&gt; &lt;dbl [2]&gt; # Creates list columns! 23.6.4 Solutions ‚úÖ SOLUTION 1: Aggregate First measurements %&gt;% group_by(person, test) %&gt;% summarize(score = mean(score), .groups = &quot;drop&quot;) %&gt;% pivot_wider( names_from = test, values_from = score ) #&gt; # A tibble: 2 √ó 3 #&gt; person test1 test2 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alice 86 NA #&gt; 2 Bob NA 91 ‚úÖ SOLUTION 2: Add Identifier # Add row number to make unique measurements %&gt;% group_by(person, test) %&gt;% mutate(attempt = row_number()) %&gt;% pivot_wider( names_from = c(test, attempt), values_from = score ) #&gt; # A tibble: 2 √ó 5 #&gt; # Groups: person [2] #&gt; person test1_1 test1_2 test2_1 test2_2 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alice 85 87 NA NA #&gt; 2 Bob NA NA 90 92 ‚úÖ SOLUTION 3: Use values_fn # Specify how to aggregate measurements %&gt;% pivot_wider( names_from = test, values_from = score, values_fn = list(score = mean) ) #&gt; # A tibble: 2 √ó 3 #&gt; person test1 test2 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Alice 86 NA #&gt; 2 Bob NA 91 # Or use list for multiple aggregations measurements %&gt;% pivot_wider( names_from = test, values_from = score, values_fn = list(score = list) ) #&gt; # A tibble: 2 √ó 3 #&gt; person test1 test2 #&gt; &lt;chr&gt; &lt;list&gt; &lt;list&gt; #&gt; 1 Alice &lt;dbl [2]&gt; &lt;NULL&gt; #&gt; 2 Bob &lt;NULL&gt; &lt;dbl [2]&gt; 23.7 separate() and unite() üí° Key Insight: Splitting and Combining Columns # separate: split one column into multiple data &lt;- tibble( id = 1:3, name = c(&quot;Alice_Smith&quot;, &quot;Bob_Jones&quot;, &quot;Charlie_Brown&quot;) ) data %&gt;% separate(name, into = c(&quot;first&quot;, &quot;last&quot;), sep = &quot;_&quot;) #&gt; # A tibble: 3 √ó 3 #&gt; id first last #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Alice Smith #&gt; 2 2 Bob Jones #&gt; 3 3 Charlie Brown # With different separator data2 &lt;- tibble( id = 1:3, date = c(&quot;2024-01-15&quot;, &quot;2024-02-20&quot;, &quot;2024-03-25&quot;) ) data2 %&gt;% separate(date, into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep = &quot;-&quot;) #&gt; # A tibble: 3 √ó 4 #&gt; id year month day #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 2024 01 15 #&gt; 2 2 2024 02 20 #&gt; 3 3 2024 03 25 # Convert types data2 %&gt;% separate(date, into = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;), sep = &quot;-&quot;, convert = TRUE) #&gt; # A tibble: 3 √ó 4 #&gt; id year month day #&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 1 2024 1 15 #&gt; 2 2 2024 2 20 #&gt; 3 3 2024 3 25 # unite: combine multiple columns data_split &lt;- tibble( id = 1:3, first = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), last = c(&quot;Smith&quot;, &quot;Jones&quot;, &quot;Brown&quot;) ) data_split %&gt;% unite(name, first, last, sep = &quot; &quot;) #&gt; # A tibble: 3 √ó 2 #&gt; id name #&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 1 Alice Smith #&gt; 2 2 Bob Jones #&gt; 3 3 Charlie Brown # Keep original columns data_split %&gt;% unite(name, first, last, sep = &quot; &quot;, remove = FALSE) #&gt; # A tibble: 3 √ó 4 #&gt; id name first last #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Alice Smith Alice Smith #&gt; 2 2 Bob Jones Bob Jones #&gt; 3 3 Charlie Brown Charlie Brown 23.8 fill() for Missing Values üí° Key Insight: Fill Missing Values # Data with implicit missing values data &lt;- tibble( group = c(&quot;A&quot;, NA, NA, &quot;B&quot;, NA, &quot;C&quot;), value = 1:6 ) # Fill down data %&gt;% fill(group) #&gt; # A tibble: 6 √ó 2 #&gt; group value #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 A 1 #&gt; 2 A 2 #&gt; 3 A 3 #&gt; 4 B 4 #&gt; 5 B 5 #&gt; 6 C 6 # Fill up data %&gt;% fill(group, .direction = &quot;up&quot;) #&gt; # A tibble: 6 √ó 2 #&gt; group value #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 A 1 #&gt; 2 B 2 #&gt; 3 B 3 #&gt; 4 B 4 #&gt; 5 C 5 #&gt; 6 C 6 # Fill both directions data %&gt;% fill(group, .direction = &quot;downup&quot;) #&gt; # A tibble: 6 √ó 2 #&gt; group value #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 A 1 #&gt; 2 A 2 #&gt; 3 A 3 #&gt; 4 B 4 #&gt; 5 B 5 #&gt; 6 C 6 23.9 complete() for Implicit Missing Values üí° Key Insight: Make Implicit NAs Explicit # Incomplete data sales &lt;- tibble( product = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;), quarter = c(1, 2, 1), sales = c(100, 150, 200) ) # Missing: product B quarter 2 # Make it explicit sales %&gt;% complete(product, quarter) #&gt; # A tibble: 4 √ó 3 #&gt; product quarter sales #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A 1 100 #&gt; 2 A 2 150 #&gt; 3 B 1 200 #&gt; 4 B 2 NA # Fill with specific value sales %&gt;% complete(product, quarter, fill = list(sales = 0)) #&gt; # A tibble: 4 √ó 3 #&gt; product quarter sales #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 A 1 100 #&gt; 2 A 2 150 #&gt; 3 B 1 200 #&gt; 4 B 2 0 # With sequences dates &lt;- tibble( date = as.Date(c(&quot;2024-01-01&quot;, &quot;2024-01-03&quot;, &quot;2024-01-05&quot;)), value = c(10, 20, 30) ) dates %&gt;% complete(date = seq(min(date), max(date), by = &quot;day&quot;)) #&gt; # A tibble: 5 √ó 2 #&gt; date value #&gt; &lt;date&gt; &lt;dbl&gt; #&gt; 1 2024-01-01 10 #&gt; 2 2024-01-02 NA #&gt; 3 2024-01-03 20 #&gt; 4 2024-01-04 NA #&gt; 5 2024-01-05 30 23.10 Common Patterns üéØ Best Practice: Reshaping Workflows # 1. Survey data wide to long survey_wide &lt;- tibble( id = 1:3, q1_satisfaction = c(5, 4, 3), q1_importance = c(5, 5, 4), q2_satisfaction = c(4, 3, 5), q2_importance = c(4, 4, 5) ) survey_long &lt;- survey_wide %&gt;% pivot_longer( cols = -id, names_to = c(&quot;question&quot;, &quot;measure&quot;), names_sep = &quot;_&quot;, values_to = &quot;rating&quot; ) survey_long #&gt; # A tibble: 12 √ó 4 #&gt; id question measure rating #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 q1 satisfaction 5 #&gt; 2 1 q1 importance 5 #&gt; 3 1 q2 satisfaction 4 #&gt; 4 1 q2 importance 4 #&gt; 5 2 q1 satisfaction 4 #&gt; 6 2 q1 importance 5 #&gt; 7 2 q2 satisfaction 3 #&gt; 8 2 q2 importance 4 #&gt; 9 3 q1 satisfaction 3 #&gt; 10 3 q1 importance 4 #&gt; 11 3 q2 satisfaction 5 #&gt; 12 3 q2 importance 5 # 2. Time series wide to long stocks &lt;- tibble( date = as.Date(&quot;2024-01-01&quot;) + 0:2, AAPL = c(150, 152, 149), GOOGL = c(140, 142, 138), MSFT = c(380, 385, 378) ) stocks %&gt;% pivot_longer( cols = -date, names_to = &quot;stock&quot;, values_to = &quot;price&quot; ) #&gt; # A tibble: 9 √ó 3 #&gt; date stock price #&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 2024-01-01 AAPL 150 #&gt; 2 2024-01-01 GOOGL 140 #&gt; 3 2024-01-01 MSFT 380 #&gt; 4 2024-01-02 AAPL 152 #&gt; 5 2024-01-02 GOOGL 142 #&gt; 6 2024-01-02 MSFT 385 #&gt; 7 2024-01-03 AAPL 149 #&gt; 8 2024-01-03 GOOGL 138 #&gt; 9 2024-01-03 MSFT 378 # 3. Pivot wider for comparison comparisons &lt;- tibble( id = rep(1:3, each = 2), condition = rep(c(&quot;control&quot;, &quot;treatment&quot;), 3), outcome = c(10, 12, 15, 18, 20, 22) ) comparisons %&gt;% pivot_wider( names_from = condition, values_from = outcome ) %&gt;% mutate(difference = treatment - control) #&gt; # A tibble: 3 √ó 4 #&gt; id control treatment difference #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 12 2 #&gt; 2 2 15 18 3 #&gt; 3 3 20 22 2 # 4. Complex reshape data &lt;- tibble( id = 1:2, treatment_1_pre = c(10, 15), treatment_1_post = c(12, 17), treatment_2_pre = c(20, 25), treatment_2_post = c(22, 27) ) data %&gt;% pivot_longer( cols = -id, names_to = c(&quot;treatment&quot;, &quot;time&quot;), names_pattern = &quot;treatment_(.*)_(.*)&quot;, values_to = &quot;score&quot; ) #&gt; # A tibble: 8 √ó 4 #&gt; id treatment time score #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 1 pre 10 #&gt; 2 1 1 post 12 #&gt; 3 1 2 pre 20 #&gt; 4 1 2 post 22 #&gt; 5 2 1 pre 15 #&gt; 6 2 1 post 17 #&gt; 7 2 2 pre 25 #&gt; 8 2 2 post 27 23.11 Summary Key Takeaways: Tidy data principles - Variables in columns, observations in rows pivot_longer() - Wide to long format pivot_wider() - Long to wide format Check for duplicates - Before pivot_wider() separate() and unite() - Split/combine columns fill() - Handle missing values complete() - Make implicit NAs explicit Quick Reference: Function Purpose Common Use pivot_longer() Wide ‚Üí Long Convert multiple columns to rows pivot_wider() Long ‚Üí Wide Spread values across columns separate() Split column Parse combined data unite() Combine columns Create composite keys fill() Fill NAs Propagate values complete() Add missing combos Explicit NAs Reshaping: # Wide to long data %&gt;% pivot_longer( cols = col1:col3, names_to = &quot;variable&quot;, values_to = &quot;value&quot; ) # Long to wide data %&gt;% pivot_wider( names_from = variable, values_from = value ) # Split column data %&gt;% separate(col, into = c(&quot;part1&quot;, &quot;part2&quot;), sep = &quot;_&quot;) # Combine columns data %&gt;% unite(new_col, col1, col2, sep = &quot;_&quot;) # Fill missing data %&gt;% fill(col, .direction = &quot;down&quot;) # Complete combinations data %&gt;% complete(var1, var2, fill = list(value = 0)) Best Practices: # ‚úÖ Good Check data structure first # Know what you have Aggregate before pivot_wider # Avoid list columns Use descriptive names_to/values_to # Clear column names Test on small sample first # Verify logic # ‚ùå Avoid Pivot_wider with duplicates # Creates list columns Complex reshapes in one step # Hard to debug Forgetting to specify cols # Error or unexpected Not checking result structure # May not be what you want 23.12 Exercises üìù Exercise 1: Wide to Long Given: grades &lt;- tibble( student = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), math_q1 = c(85, 78, 92), math_q2 = c(88, 82, 95), english_q1 = c(90, 85, 88), english_q2 = c(92, 87, 90) ) Convert to long format with columns: student, subject, quarter, grade üìù Exercise 2: Long to Wide Given: measurements &lt;- tibble( id = rep(1:3, each = 3), time = rep(c(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;), 3), value = c(10, 12, 14, 20, 22, 24, 30, 32, 34) ) Convert to wide format with time as columns üìù Exercise 3: Safe Pivot Write safe_pivot_wider(data, names_from, values_from) that: 1. Checks for duplicate combinations 2. Aggregates if needed 3. Performs pivot 4. Validates result üìù Exercise 4: Complex Reshape Given survey data: survey &lt;- tibble( id = 1:3, age = c(25, 30, 35), q1_pre = c(3, 4, 2), q1_post = c(4, 5, 3), q2_pre = c(2, 3, 4), q2_post = c(3, 4, 5) ) Reshape to: id, age, question, time, response 23.13 Exercise Answers Click to see answers Exercise 1: grades &lt;- tibble( student = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), math_q1 = c(85, 78, 92), math_q2 = c(88, 82, 95), english_q1 = c(90, 85, 88), english_q2 = c(92, 87, 90) ) # Method 1: Two-step pivot result &lt;- grades %&gt;% pivot_longer( cols = -student, names_to = &quot;subject_quarter&quot;, values_to = &quot;grade&quot; ) %&gt;% separate(subject_quarter, into = c(&quot;subject&quot;, &quot;quarter&quot;), sep = &quot;_&quot;) result #&gt; # A tibble: 12 √ó 4 #&gt; student subject quarter grade #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alice math q1 85 #&gt; 2 Alice math q2 88 #&gt; 3 Alice english q1 90 #&gt; 4 Alice english q2 92 #&gt; 5 Bob math q1 78 #&gt; 6 Bob math q2 82 #&gt; 7 Bob english q1 85 #&gt; 8 Bob english q2 87 #&gt; 9 Charlie math q1 92 #&gt; 10 Charlie math q2 95 #&gt; 11 Charlie english q1 88 #&gt; 12 Charlie english q2 90 # Method 2: Use names_pattern result2 &lt;- grades %&gt;% pivot_longer( cols = -student, names_to = c(&quot;subject&quot;, &quot;quarter&quot;), names_pattern = &quot;(.*)_(.*)&quot;, values_to = &quot;grade&quot; ) result2 #&gt; # A tibble: 12 √ó 4 #&gt; student subject quarter grade #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Alice math q1 85 #&gt; 2 Alice math q2 88 #&gt; 3 Alice english q1 90 #&gt; 4 Alice english q2 92 #&gt; 5 Bob math q1 78 #&gt; 6 Bob math q2 82 #&gt; 7 Bob english q1 85 #&gt; 8 Bob english q2 87 #&gt; 9 Charlie math q1 92 #&gt; 10 Charlie math q2 95 #&gt; 11 Charlie english q1 88 #&gt; 12 Charlie english q2 90 Exercise 2: measurements &lt;- tibble( id = rep(1:3, each = 3), time = rep(c(&quot;t1&quot;, &quot;t2&quot;, &quot;t3&quot;), 3), value = c(10, 12, 14, 20, 22, 24, 30, 32, 34) ) result &lt;- measurements %&gt;% pivot_wider( names_from = time, values_from = value ) result #&gt; # A tibble: 3 √ó 4 #&gt; id t1 t2 t3 #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 12 14 #&gt; 2 2 20 22 24 #&gt; 3 3 30 32 34 # Verify dimensions cat(&quot;Original: &quot;, nrow(measurements), &quot;rows\\n&quot;) #&gt; Original: 9 rows cat(&quot;Wide: &quot;, nrow(result), &quot;rows,&quot;, ncol(result) - 1, &quot;time columns\\n&quot;) #&gt; Wide: 3 rows, 3 time columns Exercise 3: safe_pivot_wider &lt;- function(data, names_from, values_from, aggregate_fn = mean, warn = TRUE) { names_col &lt;- rlang::ensym(names_from) values_col &lt;- rlang::ensym(values_from) # Get ID columns (everything except names_from and values_from) id_cols &lt;- setdiff(names(data), c(as.character(names_col), as.character(values_col))) # Check for duplicates dup_check &lt;- data %&gt;% group_by(across(all_of(c(id_cols, as.character(names_col))))) %&gt;% filter(n() &gt; 1) %&gt;% ungroup() if (nrow(dup_check) &gt; 0) { if (warn) { warning(&quot;Found &quot;, nrow(dup_check), &quot; duplicate rows. &quot;, &quot;Aggregating with &quot;, deparse(substitute(aggregate_fn))) print(head(dup_check)) } # Aggregate data &lt;- data %&gt;% group_by(across(all_of(c(id_cols, as.character(names_col))))) %&gt;% summarize( !!values_col := aggregate_fn(!!values_col), .groups = &quot;drop&quot; ) } # Perform pivot result &lt;- data %&gt;% pivot_wider( names_from = !!names_col, values_from = !!values_col ) # Validate expected_rows &lt;- length(unique(interaction(data[id_cols]))) actual_rows &lt;- nrow(result) if (expected_rows != actual_rows) { warning(&quot;Row count mismatch! Expected: &quot;, expected_rows, &quot;, Got: &quot;, actual_rows) } result } # Test with clean data measurements &lt;- tibble( id = rep(1:3, each = 2), time = rep(c(&quot;t1&quot;, &quot;t2&quot;), 3), value = c(10, 15, 20, 25, 30, 35) ) safe_pivot_wider(measurements, time, value) #&gt; # A tibble: 3 √ó 3 #&gt; id t1 t2 #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 10 15 #&gt; 2 2 20 25 #&gt; 3 3 30 35 # Test with duplicates measurements_dup &lt;- tibble( id = c(1, 1, 2, 2, 2), time = c(&quot;t1&quot;, &quot;t1&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;t2&quot;), value = c(10, 12, 20, 25, 27) ) safe_pivot_wider(measurements_dup, time, value) #&gt; Warning in safe_pivot_wider(measurements_dup, time, value): Found 4 duplicate #&gt; rows. Aggregating with mean #&gt; # A tibble: 4 √ó 3 #&gt; id time value #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 t1 10 #&gt; 2 1 t1 12 #&gt; 3 2 t2 25 #&gt; 4 2 t2 27 #&gt; # A tibble: 2 √ó 3 #&gt; id t1 t2 #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 11 NA #&gt; 2 2 20 26 Exercise 4: survey &lt;- tibble( id = 1:3, age = c(25, 30, 35), q1_pre = c(3, 4, 2), q1_post = c(4, 5, 3), q2_pre = c(2, 3, 4), q2_post = c(3, 4, 5) ) # Method 1: Step by step result &lt;- survey %&gt;% pivot_longer( cols = starts_with(&quot;q&quot;), names_to = &quot;question_time&quot;, values_to = &quot;response&quot; ) %&gt;% separate(question_time, into = c(&quot;question&quot;, &quot;time&quot;), sep = &quot;_&quot;) result #&gt; # A tibble: 12 √ó 5 #&gt; id age question time response #&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 25 q1 pre 3 #&gt; 2 1 25 q1 post 4 #&gt; 3 1 25 q2 pre 2 #&gt; 4 1 25 q2 post 3 #&gt; 5 2 30 q1 pre 4 #&gt; 6 2 30 q1 post 5 #&gt; 7 2 30 q2 pre 3 #&gt; 8 2 30 q2 post 4 #&gt; 9 3 35 q1 pre 2 #&gt; 10 3 35 q1 post 3 #&gt; 11 3 35 q2 pre 4 #&gt; 12 3 35 q2 post 5 # Method 2: Using names_pattern result2 &lt;- survey %&gt;% pivot_longer( cols = starts_with(&quot;q&quot;), names_to = c(&quot;question&quot;, &quot;time&quot;), names_pattern = &quot;(q\\\\d+)_(.*)&quot;, values_to = &quot;response&quot; ) result2 #&gt; # A tibble: 12 √ó 5 #&gt; id age question time response #&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 25 q1 pre 3 #&gt; 2 1 25 q1 post 4 #&gt; 3 1 25 q2 pre 2 #&gt; 4 1 25 q2 post 3 #&gt; 5 2 30 q1 pre 4 #&gt; 6 2 30 q1 post 5 #&gt; 7 2 30 q2 pre 3 #&gt; 8 2 30 q2 post 4 #&gt; 9 3 35 q1 pre 2 #&gt; 10 3 35 q1 post 3 #&gt; 11 3 35 q2 pre 4 #&gt; 12 3 35 q2 post 5 # Verify cat(&quot;Original questions:&quot;, (ncol(survey) - 2), &quot;\\n&quot;) #&gt; Original questions: 4 cat(&quot;Long format rows:&quot;, nrow(result), &quot;\\n&quot;) #&gt; Long format rows: 12 cat(&quot;Should be:&quot;, nrow(survey) * (ncol(survey) - 2), &quot;\\n&quot;) #&gt; Should be: 12 "],["dplyr-advanced.html", "Chapter 24 Advanced dplyr Patterns 24.1 Introduction 24.2 Tidy Evaluation Basics 24.3 Error #1: Cannot use object of type ‚Äòsymbol‚Äô 24.4 rowwise() Operations 24.5 across() Advanced Usage 24.6 if_any() and if_all() 24.7 Summary 24.8 Exercises 24.9 Exercise Answer", " Chapter 24 Advanced dplyr Patterns What You‚Äôll Learn: Programming with dplyr Tidy evaluation Dynamic column selection Row-wise operations Complex aggregations Key Errors Covered: 12+ advanced dplyr errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 24.1 Introduction Advanced dplyr enables programmatic data manipulation: library(dplyr) library(rlang) # Function with column name as string summarize_col &lt;- function(data, col_name) { data %&gt;% summarize( mean = mean(.data[[col_name]], na.rm = TRUE), sd = sd(.data[[col_name]], na.rm = TRUE) ) } summarize_col(mtcars, &quot;mpg&quot;) #&gt; mean sd #&gt; 1 20.09062 6.026948 Let‚Äôs master advanced patterns! 24.2 Tidy Evaluation Basics üí° Key Insight: .data and .env Pronouns # .data pronoun for data frame columns mtcars %&gt;% summarize(avg = mean(.data$mpg)) #&gt; avg #&gt; 1 20.09062 # .env pronoun for environment variables threshold &lt;- 20 mtcars %&gt;% filter(.data$mpg &gt; .env$threshold) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # In functions filter_by_value &lt;- function(data, col, value) { data %&gt;% filter(.data[[col]] &gt; value) } filter_by_value(mtcars, &quot;mpg&quot;, 20) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # Dynamic column creation create_column &lt;- function(data, new_col, value) { data %&gt;% mutate(&quot;{new_col}&quot; := value) } create_column(mtcars, &quot;test&quot;, 42) %&gt;% select(mpg, test) #&gt; Error in select(., mpg, test): unused arguments (mpg, test) 24.3 Error #1: Cannot use object of type ‚Äòsymbol‚Äô ‚≠ê‚≠ê‚≠ê ADVANCED üîÆ TIDY-EVAL 24.3.1 The Error my_function &lt;- function(data, col) { data %&gt;% summarize(mean = mean(col)) } my_function(mtcars, mpg) #&gt; Warning: There was 1 warning in `summarize()`. #&gt; ‚Ñπ In argument: `mean = mean(col)`. #&gt; Caused by warning in `mean.default()`: #&gt; ! argument is not numeric or logical: returning NA #&gt; mean #&gt; 1 NA üî¥ ERROR Error in mean(col) : object &#39;mpg&#39; not found 24.3.2 What It Means Need to use tidy evaluation to pass column names. 24.3.3 Solutions ‚úÖ SOLUTION 1: Use {{ }} (Embrace) my_function &lt;- function(data, col) { data %&gt;% summarize(mean = mean({{ col }})) } my_function(mtcars, mpg) #&gt; mean #&gt; 1 20.09062 # Works with multiple operations my_filter_summarize &lt;- function(data, filter_col, summary_col) { data %&gt;% filter({{ filter_col }} &gt; 4) %&gt;% summarize( mean = mean({{ summary_col }}), n = n() ) } my_filter_summarize(mtcars, cyl, mpg) #&gt; mean n #&gt; 1 16.64762 21 ‚úÖ SOLUTION 2: Use .data[[]] for Strings my_function2 &lt;- function(data, col_name) { data %&gt;% summarize(mean = mean(.data[[col_name]])) } my_function2(mtcars, &quot;mpg&quot;) #&gt; mean #&gt; 1 20.09062 # Dynamic column names summarize_multiple &lt;- function(data, cols) { data %&gt;% summarize( across(all_of(cols), mean, .names = &quot;mean_{.col}&quot;) ) } summarize_multiple(mtcars, c(&quot;mpg&quot;, &quot;hp&quot;, &quot;wt&quot;)) #&gt; mean_mpg mean_hp mean_wt #&gt; 1 20.09062 146.6875 3.21725 24.4 rowwise() Operations üí° Key Insight: Row-wise Operations # Calculate row means data &lt;- tibble( id = 1:3, x = c(1, 2, 3), y = c(4, 5, 6), z = c(7, 8, 9) ) # Wrong: column mean data %&gt;% mutate(mean = mean(c(x, y, z))) #&gt; # A tibble: 3 √ó 5 #&gt; id x y z mean #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 4 7 5 #&gt; 2 2 2 5 8 5 #&gt; 3 3 3 6 9 5 # Right: use rowwise() data %&gt;% rowwise() %&gt;% mutate(mean = mean(c(x, y, z))) %&gt;% ungroup() #&gt; # A tibble: 3 √ó 5 #&gt; id x y z mean #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 4 7 4 #&gt; 2 2 2 5 8 5 #&gt; 3 3 3 6 9 6 # Or use c_across() data %&gt;% rowwise() %&gt;% mutate(mean = mean(c_across(x:z))) %&gt;% ungroup() #&gt; # A tibble: 3 √ó 5 #&gt; id x y z mean #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 4 7 4 #&gt; 2 2 2 5 8 5 #&gt; 3 3 3 6 9 6 # Complex row operations data %&gt;% rowwise() %&gt;% mutate( total = sum(c_across(x:z)), min_val = min(c_across(x:z)), max_val = max(c_across(x:z)) ) %&gt;% ungroup() #&gt; # A tibble: 3 √ó 7 #&gt; id x y z total min_val max_val #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1 4 7 12 1 7 #&gt; 2 2 2 5 8 15 2 8 #&gt; 3 3 3 6 9 18 3 9 24.5 across() Advanced Usage üéØ Best Practice: across() Patterns # Multiple functions mtcars %&gt;% summarize( across(c(mpg, hp, wt), list(mean = mean, sd = sd, min = min, max = max), .names = &quot;{.col}_{.fn}&quot;) ) #&gt; mpg_mean mpg_sd mpg_min mpg_max hp_mean hp_sd hp_min hp_max wt_mean #&gt; 1 20.09062 6.026948 10.4 33.9 146.6875 68.56287 52 335 3.21725 #&gt; wt_sd wt_min wt_max #&gt; 1 0.9784574 1.513 5.424 # With where() mtcars %&gt;% summarize( across(where(is.numeric) &amp; !c(vs, am), mean, .names = &quot;avg_{.col}&quot;) ) #&gt; avg_mpg avg_cyl avg_disp avg_hp avg_drat avg_wt avg_qsec avg_gear #&gt; 1 20.09062 6.1875 230.7219 146.6875 3.596563 3.21725 17.84875 3.6875 #&gt; avg_carb #&gt; 1 2.8125 # In mutate with formula mtcars %&gt;% mutate( across(c(mpg, hp), ~ . / mean(.), .names = &quot;{.col}_scaled&quot;) ) %&gt;% select(mpg, mpg_scaled, hp, hp_scaled) #&gt; Error in select(., mpg, mpg_scaled, hp, hp_scaled): unused arguments (mpg, mpg_scaled, hp, hp_scaled) # Conditional transformation mtcars %&gt;% mutate( across(where(is.numeric), ~ if_else(. &lt; median(.), &quot;Low&quot;, &quot;High&quot;), .names = &quot;{.col}_cat&quot;) ) %&gt;% select(mpg, mpg_cat, hp, hp_cat) #&gt; Error in select(., mpg, mpg_cat, hp, hp_cat): unused arguments (mpg, mpg_cat, hp, hp_cat) 24.6 if_any() and if_all() üí° Key Insight: Filter with Multiple Conditions # if_any: TRUE if ANY condition met mtcars %&gt;% filter(if_any(c(mpg, hp), ~ . &gt; 100)) %&gt;% select(mpg, hp) %&gt;% head() #&gt; Error in select(., mpg, hp): unused arguments (mpg, hp) # if_all: TRUE if ALL conditions met mtcars %&gt;% filter(if_all(c(mpg, hp), ~ . &gt; 100)) %&gt;% select(mpg, hp) #&gt; Error in select(., mpg, hp): unused arguments (mpg, hp) # With where() mtcars %&gt;% filter(if_any(where(is.numeric), ~ . &gt; 200)) %&gt;% select(where(function(x) any(x &gt; 200))) #&gt; Error in select(., where(function(x) any(x &gt; 200))): unused argument (where(function(x) any(x &gt; 200))) 24.7 Summary Key Takeaways: Use {{ }} - For passing column names to functions Use .data[[]] - For string column names rowwise() - For row-by-row operations across() - Apply functions to multiple columns if_any() / if_all() - Filter with multiple conditions Always ungroup() - After rowwise() Quick Reference: # Tidy evaluation function(data, col) { data %&gt;% mutate(new = {{ col }} * 2) } # String column names function(data, col_name) { data %&gt;% mutate(new = .data[[col_name]] * 2) } # Rowwise data %&gt;% rowwise() %&gt;% mutate(mean = mean(c_across(x:z))) %&gt;% ungroup() # across data %&gt;% summarize(across(where(is.numeric), mean)) # if_any/if_all data %&gt;% filter(if_any(c(x, y), ~ . &gt; 10)) 24.8 Exercises üìù Exercise: Create Flexible Function Write summarize_by_group(data, group_col, summary_cols) using tidy evaluation that groups by one column and summarizes multiple columns. 24.9 Exercise Answer Click to see answer summarize_by_group &lt;- function(data, group_col, summary_cols) { data %&gt;% group_by({{ group_col }}) %&gt;% summarize( across({{ summary_cols }}, list(mean = mean, sd = sd, n = ~n()), .names = &quot;{.col}_{.fn}&quot;), .groups = &quot;drop&quot; ) } summarize_by_group(mtcars, cyl, c(mpg, hp, wt)) #&gt; # A tibble: 3 √ó 10 #&gt; cyl mpg_mean mpg_sd mpg_n hp_mean hp_sd hp_n wt_mean wt_sd wt_n #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; #&gt; 1 4 26.7 4.51 11 82.6 20.9 11 2.29 0.570 11 #&gt; 2 6 19.7 1.45 7 122. 24.3 7 3.12 0.356 7 #&gt; 3 8 15.1 2.56 14 209. 51.0 14 4.00 0.759 14 "],["dplyr-best-practices.html", "Chapter 25 Data Manipulation Best Practices 25.1 Introduction 25.2 Performance Optimization 25.3 Code Organization 25.4 Common Anti-Patterns 25.5 Debugging Strategies 25.6 Documentation 25.7 Error Handling 25.8 Testing Pipelines 25.9 Summary 25.10 Exercise 25.11 Exercise Answer 25.12 Completion", " Chapter 25 Data Manipulation Best Practices What You‚Äôll Learn: Efficient dplyr workflows Performance optimization Code organization Common anti-patterns Debugging strategies Key Errors Covered: 10+ workflow errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 25.1 Introduction Best practices make code faster, clearer, and more maintainable: library(dplyr) library(tidyr) # Good: Clear pipeline result &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% select(mpg, cyl, hp) %&gt;% mutate(hp_per_cyl = hp / cyl) %&gt;% arrange(desc(hp_per_cyl)) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) head(result, 3) #&gt; # A tibble: 3 √ó 5 #&gt; id age question time response #&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 25 q1 pre 3 #&gt; 2 1 25 q1 post 4 #&gt; 3 1 25 q2 pre 2 25.2 Performance Optimization üéØ Best Practice: Optimize for Speed # 1. Filter early # Bad: filter after heavy operations mtcars %&gt;% mutate(complex = mpg * hp / wt) %&gt;% left_join(mtcars, by = c(&quot;cyl&quot;)) %&gt;% filter(mpg &gt; 20) #&gt; Warning in left_join(., mtcars, by = c(&quot;cyl&quot;)): Detected an unexpected many-to-many relationship between `x` and `y`. #&gt; ‚Ñπ Row 1 of `x` matches multiple rows in `y`. #&gt; ‚Ñπ Row 1 of `y` matches multiple rows in `x`. #&gt; ‚Ñπ If a many-to-many relationship is expected, set `relationship = #&gt; &quot;many-to-many&quot;` to silence this warning. #&gt; Error in `filter()`: #&gt; ‚Ñπ In argument: `mpg &gt; 20`. #&gt; Caused by error: #&gt; ! `..1` must be of size 366 or 1, not size 234. # Good: filter first mtcars %&gt;% filter(mpg &gt; 20) %&gt;% mutate(complex = mpg * hp / wt) %&gt;% left_join(mtcars, by = c(&quot;cyl&quot;)) #&gt; Warning in left_join(., mtcars, by = c(&quot;cyl&quot;)): Detected an unexpected many-to-many relationship between `x` and `y`. #&gt; ‚Ñπ Row 1 of `x` matches multiple rows in `y`. #&gt; ‚Ñπ Row 1 of `y` matches multiple rows in `x`. #&gt; ‚Ñπ If a many-to-many relationship is expected, set `relationship = #&gt; &quot;many-to-many&quot;` to silence this warning. #&gt; mpg.x cyl disp.x hp.x drat.x wt.x qsec.x vs.x am.x gear.x carb.x complex #&gt; 1 21 6 160 110 3.9 2.62 16.46 0 1 4 4 881.6794 #&gt; 2 21 6 160 110 3.9 2.62 16.46 0 1 4 4 881.6794 #&gt; 3 21 6 160 110 3.9 2.62 16.46 0 1 4 4 881.6794 #&gt; 4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 881.6794 #&gt; mpg.y disp.y hp.y drat.y wt.y qsec.y vs.y am.y gear.y carb.y #&gt; 1 21.0 160 110 3.90 2.620 16.46 0 1 4 4 #&gt; 2 21.0 160 110 3.90 2.875 17.02 0 1 4 4 #&gt; 3 21.4 258 110 3.08 3.215 19.44 1 0 3 1 #&gt; 4 18.1 225 105 2.76 3.460 20.22 1 0 3 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 138 rows ] # 2. Select early # Bad: keep all columns mtcars %&gt;% mutate(new = mpg * 2) %&gt;% filter(cyl == 4) %&gt;% select(mpg, cyl, new) #&gt; Error in select(., mpg, cyl, new): unused arguments (mpg, cyl, new) # Good: select needed columns early mtcars %&gt;% select(mpg, cyl, hp, wt) %&gt;% filter(cyl == 4) %&gt;% mutate(new = mpg * 2) #&gt; Error in select(., mpg, cyl, hp, wt): unused arguments (mpg, cyl, hp, wt) # 3. Use data.table for large data # library(dtplyr) # lazy_dt(large_data) %&gt;% # filter(...) %&gt;% # as_tibble() 25.3 Code Organization üéØ Best Practice: Readable Pipelines # Good: One operation per line result &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% mutate( hp_per_ton = hp / wt, efficiency = mpg / hp ) %&gt;% group_by(cyl) %&gt;% summarize( avg_efficiency = mean(efficiency), n = n(), .groups = &quot;drop&quot; ) %&gt;% arrange(desc(avg_efficiency)) # Good: Use intermediate variables for clarity filtered_cars &lt;- mtcars %&gt;% filter(mpg &gt; 20, cyl %in% c(4, 6)) efficiency_metrics &lt;- filtered_cars %&gt;% mutate( hp_per_ton = hp / wt, efficiency = mpg / hp ) final_summary &lt;- efficiency_metrics %&gt;% group_by(cyl) %&gt;% summarize( avg_efficiency = mean(efficiency), n = n(), .groups = &quot;drop&quot; ) # Bad: Everything in one long pipe # result &lt;- mtcars %&gt;% filter(mpg &gt; 20) %&gt;% mutate(hp_per_ton = hp / wt, efficiency = mpg / hp) %&gt;% group_by(cyl) %&gt;% summarize(avg_efficiency = mean(efficiency), n = n(), .groups = &quot;drop&quot;) %&gt;% arrange(desc(avg_efficiency)) 25.4 Common Anti-Patterns ‚ö†Ô∏è Avoid These Patterns # Anti-pattern 1: Growing data frame in loop # Bad result &lt;- tibble() for (i in 1:100) { result &lt;- bind_rows(result, tibble(x = i, y = i^2)) } # Good result &lt;- tibble( x = 1:100, y = x^2 ) # Anti-pattern 2: Unnecessary grouping # Bad mtcars %&gt;% group_by(cyl) %&gt;% select(mpg, cyl, hp) # select doesn&#39;t need groups #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Good mtcars %&gt;% select(mpg, cyl, hp) %&gt;% group_by(cyl) # Group only when needed #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # Anti-pattern 3: Repeated similar code # Bad mtcars %&gt;% summarize( mean_mpg = mean(mpg), mean_hp = mean(hp), mean_wt = mean(wt), mean_disp = mean(disp) ) #&gt; mean_mpg mean_hp mean_wt mean_disp #&gt; 1 20.09062 146.6875 3.21725 230.7219 # Good mtcars %&gt;% summarize(across(c(mpg, hp, wt, disp), mean, .names = &quot;mean_{.col}&quot;)) #&gt; mean_mpg mean_hp mean_wt mean_disp #&gt; 1 20.09062 146.6875 3.21725 230.7219 # Anti-pattern 4: Ignoring NAs # Bad data_with_na &lt;- tibble(x = c(1, 2, NA, 4)) data_with_na %&gt;% summarize(mean_x = mean(x)) # Returns NA! #&gt; # A tibble: 1 √ó 1 #&gt; mean_x #&gt; &lt;dbl&gt; #&gt; 1 NA # Good data_with_na %&gt;% summarize(mean_x = mean(x, na.rm = TRUE)) #&gt; # A tibble: 1 √ó 1 #&gt; mean_x #&gt; &lt;dbl&gt; #&gt; 1 2.33 25.5 Debugging Strategies üéØ Best Practice: Debug Effectively # 1. Check intermediate steps mtcars %&gt;% filter(mpg &gt; 20) %&gt;% {cat(&quot;After filter:&quot;, nrow(.), &quot;rows\\n&quot;); .} %&gt;% select(mpg, cyl, hp) %&gt;% {cat(&quot;After select:&quot;, ncol(.), &quot;cols\\n&quot;); .} %&gt;% head(3) #&gt; Error in select(., mpg, cyl, hp): unused arguments (mpg, cyl, hp) # 2. Use View() in RStudio # mtcars %&gt;% # filter(mpg &gt; 20) %&gt;% # View() # 3. Print summary statistics debug_data &lt;- function(data, label = &quot;&quot;) { cat(&quot;\\n=== Debug:&quot;, label, &quot;===\\n&quot;) cat(&quot;Rows:&quot;, nrow(data), &quot;\\n&quot;) cat(&quot;Cols:&quot;, ncol(data), &quot;\\n&quot;) cat(&quot;Columns:&quot;, paste(names(data), collapse = &quot;, &quot;), &quot;\\n&quot;) data } mtcars %&gt;% debug_data(&quot;original&quot;) %&gt;% filter(mpg &gt; 20) %&gt;% debug_data(&quot;after filter&quot;) #&gt; #&gt; === Debug: after filter === #&gt; #&gt; === Debug: original === #&gt; Rows: 32 #&gt; Cols: 11 #&gt; Columns: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; Rows: 14 #&gt; Cols: 11 #&gt; Columns: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb #&gt; mpg cyl disp hp drat wt qsec vs am gear carb #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 5 rows ] # 4. Check for common issues check_pipeline &lt;- function(data) { cat(&quot;=== Pipeline Check ===\\n&quot;) cat(&quot;Rows:&quot;, nrow(data), &quot;\\n&quot;) cat(&quot;NA counts:\\n&quot;) print(colSums(is.na(data))) cat(&quot;\\nGrouping:&quot;, paste(group_vars(data), collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot;Grouped:&quot;, is_grouped_df(data), &quot;\\n&quot;) data } 25.6 Documentation üéØ Best Practice: Document Complex Operations # Good: Comments explain WHY, not WHAT clean_sales_data &lt;- function(data) { data %&gt;% # Remove test transactions (internal use only) filter(customer_id &gt;= 1000) %&gt;% # Standardize date format for downstream systems mutate(date = as.Date(date)) %&gt;% # Calculate revenue (excluding tax per accounting rules) mutate(revenue = quantity * price) %&gt;% # Remove cancelled orders (status code 99) filter(status != 99) } # Good: Function documentation #&#39; Calculate customer lifetime value #&#39; #&#39; @param orders Data frame with customer_id, date, amount #&#39; @param window_days Number of days to consider (default: 365) #&#39; @return Data frame with customer_id and lifetime_value calculate_ltv &lt;- function(orders, window_days = 365) { cutoff_date &lt;- Sys.Date() - window_days orders %&gt;% filter(date &gt;= cutoff_date) %&gt;% group_by(customer_id) %&gt;% summarize( lifetime_value = sum(amount), n_orders = n(), .groups = &quot;drop&quot; ) } 25.7 Error Handling üéØ Best Practice: Handle Errors Gracefully # Validate inputs safe_summarize &lt;- function(data, col) { # Check data frame if (!is.data.frame(data)) { stop(&quot;data must be a data frame&quot;) } # Check column exists if (!col %in% names(data)) { stop(&quot;Column &#39;&quot;, col, &quot;&#39; not found. &quot;, &quot;Available: &quot;, paste(names(data), collapse = &quot;, &quot;)) } # Check numeric if (!is.numeric(data[[col]])) { stop(&quot;Column &#39;&quot;, col, &quot;&#39; must be numeric&quot;) } # Perform operation data %&gt;% summarize( mean = mean(.data[[col]], na.rm = TRUE), sd = sd(.data[[col]], na.rm = TRUE), n = sum(!is.na(.data[[col]])) ) } # Test safe_summarize(mtcars, &quot;mpg&quot;) #&gt; mean sd n #&gt; 1 20.09062 6.026948 32 safe_summarize(mtcars, &quot;missing_col&quot;) #&gt; Error in safe_summarize(mtcars, &quot;missing_col&quot;): Column &#39;missing_col&#39; not found. Available: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb 25.8 Testing Pipelines üéØ Best Practice: Test Your Code # Create test function test_clean_data &lt;- function() { # Setup test data test_data &lt;- tibble( id = 1:5, value = c(10, NA, 30, 40, 50), group = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;, &quot;C&quot;) ) # Run pipeline result &lt;- test_data %&gt;% filter(!is.na(value)) %&gt;% group_by(group) %&gt;% summarize(mean_value = mean(value), .groups = &quot;drop&quot;) # Check results stopifnot(nrow(result) == 3) # 3 groups stopifnot(all(!is.na(result$mean_value))) # No NAs stopifnot(&quot;group&quot; %in% names(result)) # Has group column message(&quot;‚úì All tests passed&quot;) TRUE } test_clean_data() #&gt; ‚úì All tests passed #&gt; [1] TRUE 25.9 Summary Key Takeaways: Filter early - Reduce data size first Select needed columns - Don‚Äôt carry extra data One operation per line - Readable pipelines Use across() - Avoid repetition Handle NAs - Always specify na.rm Ungroup - Clean up after group operations Document WHY - Not what code does Test code - Catch errors early Best Practices: # ‚úÖ Excellent pipeline result &lt;- data %&gt;% # Filter first (reduce data) filter(important_condition) %&gt;% # Select needed columns select(needed_cols) %&gt;% # Transform mutate(new_col = calculation) %&gt;% # Aggregate group_by(category) %&gt;% summarize( metric = mean(value, na.rm = TRUE), n = n(), .groups = &quot;drop&quot; # Always ungroup ) %&gt;% # Sort arrange(desc(metric)) # ‚úÖ Use functions for repeated logic calculate_stats &lt;- function(data, group_var, value_var) { data %&gt;% group_by({{ group_var }}) %&gt;% summarize( across({{ value_var }}, list(mean = ~mean(., na.rm = TRUE), sd = ~sd(., na.rm = TRUE)), .names = &quot;{.col}_{.fn}&quot;), .groups = &quot;drop&quot; ) } # ‚úÖ Document complex operations # Remove outliers using IQR method (1.5 * IQR) clean_data &lt;- data %&gt;% group_by(category) %&gt;% filter( value &gt;= quantile(value, 0.25) - 1.5 * IQR(value), value &lt;= quantile(value, 0.75) + 1.5 * IQR(value) ) %&gt;% ungroup() Anti-Patterns to Avoid: # ‚ùå Bad Growing data in loops Unnecessary grouping Repeated similar code Ignoring NAs No error checking Complex one-liners No comments on complex logic # ‚úÖ Good Vectorized operations Group only when needed Use across() for repetition Always handle NAs Validate inputs Break into readable steps Document WHY not WHAT 25.10 Exercise üìù Exercise: Refactor Pipeline Improve this code: result &lt;- data %&gt;% mutate(x = a + b, y = c + d, z = e + f) %&gt;% filter(category == &quot;A&quot; | category == &quot;B&quot; | category == &quot;C&quot;) %&gt;% group_by(category) %&gt;% summarize(mean_x = mean(x), mean_y = mean(y), mean_z = mean(z)) %&gt;% filter(mean_x &gt; 0) 25.11 Exercise Answer Click to see answer # Refactored version result &lt;- data %&gt;% # Filter early for better performance filter(category %in% c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) %&gt;% # Use across() to avoid repetition mutate( across(c(a, b), .names = &quot;sum_{.col}&quot;, .fns = ~ . + .) ) %&gt;% # Group for aggregation group_by(category) %&gt;% # Use across() in summarize summarize( across(starts_with(&quot;sum_&quot;), mean, na.rm = TRUE, .names = &quot;mean_{.col}&quot;), .groups = &quot;drop&quot; ) %&gt;% # Filter on summarized values filter(mean_sum_a &gt; 0) 25.12 Completion Part VIII Complete! You‚Äôve mastered: - dplyr fundamentals (filter, select, mutate, etc.) - Grouping and summarizing - Joining data - Reshaping with tidyr - Advanced tidy evaluation - Best practices and optimization Ready for: Part IX (Graphics) or other advanced topics! "],["part-ix-graphics-ggplot2.html", "Part IX: Graphics (ggplot2)", " Part IX: Graphics (ggplot2) "],["ggplot2-intro.html", "Chapter 26 Introduction to ggplot2 26.1 Introduction 26.2 ggplot2 Structure 26.3 Error #1: object not found in aes() 26.4 Error #2: Using + vs %&gt;% 26.5 Aesthetics (aes) 26.6 Error #3: Aesthetic outside aes() 26.7 Common geoms 26.8 Error #4: stat_count() requires x or y 26.9 Faceting 26.10 Themes and Customization 26.11 Error #5: Non-numeric variable for histogram 26.12 Saving Plots 26.13 Common Patterns 26.14 Summary 26.15 Exercises 26.16 Exercise Answers", " Chapter 26 Introduction to ggplot2 What You‚Äôll Learn: Grammar of Graphics principles Basic ggplot2 structure Common plotting errors Aesthetics and geoms Layer system Key Errors Covered: 20+ ggplot2 errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 26.1 Introduction ggplot2 revolutionized R graphics with the Grammar of Graphics: library(ggplot2) # Basic plot ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() But ggplot2 has unique error patterns. Let‚Äôs master them! 26.2 ggplot2 Structure üí° Key Insight: Grammar of Graphics # Three essential components: # 1. Data # 2. Aesthetic mappings (aes) # 3. Geometric objects (geom) # Basic structure ggplot(data = mtcars, mapping = aes(x = mpg, y = hp)) + geom_point() # Shortened (common) ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() # Can specify aes in geom instead ggplot(mtcars) + geom_point(aes(x = mpg, y = hp)) # Or mix (useful for multiple layers) ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39; Key principle: Build plots in layers with + 26.3 Error #1: object not found in aes() ‚≠ê BEGINNER üîç SCOPE 26.3.1 The Error ggplot(mtcars, aes(x = mpg, y = horsepower)) + geom_point() #&gt; Error in `geom_point()`: #&gt; ! Problem while computing aesthetics. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error: #&gt; ! object &#39;horsepower&#39; not found üî¥ ERROR Error in FUN(X[[i]], ...) : object &#39;horsepower&#39; not found 26.3.2 What It Means The column name doesn‚Äôt exist in the data. 26.3.3 Common Causes # Typo in column name ggplot(mtcars, aes(x = mpgg, y = hp)) + geom_point() #&gt; Error in `geom_point()`: #&gt; ! Problem while computing aesthetics. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error: #&gt; ! object &#39;mpgg&#39; not found # Wrong dataset ggplot(iris, aes(x = mpg, y = hp)) + geom_point() #&gt; Error in `geom_point()`: #&gt; ! Problem while computing aesthetics. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error: #&gt; ! object &#39;hp&#39; not found # Forgot to create column ggplot(mtcars, aes(x = mpg, y = efficiency)) + geom_point() #&gt; Error in `geom_point()`: #&gt; ! Problem while computing aesthetics. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error: #&gt; ! object &#39;efficiency&#39; not found 26.3.4 Solutions ‚úÖ SOLUTION 1: Check Column Names # Verify columns names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; # Use correct name ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() ‚úÖ SOLUTION 2: Create Column First library(dplyr) mtcars %&gt;% mutate(efficiency = mpg / hp) %&gt;% ggplot(aes(x = hp, y = efficiency)) + geom_point() 26.4 Error #2: Using + vs %&gt;% ‚≠ê BEGINNER üî§ SYNTAX 26.4.1 The Error library(dplyr) mtcars %&gt;% filter(cyl == 4) %&gt;% ggplot(aes(x = mpg, y = hp)) %&gt;% # Wrong operator! geom_point() #&gt; Error in `geom_point()`: #&gt; ! `mapping` must be created by `aes()`. #&gt; ‚úñ You&#39;ve supplied a &lt;ggplot2::ggplot&gt; object. #&gt; ‚Ñπ Did you use `%&gt;%` or `|&gt;` instead of `+`? üî¥ ERROR Error in geom_point(.) : Cannot use `+` with a ggplot object. Did you accidentally use `%&gt;%` instead of `+`? 26.4.2 What It Means Must use + to add ggplot2 layers, not %&gt;%. 26.4.3 Solutions ‚úÖ SOLUTION: Use + for ggplot layers # Correct: + for ggplot mtcars %&gt;% filter(cyl == 4) %&gt;% ggplot(aes(x = mpg, y = hp)) + # Use + geom_point() # Pipe data into ggplot, then use + mtcars %&gt;% filter(cyl == 4) %&gt;% ggplot(aes(x = mpg, y = hp)) + geom_point() + theme_minimal() 26.5 Aesthetics (aes) üí° Key Insight: Aesthetic Mappings # Map variables to visual properties ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() # Common aesthetics: # x, y - position # color - point/line color # fill - area fill color # size - point/line size # shape - point shape # alpha - transparency # linetype - line pattern # Multiple aesthetics ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl), size = wt)) + geom_point() # Set vs map ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point(color = &quot;blue&quot;) # Set: all points blue ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() # Map: color varies by cyl 26.6 Error #3: Aesthetic outside aes() ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 26.6.1 The Error # Trying to map cyl to color outside aes() ggplot(mtcars) + geom_point(aes(x = mpg, y = hp), color = cyl) #&gt; Error: object &#39;cyl&#39; not found üî¥ ERROR Error in layer(...) : object &#39;cyl&#39; not found 26.6.2 What It Means Variable mappings must be inside aes(). 26.6.3 Common Causes # Want color by variable ggplot(mtcars) + geom_point(aes(x = mpg, y = hp), color = factor(cyl)) #&gt; Error: object &#39;cyl&#39; not found # Want size by variable ggplot(mtcars) + geom_point(aes(x = mpg, y = hp), size = wt) #&gt; Error: object &#39;wt&#39; not found 26.6.4 Solutions ‚úÖ SOLUTION: Put Variable Mappings in aes() # Correct: color mapping inside aes ggplot(mtcars) + geom_point(aes(x = mpg, y = hp, color = factor(cyl))) # Can be in ggplot() aes ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() # Fixed values go OUTSIDE aes ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point(color = &quot;blue&quot;, size = 3) # All points same ‚ö†Ô∏è Common Confusion: Inside vs Outside aes() # INSIDE aes(): varies by data ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() # Color varies by cyl # OUTSIDE aes(): fixed for all ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point(color = &quot;red&quot;) # All points red # Wrong: puts string in aes ggplot(mtcars, aes(x = mpg, y = hp, color = &quot;red&quot;)) + geom_point() # Creates legend for &quot;red&quot;! 26.7 Common geoms üí° Key Insight: Geometric Objects # Points ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() # Lines ggplot(economics, aes(x = date, y = unemploy)) + geom_line() # Bars ggplot(mtcars, aes(x = factor(cyl))) + geom_bar() # Histogram ggplot(mtcars, aes(x = mpg)) + geom_histogram(bins = 10) # Boxplot ggplot(mtcars, aes(x = factor(cyl), y = mpg)) + geom_boxplot() # Smooth ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + geom_smooth(method = &quot;lm&quot;) #&gt; `geom_smooth()` using formula = &#39;y ~ x&#39; # Text ggplot(mtcars, aes(x = mpg, y = hp, label = rownames(mtcars))) + geom_text(size = 3) 26.8 Error #4: stat_count() requires x or y ‚≠ê BEGINNER üìã ARGS 26.8.1 The Error ggplot(mtcars, aes(x = mpg, y = hp)) + geom_bar() #&gt; Error in `geom_bar()`: #&gt; ! Problem while computing stat. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error in `setup_params()`: #&gt; ! `stat_count()` must only have an x or y aesthetic. üî¥ ERROR Error in `geom_bar()`: ! Problem while computing stat. ‚Ñπ Error occurred in the 1st layer. Caused by error: ! `stat_count()` must only have an `x` or `y` aesthetic. 26.8.2 What It Means geom_bar() is for counts. For pre-computed heights, use geom_col(). 26.8.3 Solutions ‚úÖ SOLUTION 1: Use geom_col() for Heights # Pre-computed values data &lt;- data.frame( category = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), value = c(10, 15, 20) ) ggplot(data, aes(x = category, y = value)) + geom_col() # Or use stat = &quot;identity&quot; with geom_bar ggplot(data, aes(x = category, y = value)) + geom_bar(stat = &quot;identity&quot;) ‚úÖ SOLUTION 2: Use geom_bar() for Counts # Count occurrences ggplot(mtcars, aes(x = factor(cyl))) + geom_bar() # Equivalent to mtcars %&gt;% count(cyl) %&gt;% ggplot(aes(x = factor(cyl), y = n)) + geom_col() 26.9 Faceting üí° Key Insight: Small Multiples # Facet by one variable ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + facet_wrap(~ cyl) # Facet by two variables ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + facet_grid(cyl ~ gear) # Free scales ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + facet_wrap(~ cyl, scales = &quot;free&quot;) # Number of columns ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + facet_wrap(~ cyl, ncol = 2) 26.10 Themes and Customization üéØ Best Practice: Customizing Plots # Built-in themes p &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() p + theme_minimal() p + theme_classic() p + theme_bw() # Custom labels ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + labs( title = &quot;Fuel Efficiency vs Horsepower&quot;, subtitle = &quot;Motor Trend Car Road Tests&quot;, x = &quot;Miles per Gallon&quot;, y = &quot;Horsepower&quot;, caption = &quot;Source: mtcars dataset&quot; ) # Customize theme elements ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + theme_minimal() + theme( plot.title = element_text(face = &quot;bold&quot;, size = 14), axis.text = element_text(size = 10), panel.grid.minor = element_blank() ) 26.11 Error #5: Non-numeric variable for histogram ‚≠ê BEGINNER üî¢ TYPE 26.11.1 The Error ggplot(mtcars, aes(x = factor(cyl))) + geom_histogram() #&gt; Error in `geom_histogram()`: #&gt; ! Problem while computing stat. #&gt; ‚Ñπ Error occurred in the 1st layer. #&gt; Caused by error in `setup_params()`: #&gt; ! `stat_bin()` requires a continuous x aesthetic. #&gt; ‚úñ the x aesthetic is discrete. #&gt; ‚Ñπ Perhaps you want `stat=&quot;count&quot;`? üî¥ ERROR Error in `geom_histogram()`: ! `stat_bin()` requires a numeric `x` variable 26.11.2 What It Means Histograms need continuous numeric data, not categorical. 26.11.3 Solutions ‚úÖ SOLUTION: Use Appropriate Geom # For categorical: use geom_bar ggplot(mtcars, aes(x = factor(cyl))) + geom_bar() # For continuous: histogram works ggplot(mtcars, aes(x = mpg)) + geom_histogram(bins = 10) # Density plot alternative ggplot(mtcars, aes(x = mpg)) + geom_density() 26.12 Saving Plots üéØ Best Practice: Save Plots # Create plot p &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + theme_minimal() # Save with ggsave ggsave(&quot;plot.png&quot;, p, width = 6, height = 4, dpi = 300) # Or save last plot ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() ggsave(&quot;last_plot.png&quot;, width = 6, height = 4) # Different formats ggsave(&quot;plot.pdf&quot;, p) ggsave(&quot;plot.svg&quot;, p) ggsave(&quot;plot.jpg&quot;, p) 26.13 Common Patterns üéØ Best Practice: Common Plot Types # Scatterplot with trend line ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point(aes(color = factor(cyl))) + geom_smooth(method = &quot;lm&quot;, se = FALSE) + theme_minimal() #&gt; `geom_smooth()` using formula = &#39;y ~ x&#39; # Grouped bar chart mtcars %&gt;% count(cyl, gear) %&gt;% ggplot(aes(x = factor(cyl), y = n, fill = factor(gear))) + geom_col(position = &quot;dodge&quot;) # Boxplot with points ggplot(mtcars, aes(x = factor(cyl), y = mpg)) + geom_boxplot() + geom_jitter(width = 0.2, alpha = 0.3) # Time series ggplot(economics, aes(x = date, y = unemploy)) + geom_line() + theme_minimal() + labs(title = &quot;US Unemployment Over Time&quot;) 26.14 Summary Key Takeaways: Three components - Data, aes(), geom Use + not %&gt;% - Add layers with + Variables in aes() - Fixed values outside geom_bar() vs geom_col() - Counts vs heights Check column names - Before plotting Histograms need numeric - Use geom_bar() for categorical Build in layers - Add components step by step Quick Reference: Error Cause Fix object not found Column doesn‚Äôt exist Check names(data) Can‚Äôt use + Used %&gt;% instead of + Use + for ggplot layers object ‚Äòvar‚Äô not found Variable outside aes Put in aes() stat_count requires x or y geom_bar with y Use geom_col() requires numeric x Non-numeric histogram Use appropriate geom Basic Structure: # Template ggplot(data, aes(x = var1, y = var2)) + geom_point() + theme_minimal() # With pipes data %&gt;% filter(condition) %&gt;% ggplot(aes(x = var1, y = var2)) + # Use + geom_point() + labs(title = &quot;Plot Title&quot;) # Common aesthetics aes( x = var, # x-axis y = var, # y-axis color = var, # point/line color fill = var, # area fill size = var, # size shape = var, # point shape alpha = var, # transparency linetype = var # line pattern ) # Common geoms geom_point() # scatter geom_line() # line geom_bar() # bar (counts) geom_col() # bar (heights) geom_histogram() # histogram geom_boxplot() # boxplot geom_smooth() # trend line Best Practices: # ‚úÖ Good ggplot(data, aes(x = var1, y = var2, color = var3)) + geom_point() + theme_minimal() data %&gt;% filter(...) %&gt;% ggplot(aes(x = var)) + # + not %&gt;% geom_histogram() # ‚ùå Avoid ggplot(data, aes(x = var1, y = var2)) %&gt;% # Wrong operator geom_point() ggplot(data) + geom_point(aes(x = var), color = other_var) # Should be in aes geom_histogram(aes(x = factor_var)) # Need numeric 26.15 Exercises üìù Exercise 1: Basic Plot Create a scatterplot of mtcars: 1. mpg vs hp 2. Color by cyl 3. Size by wt 4. Add title and labels 5. Use theme_minimal() üìù Exercise 2: Error Fixing Fix these errors: # Error 1 ggplot(mtcars, aes(x = mpg, y = hp)) %&gt;% geom_point() # Error 2 ggplot(mtcars) + geom_point(aes(x = mpg, y = hp), color = cyl) # Error 3 ggplot(mtcars, aes(x = factor(cyl), y = mpg)) + geom_histogram() üìù Exercise 3: Multiple Geoms Create a plot with: 1. Points for raw data 2. Smooth line for trend 3. Faceted by cyl 4. Custom colors üìù Exercise 4: Bar Chart Using mtcars: 1. Count cars by cyl 2. Fill by gear 3. Dodge position 4. Add labels 26.16 Exercise Answers Click to see answers Exercise 1: ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl), size = wt)) + geom_point(alpha = 0.7) + labs( title = &quot;Fuel Efficiency vs Horsepower&quot;, subtitle = &quot;Motor Trend Car Road Tests&quot;, x = &quot;Miles per Gallon&quot;, y = &quot;Horsepower&quot;, color = &quot;Cylinders&quot;, size = &quot;Weight (1000 lbs)&quot; ) + theme_minimal() + theme( plot.title = element_text(face = &quot;bold&quot;, size = 14), legend.position = &quot;right&quot; ) Exercise 2: # Error 1: Use + not %&gt;% ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() # Error 2: Put variable in aes() ggplot(mtcars) + geom_point(aes(x = mpg, y = hp, color = factor(cyl))) # Error 3: Use geom_boxplot for this ggplot(mtcars, aes(x = factor(cyl), y = mpg)) + geom_boxplot() # Or if want histogram of mpg ggplot(mtcars, aes(x = mpg)) + geom_histogram(bins = 10) Exercise 3: ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point(aes(color = factor(cyl)), size = 3, alpha = 0.6) + geom_smooth(method = &quot;lm&quot;, se = FALSE, color = &quot;black&quot;, linetype = &quot;dashed&quot;) + facet_wrap(~ cyl, labeller = label_both) + scale_color_manual(values = c(&quot;4&quot; = &quot;#E41A1C&quot;, &quot;6&quot; = &quot;#377EB8&quot;, &quot;8&quot; = &quot;#4DAF4A&quot;)) + labs( title = &quot;MPG vs HP by Number of Cylinders&quot;, x = &quot;Miles per Gallon&quot;, y = &quot;Horsepower&quot;, color = &quot;Cylinders&quot; ) + theme_bw() #&gt; `geom_smooth()` using formula = &#39;y ~ x&#39; Exercise 4: library(dplyr) mtcars %&gt;% count(cyl, gear) %&gt;% ggplot(aes(x = factor(cyl), y = n, fill = factor(gear))) + geom_col(position = &quot;dodge&quot;) + labs( title = &quot;Car Count by Cylinders and Gears&quot;, x = &quot;Number of Cylinders&quot;, y = &quot;Count&quot;, fill = &quot;Number of Gears&quot; ) + theme_minimal() + scale_fill_brewer(palette = &quot;Set2&quot;) "],["ggplot2-advanced.html", "Chapter 27 Advanced ggplot2 27.1 Introduction 27.2 Scales 27.3 Error #1: Discrete value supplied to continuous scale 27.4 Themes 27.5 Annotations 27.6 Summary", " Chapter 27 Advanced ggplot2 What You‚Äôll Learn: Scales and coordinate systems Advanced themes Annotations and labels Multiple plots Statistical transformations Key Errors Covered: 18+ advanced ggplot2 errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 27.1 Introduction Advanced ggplot2 enables publication-quality graphics: library(ggplot2) library(dplyr) # Advanced plot ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) + geom_point(size = 3) + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) + scale_x_continuous(breaks = seq(10, 35, 5)) + coord_cartesian(ylim = c(50, 350)) + theme_minimal() + labs(title = &quot;Horsepower vs MPG&quot;) 27.2 Scales üí° Key Insight: Scale Functions # Continuous scales ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) + geom_point() + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) # Discrete scales ggplot(mtcars, aes(x = factor(cyl), y = mpg, fill = factor(cyl))) + geom_boxplot() + scale_fill_manual(values = c(&quot;4&quot; = &quot;green&quot;, &quot;6&quot; = &quot;blue&quot;, &quot;8&quot; = &quot;red&quot;)) # Log scales ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + scale_y_log10() 27.3 Error #1: Discrete value supplied to continuous scale ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 27.3.1 The Error ggplot(mtcars, aes(x = mpg, y = hp, color = cyl)) + geom_point() + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) üî¥ ERROR Error: Discrete value supplied to continuous scale 27.3.2 Solutions ‚úÖ SOLUTION: Match Scale to Data Type # For discrete: use discrete scale ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() + scale_color_manual(values = c(&quot;4&quot; = &quot;green&quot;, &quot;6&quot; = &quot;blue&quot;, &quot;8&quot; = &quot;red&quot;)) # For continuous: ensure numeric ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) + geom_point() + scale_color_gradient(low = &quot;blue&quot;, high = &quot;red&quot;) 27.4 Themes üéØ Best Practice: Custom Themes custom_theme &lt;- theme_minimal() + theme( plot.title = element_text(size = 16, face = &quot;bold&quot;), axis.title = element_text(size = 12, face = &quot;bold&quot;), legend.position = &quot;right&quot;, panel.grid.minor = element_blank() ) ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point(size = 3) + custom_theme + labs(title = &quot;Custom Themed Plot&quot;) 27.5 Annotations üí° Key Insight: Adding Annotations ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + annotate(&quot;text&quot;, x = 30, y = 250, label = &quot;High HP&quot;, color = &quot;red&quot;) + geom_hline(yintercept = mean(mtcars$hp), linetype = &quot;dashed&quot;) 27.6 Summary Key Takeaways: Match scales to data types Customize with themes Add annotations for context Use appropriate coordinates Quick Reference: # Scales scale_x_continuous() scale_color_manual() scale_fill_brewer() # Themes theme_minimal() theme() # Annotations annotate() geom_hline/vline() "],["ggplot2-extensions.html", "Chapter 28 ggplot2 Extensions 28.1 Introduction 28.2 patchwork 28.3 ggrepel 28.4 Summary", " Chapter 28 ggplot2 Extensions What You‚Äôll Learn: Extension packages Special plot types Interactive plots Combining plots Key Errors Covered: 15+ extension errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 28.1 Introduction ggplot2 extensions add specialized functionality: library(ggplot2) library(dplyr) 28.2 patchwork üí° Key Insight: Combining Plots library(patchwork) #&gt; Warning: package &#39;patchwork&#39; was built under R version 4.5.1 p1 &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() p2 &lt;- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point() p1 + p2 p1 / p2 28.3 ggrepel üí° Key Insight: Better Labels library(ggrepel) ggplot(mtcars, aes(x = mpg, y = hp, label = rownames(mtcars))) + geom_point() + geom_text_repel(max.overlaps = 10) #&gt; Warning: ggrepel: 4 unlabeled data points (too many overlaps). Consider #&gt; increasing max.overlaps 28.4 Summary Key Takeaways: patchwork - Combine plots ggrepel - Non-overlapping labels Many extensions available Common Extensions: library(patchwork) # Combine plots library(ggrepel) # Labels library(ggthemes) # Themes library(plotly) # Interactive "],["ggplot2-troubleshooting.html", "Chapter 29 ggplot2 Troubleshooting 29.1 Introduction 29.2 Common Pitfalls 29.3 Debugging Strategies 29.4 Performance Tips 29.5 Publication-Ready Plots 29.6 Saving Plots 29.7 Error Checklist 29.8 Common Error Solutions 29.9 Summary 29.10 Exercises 29.11 Exercise Answers 29.12 Completion", " Chapter 29 ggplot2 Troubleshooting What You‚Äôll Learn: Common pitfalls Debugging strategies Performance tips Best practices Publication-ready plots Key Errors Covered: 12+ workflow errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 29.1 Introduction Mastering ggplot2 troubleshooting saves time: library(ggplot2) library(dplyr) 29.2 Common Pitfalls ‚ö†Ô∏è Common ggplot2 Mistakes # Pitfall 1: Using %&gt;% instead of + # mtcars %&gt;% # ggplot(aes(x = mpg, y = hp)) %&gt;% # geom_point() # Pitfall 2: Variable outside aes # ggplot(mtcars) + # geom_point(aes(x = mpg, y = hp), color = cyl) # Pitfall 3: Wrong geom for data # ggplot(mtcars, aes(x = factor(cyl))) + # geom_histogram() # Pitfall 4: Modifying after ggsave p &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() ggsave(&quot;plot.png&quot;, p, width = 6, height = 4) # p + theme_minimal() # Won&#39;t affect saved plot 29.3 Debugging Strategies üéØ Best Practice: Debug Plots # Build incrementally p &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) p # Check data and aesthetics p &lt;- p + geom_point() p # Check geom p &lt;- p + theme_minimal() p # Check theme # Check data ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() + labs(title = paste(&quot;N =&quot;, nrow(mtcars))) # Verify aesthetics p &lt;- ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) p$mapping # See mappings #&gt; Aesthetic mapping: #&gt; * `x` -&gt; `mpg` #&gt; * `y` -&gt; `hp` #&gt; * `colour` -&gt; `factor(cyl)` 29.4 Performance Tips üéØ Best Practice: Optimize Performance # For large data: sample first # large_data %&gt;% # sample_n(1000) %&gt;% # ggplot(aes(x = x, y = y)) + # geom_point(alpha = 0.5) # Use geom_hex for many points ggplot(diamonds, aes(x = carat, y = price)) + geom_hex() + scale_fill_viridis_c() # Avoid unnecessary calculations # Bad: calculate in aes # ggplot(mtcars, aes(x = mpg, y = hp / wt)) + geom_point() # Good: calculate first mtcars %&gt;% mutate(hp_per_wt = hp / wt) %&gt;% ggplot(aes(x = mpg, y = hp_per_wt)) + geom_point() 29.5 Publication-Ready Plots üéØ Best Practice: Publication Quality publication_plot &lt;- function(data, x, y, color = NULL) { ggplot(data, aes(x = {{x}}, y = {{y}}, color = {{color}})) + geom_point(size = 3, alpha = 0.7) + theme_minimal() + theme( plot.title = element_text(face = &quot;bold&quot;, size = 14), axis.title = element_text(size = 12, face = &quot;bold&quot;), axis.text = element_text(size = 10), legend.position = &quot;right&quot;, legend.title = element_text(face = &quot;bold&quot;), panel.grid.minor = element_blank(), panel.border = element_rect(color = &quot;black&quot;, fill = NA) ) + scale_color_viridis_d(option = &quot;plasma&quot;) } publication_plot(mtcars, mpg, hp, factor(cyl)) + labs( title = &quot;Fuel Efficiency vs Horsepower&quot;, subtitle = &quot;Motor Trend Car Road Tests&quot;, x = &quot;Miles per Gallon&quot;, y = &quot;Horsepower&quot;, color = &quot;Cylinders&quot;, caption = &quot;Source: mtcars dataset&quot; ) 29.6 Saving Plots üéØ Best Practice: Save High-Quality Plots # High-resolution PNG ggsave(&quot;plot.png&quot;, width = 8, height = 6, dpi = 300) # Vector format ggsave(&quot;plot.pdf&quot;, width = 8, height = 6) ggsave(&quot;plot.svg&quot;, width = 8, height = 6) # Specify plot object p &lt;- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point() ggsave(&quot;my_plot.png&quot;, plot = p, width = 10, height = 8, dpi = 300) # Different devices ggsave(&quot;plot.jpg&quot;, device = &quot;jpeg&quot;, quality = 95) ggsave(&quot;plot.tiff&quot;, device = &quot;tiff&quot;, compression = &quot;lzw&quot;) 29.7 Error Checklist üéØ Debugging Checklist When a plot fails, check: Column names - Do they exist in data? names(data) Data types - Numeric vs factor? str(data) Missing values - NAs present? summary(data) colSums(is.na(data)) Operators - Using + not %&gt;%? Aesthetics - Variables in aes()? Geom compatibility - Right geom for data? Scale compatibility - Match data type? 29.8 Common Error Solutions ‚úÖ Quick Fixes # object not found ‚Üí Check column names names(mtcars) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; # + vs %&gt;% ‚Üí Use + for ggplot layers mtcars %&gt;% filter(cyl == 4) %&gt;% ggplot(aes(x = mpg, y = hp)) + # Use + geom_point() # Discrete/continuous mismatch ‚Üí Check data type ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) + geom_point() + scale_color_manual(values = c(&quot;4&quot; = &quot;red&quot;, &quot;6&quot; = &quot;blue&quot;, &quot;8&quot; = &quot;green&quot;)) # stat_count requires x or y ‚Üí Use geom_col for heights data.frame(x = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), y = c(10, 20, 15)) %&gt;% ggplot(aes(x = x, y = y)) + geom_col() # Histogram needs numeric ‚Üí Use geom_bar for categorical ggplot(mtcars, aes(x = factor(cyl))) + geom_bar() 29.9 Summary Key Takeaways: Use + not %&gt;% - For ggplot layers Build incrementally - Test each step Check data first - Verify structure Variables in aes() - Fixed values outside Match scales - To data types Save properly - High resolution for publication Follow checklist - When debugging Quick Reference: # Basic structure ggplot(data, aes(x = var1, y = var2)) + geom_point() + theme_minimal() # With preprocessing data %&gt;% filter(condition) %&gt;% ggplot(aes(x = var1, y = var2)) + # + not %&gt;% geom_point() # Save plot ggsave(&quot;plot.png&quot;, width = 8, height = 6, dpi = 300) # Debug checklist names(data) # Column names str(data) # Data types summary(data) # Check NAs p$mapping # Check aesthetics Best Practices: # ‚úÖ Good Build plots incrementally Check data structure first Use appropriate geom for data type Match scales to data Save at high resolution Document complex plots # ‚ùå Avoid Using %&gt;% for ggplot layers Variables outside aes() Ignoring warnings Low-resolution saves Complex one-liners without testing 29.10 Exercises üìù Exercise 1: Fix Errors Fix these common errors: # Error 1 mtcars %&gt;% ggplot(aes(x = mpg, y = hp)) %&gt;% geom_point() # Error 2 ggplot(mtcars) + geom_point(aes(x = mpg, y = hp), color = cyl) # Error 3 ggplot(mtcars, aes(x = factor(cyl))) + geom_histogram() üìù Exercise 2: Publication Plot Create a publication-ready plot with: - Custom theme - Proper labels - High-quality aesthetics - Save at 300 DPI 29.11 Exercise Answers Click to see answers Exercise 1: # Error 1: Use + not %&gt;% mtcars %&gt;% ggplot(aes(x = mpg, y = hp)) + geom_point() # Error 2: Put variable in aes() ggplot(mtcars) + geom_point(aes(x = mpg, y = hp, color = factor(cyl))) # Error 3: Use geom_bar() for categorical ggplot(mtcars, aes(x = factor(cyl))) + geom_bar() Exercise 2: p &lt;- mtcars %&gt;% ggplot(aes(x = mpg, y = hp, color = factor(cyl), size = wt)) + geom_point(alpha = 0.7) + scale_color_manual( values = c(&quot;4&quot; = &quot;#1f77b4&quot;, &quot;6&quot; = &quot;#ff7f0e&quot;, &quot;8&quot; = &quot;#2ca02c&quot;), name = &quot;Cylinders&quot; ) + scale_size_continuous(name = &quot;Weight (1000 lbs)&quot;, range = c(2, 6)) + labs( title = &quot;Fuel Efficiency vs Horsepower&quot;, subtitle = &quot;Motor Trend Car Road Tests (1974)&quot;, x = &quot;Miles per Gallon&quot;, y = &quot;Horsepower&quot;, caption = &quot;Source: Henderson and Velleman (1981), mtcars dataset&quot; ) + theme_minimal() + theme( plot.title = element_text(face = &quot;bold&quot;, size = 16, hjust = 0), plot.subtitle = element_text(size = 12, color = &quot;gray40&quot;), axis.title = element_text(size = 12, face = &quot;bold&quot;), axis.text = element_text(size = 10), legend.position = &quot;right&quot;, legend.title = element_text(face = &quot;bold&quot;, size = 11), legend.text = element_text(size = 10), panel.grid.minor = element_blank(), panel.border = element_rect(color = &quot;black&quot;, fill = NA, linewidth = 0.5), plot.caption = element_text(hjust = 0, size = 8, color = &quot;gray50&quot;) ) # Save high-resolution ggsave(&quot;publication_plot.png&quot;, plot = p, width = 10, height = 7, dpi = 300, bg = &quot;white&quot;) # Also save vector version ggsave(&quot;publication_plot.pdf&quot;, plot = p, width = 10, height = 7) 29.12 Completion Part IX Complete! You‚Äôve mastered: - ggplot2 basics and structure - Advanced customization - Extensions and special plots - Troubleshooting and best practices Ready for: Part X (Statistical Operations) or other topics! "],["part-x-statistical-operations.html", "Part X: Statistical Operations", " Part X: Statistical Operations "],["statistical-tests.html", "Chapter 30 Statistical Tests 30.1 Introduction 30.2 t-tests 30.3 Error #1: not enough 'x' observations 30.4 Error #2: data are essentially constant 30.5 Formula Interface 30.6 Error #3: grouping factor must have 2 levels 30.7 Assumptions 30.8 Interpreting Results 30.9 Effect Size 30.10 Paired t-tests 30.11 Error #4: 'x' and 'y' must have the same length 30.12 Power and Sample Size 30.13 Summary 30.14 Exercises 30.15 Exercise Answers", " Chapter 30 Statistical Tests What You‚Äôll Learn: t-tests (one-sample, two-sample, paired) Common statistical test errors Assumptions and violations Interpreting results Effect sizes Key Errors Covered: 22+ statistical errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 30.1 Introduction R excels at statistical testing, but errors are common: # Simple t-test t.test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 1]) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mtcars$mpg[mtcars$am == 0] and mtcars$mpg[mtcars$am == 1] #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 17.14737 24.39231 Let‚Äôs master statistical testing errors! 30.2 t-tests üí° Key Insight: Types of t-tests # One-sample t-test (compare to population mean) t.test(mtcars$mpg, mu = 20) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: mtcars$mpg #&gt; t = 0.08506, df = 31, p-value = 0.9328 #&gt; alternative hypothesis: true mean is not equal to 20 #&gt; 95 percent confidence interval: #&gt; 17.91768 22.26357 #&gt; sample estimates: #&gt; mean of x #&gt; 20.09062 # Two-sample t-test (independent groups) t.test(mpg ~ am, data = mtcars) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Paired t-test (same subjects, two conditions) before &lt;- c(120, 135, 140, 125, 130) after &lt;- c(115, 130, 135, 120, 128) t.test(before, after, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: before and after #&gt; t = 7.3333, df = 4, p-value = 0.001841 #&gt; alternative hypothesis: true mean difference is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 2.734133 6.065867 #&gt; sample estimates: #&gt; mean difference #&gt; 4.4 # One-sided test t.test(mpg ~ am, data = mtcars, alternative = &quot;greater&quot;) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.9993 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is greater than 0 #&gt; 95 percent confidence interval: #&gt; -10.57662 Inf #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Unequal variances (Welch&#39;s t-test, default) t.test(mpg ~ am, data = mtcars, var.equal = FALSE) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Equal variances (Student&#39;s t-test) t.test(mpg ~ am, data = mtcars, var.equal = TRUE) #&gt; #&gt; Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -4.1061, df = 30, p-value = 0.000285 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -10.84837 -3.64151 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 30.3 Error #1: not enough 'x' observations ‚≠ê BEGINNER üìä DATA 30.3.1 The Error # Only one observation t.test(c(5)) #&gt; Error in t.test.default(c(5)): not enough &#39;x&#39; observations üî¥ ERROR Error in t.test.default(c(5)) : not enough &#39;x&#39; observations 30.3.2 What It Means Need at least 2 observations for t-test. 30.3.3 Common Causes # Empty vector after filtering data &lt;- mtcars$mpg[mtcars$cyl == 99] # No cars with 99 cylinders t.test(data) #&gt; Error in t.test.default(data): not enough &#39;x&#39; observations # Single group t.test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 99]) #&gt; Error in t.test.default(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == : not enough &#39;y&#39; observations 30.3.4 Solutions ‚úÖ SOLUTION 1: Check Data First # Check sample sizes automatic &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] cat(&quot;Automatic:&quot;, length(automatic), &quot;observations\\n&quot;) #&gt; Automatic: 19 observations cat(&quot;Manual:&quot;, length(manual), &quot;observations\\n&quot;) #&gt; Manual: 13 observations if (length(automatic) &gt;= 2 &amp;&amp; length(manual) &gt;= 2) { t.test(automatic, manual) } else { warning(&quot;Insufficient data for t-test&quot;) } #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: automatic and manual #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 17.14737 24.39231 ‚úÖ SOLUTION 2: Safe t-test Function safe_t_test &lt;- function(x, y = NULL, ...) { if (is.null(y)) { if (length(x) &lt; 2) { stop(&quot;x must have at least 2 observations&quot;) } } else { if (length(x) &lt; 2) { stop(&quot;x must have at least 2 observations&quot;) } if (length(y) &lt; 2) { stop(&quot;y must have at least 2 observations&quot;) } } t.test(x, y, ...) } # Test safe_t_test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 1]) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: x and y #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 17.14737 24.39231 30.4 Error #2: data are essentially constant ‚≠ê‚≠ê INTERMEDIATE üìä DATA 30.4.1 The Error # All values the same t.test(c(5, 5, 5, 5, 5)) #&gt; Error in t.test.default(c(5, 5, 5, 5, 5)): data are essentially constant üî¥ ERROR Error in t.test.default(c(5, 5, 5, 5, 5)) : data are essentially constant 30.4.2 What It Means No variation in data - standard deviation is zero or near-zero. 30.4.3 Common Causes # Rounded data with no variation t.test(c(10, 10, 10, 10, 10)) #&gt; Error in t.test.default(c(10, 10, 10, 10, 10)): data are essentially constant # Binary data coded as 0/1 with all same t.test(c(1, 1, 1, 1)) #&gt; Error in t.test.default(c(1, 1, 1, 1)): data are essentially constant 30.4.4 Solutions ‚úÖ SOLUTION 1: Check for Variation check_variation &lt;- function(x) { if (sd(x) == 0 || length(unique(x)) == 1) { warning(&quot;No variation in data - t-test not appropriate&quot;) return(FALSE) } TRUE } # Check before test data &lt;- c(10, 10, 10, 10) if (check_variation(data)) { t.test(data) } else { cat(&quot;Data has no variation\\n&quot;) } #&gt; Warning in check_variation(data): No variation in data - t-test not appropriate #&gt; Data has no variation ‚úÖ SOLUTION 2: Use Appropriate Test # For proportions, use prop.test successes &lt;- c(1, 1, 1, 1) # All successes prop.test(sum(successes), length(successes)) #&gt; Warning in prop.test(sum(successes), length(successes)): Chi-squared #&gt; approximation may be incorrect #&gt; #&gt; 1-sample proportions test with continuity correction #&gt; #&gt; data: sum(successes) out of length(successes), null probability 0.5 #&gt; X-squared = 2.25, df = 1, p-value = 0.1336 #&gt; alternative hypothesis: true p is not equal to 0.5 #&gt; 95 percent confidence interval: #&gt; 0.395773 1.000000 #&gt; sample estimates: #&gt; p #&gt; 1 # Or check if variation exists data &lt;- mtcars$mpg if (sd(data) &gt; 0) { t.test(data, mu = 20) } else { cat(&quot;Data is constant, mean =&quot;, mean(data), &quot;\\n&quot;) } #&gt; #&gt; One Sample t-test #&gt; #&gt; data: data #&gt; t = 0.08506, df = 31, p-value = 0.9328 #&gt; alternative hypothesis: true mean is not equal to 20 #&gt; 95 percent confidence interval: #&gt; 17.91768 22.26357 #&gt; sample estimates: #&gt; mean of x #&gt; 20.09062 30.5 Formula Interface üí° Key Insight: Formula vs Vector Interface # Vector interface group1 &lt;- mtcars$mpg[mtcars$am == 0] group2 &lt;- mtcars$mpg[mtcars$am == 1] t.test(group1, group2) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: group1 and group2 #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 17.14737 24.39231 # Formula interface (preferred) t.test(mpg ~ am, data = mtcars) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Formula with subset t.test(mpg ~ am, data = mtcars, subset = cyl == 4) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -2.8855, df = 8.9993, p-value = 0.01802 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -9.232108 -1.117892 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 22.900 28.075 # Advantages of formula: # - Cleaner code # - Automatic labeling # - Works with model functions # - Subset argument 30.6 Error #3: grouping factor must have 2 levels ‚≠ê BEGINNER üìä DATA 30.6.1 The Error # Three levels in grouping variable t.test(mpg ~ cyl, data = mtcars) #&gt; Error in t.test.formula(mpg ~ cyl, data = mtcars): grouping factor must have exactly 2 levels üî¥ ERROR Error in t.test.formula(mpg ~ cyl, data = mtcars) : grouping factor must have exactly 2 levels 30.6.2 What It Means t-test compares exactly 2 groups. Variable has more than 2 levels. 30.6.3 Solutions ‚úÖ SOLUTION 1: Filter to 2 Groups # Compare only 4 vs 6 cylinders mtcars_subset &lt;- mtcars[mtcars$cyl %in% c(4, 6), ] t.test(mpg ~ cyl, data = mtcars_subset) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by cyl #&gt; t = 4.7191, df = 12.956, p-value = 0.0004048 #&gt; alternative hypothesis: true difference in means between group 4 and group 6 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 3.751376 10.090182 #&gt; sample estimates: #&gt; mean in group 4 mean in group 6 #&gt; 26.66364 19.74286 # Or use subset argument t.test(mpg ~ cyl, data = mtcars, subset = cyl %in% c(4, 6)) #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by cyl #&gt; t = 4.7191, df = 12.956, p-value = 0.0004048 #&gt; alternative hypothesis: true difference in means between group 4 and group 6 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 3.751376 10.090182 #&gt; sample estimates: #&gt; mean in group 4 mean in group 6 #&gt; 26.66364 19.74286 ‚úÖ SOLUTION 2: Use ANOVA for &gt;2 Groups # For 3+ groups, use ANOVA anova_result &lt;- aov(mpg ~ factor(cyl), data = mtcars) summary(anova_result) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; factor(cyl) 2 824.8 412.4 39.7 4.98e-09 *** #&gt; Residuals 29 301.3 10.4 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Post-hoc tests TukeyHSD(anova_result) #&gt; Tukey multiple comparisons of means #&gt; 95% family-wise confidence level #&gt; #&gt; Fit: aov(formula = mpg ~ factor(cyl), data = mtcars) #&gt; #&gt; $`factor(cyl)` #&gt; diff lwr upr p adj #&gt; 6-4 -6.920779 -10.769350 -3.0722086 0.0003424 #&gt; 8-4 -11.563636 -14.770779 -8.3564942 0.0000000 #&gt; 8-6 -4.642857 -8.327583 -0.9581313 0.0112287 ‚úÖ SOLUTION 3: Multiple Comparisons # Compare all pairs library(dplyr) # Get unique cylinder values cyl_levels &lt;- unique(mtcars$cyl) comparisons &lt;- combn(cyl_levels, 2) # Perform all pairwise tests results &lt;- apply(comparisons, 2, function(pair) { subset_data &lt;- mtcars[mtcars$cyl %in% pair, ] test &lt;- t.test(mpg ~ cyl, data = subset_data) data.frame( comparison = paste(pair[1], &quot;vs&quot;, pair[2]), p_value = test$p.value, statistic = test$statistic ) }) do.call(rbind, results) #&gt; comparison p_value statistic #&gt; t 6 vs 4 4.048495e-04 4.719059 #&gt; t1 6 vs 8 4.540355e-05 5.291135 #&gt; t2 4 vs 8 1.641348e-06 7.596664 30.7 Assumptions üí° Key Insight: t-test Assumptions # Assumptions: # 1. Independence # 2. Normality (esp. for small samples) # 3. Equal variances (for Student&#39;s t-test) # Check normality shapiro.test(mtcars$mpg) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: mtcars$mpg #&gt; W = 0.94756, p-value = 0.1229 # Visual check qqnorm(mtcars$mpg) qqline(mtcars$mpg) # Check equal variances var.test(mpg ~ am, data = mtcars) #&gt; #&gt; F test to compare two variances #&gt; #&gt; data: mpg by am #&gt; F = 0.38656, num df = 18, denom df = 12, p-value = 0.06691 #&gt; alternative hypothesis: true ratio of variances is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.1243721 1.0703429 #&gt; sample estimates: #&gt; ratio of variances #&gt; 0.3865615 # If assumptions violated: # - Use Welch&#39;s t-test (var.equal = FALSE, default) # - Use Mann-Whitney U test (non-parametric) wilcox.test(mpg ~ am, data = mtcars) #&gt; Warning in wilcox.test.default(x = DATA[[1L]], y = DATA[[2L]], ...): cannot #&gt; compute exact p-value with ties #&gt; #&gt; Wilcoxon rank sum test with continuity correction #&gt; #&gt; data: mpg by am #&gt; W = 42, p-value = 0.001871 #&gt; alternative hypothesis: true location shift is not equal to 0 30.8 Interpreting Results üí° Key Insight: Understanding Output result &lt;- t.test(mpg ~ am, data = mtcars) result #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Extract components result$statistic # t-statistic #&gt; t #&gt; -3.767123 result$parameter # degrees of freedom #&gt; df #&gt; 18.33225 result$p.value # p-value #&gt; [1] 0.001373638 result$conf.int # confidence interval #&gt; [1] -11.280194 -3.209684 #&gt; attr(,&quot;conf.level&quot;) #&gt; [1] 0.95 result$estimate # group means #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # Interpretation cat(&quot;t-statistic:&quot;, round(result$statistic, 3), &quot;\\n&quot;) #&gt; t-statistic: -3.767 cat(&quot;p-value:&quot;, round(result$p.value, 4), &quot;\\n&quot;) #&gt; p-value: 0.0014 cat(&quot;95% CI:&quot;, round(result$conf.int, 2), &quot;\\n&quot;) #&gt; 95% CI: -11.28 -3.21 cat(&quot;Mean difference:&quot;, round(diff(result$estimate), 2), &quot;\\n&quot;) #&gt; Mean difference: 7.24 if (result$p.value &lt; 0.05) { cat(&quot;\\nSignificant difference between groups (p &lt; 0.05)\\n&quot;) } else { cat(&quot;\\nNo significant difference between groups (p &gt;= 0.05)\\n&quot;) } #&gt; #&gt; Significant difference between groups (p &lt; 0.05) 30.9 Effect Size üéØ Best Practice: Report Effect Sizes # Cohen&#39;s d for effect size cohens_d &lt;- function(x, y) { n1 &lt;- length(x) n2 &lt;- length(y) # Pooled standard deviation s_pooled &lt;- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2)) # Cohen&#39;s d d &lt;- (mean(x) - mean(y)) / s_pooled # Interpretation interpretation &lt;- if (abs(d) &lt; 0.2) &quot;negligible&quot; else if (abs(d) &lt; 0.5) &quot;small&quot; else if (abs(d) &lt; 0.8) &quot;medium&quot; else &quot;large&quot; list( d = d, interpretation = interpretation ) } # Calculate effect size auto &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] effect &lt;- cohens_d(auto, manual) cat(&quot;Cohen&#39;s d:&quot;, round(effect$d, 2), &quot;\\n&quot;) #&gt; Cohen&#39;s d: -1.48 cat(&quot;Effect size:&quot;, effect$interpretation, &quot;\\n&quot;) #&gt; Effect size: large 30.10 Paired t-tests üí° Key Insight: Paired vs Independent # Paired: same subjects, two conditions before &lt;- c(120, 135, 140, 125, 130, 145, 150) after &lt;- c(115, 130, 135, 120, 128, 140, 145) # Paired t-test t.test(before, after, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: before and after #&gt; t = 10.667, df = 6, p-value = 4.004e-05 #&gt; alternative hypothesis: true mean difference is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 3.522752 5.620105 #&gt; sample estimates: #&gt; mean difference #&gt; 4.571429 # Calculate differences differences &lt;- before - after cat(&quot;Mean difference:&quot;, mean(differences), &quot;\\n&quot;) #&gt; Mean difference: 4.571429 cat(&quot;SD of differences:&quot;, sd(differences), &quot;\\n&quot;) #&gt; SD of differences: 1.133893 # One-sample test on differences (equivalent) t.test(differences, mu = 0) #&gt; #&gt; One Sample t-test #&gt; #&gt; data: differences #&gt; t = 10.667, df = 6, p-value = 4.004e-05 #&gt; alternative hypothesis: true mean is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 3.522752 5.620105 #&gt; sample estimates: #&gt; mean of x #&gt; 4.571429 # Independent would be WRONG here t.test(before, after, paired = FALSE) # Ignores pairing #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: before and after #&gt; t = 0.79817, df = 11.997, p-value = 0.4403 #&gt; alternative hypothesis: true difference in means is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -7.907792 17.050649 #&gt; sample estimates: #&gt; mean of x mean of y #&gt; 135.0000 130.4286 30.11 Error #4: 'x' and 'y' must have the same length ‚≠ê BEGINNER üìä DATA 30.11.1 The Error before &lt;- c(120, 135, 140, 125) after &lt;- c(115, 130, 135) # Only 3 values t.test(before, after, paired = TRUE) #&gt; Error in complete.cases(x, y): not all arguments have the same length üî¥ ERROR Error in t.test.default(before, after, paired = TRUE) : &#39;x&#39; and &#39;y&#39; must have the same length 30.11.2 What It Means Paired t-test requires same number of observations in each group. 30.11.3 Solutions ‚úÖ SOLUTION 1: Check Lengths before &lt;- c(120, 135, 140, 125, 130) after &lt;- c(115, 130, 135, 120, 128) if (length(before) != length(after)) { stop(&quot;before and after must have same length for paired test&quot;) } t.test(before, after, paired = TRUE) #&gt; #&gt; Paired t-test #&gt; #&gt; data: before and after #&gt; t = 7.3333, df = 4, p-value = 0.001841 #&gt; alternative hypothesis: true mean difference is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 2.734133 6.065867 #&gt; sample estimates: #&gt; mean difference #&gt; 4.4 ‚úÖ SOLUTION 2: Handle Missing Data # Data with NAs before &lt;- c(120, 135, NA, 125, 130) after &lt;- c(115, 130, 135, 120, NA) # Remove pairs with any NA complete_cases &lt;- complete.cases(before, after) before_clean &lt;- before[complete_cases] after_clean &lt;- after[complete_cases] cat(&quot;Complete pairs:&quot;, sum(complete_cases), &quot;\\n&quot;) #&gt; Complete pairs: 3 t.test(before_clean, after_clean, paired = TRUE) #&gt; Error in t.test.default(before_clean, after_clean, paired = TRUE): data are essentially constant ‚úÖ SOLUTION 3: Use Data Frame Approach library(dplyr) library(tidyr) # Store in data frame data &lt;- data.frame( id = 1:5, before = c(120, 135, NA, 125, 130), after = c(115, 130, 135, 120, NA) ) # Remove incomplete cases data_complete &lt;- data %&gt;% filter(!is.na(before) &amp; !is.na(after)) cat(&quot;Complete cases:&quot;, nrow(data_complete), &quot;\\n&quot;) #&gt; Complete cases: 3 with(data_complete, t.test(before, after, paired = TRUE)) #&gt; Error in t.test.default(before, after, paired = TRUE): data are essentially constant 30.12 Power and Sample Size üéØ Best Practice: Power Analysis # Calculate required sample size power.t.test( delta = 5, # Expected difference sd = 10, # Standard deviation sig.level = 0.05, # Alpha power = 0.80 # Desired power ) #&gt; #&gt; Two-sample t test power calculation #&gt; #&gt; n = 63.76576 #&gt; delta = 5 #&gt; sd = 10 #&gt; sig.level = 0.05 #&gt; power = 0.8 #&gt; alternative = two.sided #&gt; #&gt; NOTE: n is number in *each* group # Calculate power for given sample size power.t.test( n = 20, delta = 5, sd = 10, sig.level = 0.05 ) #&gt; #&gt; Two-sample t test power calculation #&gt; #&gt; n = 20 #&gt; delta = 5 #&gt; sd = 10 #&gt; sig.level = 0.05 #&gt; power = 0.3377084 #&gt; alternative = two.sided #&gt; #&gt; NOTE: n is number in *each* group # For existing study auto &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] power.t.test( n = length(auto), delta = abs(mean(auto) - mean(manual)), sd = sd(c(auto, manual)), sig.level = 0.05 ) #&gt; #&gt; Two-sample t test power calculation #&gt; #&gt; n = 19 #&gt; delta = 7.244939 #&gt; sd = 6.026948 #&gt; sig.level = 0.05 #&gt; power = 0.9499733 #&gt; alternative = two.sided #&gt; #&gt; NOTE: n is number in *each* group 30.13 Summary Key Takeaways: Check sample sizes - Need at least 2 observations per group Check variation - Data can‚Äôt be constant Exactly 2 groups - Use ANOVA for 3+ Paired = same length - Remove incomplete pairs Check assumptions - Normality, equal variances Report effect sizes - Not just p-values Formula interface preferred - Cleaner code Quick Reference: Error Cause Fix not enough observations n &lt; 2 Check sample sizes data are constant sd = 0 Check for variation must have 2 levels 3+ groups Filter or use ANOVA must have same length Paired mismatch Remove incomplete pairs t-test Variations: # One-sample t.test(x, mu = 0) # Two-sample (independent) t.test(x, y) t.test(y ~ x, data = df) # Paired t.test(x, y, paired = TRUE) # One-sided t.test(x, y, alternative = &quot;greater&quot;) t.test(x, y, alternative = &quot;less&quot;) # Equal variances t.test(x, y, var.equal = TRUE) # With subset t.test(y ~ x, data = df, subset = condition) Best Practices: # ‚úÖ Good Check sample sizes first Check assumptions (normality, equal variance) Use formula interface: t.test(y ~ x, data = df) Report effect sizes (Cohen&#39;s d) Use Welch&#39;s t-test (default) for unequal variances Check for paired vs independent design # ‚ùå Avoid Assuming data meets assumptions Using t-test for 3+ groups Ignoring pairing in data Only reporting p-values Using with constant data Not checking sample sizes 30.14 Exercises üìù Exercise 1: Basic t-test Using mtcars: 1. Test if mean mpg differs by transmission (am) 2. Check assumptions 3. Calculate effect size 4. Interpret results üìù Exercise 2: Paired t-test Create before/after data and: 1. Perform paired t-test 2. Check if order matters 3. Calculate mean difference 4. Visualize differences üìù Exercise 3: Safe t-test Function Write safe_t_test() that: 1. Checks sample sizes 2. Checks for variation 3. Verifies assumptions 4. Performs test 5. Returns formatted results üìù Exercise 4: Multiple Comparisons Using iris dataset: 1. Compare petal length across species 2. Perform all pairwise t-tests 3. Adjust for multiple testing 4. Report results in table 30.15 Exercise Answers Click to see answers Exercise 1: # 1. Test mean mpg by transmission result &lt;- t.test(mpg ~ am, data = mtcars) result #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 # 2. Check assumptions # Normality shapiro.test(mtcars$mpg[mtcars$am == 0]) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: mtcars$mpg[mtcars$am == 0] #&gt; W = 0.97677, p-value = 0.8987 shapiro.test(mtcars$mpg[mtcars$am == 1]) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: mtcars$mpg[mtcars$am == 1] #&gt; W = 0.9458, p-value = 0.5363 # Equal variances var.test(mpg ~ am, data = mtcars) #&gt; #&gt; F test to compare two variances #&gt; #&gt; data: mpg by am #&gt; F = 0.38656, num df = 18, denom df = 12, p-value = 0.06691 #&gt; alternative hypothesis: true ratio of variances is not equal to 1 #&gt; 95 percent confidence interval: #&gt; 0.1243721 1.0703429 #&gt; sample estimates: #&gt; ratio of variances #&gt; 0.3865615 # 3. Effect size auto &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] cohens_d &lt;- function(x, y) { n1 &lt;- length(x) n2 &lt;- length(y) s_pooled &lt;- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2)) (mean(x) - mean(y)) / s_pooled } d &lt;- cohens_d(auto, manual) # 4. Interpret cat(&quot;\\n=== Results ===\\n&quot;) #&gt; #&gt; === Results === cat(&quot;t-statistic:&quot;, round(result$statistic, 3), &quot;\\n&quot;) #&gt; t-statistic: -3.767 cat(&quot;p-value:&quot;, format.pval(result$p.value, digits = 3), &quot;\\n&quot;) #&gt; p-value: 0.00137 cat(&quot;Mean difference:&quot;, round(diff(result$estimate), 2), &quot;mpg\\n&quot;) #&gt; Mean difference: 7.24 mpg cat(&quot;95% CI:&quot;, round(result$conf.int, 2), &quot;\\n&quot;) #&gt; 95% CI: -11.28 -3.21 cat(&quot;Cohen&#39;s d:&quot;, round(d, 2), &quot;\\n&quot;) #&gt; Cohen&#39;s d: -1.48 if (result$p.value &lt; 0.05) { cat(&quot;\\nConclusion: Significant difference in mpg between transmission types (p &lt; 0.05)\\n&quot;) cat(&quot;Manual transmission has&quot;, round(abs(diff(result$estimate)), 1), &quot;higher mpg on average.\\n&quot;) } #&gt; #&gt; Conclusion: Significant difference in mpg between transmission types (p &lt; 0.05) #&gt; Manual transmission has 7.2 higher mpg on average. Exercise 2: # Create data set.seed(123) before &lt;- c(120, 135, 140, 125, 130, 145, 150, 128, 138, 142) after &lt;- before - rnorm(10, mean = 8, sd = 3) # 1. Paired t-test result &lt;- t.test(before, after, paired = TRUE) result #&gt; #&gt; Paired t-test #&gt; #&gt; data: before and after #&gt; t = 9.0888, df = 9, p-value = 7.879e-06 #&gt; alternative hypothesis: true mean difference is not equal to 0 #&gt; 95 percent confidence interval: #&gt; 6.176989 10.270765 #&gt; sample estimates: #&gt; mean difference #&gt; 8.223877 # 2. Order doesn&#39;t matter for pairing t.test(after, before, paired = TRUE) # Same magnitude, opposite sign #&gt; #&gt; Paired t-test #&gt; #&gt; data: after and before #&gt; t = -9.0888, df = 9, p-value = 7.879e-06 #&gt; alternative hypothesis: true mean difference is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -10.270765 -6.176989 #&gt; sample estimates: #&gt; mean difference #&gt; -8.223877 # 3. Mean difference differences &lt;- before - after cat(&quot;\\nMean difference:&quot;, round(mean(differences), 2), &quot;\\n&quot;) #&gt; #&gt; Mean difference: 8.22 cat(&quot;SD of differences:&quot;, round(sd(differences), 2), &quot;\\n&quot;) #&gt; SD of differences: 2.86 # 4. Visualize library(ggplot2) data_df &lt;- data.frame( id = rep(1:10, 2), time = rep(c(&quot;Before&quot;, &quot;After&quot;), each = 10), value = c(before, after) ) ggplot(data_df, aes(x = time, y = value, group = id)) + geom_line(alpha = 0.5) + geom_point(size = 3) + labs(title = &quot;Before vs After Comparison&quot;, subtitle = paste(&quot;Mean difference:&quot;, round(mean(differences), 1)), y = &quot;Value&quot;) + theme_minimal() # Difference plot diff_df &lt;- data.frame( id = 1:10, difference = differences ) ggplot(diff_df, aes(x = id, y = difference)) + geom_hline(yintercept = 0, linetype = &quot;dashed&quot;) + geom_point(size = 3) + geom_segment(aes(xend = id, yend = 0)) + labs(title = &quot;Individual Differences&quot;, y = &quot;Before - After&quot;) + theme_minimal() Exercise 3: safe_t_test &lt;- function(x, y = NULL, paired = FALSE, ...) { # Check inputs if (is.null(y)) { # One-sample test if (length(x) &lt; 2) { stop(&quot;Need at least 2 observations&quot;) } if (sd(x) == 0) { stop(&quot;Data has no variation&quot;) } } else { # Two-sample test if (length(x) &lt; 2) stop(&quot;x needs at least 2 observations&quot;) if (length(y) &lt; 2) stop(&quot;y needs at least 2 observations&quot;) if (sd(x) == 0) stop(&quot;x has no variation&quot;) if (sd(y) == 0) stop(&quot;y has no variation&quot;) # Check paired if (paired &amp;&amp; length(x) != length(y)) { stop(&quot;For paired test, x and y must have same length&quot;) } } # Perform test result &lt;- t.test(x, y, paired = paired, ...) # Format output output &lt;- list( test = result, summary = data.frame( statistic = result$statistic, df = result$parameter, p_value = result$p.value, mean_diff = ifelse(is.null(y), result$estimate - result$null.value, diff(result$estimate)), ci_lower = result$conf.int[1], ci_upper = result$conf.int[2] ) ) # Print summary cat(&quot;=== t-test Results ===\\n&quot;) cat(&quot;t =&quot;, round(output$summary$statistic, 3), &quot;\\n&quot;) cat(&quot;df =&quot;, round(output$summary$df, 1), &quot;\\n&quot;) cat(&quot;p-value =&quot;, format.pval(output$summary$p_value, digits = 3), &quot;\\n&quot;) cat(&quot;Mean difference =&quot;, round(output$summary$mean_diff, 2), &quot;\\n&quot;) cat(&quot;95% CI: [&quot;, round(output$summary$ci_lower, 2), &quot;,&quot;, round(output$summary$ci_upper, 2), &quot;]\\n&quot;) if (output$summary$p_value &lt; 0.05) { cat(&quot;\\nSignificant at Œ± = 0.05\\n&quot;) } else { cat(&quot;\\nNot significant at Œ± = 0.05\\n&quot;) } invisible(output) } # Test it safe_t_test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 1]) #&gt; === t-test Results === #&gt; t = -3.767 #&gt; df = 18.3 #&gt; p-value = 0.00137 #&gt; Mean difference = 7.24 #&gt; 95% CI: [ -11.28 , -3.21 ] #&gt; #&gt; Significant at Œ± = 0.05 Exercise 4: library(dplyr) # 1 &amp; 2. All pairwise comparisons species &lt;- levels(iris$Species) results_list &lt;- list() for (i in 1:(length(species) - 1)) { for (j in (i + 1):length(species)) { sp1 &lt;- species[i] sp2 &lt;- species[j] data_subset &lt;- iris %&gt;% filter(Species %in% c(sp1, sp2)) test &lt;- t.test(Petal.Length ~ Species, data = data_subset) results_list[[paste(sp1, &quot;vs&quot;, sp2)]] &lt;- data.frame( comparison = paste(sp1, &quot;vs&quot;, sp2), mean_1 = test$estimate[1], mean_2 = test$estimate[2], mean_diff = diff(test$estimate), t_stat = test$statistic, p_value = test$p.value, ci_lower = test$conf.int[1], ci_upper = test$conf.int[2] ) } } results_df &lt;- do.call(rbind, results_list) rownames(results_df) &lt;- NULL # 3. Adjust for multiple testing results_df$p_adjusted &lt;- p.adjust(results_df$p_value, method = &quot;bonferroni&quot;) # 4. Display results cat(&quot;=== Pairwise Comparisons of Petal Length ===\\n\\n&quot;) #&gt; === Pairwise Comparisons of Petal Length === print(results_df, digits = 3) #&gt; comparison mean_1 mean_2 mean_diff t_stat p_value ci_lower #&gt; 1 setosa vs versicolor 1.46 4.26 2.80 -39.5 9.93e-46 -2.94 #&gt; 2 setosa vs virginica 1.46 5.55 4.09 -50.0 9.27e-50 -4.25 #&gt; 3 versicolor vs virginica 4.26 5.55 1.29 -12.6 4.90e-22 -1.50 #&gt; ci_upper p_adjusted #&gt; 1 -2.66 2.98e-45 #&gt; 2 -3.93 2.78e-49 #&gt; 3 -1.09 1.47e-21 cat(&quot;\\n=== Summary ===\\n&quot;) #&gt; #&gt; === Summary === cat(&quot;Total comparisons:&quot;, nrow(results_df), &quot;\\n&quot;) #&gt; Total comparisons: 3 cat(&quot;Significant (unadjusted):&quot;, sum(results_df$p_value &lt; 0.05), &quot;\\n&quot;) #&gt; Significant (unadjusted): 3 cat(&quot;Significant (Bonferroni):&quot;, sum(results_df$p_adjusted &lt; 0.05), &quot;\\n&quot;) #&gt; Significant (Bonferroni): 3 "],["regression-anova.html", "Chapter 31 Regression &amp; ANOVA 31.1 Introduction 31.2 Linear Regression 31.3 Error #1: NA/NaN/Inf in 'y' 31.4 Model Diagnostics 31.5 ANOVA 31.6 Error #2: contrasts can be applied only to factors 31.7 Predictions 31.8 Error #3: variable lengths differ 31.9 Model Comparison 31.10 Summary", " Chapter 31 Regression &amp; ANOVA What You‚Äôll Learn: Linear regression ANOVA (one-way, two-way) Model diagnostics Common regression errors Interpreting results Key Errors Covered: 20+ regression errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 31.1 Introduction Regression and ANOVA are fundamental statistical tools: # Simple linear regression model &lt;- lm(mpg ~ hp, data = mtcars) summary(model) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ hp, data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -5.7121 -2.1122 -0.8854 1.5819 8.2360 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** #&gt; hp -0.06823 0.01012 -6.742 1.79e-07 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 3.863 on 30 degrees of freedom #&gt; Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 #&gt; F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 Let‚Äôs master these analyses! 31.2 Linear Regression üí° Key Insight: lm() Function # Simple regression (one predictor) model1 &lt;- lm(mpg ~ hp, data = mtcars) summary(model1) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ hp, data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -5.7121 -2.1122 -0.8854 1.5819 8.2360 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 30.09886 1.63392 18.421 &lt; 2e-16 *** #&gt; hp -0.06823 0.01012 -6.742 1.79e-07 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 3.863 on 30 degrees of freedom #&gt; Multiple R-squared: 0.6024, Adjusted R-squared: 0.5892 #&gt; F-statistic: 45.46 on 1 and 30 DF, p-value: 1.788e-07 # Multiple regression model2 &lt;- lm(mpg ~ hp + wt + cyl, data = mtcars) summary(model2) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ hp + wt + cyl, data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -3.9290 -1.5598 -0.5311 1.1850 5.8986 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 38.75179 1.78686 21.687 &lt; 2e-16 *** #&gt; hp -0.01804 0.01188 -1.519 0.140015 #&gt; wt -3.16697 0.74058 -4.276 0.000199 *** #&gt; cyl -0.94162 0.55092 -1.709 0.098480 . #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 2.512 on 28 degrees of freedom #&gt; Multiple R-squared: 0.8431, Adjusted R-squared: 0.8263 #&gt; F-statistic: 50.17 on 3 and 28 DF, p-value: 2.184e-11 # With interaction model3 &lt;- lm(mpg ~ hp * wt, data = mtcars) summary(model3) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ hp * wt, data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -3.0632 -1.6491 -0.7362 1.4211 4.5513 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 49.80842 3.60516 13.816 5.01e-14 *** #&gt; hp -0.12010 0.02470 -4.863 4.04e-05 *** #&gt; wt -8.21662 1.26971 -6.471 5.20e-07 *** #&gt; hp:wt 0.02785 0.00742 3.753 0.000811 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 2.153 on 28 degrees of freedom #&gt; Multiple R-squared: 0.8848, Adjusted R-squared: 0.8724 #&gt; F-statistic: 71.66 on 3 and 28 DF, p-value: 2.981e-13 # Polynomial model4 &lt;- lm(mpg ~ poly(hp, 2), data = mtcars) summary(model4) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ poly(hp, 2), data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -4.5512 -1.6027 -0.6977 1.5509 8.7213 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 20.091 0.544 36.931 &lt; 2e-16 *** #&gt; poly(hp, 2)1 -26.046 3.077 -8.464 2.51e-09 *** #&gt; poly(hp, 2)2 13.155 3.077 4.275 0.000189 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 3.077 on 29 degrees of freedom #&gt; Multiple R-squared: 0.7561, Adjusted R-squared: 0.7393 #&gt; F-statistic: 44.95 on 2 and 29 DF, p-value: 1.301e-09 # Extract components coef(model1) # Coefficients #&gt; (Intercept) hp #&gt; 30.09886054 -0.06822828 fitted(model1) # Fitted values #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; 22.593750 22.593750 23.753631 22.593750 #&gt; Hornet Sportabout Valiant Duster 360 Merc 240D #&gt; 18.158912 22.934891 13.382932 25.868707 #&gt; Merc 230 Merc 280 Merc 280C Merc 450SE #&gt; 23.617174 21.706782 21.706782 17.817770 #&gt; Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental #&gt; 17.817770 17.817770 16.112064 15.429781 #&gt; Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla #&gt; 14.406357 25.595794 26.550990 25.664022 #&gt; Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 #&gt; 23.480718 19.864619 19.864619 13.382932 #&gt; Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa #&gt; 18.158912 25.595794 23.890087 22.389065 #&gt; Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E #&gt; 12.086595 18.158912 7.242387 22.661978 residuals(model1) # Residuals #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; -1.59374995 -1.59374995 -0.95363068 -1.19374995 #&gt; Hornet Sportabout Valiant Duster 360 Merc 240D #&gt; 0.54108812 -4.83489134 0.91706759 -1.46870730 #&gt; Merc 230 Merc 280 Merc 280C Merc 450SE #&gt; -0.81717412 -2.50678234 -3.90678234 -1.41777049 #&gt; Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental #&gt; -0.51777049 -2.61777049 -5.71206353 -5.02978075 #&gt; Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla #&gt; 0.29364342 6.80420581 3.84900992 8.23597754 #&gt; Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 #&gt; -1.98071757 -4.36461883 -4.66461883 -0.08293241 #&gt; Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa #&gt; 1.04108812 1.70420581 2.10991276 8.01093488 #&gt; Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E #&gt; 3.71340487 1.54108812 7.75761261 -1.26197823 predict(model1) # Predictions #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; 22.593750 22.593750 23.753631 22.593750 #&gt; Hornet Sportabout Valiant Duster 360 Merc 240D #&gt; 18.158912 22.934891 13.382932 25.868707 #&gt; Merc 230 Merc 280 Merc 280C Merc 450SE #&gt; 23.617174 21.706782 21.706782 17.817770 #&gt; Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental #&gt; 17.817770 17.817770 16.112064 15.429781 #&gt; Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla #&gt; 14.406357 25.595794 26.550990 25.664022 #&gt; Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 #&gt; 23.480718 19.864619 19.864619 13.382932 #&gt; Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa #&gt; 18.158912 25.595794 23.890087 22.389065 #&gt; Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E #&gt; 12.086595 18.158912 7.242387 22.661978 confint(model1) # Confidence intervals #&gt; 2.5 % 97.5 % #&gt; (Intercept) 26.76194879 33.4357723 #&gt; hp -0.08889465 -0.0475619 31.3 Error #1: NA/NaN/Inf in 'y' ‚≠ê BEGINNER üìä DATA 31.3.1 The Error # Data with NA data_na &lt;- mtcars data_na$mpg[1:3] &lt;- NA lm(mpg ~ hp, data = data_na) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ hp, data = data_na) #&gt; #&gt; Coefficients: #&gt; (Intercept) hp #&gt; 30.44325 -0.06956 üî¥ ERROR/WARNING Model runs but removes NAs with warning. Can cause issues downstream. 31.3.2 Solutions ‚úÖ SOLUTION 1: Handle NAs Explicitly # Remove NAs before modeling data_clean &lt;- mtcars[complete.cases(mtcars[, c(&quot;mpg&quot;, &quot;hp&quot;)]), ] model &lt;- lm(mpg ~ hp, data = data_clean) # Or use na.omit data_clean2 &lt;- na.omit(mtcars[, c(&quot;mpg&quot;, &quot;hp&quot;, &quot;wt&quot;)]) model2 &lt;- lm(mpg ~ hp + wt, data = data_clean2) # Check for NAs cat(&quot;Complete cases:&quot;, sum(complete.cases(mtcars)), &quot;\\n&quot;) #&gt; Complete cases: 32 cat(&quot;NAs in mpg:&quot;, sum(is.na(mtcars$mpg)), &quot;\\n&quot;) #&gt; NAs in mpg: 0 ‚úÖ SOLUTION 2: Use na.action # Different NA handling model_fail &lt;- lm(mpg ~ hp, data = data_na, na.action = na.fail) # Fails if NA #&gt; Error in na.fail.default(structure(list(mpg = c(NA, NA, NA, 21.4, 18.7, : missing values in object # model_exclude &lt;- lm(mpg ~ hp, data = data_na, na.action = na.exclude) # Excludes # model_omit &lt;- lm(mpg ~ hp, data = data_na, na.action = na.omit) # Omits (default) cat(&quot;na.omit: removes NAs, shortens residuals\\n&quot;) #&gt; na.omit: removes NAs, shortens residuals cat(&quot;na.exclude: removes NAs, preserves length with NAs\\n&quot;) #&gt; na.exclude: removes NAs, preserves length with NAs 31.4 Model Diagnostics üí° Key Insight: Checking Assumptions model &lt;- lm(mpg ~ hp + wt, data = mtcars) # Diagnostic plots par(mfrow = c(2, 2)) plot(model) par(mfrow = c(1, 1)) # 1. Residuals vs Fitted - Check linearity # 2. Q-Q plot - Check normality # 3. Scale-Location - Check homoscedasticity # 4. Residuals vs Leverage - Check influential points # Individual checks # Normality of residuals shapiro.test(residuals(model)) #&gt; #&gt; Shapiro-Wilk normality test #&gt; #&gt; data: residuals(model) #&gt; W = 0.92792, p-value = 0.03427 # Homoscedasticity library(lmtest) #&gt; Loading required package: zoo #&gt; #&gt; Attaching package: &#39;zoo&#39; #&gt; The following objects are masked from &#39;package:base&#39;: #&gt; #&gt; as.Date, as.Date.numeric bptest(model) #&gt; Warning in formula$x: partial match of &#39;x&#39; to &#39;xlevels&#39; #&gt; #&gt; studentized Breusch-Pagan test #&gt; #&gt; data: model #&gt; BP = 0.88072, df = 2, p-value = 0.6438 # Multicollinearity library(car) #&gt; Loading required package: carData #&gt; #&gt; Attaching package: &#39;car&#39; #&gt; The following object is masked from &#39;package:purrr&#39;: #&gt; #&gt; some #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; recode vif(model) #&gt; hp wt #&gt; 1.766625 1.766625 31.5 ANOVA üí° Key Insight: Analysis of Variance # One-way ANOVA anova_model &lt;- aov(mpg ~ factor(cyl), data = mtcars) summary(anova_model) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; factor(cyl) 2 824.8 412.4 39.7 4.98e-09 *** #&gt; Residuals 29 301.3 10.4 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Two-way ANOVA anova_model2 &lt;- aov(mpg ~ factor(cyl) + factor(gear), data = mtcars) summary(anova_model2) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; factor(cyl) 2 824.8 412.4 38.00 1.41e-08 *** #&gt; factor(gear) 2 8.3 4.1 0.38 0.687 #&gt; Residuals 27 293.0 10.9 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # With interaction anova_model3 &lt;- aov(mpg ~ factor(cyl) * factor(gear), data = mtcars) summary(anova_model3) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; factor(cyl) 2 824.8 412.4 36.777 4.92e-08 *** #&gt; factor(gear) 2 8.3 4.1 0.368 0.696 #&gt; factor(cyl):factor(gear) 3 23.9 8.0 0.710 0.555 #&gt; Residuals 24 269.1 11.2 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # Post-hoc tests TukeyHSD(anova_model) #&gt; Tukey multiple comparisons of means #&gt; 95% family-wise confidence level #&gt; #&gt; Fit: aov(formula = mpg ~ factor(cyl), data = mtcars) #&gt; #&gt; $`factor(cyl)` #&gt; diff lwr upr p adj #&gt; 6-4 -6.920779 -10.769350 -3.0722086 0.0003424 #&gt; 8-4 -11.563636 -14.770779 -8.3564942 0.0000000 #&gt; 8-6 -4.642857 -8.327583 -0.9581313 0.0112287 31.6 Error #2: contrasts can be applied only to factors ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 31.6.1 The Error # Using numeric variable as factor model &lt;- lm(mpg ~ cyl, data = mtcars, contrasts = list(cyl = contr.treatment)) #&gt; Error in `contrasts&lt;-`(`*tmp*`, value = ca): contrasts apply only to factors üî¥ ERROR Error in contrasts&lt;-: contrasts can be applied only to factors with 2 or more levels 31.6.2 Solutions ‚úÖ SOLUTION: Convert to Factor # Convert numeric to factor mtcars$cyl_factor &lt;- factor(mtcars$cyl) model &lt;- lm(mpg ~ cyl_factor, data = mtcars) summary(model) #&gt; #&gt; Call: #&gt; lm(formula = mpg ~ cyl_factor, data = mtcars) #&gt; #&gt; Residuals: #&gt; Min 1Q Median 3Q Max #&gt; -5.2636 -1.8357 0.0286 1.3893 7.2364 #&gt; #&gt; Coefficients: #&gt; Estimate Std. Error t value Pr(&gt;|t|) #&gt; (Intercept) 26.6636 0.9718 27.437 &lt; 2e-16 *** #&gt; cyl_factor6 -6.9208 1.5583 -4.441 0.000119 *** #&gt; cyl_factor8 -11.5636 1.2986 -8.905 8.57e-10 *** #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 #&gt; #&gt; Residual standard error: 3.223 on 29 degrees of freedom #&gt; Multiple R-squared: 0.7325, Adjusted R-squared: 0.714 #&gt; F-statistic: 39.7 on 2 and 29 DF, p-value: 4.979e-09 # For ANOVA, must be factor anova_model &lt;- aov(mpg ~ factor(cyl), data = mtcars) summary(anova_model) #&gt; Df Sum Sq Mean Sq F value Pr(&gt;F) #&gt; factor(cyl) 2 824.8 412.4 39.7 4.98e-09 *** #&gt; Residuals 29 301.3 10.4 #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 31.7 Predictions üéØ Best Practice: Making Predictions model &lt;- lm(mpg ~ hp + wt, data = mtcars) # Predict on original data predictions &lt;- predict(model) head(predictions) #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; 23.57233 22.58348 25.27582 21.26502 #&gt; Hornet Sportabout Valiant #&gt; 18.32727 20.47382 # Predict on new data new_data &lt;- data.frame( hp = c(100, 150, 200), wt = c(2.5, 3.0, 3.5) ) predict(model, newdata = new_data) #&gt; 1 2 3 #&gt; 24.35540 20.82784 17.30027 # With confidence intervals predict(model, newdata = new_data, interval = &quot;confidence&quot;) #&gt; fit lwr upr #&gt; 1 24.35540 23.15968 25.55111 #&gt; 2 20.82784 19.83556 21.82012 #&gt; 3 17.30027 16.07235 18.52820 # With prediction intervals predict(model, newdata = new_data, interval = &quot;prediction&quot;) #&gt; fit lwr upr #&gt; 1 24.35540 18.91817 29.79263 #&gt; 2 20.82784 15.43169 26.22398 #&gt; 3 17.30027 11.85587 22.74468 31.8 Error #3: variable lengths differ ‚≠ê BEGINNER üìä DATA 31.8.1 The Error # Mismatched lengths x &lt;- 1:10 y &lt;- 1:5 lm(y ~ x) #&gt; Error in model.frame.default(formula = y ~ x, drop.unused.levels = TRUE): variable lengths differ (found for &#39;x&#39;) üî¥ ERROR Error in model.frame.default: variable lengths differ (found for &#39;x&#39;) 31.8.2 Solutions ‚úÖ SOLUTION: Check Data Lengths # Check before modeling x &lt;- 1:10 y &lt;- 1:10 # Fixed if (length(x) != length(y)) { stop(&quot;Variables must have same length&quot;) } model &lt;- lm(y ~ x) 31.9 Model Comparison üéØ Best Practice: Compare Models # Nested models model1 &lt;- lm(mpg ~ hp, data = mtcars) model2 &lt;- lm(mpg ~ hp + wt, data = mtcars) model3 &lt;- lm(mpg ~ hp + wt + cyl, data = mtcars) # ANOVA comparison anova(model1, model2, model3) #&gt; Analysis of Variance Table #&gt; #&gt; Model 1: mpg ~ hp #&gt; Model 2: mpg ~ hp + wt #&gt; Model 3: mpg ~ hp + wt + cyl #&gt; Res.Df RSS Df Sum of Sq F Pr(&gt;F) #&gt; 1 30 447.67 #&gt; 2 29 195.05 1 252.627 40.0494 7.597e-07 *** #&gt; 3 28 176.62 1 18.427 2.9213 0.09848 . #&gt; --- #&gt; Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # AIC/BIC AIC(model1, model2, model3) #&gt; df AIC #&gt; model1 3 181.2386 #&gt; model2 4 156.6523 #&gt; model3 5 155.4766 BIC(model1, model2, model3) #&gt; df BIC #&gt; model1 3 185.6358 #&gt; model2 4 162.5153 #&gt; model3 5 162.8053 # R-squared summary(model1)$r.squared #&gt; [1] 0.6024373 summary(model2)$r.squared #&gt; [1] 0.8267855 summary(model3)$r.squared #&gt; [1] 0.84315 # Adjusted R-squared (accounts for # predictors) summary(model1)$adj.r.squared #&gt; [1] 0.5891853 summary(model2)$adj.r.squared #&gt; [1] 0.8148396 summary(model3)$adj.r.squared #&gt; [1] 0.8263446 31.10 Summary Key Takeaways: Handle NAs explicitly - Check before modeling Factors for ANOVA - Convert numeric to factor Check diagnostics - Assumptions matter Compare models - Use ANOVA, AIC, BIC Report properly - Coefficients, p-values, R¬≤ Predict carefully - Match variable names Quick Reference: # Linear regression model &lt;- lm(y ~ x, data = df) model &lt;- lm(y ~ x1 + x2, data = df) model &lt;- lm(y ~ x1 * x2, data = df) # Interaction # ANOVA model &lt;- aov(y ~ factor(group), data = df) TukeyHSD(model) # Diagnostics plot(model) summary(model) # Predictions predict(model, newdata = new_df) predict(model, interval = &quot;confidence&quot;) "],["stats-best-practices.html", "Chapter 32 Statistical Best Practices 32.1 Introduction 32.2 P-values 32.3 Multiple Testing 32.4 Effect Sizes 32.5 Power Analysis 32.6 Reproducible Analysis 32.7 Common Pitfalls 32.8 Reporting Results 32.9 Checklist 32.10 Summary 32.11 Completion", " Chapter 32 Statistical Best Practices What You‚Äôll Learn: P-value interpretation Multiple testing corrections Effect sizes and power Reproducible analyses Common pitfalls Key Errors Covered: 15+ conceptual errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 32.1 Introduction Statistical best practices prevent common mistakes: library(dplyr) 32.2 P-values üí° Key Insight: Understanding P-values # P-value is NOT: # - Probability hypothesis is true # - Probability of replication # - Effect size # P-value IS: # - P(data | H0 is true) # - Probability of seeing data this extreme if null is true # Example t_result &lt;- t.test(mpg ~ am, data = mtcars) cat(&quot;P-value:&quot;, round(t_result$p.value, 4), &quot;\\n&quot;) cat(&quot;\\nInterpretation:\\n&quot;) cat(&quot;If there were truly no difference in mpg between transmissions,\\n&quot;) cat(&quot;we would see a difference this large or larger in&quot;, round(t_result$p.value * 100, 2), &quot;% of studies.\\n&quot;) # Common thresholds if (t_result$p.value &lt; 0.001) cat(&quot;\\nVery strong evidence against H0\\n&quot;) else if (t_result$p.value &lt; 0.01) cat(&quot;\\nStrong evidence against H0\\n&quot;) else if (t_result$p.value &lt; 0.05) cat(&quot;\\nModerate evidence against H0\\n&quot;) else cat(&quot;\\nWeak evidence against H0\\n&quot;) #&gt; Error in parse(text = input): &lt;text&gt;:21:1: unexpected &#39;else&#39; #&gt; 20: if (t_result$p.value &lt; 0.001) cat(&quot;\\nVery strong evidence against H0\\n&quot;) #&gt; 21: else #&gt; ^ 32.3 Multiple Testing üí° Key Insight: Adjusting for Multiple Tests # Problem: More tests = more false positives set.seed(123) n_tests &lt;- 20 p_values &lt;- replicate(n_tests, { x &lt;- rnorm(30) y &lt;- rnorm(30) t.test(x, y)$p.value }) cat(&quot;Significant at Œ± = 0.05:&quot;, sum(p_values &lt; 0.05), &quot;out of&quot;, n_tests, &quot;\\n&quot;) #&gt; Significant at Œ± = 0.05: 1 out of 20 cat(&quot;Expected false positives:&quot;, n_tests * 0.05, &quot;\\n&quot;) #&gt; Expected false positives: 1 # Solutions: # 1. Bonferroni correction (conservative) p_bonferroni &lt;- p.adjust(p_values, method = &quot;bonferroni&quot;) cat(&quot;\\nAfter Bonferroni:&quot;, sum(p_bonferroni &lt; 0.05), &quot;significant\\n&quot;) #&gt; #&gt; After Bonferroni: 0 significant # 2. FDR control (less conservative) p_fdr &lt;- p.adjust(p_values, method = &quot;fdr&quot;) cat(&quot;After FDR:&quot;, sum(p_fdr &lt; 0.05), &quot;significant\\n&quot;) #&gt; After FDR: 0 significant # 3. Holm method (sequential) p_holm &lt;- p.adjust(p_values, method = &quot;holm&quot;) cat(&quot;After Holm:&quot;, sum(p_holm &lt; 0.05), &quot;significant\\n&quot;) #&gt; After Holm: 0 significant 32.4 Effect Sizes üéØ Best Practice: Always Report Effect Sizes # t-test with effect size auto &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] t_result &lt;- t.test(auto, manual) # Cohen&#39;s d cohens_d &lt;- function(x, y) { n1 &lt;- length(x) n2 &lt;- length(y) s_pooled &lt;- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2)) (mean(x) - mean(y)) / s_pooled } d &lt;- cohens_d(auto, manual) # Complete reporting cat(&quot;=== Complete Statistical Report ===\\n\\n&quot;) #&gt; === Complete Statistical Report === cat(&quot;Descriptives:\\n&quot;) #&gt; Descriptives: cat(&quot; Automatic: M =&quot;, round(mean(auto), 2), &quot;, SD =&quot;, round(sd(auto), 2), &quot;, n =&quot;, length(auto), &quot;\\n&quot;) #&gt; Automatic: M = 17.15 , SD = 3.83 , n = 19 cat(&quot; Manual: M =&quot;, round(mean(manual), 2), &quot;, SD =&quot;, round(sd(manual), 2), &quot;, n =&quot;, length(manual), &quot;\\n\\n&quot;) #&gt; Manual: M = 24.39 , SD = 6.17 , n = 13 cat(&quot;Inferential:\\n&quot;) #&gt; Inferential: cat(&quot; t(&quot;, round(t_result$parameter, 1), &quot;) = &quot;, round(t_result$statistic, 2), &quot;\\n&quot;, sep = &quot;&quot;) #&gt; t(18.3) = -3.77 cat(&quot; p =&quot;, format.pval(t_result$p.value, digits = 3), &quot;\\n&quot;) #&gt; p = 0.00137 cat(&quot; 95% CI: [&quot;, round(t_result$conf.int[1], 2), &quot;, &quot;, round(t_result$conf.int[2], 2), &quot;]\\n&quot;, sep = &quot;&quot;) #&gt; 95% CI: [-11.28, -3.21] cat(&quot; Cohen&#39;s d =&quot;, round(d, 2), &quot;\\n&quot;) #&gt; Cohen&#39;s d = -1.48 32.5 Power Analysis üéØ Best Practice: Consider Statistical Power # A priori power analysis (before study) power_result &lt;- power.t.test( delta = 5, # Expected difference sd = 6, # Expected SD sig.level = 0.05, power = 0.80 ) cat(&quot;Required sample size per group:&quot;, ceiling(power_result$n), &quot;\\n&quot;) #&gt; Required sample size per group: 24 # Post-hoc power analysis (after study) power_observed &lt;- power.t.test( n = length(auto), delta = abs(mean(auto) - mean(manual)), sd = sd(c(auto, manual)), sig.level = 0.05 ) cat(&quot;Observed power:&quot;, round(power_observed$power, 2), &quot;\\n&quot;) #&gt; Observed power: 0.95 # Sensitivity analysis cat(&quot;\\nDetectable effect sizes with 80% power:\\n&quot;) #&gt; #&gt; Detectable effect sizes with 80% power: for (n in c(10, 20, 30, 50)) { result &lt;- power.t.test(n = n, sd = 6, sig.level = 0.05, power = 0.80) cat(&quot; n =&quot;, n, &quot;: d =&quot;, round(result$delta / 6, 2), &quot;\\n&quot;) } #&gt; n = 10 : d = 1.32 #&gt; n = 20 : d = 0.91 #&gt; n = 30 : d = 0.74 #&gt; n = 50 : d = 0.57 32.6 Reproducible Analysis üéØ Best Practice: Make Analyses Reproducible # Set seed for reproducibility set.seed(42) # Document R version and packages cat(&quot;R version:&quot;, R.version.string, &quot;\\n&quot;) #&gt; R version: R version 4.5.0 (2025-04-11) cat(&quot;Packages:\\n&quot;) #&gt; Packages: cat(&quot; dplyr:&quot;, as.character(packageVersion(&quot;dplyr&quot;)), &quot;\\n&quot;) #&gt; dplyr: 1.1.4 # Save session info # sessionInfo() # Complete analysis function reproducible_t_test &lt;- function(data, formula, seed = NULL) { if (!is.null(seed)) set.seed(seed) # Record context context &lt;- list( date = Sys.time(), r_version = R.version.string, data_rows = nrow(data), seed = seed ) # Perform test result &lt;- t.test(formula, data = data) # Return everything list( result = result, context = context, data_summary = summary(data) ) } # Use it analysis &lt;- reproducible_t_test(mtcars, mpg ~ am, seed = 123) analysis$result #&gt; #&gt; Welch Two Sample t-test #&gt; #&gt; data: mpg by am #&gt; t = -3.7671, df = 18.332, p-value = 0.001374 #&gt; alternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0 #&gt; 95 percent confidence interval: #&gt; -11.280194 -3.209684 #&gt; sample estimates: #&gt; mean in group 0 mean in group 1 #&gt; 17.14737 24.39231 32.7 Common Pitfalls ‚ö†Ô∏è Avoid These Common Mistakes # Pitfall 1: P-hacking (testing until significant) # BAD: Keep testing different variables until p &lt; 0.05 # GOOD: Pre-specify hypotheses # Pitfall 2: HARKing (Hypothesizing After Results Known) # BAD: Claim you predicted a finding you discovered # GOOD: Be transparent about exploratory vs confirmatory # Pitfall 3: Not checking assumptions model &lt;- lm(mpg ~ hp, data = mtcars) # BAD: Trust results without checking # GOOD: Check diagnostics plot(model) # Pitfall 4: Confusing significance with importance # p &lt; 0.05 doesn&#39;t mean effect is large or meaningful # Always report effect sizes # Pitfall 5: Ignoring multiple comparisons # BAD: Do 20 t-tests, report any p &lt; 0.05 # GOOD: Adjust for multiple testing # Pitfall 6: Treating p = 0.051 differently than p = 0.049 # BAD: Arbitrary cutoffs # GOOD: Report actual p-values and confidence intervals 32.8 Reporting Results üéØ Best Practice: Complete Reporting Template report_t_test &lt;- function(x, y, test_name = &quot;t-test&quot;) { # Perform test result &lt;- t.test(x, y) # Calculate effect size n1 &lt;- length(x) n2 &lt;- length(y) s_pooled &lt;- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2)) d &lt;- (mean(x) - mean(y)) / s_pooled # Format report cat(&quot;======================\\n&quot;) cat(test_name, &quot;\\n&quot;) cat(&quot;======================\\n\\n&quot;) cat(&quot;Sample sizes:\\n&quot;) cat(&quot; Group 1: n =&quot;, n1, &quot;\\n&quot;) cat(&quot; Group 2: n =&quot;, n2, &quot;\\n\\n&quot;) cat(&quot;Descriptive statistics:\\n&quot;) cat(&quot; Group 1: M =&quot;, round(mean(x), 2), &quot;, SD =&quot;, round(sd(x), 2), &quot;\\n&quot;) cat(&quot; Group 2: M =&quot;, round(mean(y), 2), &quot;, SD =&quot;, round(sd(y), 2), &quot;\\n&quot;) cat(&quot; Difference: M =&quot;, round(mean(x) - mean(y), 2), &quot;\\n\\n&quot;) cat(&quot;Inferential statistics:\\n&quot;) cat(&quot; t(&quot;, round(result$parameter, 1), &quot;) = &quot;, round(result$statistic, 2), &quot;\\n&quot;, sep = &quot;&quot;) cat(&quot; p-value:&quot;, format.pval(result$p.value, digits = 3), &quot;\\n&quot;) cat(&quot; 95% CI: [&quot;, round(result$conf.int[1], 2), &quot;, &quot;, round(result$conf.int[2], 2), &quot;]\\n&quot;, sep = &quot;&quot;) cat(&quot; Cohen&#39;s d =&quot;, round(d, 2)) if (abs(d) &lt; 0.2) cat(&quot; (negligible)&quot;) else if (abs(d) &lt; 0.5) cat(&quot; (small)&quot;) else if (abs(d) &lt; 0.8) cat(&quot; (medium)&quot;) else cat(&quot; (large)&quot;) cat(&quot;\\n\\nInterpretation:\\n&quot;) if (result$p.value &lt; 0.05) { cat(&quot; Statistically significant difference (p &lt; 0.05)\\n&quot;) } else { cat(&quot; No statistically significant difference (p &gt;= 0.05)\\n&quot;) } cat(&quot; Effect size is&quot;, ifelse(abs(d) &lt; 0.5, &quot;small&quot;, &quot;moderate to large&quot;), &quot;\\n&quot;) invisible(list(result = result, effect_size = d)) } # Use it auto &lt;- mtcars$mpg[mtcars$am == 0] manual &lt;- mtcars$mpg[mtcars$am == 1] report_t_test(auto, manual, &quot;Transmission Type Comparison&quot;) #&gt; ====================== #&gt; Transmission Type Comparison #&gt; ====================== #&gt; #&gt; Sample sizes: #&gt; Group 1: n = 19 #&gt; Group 2: n = 13 #&gt; #&gt; Descriptive statistics: #&gt; Group 1: M = 17.15 , SD = 3.83 #&gt; Group 2: M = 24.39 , SD = 6.17 #&gt; Difference: M = -7.24 #&gt; #&gt; Inferential statistics: #&gt; t(18.3) = -3.77 #&gt; p-value: 0.00137 #&gt; 95% CI: [-11.28, -3.21] #&gt; Cohen&#39;s d = -1.48 (large) #&gt; #&gt; Interpretation: #&gt; Statistically significant difference (p &lt; 0.05) #&gt; Effect size is moderate to large 32.9 Checklist üéØ Pre-Analysis Checklist Before running any statistical test: Check sample sizes (adequate power?) Check for missing data Check assumptions Independence Normality (if required) Equal variances (if required) Pre-specify hypotheses Determine if multiple testing correction needed Set random seed for reproducibility After running test: Check diagnostics Calculate effect sizes Create visualizations Report completely: Descriptive statistics Test statistic and df P-value Confidence interval Effect size Interpret in context Note limitations # Example checklist function analysis_checklist &lt;- function(data, dv, iv) { cat(&quot;=== Analysis Checklist ===\\n\\n&quot;) # Sample size n &lt;- nrow(data) cat(&quot;‚úì Sample size:&quot;, n, &quot;\\n&quot;) if (n &lt; 30) cat(&quot; ‚ö† Small sample size\\n&quot;) # Missing data n_missing &lt;- sum(!complete.cases(data)) cat(&quot;‚úì Missing data:&quot;, n_missing, &quot;cases\\n&quot;) if (n_missing &gt; 0) cat(&quot; ‚ö† Consider handling missing data\\n&quot;) # Assumptions cat(&quot;‚úì Check assumptions:\\n&quot;) cat(&quot; - Independence: Consider study design\\n&quot;) cat(&quot; - Normality: Use shapiro.test() or Q-Q plot\\n&quot;) cat(&quot; - Equal variances: Use var.test()\\n\\n&quot;) cat(&quot;‚úì Analysis ready!\\n&quot;) } analysis_checklist(mtcars, &quot;mpg&quot;, &quot;am&quot;) #&gt; === Analysis Checklist === #&gt; #&gt; ‚úì Sample size: 32 #&gt; ‚úì Missing data: 0 cases #&gt; ‚úì Check assumptions: #&gt; - Independence: Consider study design #&gt; - Normality: Use shapiro.test() or Q-Q plot #&gt; - Equal variances: Use var.test() #&gt; #&gt; ‚úì Analysis ready! 32.10 Summary Key Takeaways: P-values measure evidence - Not truth or importance Adjust for multiple tests - Use Bonferroni, FDR, or Holm Always report effect sizes - Cohen‚Äôs d, R¬≤, etc. Consider power - Before and after study Be reproducible - Set seeds, document versions Check assumptions - Don‚Äôt blindly trust results Report completely - All statistics, not just p-values Reporting Template: # Complete report includes: 1. Sample sizes 2. Descriptive statistics (M, SD) 3. Test statistic and df 4. P-value (exact, not just p &lt; 0.05) 5. Confidence interval 6. Effect size 7. Interpretation in context Best Practices: # ‚úÖ Good Pre-specify hypotheses Check all assumptions Report effect sizes Adjust for multiple testing Use confidence intervals Be transparent about exploratory analyses Set random seeds Document everything # ‚ùå Avoid P-hacking HARKing Treating p = 0.05 as magic threshold Only reporting significant results Ignoring effect sizes Not checking assumptions Cherry-picking results 32.11 Completion Part X Complete! You‚Äôve mastered: - t-tests and common errors - Regression and ANOVA - Statistical best practices - P-values and effect sizes - Multiple testing corrections - Reproducible analysis Ready for: Part XI (File I/O) or other topics! "],["part-xi-file-io.html", "Part XI: File I/O", " Part XI: File I/O "],["reading-data.html", "Chapter 33 Reading Data 33.1 Introduction 33.2 Reading CSV Files 33.3 Error #1: cannot open file 33.4 Error #2: Encoding Issues 33.5 Column Type Problems 33.6 Error #3: One or more parsing failures 33.7 Reading Excel Files 33.8 Error #4: Expecting numeric 33.9 File Paths Best Practices 33.10 Reading Other Formats 33.11 Large Files 33.12 Summary 33.13 Exercises 33.14 Exercise Answers 33.15 Cleanup", " Chapter 33 Reading Data What You‚Äôll Learn: Reading CSV and text files Excel files Common import errors Encoding issues File path problems Data type detection Key Errors Covered: 25+ import errors Difficulty: ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced 33.1 Introduction Reading data is the first step in any analysis: library(readr) library(dplyr) # Reading CSV # data &lt;- read_csv(&quot;file.csv&quot;) But file reading has many pitfalls. Let‚Äôs master them! 33.2 Reading CSV Files üí° Key Insight: Base R vs readr # Base R data1 &lt;- read.csv(&quot;file.csv&quot;) # - Converts strings to factors by default # - Uses row names # - Slower for large files # readr (tidyverse) data2 &lt;- read_csv(&quot;file.csv&quot;) # - Keeps strings as character # - No row names # - Much faster # - Better type guessing # - Progress bar 33.3 Error #1: cannot open file ‚≠ê BEGINNER üìÅ PATH 33.3.1 The Error data &lt;- read_csv(&quot;nonexistent_file.csv&quot;) #&gt; Error: &#39;nonexistent_file.csv&#39; does not exist in current working directory (&#39;/Users/bioguo/Downloads/r_errors_book&#39;). üî¥ ERROR Error: &#39;nonexistent_file.csv&#39; does not exist in current working directory 33.3.2 What It Means File not found - wrong path or filename. 33.3.3 Common Causes # Wrong filename # read_csv(&quot;daat.csv&quot;) # Typo # Wrong directory # read_csv(&quot;data/file.csv&quot;) # data/ doesn&#39;t exist # Case sensitivity (Linux/Mac) # read_csv(&quot;File.csv&quot;) # file is actually &quot;file.csv&quot; 33.3.4 Solutions ‚úÖ SOLUTION 1: Check Working Directory # Check current directory getwd() #&gt; [1] &quot;/Users/bioguo/Downloads/r_errors_book&quot; # List files list.files() #&gt; [1] &quot;_bookdown_CORRECTED.yml&quot; &quot;_bookdown.yml&quot; #&gt; [3] &quot;_output.yml&quot; &quot;{39..51}-chapter.Rmd&quot; #&gt; [5] &quot;01-installation-environment.Rmd&quot; &quot;02-working-directory-paths.Rmd&quot; #&gt; [7] &quot;03-objects-variables.Rmd&quot; &quot;04-type-mismatch.Rmd&quot; #&gt; [9] &quot;05-vectors-recycling.Rmd&quot; &quot;06-na-null-nan-inf.Rmd&quot; #&gt; [11] &quot;07-subscript-dimension.Rmd&quot; &quot;08-dollar-double-bracket.Rmd&quot; #&gt; [13] &quot;09-dataframe-construction.Rmd&quot; &quot;10-column-manipulation.Rmd&quot; #&gt; [15] &quot;11-matrix-operations.Rmd&quot; &quot;12-factor-creation-levels.Rmd&quot; #&gt; [17] &quot;13-factor-operations.Rmd&quot; &quot;14-string-basics.Rmd&quot; #&gt; [19] &quot;15-string-pattern-matching.Rmd&quot; &quot;16-function-creation.Rmd&quot; #&gt; [21] &quot;17-scoping-environments.Rmd&quot; &quot;18-control-flow.Rmd&quot; #&gt; [23] &quot;19-error-handling.Rmd&quot; &quot;20-dplyr-intro.Rmd&quot; #&gt; [25] &quot;21-dplyr-grouping.Rmd&quot; &quot;22-dplyr-joins.Rmd&quot; #&gt; [27] &quot;23-tidyr-intro.Rmd&quot; &quot;24-dplyr-advanced.Rmd&quot; #&gt; [29] &quot;25-dplyr-best-practices.Rmd&quot; &quot;26-ggplot2-intro.Rmd&quot; #&gt; [31] &quot;27-ggplot2-advanced.Rmd&quot; &quot;28-ggplot2-extensions.Rmd&quot; #&gt; [33] &quot;29-ggplot2-troubleshooting.Rmd&quot; &quot;30-statistical-tests.Rmd&quot; #&gt; [35] &quot;31-regression-anova.Rmd&quot; &quot;32-stats-best-practices.Rmd&quot; #&gt; [37] &quot;33-reading-data.Rmd&quot; &quot;34-writing-data.Rmd&quot; #&gt; [39] &quot;35-database-connections.Rmd&quot; &quot;36-apply-family.Rmd&quot; #&gt; [41] &quot;37-purrr-package.Rmd&quot; &quot;38-iteration-best-practices.Rmd&quot; #&gt; [43] &quot;39-package-basics.Rmd&quot; &quot;40-documentation-testing.Rmd&quot; #&gt; [45] &quot;41-package-best-practices.Rmd&quot; &quot;42-profiling.Rmd&quot; #&gt; [47] &quot;43-optimization.Rmd&quot; &quot;44-memory.Rmd&quot; #&gt; [49] &quot;45-parallel.Rmd&quot; &quot;46-advanced-databases.Rmd&quot; #&gt; [51] &quot;47-web-scraping.Rmd&quot; &quot;48-shiny-basics.Rmd&quot; #&gt; [53] &quot;49-advanced-programming.Rmd&quot; &quot;50-production-code.Rmd&quot; #&gt; [55] &quot;51-final-best-practices.Rmd&quot; &quot;52-s3-oop.Rmd&quot; #&gt; [57] &quot;53-r6-classes.Rmd&quot; &quot;53-r6-s4-oop.Rmd&quot; #&gt; [59] &quot;54-nse-metaprogramming.Rmd&quot; &quot;54-s4-system.Rmd&quot; #&gt; [61] &quot;55-metaprogramming.Rmd&quot; &quot;55-rcpp-basics.Rmd&quot; #&gt; [63] &quot;56-function-factories.Rmd&quot; &quot;57-rcpp-integration.Rmd&quot; #&gt; [65] &quot;appendix-A-error-dictionary.Rmd&quot; &quot;book.bib&quot; #&gt; [67] &quot;build_pdf.R&quot; &quot;build.R&quot; #&gt; [69] &quot;chapter-template.Rmd&quot; &quot;docs&quot; #&gt; [71] &quot;images&quot; &quot;index.Rmd&quot; #&gt; [73] &quot;mastering-r-through-errors_files&quot; &quot;mastering-r-through-errors.Rmd&quot; #&gt; [75] &quot;packages.bib&quot; &quot;plot.png&quot; #&gt; [77] &quot;preamble.tex&quot; &quot;README.md&quot; #&gt; [79] &quot;references.Rmd&quot; &quot;style.css&quot; list.files(pattern = &quot;\\\\.csv$&quot;) #&gt; character(0) # Check if file exists file.exists(&quot;mtcars.csv&quot;) #&gt; [1] FALSE # Create example file for demonstration write_csv(mtcars, &quot;mtcars.csv&quot;) # Now read it if (file.exists(&quot;mtcars.csv&quot;)) { data &lt;- read_csv(&quot;mtcars.csv&quot;, show_col_types = FALSE) cat(&quot;Successfully read&quot;, nrow(data), &quot;rows\\n&quot;) } #&gt; Successfully read 32 rows ‚úÖ SOLUTION 2: Use Full Paths # Absolute path (Windows) data &lt;- read_csv(&quot;C:/Users/username/Documents/data.csv&quot;) # Absolute path (Mac/Linux) data &lt;- read_csv(&quot;/home/username/data/file.csv&quot;) # Relative from project root (best with RStudio projects) data &lt;- read_csv(&quot;data/file.csv&quot;) # Use here package for project-relative paths library(here) data &lt;- read_csv(here(&quot;data&quot;, &quot;file.csv&quot;)) ‚úÖ SOLUTION 3: Interactive File Selection # Choose file interactively file_path &lt;- file.choose() data &lt;- read_csv(file_path) # Or with safe checking safe_read_csv &lt;- function(path = NULL) { if (is.null(path)) { path &lt;- file.choose() } if (!file.exists(path)) { stop(&quot;File does not exist: &quot;, path) } read_csv(path) } 33.4 Error #2: Encoding Issues ‚≠ê‚≠ê INTERMEDIATE üî§ ENCODING 33.4.1 The Problem # File with special characters appears garbled data &lt;- read_csv(&quot;international_data.csv&quot;) # Names show as: &quot;M√ºller&quot; ‚Üí &quot;M√É¬ºller&quot; 33.4.2 What Happened Wrong character encoding - file is in different encoding than assumed. 33.4.3 Solutions ‚úÖ SOLUTION 1: Specify Encoding # Common encodings data &lt;- read_csv(&quot;file.csv&quot;, locale = locale(encoding = &quot;UTF-8&quot;)) data &lt;- read_csv(&quot;file.csv&quot;, locale = locale(encoding = &quot;latin1&quot;)) data &lt;- read_csv(&quot;file.csv&quot;, locale = locale(encoding = &quot;Windows-1252&quot;)) # Guess encoding library(readr) guess_encoding(&quot;file.csv&quot;) # Use guessed encoding encoding &lt;- guess_encoding(&quot;file.csv&quot;)$encoding[1] data &lt;- read_csv(&quot;file.csv&quot;, locale = locale(encoding = encoding)) ‚úÖ SOLUTION 2: Handle in readr # readr handles UTF-8 by default data &lt;- read_csv(&quot;file.csv&quot;) # For other encodings data &lt;- read_csv(&quot;file.csv&quot;, locale = locale(encoding = &quot;ISO-8859-1&quot;)) 33.5 Column Type Problems üí° Key Insight: Type Detection # Create sample data sample_data &lt;- tibble( id = 1:5, value = c(&quot;1.5&quot;, &quot;2.3&quot;, &quot;3.7&quot;, &quot;NA&quot;, &quot;5.2&quot;), date = c(&quot;2024-01-01&quot;, &quot;2024-01-02&quot;, &quot;2024-01-03&quot;, &quot;2024-01-04&quot;, &quot;2024-01-05&quot;) ) write_csv(sample_data, &quot;sample.csv&quot;) # Read with automatic type detection data1 &lt;- read_csv(&quot;sample.csv&quot;, show_col_types = FALSE) str(data1) #&gt; spc_tbl_ [5 √ó 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ id : num [1:5] 1 2 3 4 5 #&gt; $ value: num [1:5] 1.5 2.3 3.7 NA 5.2 #&gt; $ date : Date[1:5], format: &quot;2024-01-01&quot; &quot;2024-01-02&quot; ... #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. id = col_double(), #&gt; .. value = col_double(), #&gt; .. date = col_date(format = &quot;&quot;) #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; # Specify column types data2 &lt;- read_csv(&quot;sample.csv&quot;, col_types = cols( id = col_integer(), value = col_double(), date = col_date() )) str(data2) #&gt; spc_tbl_ [5 √ó 3] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ id : int [1:5] 1 2 3 4 5 #&gt; $ value: num [1:5] 1.5 2.3 3.7 NA 5.2 #&gt; $ date : Date[1:5], format: &quot;2024-01-01&quot; &quot;2024-01-02&quot; ... #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. id = col_integer(), #&gt; .. value = col_double(), #&gt; .. date = col_date(format = &quot;&quot;) #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; # Shorthand data3 &lt;- read_csv(&quot;sample.csv&quot;, col_types = &quot;iDd&quot;) # integer, double, date #&gt; Warning: One or more parsing issues, call `problems()` on your data frame for details, #&gt; e.g.: #&gt; dat &lt;- vroom(...) #&gt; problems(dat) 33.6 Error #3: One or more parsing failures ‚≠ê‚≠ê INTERMEDIATE üîß PARSE 33.6.1 The Warning # Create problematic data bad_data &lt;- tibble( id = 1:5, value = c(&quot;1.5&quot;, &quot;2.3&quot;, &quot;not_a_number&quot;, &quot;4.1&quot;, &quot;5.2&quot;) ) write_csv(bad_data, &quot;bad_data.csv&quot;) # Read with type specification data &lt;- read_csv(&quot;bad_data.csv&quot;, col_types = cols(value = col_double()), show_col_types = FALSE) #&gt; Warning: One or more parsing issues, call `problems()` on your data frame for details, #&gt; e.g.: #&gt; dat &lt;- vroom(...) #&gt; problems(dat) ‚ö†Ô∏è WARNING Warning: One or more parsing failures 33.6.2 What It Means Data doesn‚Äôt match expected type. 33.6.3 Solutions ‚úÖ SOLUTION 1: Check Problems # See what failed problems(data) #&gt; # A tibble: 1 √ó 5 #&gt; row col expected actual file #&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 4 2 a double not_a_number /Users/bioguo/Downloads/r_errors_book/bad_d‚Ä¶ # Read as character first data_char &lt;- read_csv(&quot;bad_data.csv&quot;, col_types = cols(value = col_character())) # Manually handle conversion data_clean &lt;- data_char %&gt;% mutate(value_num = as.numeric(value), value_clean = if_else(is.na(value_num), 0, value_num)) #&gt; Warning: There was 1 warning in `mutate()`. #&gt; ‚Ñπ In argument: `value_num = as.numeric(value)`. #&gt; Caused by warning: #&gt; ! NAs introduced by coercion head(data_clean) #&gt; # A tibble: 5 √ó 4 #&gt; id value value_num value_clean #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 1.5 1.5 1.5 #&gt; 2 2 2.3 2.3 2.3 #&gt; 3 3 not_a_number NA 0 #&gt; 4 4 4.1 4.1 4.1 #&gt; 5 5 5.2 5.2 5.2 ‚úÖ SOLUTION 2: Use col_guess() # Let readr guess data_guess &lt;- read_csv(&quot;bad_data.csv&quot;, show_col_types = FALSE) # Check what it guessed spec(data_guess) #&gt; cols( #&gt; id = col_double(), #&gt; value = col_character() #&gt; ) 33.7 Reading Excel Files üí° Key Insight: readxl Package library(readxl) # Create example Excel file library(writexl) write_xlsx(list(Sheet1 = mtcars), &quot;example.xlsx&quot;) # Read Excel data &lt;- read_excel(&quot;example.xlsx&quot;) head(data) #&gt; # A tibble: 6 √ó 12 #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 6 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 6 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 6 #&gt; 5 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 8 #&gt; 6 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 6 # Specify sheet data &lt;- read_excel(&quot;example.xlsx&quot;, sheet = &quot;Sheet1&quot;) # Or by number data &lt;- read_excel(&quot;example.xlsx&quot;, sheet = 1) # List sheets excel_sheets(&quot;example.xlsx&quot;) #&gt; [1] &quot;Sheet1&quot; # Read specific range data &lt;- read_excel(&quot;example.xlsx&quot;, range = &quot;A1:D10&quot;) # Skip rows data &lt;- read_excel(&quot;example.xlsx&quot;, skip = 2) # Specify column types data &lt;- read_excel(&quot;example.xlsx&quot;, col_types = c(&quot;numeric&quot;, &quot;text&quot;, &quot;date&quot;)) #&gt; Error: Sheet 1 has 12 columns, but `col_types` has length 3. 33.8 Error #4: Expecting numeric ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 33.8.1 The Error # Excel file with mixed types in column data &lt;- read_excel(&quot;mixed_types.xlsx&quot;, col_types = &quot;numeric&quot;) üî¥ WARNING Warning: Expecting numeric in A2 / R2C1: got &#39;text&#39; 33.8.2 Solutions ‚úÖ SOLUTION: Read as Text First # Read everything as text data &lt;- read_excel(&quot;file.xlsx&quot;, col_types = &quot;text&quot;) # Then convert as needed data_clean &lt;- data %&gt;% mutate( numeric_col = as.numeric(numeric_col), date_col = as.Date(date_col) ) 33.9 File Paths Best Practices üéØ Best Practice: Portable File Paths # ‚ùå Bad: Absolute paths read_csv(&quot;C:/Users/John/Documents/data.csv&quot;) # ‚ùå Bad: Backslashes (Windows only) read_csv(&quot;data\\\\file.csv&quot;) # ‚úÖ Good: Forward slashes (cross-platform) read_csv(&quot;data/file.csv&quot;) # ‚úÖ Better: here package library(here) read_csv(here(&quot;data&quot;, &quot;file.csv&quot;)) # ‚úÖ Best: RStudio projects + here # In project root: read_csv(here(&quot;data&quot;, &quot;raw&quot;, &quot;file.csv&quot;)) # Check paths here() # Project root here(&quot;data&quot;, &quot;file.csv&quot;) # Build path file.exists(here(&quot;data&quot;)) # Check if exists 33.10 Reading Other Formats üí° Key Insight: Format-Specific Packages # SPSS, SAS, Stata library(haven) data &lt;- read_spss(&quot;file.sav&quot;) data &lt;- read_sas(&quot;file.sas7bdat&quot;) data &lt;- read_stata(&quot;file.dta&quot;) # JSON library(jsonlite) data &lt;- fromJSON(&quot;file.json&quot;) # XML library(xml2) doc &lt;- read_xml(&quot;file.xml&quot;) # Fixed-width files data &lt;- read_fwf(&quot;file.txt&quot;, fwf_widths(c(10, 8, 5))) # Delimited by other characters data &lt;- read_delim(&quot;file.txt&quot;, delim = &quot;|&quot;) data &lt;- read_tsv(&quot;file.txt&quot;) # Tab-separated 33.11 Large Files üéØ Best Practice: Handling Large Files # Read in chunks library(readr) # Specify rows to read data_sample &lt;- read_csv(&quot;large_file.csv&quot;, n_max = 1000) # Read columns selectively data &lt;- read_csv(&quot;large_file.csv&quot;, col_select = c(id, value, date)) # Use data.table for speed library(data.table) data &lt;- fread(&quot;large_file.csv&quot;) # Use vroom for very large files library(vroom) data &lt;- vroom(&quot;large_file.csv&quot;) # Read in chunks with callback library(readr) chunk_size &lt;- 10000 read_csv_chunked(&quot;large_file.csv&quot;, callback = DataFrameCallback$new(function(chunk, pos) { # Process chunk processed &lt;- chunk %&gt;% filter(value &gt; 0) # Return to accumulate processed }), chunk_size = chunk_size) 33.12 Summary Key Takeaways: Check file exists - Use file.exists() Use readr, not base R - Faster and better Specify encoding - When dealing with international characters Check column types - Use col_types or read problems() Use here package - For portable paths Handle large files - Read in chunks or use data.table Excel with readxl - Specify sheets and ranges Quick Reference: Error Cause Fix cannot open file Wrong path Check getwd(), use here() Encoding garbled Wrong encoding Use locale(encoding = ‚Ä¶) Parsing failures Type mismatch Check problems(), read as text Sheet not found Wrong sheet name Use excel_sheets() Reading Functions: # CSV/text read_csv(&quot;file.csv&quot;) # readr read_csv2(&quot;file.csv&quot;) # European format (;) read_tsv(&quot;file.txt&quot;) # Tab-separated read_delim(&quot;file.txt&quot;, &quot;|&quot;) # Custom delimiter # Excel library(readxl) read_excel(&quot;file.xlsx&quot;) read_excel(&quot;file.xlsx&quot;, sheet = 2) read_excel(&quot;file.xlsx&quot;, range = &quot;A1:D10&quot;) # Other formats library(haven) read_spss(&quot;file.sav&quot;) read_sas(&quot;file.sas7bdat&quot;) read_stata(&quot;file.dta&quot;) # JSON library(jsonlite) fromJSON(&quot;file.json&quot;) Best Practices: # ‚úÖ Good Use here() for paths Specify col_types for reliability Check file.exists() before reading Use read_csv() not read.csv() Handle encoding explicitly Read large files in chunks # ‚ùå Avoid Absolute paths Assuming default encoding Ignoring parsing warnings Reading entire large files Using read.csv() for new code 33.13 Exercises üìù Exercise 1: Safe File Reader Write safe_read_csv() that: 1. Checks if file exists 2. Handles errors gracefully 3. Reports file info 4. Returns data or informative error üìù Exercise 2: Excel Multi-Sheet Reader Write function to: 1. Read all sheets from Excel file 2. Return named list of data frames 3. Handle empty sheets 4. Report sheet names and dimensions üìù Exercise 3: Data Inspector Create inspect_file() that: 1. Checks encoding 2. Detects delimiter 3. Previews first few rows 4. Reports column types 5. Identifies problems 33.14 Exercise Answers Click to see answers Exercise 1: safe_read_csv &lt;- function(path, ...) { # Check file exists if (!file.exists(path)) { stop(&quot;File does not exist: &quot;, path) } # Get file info info &lt;- file.info(path) cat(&quot;File:&quot;, basename(path), &quot;\\n&quot;) cat(&quot;Size:&quot;, round(info$size / 1024, 2), &quot;KB\\n&quot;) cat(&quot;Modified:&quot;, format(info$mtime, &quot;%Y-%m-%d %H:%M&quot;), &quot;\\n\\n&quot;) # Try to read tryCatch({ data &lt;- read_csv(path, ..., show_col_types = FALSE) cat(&quot;Successfully read:\\n&quot;) cat(&quot; Rows:&quot;, nrow(data), &quot;\\n&quot;) cat(&quot; Columns:&quot;, ncol(data), &quot;\\n&quot;) cat(&quot; Column names:&quot;, paste(names(data), collapse = &quot;, &quot;), &quot;\\n&quot;) # Check for problems probs &lt;- problems(data) if (nrow(probs) &gt; 0) { warning(&quot;Found &quot;, nrow(probs), &quot; parsing issues&quot;) print(probs) } return(data) }, error = function(e) { stop(&quot;Failed to read file: &quot;, e$message) }) } # Test write_csv(mtcars, &quot;test.csv&quot;) data &lt;- safe_read_csv(&quot;test.csv&quot;) #&gt; File: test.csv #&gt; Size: 1.32 KB #&gt; Modified: 2025-10-25 16:53 #&gt; #&gt; Successfully read: #&gt; Rows: 32 #&gt; Columns: 12 #&gt; Column names: mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb, cyl_factor Exercise 2: library(readxl) read_all_sheets &lt;- function(path, ...) { # Check file exists if (!file.exists(path)) { stop(&quot;File does not exist: &quot;, path) } # Get sheet names sheets &lt;- excel_sheets(path) cat(&quot;Reading Excel file:&quot;, basename(path), &quot;\\n&quot;) cat(&quot;Sheets found:&quot;, length(sheets), &quot;\\n\\n&quot;) # Read all sheets result &lt;- list() for (sheet in sheets) { cat(&quot;Reading sheet:&quot;, sheet, &quot;... &quot;) tryCatch({ data &lt;- read_excel(path, sheet = sheet, ...) # Check if empty if (nrow(data) == 0) { cat(&quot;EMPTY\\n&quot;) result[[sheet]] &lt;- NULL } else { cat(&quot;OK (&quot;, nrow(data), &quot; rows, &quot;, ncol(data), &quot; cols)\\n&quot;, sep = &quot;&quot;) result[[sheet]] &lt;- data } }, error = function(e) { cat(&quot;ERROR:&quot;, e$message, &quot;\\n&quot;) result[[sheet]] &lt;- NULL }) } cat(&quot;\\nSuccessfully read&quot;, length(result), &quot;sheets\\n&quot;) return(result) } # Test library(writexl) write_xlsx(list( Cars = mtcars[1:10, ], Iris = iris[1:10, ], Empty = data.frame() ), &quot;multi_sheet.xlsx&quot;) all_data &lt;- read_all_sheets(&quot;multi_sheet.xlsx&quot;) #&gt; Reading Excel file: multi_sheet.xlsx #&gt; Sheets found: 3 #&gt; #&gt; Reading sheet: Cars ... OK (10 rows, 12 cols) #&gt; Reading sheet: Iris ... OK (10 rows, 5 cols) #&gt; Reading sheet: Empty ... EMPTY #&gt; #&gt; Successfully read 2 sheets names(all_data) #&gt; [1] &quot;Cars&quot; &quot;Iris&quot; Exercise 3: inspect_file &lt;- function(path, n_preview = 5) { cat(&quot;=== File Inspection ===\\n\\n&quot;) # Check exists if (!file.exists(path)) { stop(&quot;File does not exist: &quot;, path) } # File info info &lt;- file.info(path) cat(&quot;File:&quot;, path, &quot;\\n&quot;) cat(&quot;Size:&quot;, round(info$size / 1024, 2), &quot;KB\\n&quot;) cat(&quot;Modified:&quot;, format(info$mtime, &quot;%Y-%m-%d %H:%M&quot;), &quot;\\n\\n&quot;) # Guess encoding cat(&quot;Encoding:\\n&quot;) enc &lt;- guess_encoding(path, n_max = 1000) print(enc) cat(&quot;\\n&quot;) # Try to detect structure cat(&quot;Structure Detection:\\n&quot;) # Read first few lines lines &lt;- readLines(path, n = 10) # Detect delimiter delims &lt;- c(&quot;,&quot;, &quot;;&quot;, &quot;\\t&quot;, &quot;|&quot;) delim_counts &lt;- sapply(delims, function(d) { sum(grepl(d, lines[1], fixed = TRUE)) }) likely_delim &lt;- delims[which.max(delim_counts)] cat(&quot;Likely delimiter:&quot;, switch(likely_delim, &quot;,&quot; = &quot;comma&quot;, &quot;;&quot; = &quot;semicolon&quot;, &quot;\\t&quot; = &quot;tab&quot;, &quot;|&quot; = &quot;pipe&quot;), &quot;\\n\\n&quot;) # Preview cat(&quot;Preview (first&quot;, n_preview, &quot;lines):\\n&quot;) cat(paste(head(lines, n_preview), collapse = &quot;\\n&quot;), &quot;\\n\\n&quot;) # Try to read cat(&quot;Reading data...\\n&quot;) data &lt;- read_csv(path, show_col_types = FALSE, n_max = 100) cat(&quot;Dimensions:&quot;, nrow(data), &quot;rows (preview) x&quot;, ncol(data), &quot;columns\\n\\n&quot;) cat(&quot;Column types:\\n&quot;) print(spec(data)) # Check for problems probs &lt;- problems(data) if (nrow(probs) &gt; 0) { cat(&quot;\\nProblems found:\\n&quot;) print(probs) } else { cat(&quot;\\nNo parsing problems detected\\n&quot;) } invisible(data) } # Test write_csv(mtcars, &quot;inspect_test.csv&quot;) inspect_file(&quot;inspect_test.csv&quot;) #&gt; === File Inspection === #&gt; #&gt; File: inspect_test.csv #&gt; Size: 1.32 KB #&gt; Modified: 2025-10-25 16:53 #&gt; #&gt; Encoding: #&gt; # A tibble: 1 √ó 2 #&gt; encoding confidence #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 ASCII 1 #&gt; #&gt; Structure Detection: #&gt; Likely delimiter: comma #&gt; #&gt; Preview (first 5 lines): #&gt; mpg,cyl,disp,hp,drat,wt,qsec,vs,am,gear,carb,cyl_factor #&gt; 21,6,160,110,3.9,2.62,16.46,0,1,4,4,6 #&gt; 21,6,160,110,3.9,2.875,17.02,0,1,4,4,6 #&gt; 22.8,4,108,93,3.85,2.32,18.61,1,1,4,1,4 #&gt; 21.4,6,258,110,3.08,3.215,19.44,1,0,3,1,6 #&gt; #&gt; Reading data... #&gt; Dimensions: 32 rows (preview) x 12 columns #&gt; #&gt; Column types: #&gt; cols( #&gt; mpg = col_double(), #&gt; cyl = col_double(), #&gt; disp = col_double(), #&gt; hp = col_double(), #&gt; drat = col_double(), #&gt; wt = col_double(), #&gt; qsec = col_double(), #&gt; vs = col_double(), #&gt; am = col_double(), #&gt; gear = col_double(), #&gt; carb = col_double(), #&gt; cyl_factor = col_double() #&gt; ) #&gt; #&gt; No parsing problems detected 33.15 Cleanup "],["writing-data.html", "Chapter 34 Writing Data 34.1 Introduction 34.2 Writing CSV Files 34.3 Error #1: cannot open the connection 34.4 Writing Options 34.5 Writing Excel Files 34.6 Error #2: File Permission Denied 34.7 Preserving Data Types 34.8 Large Data Export 34.9 R-Specific Formats 34.10 Error #3: Overwriting Files 34.11 Format Comparison 34.12 Summary 34.13 Cleanup", " Chapter 34 Writing Data What You‚Äôll Learn: Writing CSV and text files Excel export Common export errors File permissions Data serialization Format preservation Key Errors Covered: 18+ export errors Difficulty: ‚≠ê‚≠ê Intermediate 34.1 Introduction Writing data is just as important as reading: library(readr) library(dplyr) # Writing CSV # write_csv(data, &quot;output.csv&quot;) 34.2 Writing CSV Files üí° Key Insight: Base R vs readr # Create sample data data &lt;- mtcars[1:5, 1:5] # Base R write.csv(data, &quot;base_output.csv&quot;) # - Adds row names by default # - Quotes strings # - Slower # readr write_csv(data, &quot;readr_output.csv&quot;) # - No row names # - Only quotes when needed # - Faster # - Better handling of special values # Compare cat(&quot;Base R file:\\n&quot;) #&gt; Base R file: cat(paste(head(readLines(&quot;base_output.csv&quot;), 3), collapse = &quot;\\n&quot;)) #&gt; &quot;&quot;,&quot;mpg&quot;,&quot;cyl&quot;,&quot;disp&quot;,&quot;hp&quot;,&quot;drat&quot; #&gt; &quot;Mazda RX4&quot;,21,6,160,110,3.9 #&gt; &quot;Mazda RX4 Wag&quot;,21,6,160,110,3.9 cat(&quot;\\n\\nreadr file:\\n&quot;) #&gt; #&gt; #&gt; readr file: cat(paste(head(readLines(&quot;readr_output.csv&quot;), 3), collapse = &quot;\\n&quot;)) #&gt; mpg,cyl,disp,hp,drat #&gt; 21,6,160,110,3.9 #&gt; 21,6,160,110,3.9 34.3 Error #1: cannot open the connection ‚≠ê BEGINNER üìÅ PATH 34.3.1 The Error # Try to write to non-existent directory write_csv(mtcars, &quot;nonexistent_dir/file.csv&quot;) #&gt; Error: Cannot open file for writing: #&gt; * &#39;nonexistent_dir/file.csv&#39; üî¥ ERROR Error: Cannot open file for writing: &#39;nonexistent_dir/file.csv&#39; 34.3.2 What It Means Directory doesn‚Äôt exist or no write permission. 34.3.3 Solutions ‚úÖ SOLUTION 1: Create Directory First # Check if directory exists output_dir &lt;- &quot;output&quot; if (!dir.exists(output_dir)) { dir.create(output_dir, recursive = TRUE) cat(&quot;Created directory:&quot;, output_dir, &quot;\\n&quot;) } #&gt; Created directory: output # Now write write_csv(mtcars, file.path(output_dir, &quot;data.csv&quot;)) cat(&quot;File written successfully\\n&quot;) #&gt; File written successfully ‚úÖ SOLUTION 2: Safe Write Function safe_write_csv &lt;- function(data, path, ...) { # Get directory dir_path &lt;- dirname(path) # Create if doesn&#39;t exist if (!dir.exists(dir_path)) { dir.create(dir_path, recursive = TRUE) message(&quot;Created directory: &quot;, dir_path) } # Check write permission if (!file.access(dir_path, mode = 2) == 0) { stop(&quot;No write permission for directory: &quot;, dir_path) } # Write file write_csv(data, path, ...) # Verify if (file.exists(path)) { message(&quot;Successfully wrote &quot;, nrow(data), &quot; rows to &quot;, path) } else { stop(&quot;File was not created&quot;) } invisible(path) } # Test safe_write_csv(mtcars, &quot;test_output/cars.csv&quot;) #&gt; Created directory: test_output #&gt; Successfully wrote 32 rows to test_output/cars.csv 34.4 Writing Options üí° Key Insight: Write Options # Control output format write_csv(mtcars, &quot;formatted.csv&quot;, na = &quot;MISSING&quot;, # How to write NAs quote = &quot;all&quot;) # Quote all fields # Append to existing file write_csv(mtcars[1:5, ], &quot;append_test.csv&quot;) write_csv(mtcars[6:10, ], &quot;append_test.csv&quot;, append = TRUE) cat(&quot;Lines in file:&quot;, length(readLines(&quot;append_test.csv&quot;)), &quot;\\n&quot;) #&gt; Lines in file: 11 # Write with semicolon delimiter (European) write_csv2(mtcars, &quot;european.csv&quot;) # Custom delimiter write_delim(mtcars, &quot;pipe_delim.txt&quot;, delim = &quot;|&quot;) # Tab-separated write_tsv(mtcars, &quot;tab_separated.txt&quot;) 34.5 Writing Excel Files üí° Key Insight: writexl Package library(writexl) # Single sheet write_xlsx(mtcars, &quot;cars.xlsx&quot;) # Multiple sheets write_xlsx( list( Cars = mtcars, Iris = iris, Summary = data.frame( Dataset = c(&quot;mtcars&quot;, &quot;iris&quot;), Rows = c(nrow(mtcars), nrow(iris)) ) ), &quot;multi_sheet.xlsx&quot; ) # Verify library(readxl) excel_sheets(&quot;multi_sheet.xlsx&quot;) #&gt; [1] &quot;Cars&quot; &quot;Iris&quot; &quot;Summary&quot; 34.6 Error #2: File Permission Denied ‚≠ê‚≠ê INTERMEDIATE üíª SYSTEM 34.6.1 The Problem # File is open in Excel or locked write_csv(data, &quot;open_file.csv&quot;) # Error: Permission denied 34.6.2 Solutions ‚úÖ SOLUTION 1: Check File Access check_file_writable &lt;- function(path) { # Check if file exists and is writable if (file.exists(path)) { if (file.access(path, mode = 2) == 0) { cat(&quot;File is writable\\n&quot;) return(TRUE) } else { warning(&quot;File exists but is not writable (may be open)&quot;) return(FALSE) } } else { # Check if directory is writable dir_path &lt;- dirname(path) if (file.access(dir_path, mode = 2) == 0) { cat(&quot;Directory is writable\\n&quot;) return(TRUE) } else { warning(&quot;No write permission for directory&quot;) return(FALSE) } } } # Test check_file_writable(&quot;test.csv&quot;) #&gt; Directory is writable #&gt; [1] TRUE ‚úÖ SOLUTION 2: Use Temporary File # Write to temp file first temp_file &lt;- tempfile(fileext = &quot;.csv&quot;) write_csv(mtcars, temp_file) # Then copy/move to destination final_path &lt;- &quot;output/final.csv&quot; if (!dir.exists(&quot;output&quot;)) dir.create(&quot;output&quot;) file.copy(temp_file, final_path, overwrite = TRUE) #&gt; [1] TRUE cat(&quot;File written via temporary location\\n&quot;) #&gt; File written via temporary location 34.7 Preserving Data Types üéØ Best Practice: Preserve Types library(lubridate) # Create data with various types complex_data &lt;- tibble( id = 1:3, name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;), value = c(1.5, 2.3, 3.7), date = ymd(&quot;2024-01-01&quot;) + days(0:2), logical = c(TRUE, FALSE, TRUE), factor_col = factor(c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) ) # CSV loses some type info write_csv(complex_data, &quot;types_csv.csv&quot;) from_csv &lt;- read_csv(&quot;types_csv.csv&quot;, show_col_types = FALSE) str(from_csv) #&gt; spc_tbl_ [3 √ó 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ id : num [1:3] 1 2 3 #&gt; $ name : chr [1:3] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; #&gt; $ value : num [1:3] 1.5 2.3 3.7 #&gt; $ date : Date[1:3], format: &quot;2024-01-01&quot; &quot;2024-01-02&quot; ... #&gt; $ logical : logi [1:3] TRUE FALSE TRUE #&gt; $ factor_col: chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. id = col_double(), #&gt; .. name = col_character(), #&gt; .. value = col_double(), #&gt; .. date = col_date(format = &quot;&quot;), #&gt; .. logical = col_logical(), #&gt; .. factor_col = col_character() #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; # RDS preserves everything saveRDS(complex_data, &quot;types_rds.rds&quot;) from_rds &lt;- readRDS(&quot;types_rds.rds&quot;) str(from_rds) #&gt; tibble [3 √ó 6] (S3: tbl_df/tbl/data.frame) #&gt; $ id : int [1:3] 1 2 3 #&gt; $ name : chr [1:3] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; #&gt; $ value : num [1:3] 1.5 2.3 3.7 #&gt; $ date : Date[1:3], format: &quot;2024-01-01&quot; &quot;2024-01-02&quot; ... #&gt; $ logical : logi [1:3] TRUE FALSE TRUE #&gt; $ factor_col: Factor w/ 3 levels &quot;A&quot;,&quot;B&quot;,&quot;C&quot;: 1 2 3 # Excel preserves some types write_xlsx(complex_data, &quot;types_excel.xlsx&quot;) from_excel &lt;- read_excel(&quot;types_excel.xlsx&quot;) str(from_excel) #&gt; tibble [3 √ó 6] (S3: tbl_df/tbl/data.frame) #&gt; $ id : num [1:3] 1 2 3 #&gt; $ name : chr [1:3] &quot;Alice&quot; &quot;Bob&quot; &quot;Charlie&quot; #&gt; $ value : num [1:3] 1.5 2.3 3.7 #&gt; $ date : POSIXct[1:3], format: &quot;2024-01-01&quot; &quot;2024-01-02&quot; ... #&gt; $ logical : logi [1:3] TRUE FALSE TRUE #&gt; $ factor_col: chr [1:3] &quot;A&quot; &quot;B&quot; &quot;C&quot; 34.8 Large Data Export üéØ Best Practice: Writing Large Files # For very large data library(data.table) fwrite(large_data, &quot;large_file.csv&quot;) # Write in chunks write_csv_chunked &lt;- function(data, path, chunk_size = 10000) { n_chunks &lt;- ceiling(nrow(data) / chunk_size) for (i in 1:n_chunks) { start &lt;- (i - 1) * chunk_size + 1 end &lt;- min(i * chunk_size, nrow(data)) chunk &lt;- data[start:end, ] write_csv(chunk, path, append = i &gt; 1, # Append after first chunk col_names = i == 1) # Only write headers first time cat(&quot;Wrote chunk&quot;, i, &quot;of&quot;, n_chunks, &quot;\\n&quot;) } } # Compressed output library(readr) write_csv(data, gzfile(&quot;data.csv.gz&quot;)) 34.9 R-Specific Formats üí° Key Insight: R Binary Formats # RDS - single object saveRDS(mtcars, &quot;mtcars.rds&quot;) cars_rds &lt;- readRDS(&quot;mtcars.rds&quot;) # RData/rda - multiple objects x &lt;- 1:10 y &lt;- &quot;text&quot; save(x, y, mtcars, file = &quot;data.RData&quot;) rm(x, y, mtcars) load(&quot;data.RData&quot;) # Restores objects with original names # Feather - fast, interoperable library(arrow) #&gt; Error in library(arrow): there is no package called &#39;arrow&#39; write_feather(mtcars, &quot;mtcars.feather&quot;) #&gt; Error in write_feather(mtcars, &quot;mtcars.feather&quot;): could not find function &quot;write_feather&quot; cars_feather &lt;- read_feather(&quot;mtcars.feather&quot;) #&gt; Error in read_feather(&quot;mtcars.feather&quot;): could not find function &quot;read_feather&quot; # Parquet - compressed, columnar write_parquet(mtcars, &quot;mtcars.parquet&quot;) #&gt; Error in write_parquet(mtcars, &quot;mtcars.parquet&quot;): could not find function &quot;write_parquet&quot; cars_parquet &lt;- read_parquet(&quot;mtcars.parquet&quot;) #&gt; Error in read_parquet(&quot;mtcars.parquet&quot;): could not find function &quot;read_parquet&quot; 34.10 Error #3: Overwriting Files ‚≠ê BEGINNER ‚ö†Ô∏è SAFETY 34.10.1 The Problem # Accidentally overwrite important file # write_csv(new_data, &quot;important_results.csv&quot;) 34.10.2 Solutions ‚úÖ SOLUTION: Safe Write with Backup safe_write_with_backup &lt;- function(data, path, backup = TRUE, ...) { # If file exists and backup requested if (file.exists(path) &amp;&amp; backup) { # Create backup backup_path &lt;- paste0(path, &quot;.backup.&quot;, format(Sys.time(), &quot;%Y%m%d_%H%M%S&quot;)) file.copy(path, backup_path) message(&quot;Created backup: &quot;, basename(backup_path)) } # Write new file write_csv(data, path, ...) message(&quot;Wrote file: &quot;, path) invisible(path) } # Create test file write_csv(mtcars[1:5, ], &quot;important.csv&quot;) # Safely overwrite safe_write_with_backup(mtcars[1:10, ], &quot;important.csv&quot;) #&gt; Created backup: important.csv.backup.20251025_165343 #&gt; Wrote file: important.csv # Check backups list.files(pattern = &quot;important&quot;) #&gt; [1] &quot;important.csv&quot; #&gt; [2] &quot;important.csv.backup.20251025_165343&quot; 34.11 Format Comparison üéØ Best Practice: Choose Right Format # Compare formats compare_formats &lt;- function(data) { formats &lt;- list( CSV = function() write_csv(data, &quot;test.csv&quot;), RDS = function() saveRDS(data, &quot;test.rds&quot;), Excel = function() write_xlsx(data, &quot;test.xlsx&quot;), Feather = function() write_feather(data, &quot;test.feather&quot;), Parquet = function() write_parquet(data, &quot;test.parquet&quot;) ) results &lt;- data.frame( Format = names(formats), Size_KB = numeric(length(formats)), Time_ms = numeric(length(formats)) ) for (i in seq_along(formats)) { # Time it time &lt;- system.time(formats[[i]]())[&quot;elapsed&quot;] * 1000 # Get size files &lt;- list.files(pattern = &quot;^test\\\\.&quot;) size &lt;- sum(file.info(files)$size) / 1024 results$Size_KB[i] &lt;- round(size, 2) results$Time_ms[i] &lt;- round(time, 2) # Cleanup unlink(files) } results } # Test with mtcars compare_formats(mtcars) #&gt; Error in write_feather(data, &quot;test.feather&quot;): could not find function &quot;write_feather&quot; #&gt; Timing stopped at: 0.001 0 0 34.12 Summary Key Takeaways: Create directories first - Check with dir.exists() Use readr functions - write_csv(), not write.csv() Check permissions - Verify file access Preserve types - Use RDS for R objects Backup important files - Before overwriting Choose right format - CSV for sharing, RDS for R Handle large files - Use data.table or chunks Quick Reference: Format Function Best For CSV write_csv() Sharing, Excel RDS saveRDS() R objects, types Excel write_xlsx() Multiple sheets Feather write_feather() Fast, interoperable Parquet write_parquet() Big data, compressed Writing Functions: # CSV write_csv(data, &quot;file.csv&quot;) write_csv2(data, &quot;european.csv&quot;) # Semicolon write_tsv(data, &quot;file.txt&quot;) # Tab write_delim(data, &quot;file.txt&quot;, &quot;|&quot;) # Excel library(writexl) write_xlsx(data, &quot;file.xlsx&quot;) write_xlsx(list(Sheet1 = data1, Sheet2 = data2), &quot;file.xlsx&quot;) # R formats saveRDS(data, &quot;file.rds&quot;) save(obj1, obj2, file = &quot;file.RData&quot;) # Modern formats library(arrow) write_feather(data, &quot;file.feather&quot;) write_parquet(data, &quot;file.parquet&quot;) Best Practices: # ‚úÖ Good Create directories before writing Check file permissions Use write_csv() not write.csv() Backup before overwriting Choose appropriate format Compress large files Test write with small sample first # ‚ùå Avoid Writing to non-existent directories Overwriting without backup Using write.csv() for new code Writing very large files without chunks Ignoring permission errors 34.13 Cleanup #&gt; [1] &quot;important.csv.backup.20251025_165343&quot; "],["database-connections.html", "Chapter 35 Database Connections 35.1 Introduction 35.2 Database Basics 35.3 SQL Queries 35.4 Error #1: could not connect to server 35.5 Error #2: table ... does not exist 35.6 dplyr with Databases 35.7 Connection Management 35.8 Writing to Databases 35.9 Prepared Statements 35.10 Error #3: columns ... have mismatching types 35.11 Transactions 35.12 Summary 35.13 Completion", " Chapter 35 Database Connections What You‚Äôll Learn: Connecting to databases SQL queries from R Common database errors Connection management Best practices Key Errors Covered: 15+ database errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 35.1 Introduction R connects to databases via DBI and database-specific packages: library(DBI) # Generic connection pattern con &lt;- dbConnect( RSQLite::SQLite(), dbname = &quot;database.db&quot; ) 35.2 Database Basics üí° Key Insight: DBI Package library(DBI) library(RSQLite) #&gt; Warning: package &#39;RSQLite&#39; was built under R version 4.5.1 # Create in-memory SQLite database con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) # Write data to database dbWriteTable(con, &quot;mtcars&quot;, mtcars) dbWriteTable(con, &quot;iris&quot;, iris) # List tables dbListTables(con) #&gt; [1] &quot;iris&quot; &quot;mtcars&quot; # Get table info dbListFields(con, &quot;mtcars&quot;) #&gt; [1] &quot;mpg&quot; &quot;cyl&quot; &quot;disp&quot; &quot;hp&quot; &quot;drat&quot; #&gt; [6] &quot;wt&quot; &quot;qsec&quot; &quot;vs&quot; &quot;am&quot; &quot;gear&quot; #&gt; [11] &quot;carb&quot; &quot;cyl_factor&quot; # Read entire table data &lt;- dbReadTable(con, &quot;mtcars&quot;) head(data, 3) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 6 #&gt; 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 6 #&gt; 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 # Always disconnect when done dbDisconnect(con) 35.3 SQL Queries üí° Key Insight: Running Queries # Reconnect con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;mtcars&quot;, mtcars) # Simple query result &lt;- dbGetQuery(con, &quot;SELECT * FROM mtcars WHERE cyl = 4&quot;) head(result, 3) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; 1 22.8 4 108.0 93 3.85 2.32 18.61 1 1 4 1 4 #&gt; 2 24.4 4 146.7 62 3.69 3.19 20.00 1 0 4 2 4 #&gt; 3 22.8 4 140.8 95 3.92 3.15 22.90 1 0 4 2 4 # Query with parameters (safe from SQL injection) result &lt;- dbGetQuery( con, &quot;SELECT * FROM mtcars WHERE cyl = ? AND mpg &gt; ?&quot;, params = list(4, 25) ) head(result) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; 1 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 4 #&gt; 2 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 4 #&gt; 3 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 4 #&gt; 4 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 4 #&gt; 5 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 4 #&gt; 6 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 4 # Count rows count &lt;- dbGetQuery(con, &quot;SELECT COUNT(*) as n FROM mtcars&quot;) count$n #&gt; [1] 32 # Aggregation summary &lt;- dbGetQuery(con, &quot;SELECT cyl, AVG(mpg) as avg_mpg, COUNT(*) as count FROM mtcars GROUP BY cyl&quot;) summary #&gt; cyl avg_mpg count #&gt; 1 4 26.66364 11 #&gt; 2 6 19.74286 7 #&gt; 3 8 15.10000 14 dbDisconnect(con) 35.4 Error #1: could not connect to server ‚≠ê‚≠ê INTERMEDIATE üîå CONNECTION 35.4.1 The Error # Try to connect to non-existent server con &lt;- dbConnect( RPostgreSQL::PostgreSQL(), host = &quot;nonexistent.server.com&quot;, dbname = &quot;mydb&quot; ) #&gt; Error in (function (cond) : error in evaluating the argument &#39;drv&#39; in selecting a method for function &#39;dbConnect&#39;: there is no package called &#39;RPostgreSQL&#39; üî¥ ERROR Error: could not connect to server 35.4.2 Solutions ‚úÖ SOLUTION: Safe Connection Function safe_db_connect &lt;- function(drv, ..., timeout = 5) { # Try to connect with timeout tryCatch({ con &lt;- dbConnect(drv, ...) # Test connection if (dbIsValid(con)) { message(&quot;Successfully connected to database&quot;) return(con) } else { stop(&quot;Connection established but not valid&quot;) } }, error = function(e) { stop(&quot;Failed to connect: &quot;, e$message, &quot;\\nCheck host, port, credentials, and network&quot;) }) } # Use it con &lt;- safe_db_connect( RSQLite::SQLite(), dbname = &quot;:memory:&quot; ) #&gt; Successfully connected to database dbIsValid(con) #&gt; [1] TRUE dbDisconnect(con) 35.5 Error #2: table ... does not exist ‚≠ê BEGINNER üìä SQL 35.5.1 The Error con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) # Try to query non-existent table dbGetQuery(con, &quot;SELECT * FROM nonexistent_table&quot;) #&gt; Error: no such table: nonexistent_table üî¥ ERROR Error: no such table: nonexistent_table 35.5.2 Solutions ‚úÖ SOLUTION: Check Table Exists con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;mtcars&quot;, mtcars) # Check if table exists table_exists &lt;- function(con, table_name) { table_name %in% dbListTables(con) } # Safe query safe_query &lt;- function(con, sql, table_name = NULL) { # Extract table name from SQL if not provided if (is.null(table_name)) { # Simple extraction (works for basic queries) table_match &lt;- regmatches(sql, regexpr(&quot;FROM\\\\s+(\\\\w+)&quot;, sql, ignore.case = TRUE)) if (length(table_match) &gt; 0) { table_name &lt;- sub(&quot;FROM\\\\s+&quot;, &quot;&quot;, table_match, ignore.case = TRUE) } } # Check table exists if (!is.null(table_name) &amp;&amp; !table_exists(con, table_name)) { stop(&quot;Table &#39;&quot;, table_name, &quot;&#39; does not exist. Available tables: &quot;, paste(dbListTables(con), collapse = &quot;, &quot;)) } # Run query dbGetQuery(con, sql) } # Test head(safe_query(con, &quot;SELECT * FROM mtcars&quot;), 3) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 6 #&gt; 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 6 #&gt; 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 dbDisconnect(con) 35.6 dplyr with Databases üí° Key Insight: Using dplyr with Databases library(dplyr) library(dbplyr) #&gt; Warning: package &#39;dbplyr&#39; was built under R version 4.5.1 con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;mtcars&quot;, mtcars) # Create dplyr table reference cars_tbl &lt;- tbl(con, &quot;mtcars&quot;) # Use dplyr verbs (lazy evaluation) result &lt;- cars_tbl %&gt;% filter(cyl == 4) %&gt;% select(mpg, hp, wt) %&gt;% arrange(desc(mpg)) #&gt; Error in select(., mpg, hp, wt): unused arguments (mpg, hp, wt) # See the SQL that will be generated result %&gt;% show_query() #&gt; Error in UseMethod(&quot;show_query&quot;): no applicable method for &#39;show_query&#39; applied to an object of class &quot;data.frame&quot; # Execute and collect results data &lt;- result %&gt;% collect() head(data) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; 1 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 4 #&gt; 2 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 4 #&gt; 3 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 4 #&gt; 4 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 4 #&gt; 5 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 4 #&gt; 6 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 4 # Or compute and store in database cars_tbl %&gt;% filter(mpg &gt; 20) %&gt;% compute(&quot;efficient_cars&quot;) #&gt; # Source: table&lt;`efficient_cars`&gt; [?? x 12] #&gt; # Database: sqlite 3.50.4 [:memory:] #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 21 6 160 110 3.9 2.62 16.5 0 1 4 4 6 #&gt; 2 21 6 160 110 3.9 2.88 17.0 0 1 4 4 6 #&gt; 3 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 4 #&gt; 4 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 6 #&gt; 5 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 4 #&gt; 6 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 4 #&gt; 7 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 4 #&gt; 8 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 4 #&gt; 9 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 4 #&gt; 10 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 4 #&gt; 11 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 4 #&gt; 12 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 4 #&gt; 13 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 4 #&gt; 14 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 4 dbListTables(con) #&gt; [1] &quot;efficient_cars&quot; &quot;mtcars&quot; &quot;sqlite_stat1&quot; &quot;sqlite_stat4&quot; dbDisconnect(con) 35.7 Connection Management üéØ Best Practice: Manage Connections # Pattern 1: Explicit disconnect con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) # ... do work ... dbDisconnect(con) # Pattern 2: Use on.exit (safer) query_with_cleanup &lt;- function() { con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) on.exit(dbDisconnect(con)) # Always disconnect dbWriteTable(con, &quot;test&quot;, mtcars) return(dbGetQuery(con, &quot;SELECT COUNT(*) FROM test&quot;)) } result &lt;- query_with_cleanup() result #&gt; COUNT(*) #&gt; 1 32 # Pattern 3: Connection pooling (for web apps) # library(pool) # pool &lt;- dbPool(RSQLite::SQLite(), dbname = &quot;:memory:&quot;) # con &lt;- poolCheckout(pool) # # ... use connection ... # poolReturn(con) # poolClose(pool) 35.8 Writing to Databases üí° Key Insight: Writing Data con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) # Write entire data frame dbWriteTable(con, &quot;iris&quot;, iris) # Append to existing table dbWriteTable(con, &quot;iris&quot;, iris[1:10, ], append = TRUE) # Overwrite existing table dbWriteTable(con, &quot;iris&quot;, iris, overwrite = TRUE) # Check row count dbGetQuery(con, &quot;SELECT COUNT(*) as count FROM iris&quot;) #&gt; count #&gt; 1 150 # Insert single row dbExecute(con, &quot;INSERT INTO iris (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species) VALUES (?, ?, ?, ?, ?)&quot;, params = list(5.1, 3.5, 1.4, 0.2, &quot;setosa&quot;) ) #&gt; Error: near &quot;.&quot;: syntax error dbDisconnect(con) 35.9 Prepared Statements üéØ Best Practice: Use Parameters con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;mtcars&quot;, mtcars) # ‚ùå BAD: SQL injection vulnerable user_input &lt;- &quot;4 OR 1=1&quot; # Malicious input # query &lt;- paste0(&quot;SELECT * FROM mtcars WHERE cyl = &quot;, user_input) # DON&#39;T DO THIS! # ‚úÖ GOOD: Parameterized query safe_query_by_cyl &lt;- function(con, cyl_value) { dbGetQuery( con, &quot;SELECT * FROM mtcars WHERE cyl = ?&quot;, params = list(cyl_value) ) } result &lt;- safe_query_by_cyl(con, 4) nrow(result) #&gt; [1] 11 dbDisconnect(con) 35.10 Error #3: columns ... have mismatching types ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 35.10.1 The Problem con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) # Create table with specific types dbExecute(con, &quot;CREATE TABLE test (id INTEGER, value REAL)&quot;) #&gt; [1] 0 # Try to insert wrong type data &lt;- data.frame(id = 1:3, value = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) dbWriteTable(con, &quot;test&quot;, data, append = TRUE) 35.10.2 Solutions ‚úÖ SOLUTION: Match Types # Check table schema dbGetQuery(con, &quot;PRAGMA table_info(test)&quot;) #&gt; cid name type notnull dflt_value pk #&gt; 1 0 id INTEGER 0 NA 0 #&gt; 2 1 value REAL 0 NA 0 # Convert data to match data_correct &lt;- data.frame( id = as.integer(1:3), value = as.numeric(c(1.5, 2.3, 3.7)) ) dbWriteTable(con, &quot;test&quot;, data_correct, append = TRUE) # Verify dbReadTable(con, &quot;test&quot;) #&gt; Warning: Column `value`: mixed type, first seen values of type string, coercing #&gt; other values of type real #&gt; id value #&gt; 1 1 a #&gt; 2 2 b #&gt; 3 3 c #&gt; 4 1 1.5 #&gt; 5 2 2.3 #&gt; 6 3 3.7 dbDisconnect(con) 35.11 Transactions üéØ Best Practice: Use Transactions con &lt;- dbConnect(RSQLite::SQLite(), &quot;:memory:&quot;) dbWriteTable(con, &quot;accounts&quot;, data.frame(id = 1:3, balance = c(100, 200, 150))) # Transaction ensures all-or-nothing safe_transfer &lt;- function(con, from_id, to_id, amount) { # Start transaction dbBegin(con) tryCatch({ # Deduct from sender dbExecute(con, &quot;UPDATE accounts SET balance = balance - ? WHERE id = ?&quot;, params = list(amount, from_id)) # Add to receiver dbExecute(con, &quot;UPDATE accounts SET balance = balance + ? WHERE id = ?&quot;, params = list(amount, to_id)) # Commit if both succeed dbCommit(con) message(&quot;Transfer successful&quot;) }, error = function(e) { # Rollback on error dbRollback(con) stop(&quot;Transfer failed: &quot;, e$message) }) } # Before dbReadTable(con, &quot;accounts&quot;) #&gt; id balance #&gt; 1 1 100 #&gt; 2 2 200 #&gt; 3 3 150 # Transfer safe_transfer(con, from_id = 1, to_id = 2, amount = 50) #&gt; Transfer successful # After dbReadTable(con, &quot;accounts&quot;) #&gt; id balance #&gt; 1 1 50 #&gt; 2 2 250 #&gt; 3 3 150 dbDisconnect(con) 35.12 Summary Key Takeaways: Use DBI package - Standard interface for all databases Always disconnect - Use on.exit() for safety Parameterize queries - Prevent SQL injection Check table exists - Before querying Use dplyr - For familiar syntax Manage connections - Pool for web apps Use transactions - For multiple operations Quick Reference: Function Purpose dbConnect() Connect to database dbDisconnect() Close connection dbListTables() List tables dbReadTable() Read entire table dbWriteTable() Write data frame dbGetQuery() Run SELECT query dbExecute() Run INSERT/UPDATE/DELETE dbBegin/Commit/Rollback() Transactions Database Operations: # Connect library(DBI) con &lt;- dbConnect(RSQLite::SQLite(), &quot;database.db&quot;) # List and inspect dbListTables(con) dbListFields(con, &quot;table_name&quot;) # Read data data &lt;- dbReadTable(con, &quot;table_name&quot;) data &lt;- dbGetQuery(con, &quot;SELECT * FROM table WHERE col = ?&quot;, params = list(value)) # Write data dbWriteTable(con, &quot;table_name&quot;, data_frame) dbExecute(con, &quot;INSERT INTO table VALUES (?, ?)&quot;, params = list(val1, val2)) # dplyr interface library(dplyr) tbl(con, &quot;table_name&quot;) %&gt;% filter(col &gt; 10) %&gt;% collect() # Always disconnect dbDisconnect(con) Best Practices: # ‚úÖ Good Use parameterized queries Always disconnect (use on.exit) Check dbIsValid() before queries Use dplyr for complex operations Use transactions for multiple operations Handle connection errors gracefully # ‚ùå Avoid Building SQL with paste() (SQL injection!) Leaving connections open Assuming table exists Not handling connection errors 35.13 Completion Part XI Complete! You‚Äôve mastered: - Reading data from various formats - Writing data efficiently - Database connections and queries - SQL integration with R - Best practices for data I/O Ready for: Part XII (Dates and Times) or other topics! "],["part-xiii-programming-patterns.html", "Part XIII: Programming Patterns", " Part XIII: Programming Patterns "],["apply-family.html", "Chapter 36 apply Family &amp; Iteration 36.1 Introduction 36.2 apply() - Arrays and Matrices 36.3 Error #1: dim(X) must have positive length 36.4 lapply() - Lists 36.5 sapply() - Simplified 36.6 Error #2: Unexpected Output Type 36.7 mapply() - Multiple Arguments 36.8 tapply() - Grouped Apply 36.9 Common Patterns 36.10 Performance Considerations 36.11 Error #3: Function Not Vectorized 36.12 Alternative: purrr Package 36.13 Summary 36.14 Exercises 36.15 Exercise Answers", " Chapter 36 apply Family &amp; Iteration What You‚Äôll Learn: apply, lapply, sapply, mapply Common iteration errors When to use each function Performance considerations Alternative approaches Key Errors Covered: 20+ iteration errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 36.1 Introduction R‚Äôs apply family provides vectorized operations: # Instead of loops result &lt;- numeric(nrow(mtcars)) for (i in 1:nrow(mtcars)) { result[i] &lt;- mean(as.numeric(mtcars[i, ])) } # Use apply result &lt;- apply(mtcars, 1, mean) #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA head(result) #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; NA NA NA NA #&gt; Hornet Sportabout Valiant #&gt; NA NA Let‚Äôs master the apply family! 36.2 apply() - Arrays and Matrices üí° Key Insight: apply() for Matrices # Create matrix mat &lt;- matrix(1:12, nrow = 3, ncol = 4) mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 # Apply to rows (MARGIN = 1) row_sums &lt;- apply(mat, 1, sum) row_sums #&gt; [1] 22 26 30 # Apply to columns (MARGIN = 2) col_means &lt;- apply(mat, 2, mean) col_means #&gt; [1] 2 5 8 11 # Custom function apply(mat, 1, function(x) max(x) - min(x)) #&gt; [1] 9 9 9 # With additional arguments apply(mat, 2, sum, na.rm = TRUE) #&gt; [1] 6 15 24 33 # Both dimensions apply(mat, c(1, 2), sqrt) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1.000000 2.000000 2.645751 3.162278 #&gt; [2,] 1.414214 2.236068 2.828427 3.316625 #&gt; [3,] 1.732051 2.449490 3.000000 3.464102 36.3 Error #1: dim(X) must have positive length ‚≠ê BEGINNER üî¢ TYPE 36.3.1 The Error # Try apply on vector vec &lt;- 1:10 apply(vec, 1, sum) #&gt; Error in apply(vec, 1, sum): dim(X) must have a positive length üî¥ ERROR Error in apply(vec, 1, sum) : dim(X) must have a positive length 36.3.2 What It Means apply() requires a matrix/array, not a vector. 36.3.3 Solutions ‚úÖ SOLUTION 1: Use lapply() or sapply() # For vectors, use lapply/sapply vec &lt;- 1:10 # Wrong: apply(vec, 1, sqrt) # Right: use sapply sapply(vec, sqrt) #&gt; [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 #&gt; [9] 3.000000 3.162278 # Or vectorized operation sqrt(vec) #&gt; [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 2.828427 #&gt; [9] 3.000000 3.162278 ‚úÖ SOLUTION 2: Convert to Matrix # If you really need apply vec &lt;- 1:10 mat &lt;- matrix(vec, ncol = 1) apply(mat, 1, function(x) x * 2) #&gt; [1] 2 4 6 8 10 12 14 16 18 20 # But this is unnecessary - use vectorization vec * 2 #&gt; [1] 2 4 6 8 10 12 14 16 18 20 36.4 lapply() - Lists üí° Key Insight: lapply() Always Returns List # Create list my_list &lt;- list(a = 1:5, b = 6:10, c = 11:15) # Apply function to each element result &lt;- lapply(my_list, mean) result #&gt; $a #&gt; [1] 3 #&gt; #&gt; $b #&gt; [1] 8 #&gt; #&gt; $c #&gt; [1] 13 # With custom function lapply(my_list, function(x) sum(x^2)) #&gt; $a #&gt; [1] 55 #&gt; #&gt; $b #&gt; [1] 330 #&gt; #&gt; $c #&gt; [1] 855 # On data frame (df is a list of columns) lapply(mtcars[, 1:3], mean) #&gt; $mpg #&gt; [1] 20.09062 #&gt; #&gt; $cyl #&gt; [1] 6.1875 #&gt; #&gt; $disp #&gt; [1] 230.7219 # Extract elements lapply(my_list, `[`, 1:2) #&gt; $a #&gt; [1] 1 2 #&gt; #&gt; $b #&gt; [1] 6 7 #&gt; #&gt; $c #&gt; [1] 11 12 # With multiple arguments lapply(my_list, sum, na.rm = TRUE) #&gt; $a #&gt; [1] 15 #&gt; #&gt; $b #&gt; [1] 40 #&gt; #&gt; $c #&gt; [1] 65 36.5 sapply() - Simplified üí° Key Insight: sapply() Simplifies Output my_list &lt;- list(a = 1:5, b = 6:10, c = 11:15) # lapply returns list lapply(my_list, mean) #&gt; $a #&gt; [1] 3 #&gt; #&gt; $b #&gt; [1] 8 #&gt; #&gt; $c #&gt; [1] 13 # sapply returns vector sapply(my_list, mean) #&gt; a b c #&gt; 3 8 13 # sapply with matrix output sapply(my_list, function(x) c(mean = mean(x), sd = sd(x))) #&gt; a b c #&gt; mean 3.000000 8.000000 13.000000 #&gt; sd 1.581139 1.581139 1.581139 # When can&#39;t simplify, returns list sapply(my_list, summary) # Returns list #&gt; a b c #&gt; Min. 1 6 11 #&gt; 1st Qu. 2 7 12 #&gt; Median 3 8 13 #&gt; Mean 3 8 13 #&gt; 3rd Qu. 4 9 14 #&gt; Max. 5 10 15 36.6 Error #2: Unexpected Output Type ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 36.6.1 The Problem # sapply behavior depends on output result1 &lt;- sapply(1:3, function(x) x) result1 #&gt; [1] 1 2 3 class(result1) # vector #&gt; [1] &quot;integer&quot; result2 &lt;- sapply(1:3, function(x) c(x, x^2)) result2 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 1 4 9 class(result2) # matrix #&gt; [1] &quot;matrix&quot; &quot;array&quot; result3 &lt;- sapply(1:3, function(x) list(x, x^2)) result3 #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 1 4 9 class(result3) # list #&gt; [1] &quot;matrix&quot; &quot;array&quot; 36.6.2 Solutions ‚úÖ SOLUTION 1: Use vapply() for Type Safety # Specify output type result &lt;- vapply(1:3, function(x) x * 2, FUN.VALUE = numeric(1)) result #&gt; [1] 2 4 6 # Will error if output doesn&#39;t match # vapply(1:3, function(x) c(x, x^2), FUN.VALUE = numeric(1)) # For multiple values result &lt;- vapply(1:3, function(x) c(x, x^2), FUN.VALUE = numeric(2)) result #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 1 4 9 ‚úÖ SOLUTION 2: Use lapply() and Post-Process # Always get list, then convert result &lt;- lapply(1:3, function(x) x * 2) unlist(result) #&gt; [1] 2 4 6 # Or use do.call do.call(c, result) #&gt; Error in do.call(c, result): &#39;what&#39; must be a function or character string 36.7 mapply() - Multiple Arguments üí° Key Insight: mapply() for Parallel Iteration # Apply function to multiple vectors in parallel mapply(function(x, y) x + y, x = 1:5, y = 6:10) #&gt; [1] 7 9 11 13 15 # Multiple arguments mapply(rep, x = 1:4, times = 4:1) #&gt; [[1]] #&gt; [1] 1 1 1 1 #&gt; #&gt; [[2]] #&gt; [1] 2 2 2 #&gt; #&gt; [[3]] #&gt; [1] 3 3 #&gt; #&gt; [[4]] #&gt; [1] 4 # With data frames df1 &lt;- data.frame(a = 1:3, b = 4:6) df2 &lt;- data.frame(c = 7:9, d = 10:12) mapply(function(x, y) x + y, df1$a, df2$c) #&gt; [1] 8 10 12 # MoreArgs for constant arguments mapply(function(x, y, z) x + y + z, x = 1:3, y = 4:6, MoreArgs = list(z = 10)) #&gt; [1] 15 17 19 36.8 tapply() - Grouped Apply üí° Key Insight: tapply() for Split-Apply-Combine # Apply function by groups tapply(mtcars$mpg, mtcars$cyl, mean) #&gt; 4 6 8 #&gt; 26.66364 19.74286 15.10000 # Multiple grouping variables tapply(mtcars$mpg, list(Cyl = mtcars$cyl, Gear = mtcars$gear), mean) #&gt; Gear #&gt; Cyl 3 4 5 #&gt; 4 21.50 26.925 28.2 #&gt; 6 19.75 19.750 19.7 #&gt; 8 15.05 NA 15.4 # With custom function tapply(mtcars$mpg, mtcars$cyl, function(x) c(mean = mean(x), sd = sd(x))) #&gt; $`4` #&gt; mean sd #&gt; 26.663636 4.509828 #&gt; #&gt; $`6` #&gt; mean sd #&gt; 19.742857 1.453567 #&gt; #&gt; $`8` #&gt; mean sd #&gt; 15.100000 2.560048 # Like dplyr group_by + summarize library(dplyr) mtcars %&gt;% group_by(cyl) %&gt;% summarize(mean_mpg = mean(mpg)) #&gt; # A tibble: 3 √ó 2 #&gt; cyl mean_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 26.7 #&gt; 2 6 19.7 #&gt; 3 8 15.1 36.9 Common Patterns üéØ Best Practice: Choose Right Function # Pattern 1: Apply to each column of data frame lapply(mtcars[, 1:3], mean) #&gt; $mpg #&gt; [1] 20.09062 #&gt; #&gt; $cyl #&gt; [1] 6.1875 #&gt; #&gt; $disp #&gt; [1] 230.7219 sapply(mtcars[, 1:3], mean) #&gt; mpg cyl disp #&gt; 20.09062 6.18750 230.72188 # Pattern 2: Apply to each row apply(mtcars[, 1:3], 1, sum) #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; 187.0 187.0 134.8 285.4 #&gt; Hornet Sportabout Valiant Duster 360 Merc 240D #&gt; 386.7 249.1 382.3 175.1 #&gt; Merc 230 Merc 280 Merc 280C Merc 450SE #&gt; 167.6 192.8 191.4 300.2 #&gt; Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental #&gt; 301.1 299.0 490.4 478.4 #&gt; Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla #&gt; 462.7 115.1 110.1 109.0 #&gt; Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 #&gt; 145.6 341.5 327.2 371.3 #&gt; Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa #&gt; 427.2 110.3 150.3 129.5 #&gt; Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E #&gt; 374.8 170.7 324.0 146.4 # Pattern 3: Apply with multiple inputs mapply(function(x, y) x / y, x = mtcars$hp, y = mtcars$wt) #&gt; [1] 41.98473 38.26087 40.08621 34.21462 50.87209 30.34682 68.62745 19.43574 #&gt; [9] 30.15873 35.75581 35.75581 44.22604 48.25737 47.61905 39.04762 39.63864 #&gt; [17] 43.03087 30.00000 32.19814 35.42234 39.35091 42.61364 43.66812 63.80208 #&gt; [25] 45.51365 34.10853 42.52336 74.68605 83.28076 63.17690 93.83754 39.20863 # Pattern 4: Apply by groups tapply(mtcars$mpg, mtcars$cyl, mean) #&gt; 4 6 8 #&gt; 26.66364 19.74286 15.10000 # Pattern 5: Nested lists nested &lt;- list( a = list(x = 1:3, y = 4:6), b = list(x = 7:9, y = 10:12) ) # Get all &#39;x&#39; elements lapply(nested, `[[`, &quot;x&quot;) #&gt; $a #&gt; [1] 1 2 3 #&gt; #&gt; $b #&gt; [1] 7 8 9 # Apply to nested structure lapply(nested, function(sublist) { lapply(sublist, mean) }) #&gt; $a #&gt; $a$x #&gt; [1] 2 #&gt; #&gt; $a$y #&gt; [1] 5 #&gt; #&gt; #&gt; $b #&gt; $b$x #&gt; [1] 8 #&gt; #&gt; $b$y #&gt; [1] 11 36.10 Performance Considerations üéØ Best Practice: Vectorize When Possible # Compare performance n &lt;- 10000 # Loop (slow) system.time({ result &lt;- numeric(n) for (i in 1:n) { result[i] &lt;- sqrt(i) } }) #&gt; user system elapsed #&gt; 0.003 0.000 0.003 # sapply (better) system.time({ result &lt;- sapply(1:n, sqrt) }) #&gt; user system elapsed #&gt; 0.002 0.000 0.003 # Vectorized (best) system.time({ result &lt;- sqrt(1:n) }) #&gt; user system elapsed #&gt; 0 0 0 # When apply family is appropriate df &lt;- data.frame(matrix(rnorm(1000), ncol = 10)) # Row-wise operations (apply is good) system.time({ apply(df, 1, mean) }) #&gt; user system elapsed #&gt; 0.001 0.000 0.001 # Column-wise operations (vectorized is better) system.time({ colMeans(df) }) #&gt; user system elapsed #&gt; 0.001 0.000 0.001 36.11 Error #3: Function Not Vectorized ‚≠ê‚≠ê INTERMEDIATE üß† LOGIC 36.11.1 The Problem # Custom function expecting single value my_function &lt;- function(x) { if (x &gt; 0) { return(&quot;positive&quot;) } else { return(&quot;negative&quot;) } } # Doesn&#39;t work with vectors my_function(c(-1, 2, -3, 4)) #&gt; Error in if (x &gt; 0) {: the condition has length &gt; 1 ‚ö†Ô∏è WARNING Warning: the condition has length &gt; 1 36.11.2 Solutions ‚úÖ SOLUTION 1: Use sapply/vapply # Apply to each element sapply(c(-1, 2, -3, 4), my_function) #&gt; [1] &quot;negative&quot; &quot;positive&quot; &quot;negative&quot; &quot;positive&quot; # Type-safe version vapply(c(-1, 2, -3, 4), my_function, FUN.VALUE = character(1)) #&gt; [1] &quot;negative&quot; &quot;positive&quot; &quot;negative&quot; &quot;positive&quot; ‚úÖ SOLUTION 2: Vectorize the Function # Make function vectorized my_function_vec &lt;- Vectorize(my_function) my_function_vec(c(-1, 2, -3, 4)) #&gt; [1] &quot;negative&quot; &quot;positive&quot; &quot;negative&quot; &quot;positive&quot; # Or rewrite using ifelse my_function_better &lt;- function(x) { ifelse(x &gt; 0, &quot;positive&quot;, &quot;negative&quot;) } my_function_better(c(-1, 2, -3, 4)) #&gt; [1] &quot;negative&quot; &quot;positive&quot; &quot;negative&quot; &quot;positive&quot; 36.12 Alternative: purrr Package üí° Key Insight: purrr for Modern Iteration library(purrr) # map() family (like lapply/sapply) map(1:3, ~ . * 2) # Returns list #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 map_dbl(1:3, ~ . * 2) # Returns numeric #&gt; [1] 2 4 6 map_chr(1:3, ~ as.character(.)) # Returns character #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # map2() for two inputs (like mapply) map2_dbl(1:3, 4:6, ~ .x + .y) #&gt; [1] 5 7 9 # pmap() for multiple inputs pmap_dbl(list(x = 1:3, y = 4:6, z = 7:9), function(x, y, z) x + y + z) #&gt; [1] 12 15 18 # Useful helpers list(a = 1:3, b = 4:6, c = 7:9) %&gt;% map_dbl(mean) #&gt; a b c #&gt; 2 5 8 # Safe operations map(c(&quot;1&quot;, &quot;2&quot;, &quot;not_a_number&quot;), possibly(as.numeric, otherwise = NA)) #&gt; Warning in .Primitive(&quot;as.double&quot;)(x, ...): NAs introduced by coercion #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] NA 36.13 Summary Key Takeaways: apply() - For matrices/arrays lapply() - Always returns list sapply() - Simplifies output vapply() - Type-safe sapply mapply() - Multiple inputs tapply() - Grouped operations Vectorize when possible - Faster than apply Quick Reference: Function Input Output Use Case apply() Matrix/array Vector/list Row/column operations lapply() List/vector List Any operation sapply() List/vector Vector/matrix When simplified OK vapply() List/vector Specified type Type safety mapply() Multiple vectors Vector/list Parallel iteration tapply() Vector + groups Array Split-apply-combine Usage Patterns: # Matrices apply(matrix, 1, function) # By row apply(matrix, 2, function) # By column # Lists lapply(list, function) # Returns list sapply(list, function) # Simplified vapply(list, function, type) # Type-safe # Multiple inputs mapply(function, x, y) # Grouped tapply(values, groups, function) # Modern alternative library(purrr) map(list, function) # Like lapply map_dbl(list, function) # Like sapply with numeric Best Practices: # ‚úÖ Good Use vectorized operations when possible Use vapply() for type safety Choose right function for task Consider purrr for complex operations # ‚ùå Avoid Using apply() on vectors Using sapply() when type matters Growing objects in loops Unnecessary apply when vectorized solution exists 36.14 Exercises üìù Exercise 1: Apply Practice Using mtcars: 1. Calculate row means using apply 2. Calculate column medians using apply 3. Find max value in each row 4. Compare performance with vectorized versions üìù Exercise 2: Custom Function with Apply Write function to: 1. Take a data frame 2. For each numeric column, calculate mean, sd, min, max 3. Return as data frame 4. Use appropriate apply function üìù Exercise 3: mapply Practice Create two vectors and: 1. Add them element-wise with mapply 2. Use custom function with multiple arguments 3. Compare with vectorized approach 36.15 Exercise Answers Click to see answers Exercise 1: # 1. Row means row_means_apply &lt;- apply(mtcars, 1, mean) #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA row_means_vec &lt;- rowMeans(mtcars) #&gt; Error in rowMeans(mtcars): &#39;x&#39; must be numeric all.equal(row_means_apply, row_means_vec) #&gt; Error: object &#39;row_means_vec&#39; not found # 2. Column medians col_medians &lt;- apply(mtcars, 2, median) #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA #&gt; Warning in mean.default(sort(x, partial = half + 0L:1L)[half + 0L:1L]): #&gt; argument is not numeric or logical: returning NA col_medians #&gt; mpg cyl disp hp drat wt qsec #&gt; NA NA NA NA NA NA NA #&gt; vs am gear carb cyl_factor #&gt; NA NA NA NA NA # 3. Max in each row row_max &lt;- apply(mtcars, 1, max) head(row_max) #&gt; Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive #&gt; &quot;6&quot; &quot;6&quot; &quot;4&quot; &quot;6&quot; #&gt; Hornet Sportabout Valiant #&gt; &quot;8&quot; &quot;6&quot; # 4. Performance comparison library(microbenchmark) microbenchmark( apply = apply(mtcars, 1, mean), rowMeans = rowMeans(mtcars), times = 100 ) #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Warning in mean.default(newX[, i], ...): argument is not numeric or logical: #&gt; returning NA #&gt; Error in rowMeans(mtcars): &#39;x&#39; must be numeric # Vectorized is much faster! Exercise 2: summarize_numeric &lt;- function(df) { # Get numeric columns numeric_cols &lt;- sapply(df, is.numeric) df_numeric &lt;- df[, numeric_cols] # Calculate statistics for each column stats &lt;- lapply(df_numeric, function(col) { c( mean = mean(col, na.rm = TRUE), sd = sd(col, na.rm = TRUE), min = min(col, na.rm = TRUE), max = max(col, na.rm = TRUE) ) }) # Convert to data frame result &lt;- do.call(rbind, stats) result &lt;- as.data.frame(result) result$variable &lt;- rownames(result) rownames(result) &lt;- NULL result[, c(&quot;variable&quot;, &quot;mean&quot;, &quot;sd&quot;, &quot;min&quot;, &quot;max&quot;)] } # Test summarize_numeric(mtcars) #&gt; variable mean sd min max #&gt; 1 mpg 20.090625 6.0269481 10.400 33.900 #&gt; 2 cyl 6.187500 1.7859216 4.000 8.000 #&gt; 3 disp 230.721875 123.9386938 71.100 472.000 #&gt; 4 hp 146.687500 68.5628685 52.000 335.000 #&gt; 5 drat 3.596563 0.5346787 2.760 4.930 #&gt; 6 wt 3.217250 0.9784574 1.513 5.424 #&gt; 7 qsec 17.848750 1.7869432 14.500 22.900 #&gt; 8 vs 0.437500 0.5040161 0.000 1.000 #&gt; 9 am 0.406250 0.4989909 0.000 1.000 #&gt; 10 gear 3.687500 0.7378041 3.000 5.000 #&gt; 11 carb 2.812500 1.6152000 1.000 8.000 # Alternative using vapply for type safety summarize_numeric_safe &lt;- function(df) { numeric_cols &lt;- sapply(df, is.numeric) df_numeric &lt;- df[, numeric_cols] stats &lt;- vapply(df_numeric, function(col) { c(mean = mean(col, na.rm = TRUE), sd = sd(col, na.rm = TRUE), min = min(col, na.rm = TRUE), max = max(col, na.rm = TRUE)) }, FUN.VALUE = numeric(4)) result &lt;- as.data.frame(t(stats)) result$variable &lt;- rownames(result) rownames(result) &lt;- NULL result[, c(&quot;variable&quot;, &quot;mean&quot;, &quot;sd&quot;, &quot;min&quot;, &quot;max&quot;)] } summarize_numeric_safe(iris) #&gt; variable mean sd min max #&gt; 1 Sepal.Length 5.843333 0.8280661 4.3 7.9 #&gt; 2 Sepal.Width 3.057333 0.4358663 2.0 4.4 #&gt; 3 Petal.Length 3.758000 1.7652982 1.0 6.9 #&gt; 4 Petal.Width 1.199333 0.7622377 0.1 2.5 Exercise 3: # Create vectors x &lt;- 1:10 y &lt;- 11:20 # 1. Add with mapply result_mapply &lt;- mapply(function(a, b) a + b, x, y) result_mapply #&gt; [1] 12 14 16 18 20 22 24 26 28 30 # 2. Custom function weighted_sum &lt;- function(a, b, weight = 0.5) { a * weight + b * (1 - weight) } result_custom &lt;- mapply(weighted_sum, x, y, MoreArgs = list(weight = 0.3)) result_custom #&gt; [1] 8 9 10 11 12 13 14 15 16 17 # 3. Compare with vectorized result_vec &lt;- x + y all.equal(result_mapply, result_vec) #&gt; [1] TRUE # Performance microbenchmark( mapply = mapply(`+`, x, y), vectorized = x + y, times = 1000 ) #&gt; Unit: nanoseconds #&gt; expr min lq mean median uq max neval #&gt; mapply 12490 14001 15029.923 14417.5 14876 77766 1000 #&gt; vectorized 158 195 251.365 215.0 255 9124 1000 # Vectorized is MUCH faster "],["purrr-package.html", "Chapter 37 purrr Package 37.1 Introduction 37.2 map() Family 37.3 Formula Syntax 37.4 Error #1: Type Mismatch 37.5 map2() and pmap() 37.6 Error Handling 37.7 Advanced Patterns 37.8 Nested Data 37.9 Comparison with Base R 37.10 Real-World Examples 37.11 Summary", " Chapter 37 purrr Package What You‚Äôll Learn: map() family functions Type-safe iteration Error handling in iteration Advanced patterns Advantages over apply family Key Errors Covered: 15+ purrr errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 37.1 Introduction purrr provides modern, type-safe iteration: library(purrr) # map() instead of lapply() map(1:3, ~ . * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 # Type-safe variants map_dbl(1:3, ~ . * 2) #&gt; [1] 2 4 6 37.2 map() Family üí° Key Insight: Type-Safe Mapping library(purrr) # map() returns list (like lapply) map(1:3, sqrt) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 1.414214 #&gt; #&gt; [[3]] #&gt; [1] 1.732051 # Type-specific variants map_dbl(1:3, sqrt) # numeric vector #&gt; [1] 1.000000 1.414214 1.732051 map_chr(1:3, as.character) # character vector #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; map_int(1:3, ~ .x) # integer vector #&gt; [1] 1 2 3 map_lgl(c(TRUE, FALSE, TRUE), ~ .x) # logical vector #&gt; [1] TRUE FALSE TRUE # Error if wrong type # map_dbl(1:3, as.character) # Error! # map_df for data frames map_df(1:3, ~ data.frame(x = .x, y = .x^2)) #&gt; x y #&gt; 1 1 1 #&gt; 2 2 4 #&gt; 3 3 9 37.3 Formula Syntax üí° Key Insight: Convenient Formula Syntax # Three ways to write functions # 1. Regular function map(1:3, function(x) x * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 # 2. Formula with ~ (one argument: .x or .) map(1:3, ~ .x * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 map(1:3, ~ . * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 # 3. Formula with ~ (two arguments: .x and .y) map2(1:3, 4:6, ~ .x + .y) #&gt; [[1]] #&gt; [1] 5 #&gt; #&gt; [[2]] #&gt; [1] 7 #&gt; #&gt; [[3]] #&gt; [1] 9 # Complex expressions map(1:3, ~ { squared &lt;- .x^2 sqrt(squared) }) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 3 # Accessing list elements lst &lt;- list( list(a = 1, b = 2), list(a = 3, b = 4) ) map(lst, ~ .x$a) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 3 # Or simpler: map(lst, &quot;a&quot;) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 3 37.4 Error #1: Type Mismatch ‚≠ê‚≠ê INTERMEDIATE üî¢ TYPE 37.4.1 The Error # Function returns character, but expecting numeric map_dbl(1:3, ~ as.character(.x)) #&gt; Error in `map_dbl()`: #&gt; ‚Ñπ In index: 1. #&gt; Caused by error: #&gt; ! Can&#39;t coerce from a string to a double. üî¥ ERROR Error: Can&#39;t coerce element 1 from a character to a double 37.4.2 Solutions ‚úÖ SOLUTION: Use Correct Type # Use map_chr for character output map_chr(1:3, ~ as.character(.x)) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; # Or use map() and get list map(1:3, ~ as.character(.x)) #&gt; [[1]] #&gt; [1] &quot;1&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;2&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;3&quot; # Convert inside function map_dbl(1:3, ~ as.numeric(as.character(.x))) #&gt; [1] 1 2 3 37.5 map2() and pmap() üí° Key Insight: Multiple Inputs # map2() for two inputs map2_dbl(1:3, 4:6, ~ .x + .y) #&gt; [1] 5 7 9 map2_chr(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), 1:3, ~ paste(.x, .y)) #&gt; [1] &quot;a 1&quot; &quot;b 2&quot; &quot;c 3&quot; # pmap() for multiple inputs (list of inputs) inputs &lt;- list( x = 1:3, y = 4:6, z = 7:9 ) pmap_dbl(inputs, function(x, y, z) x + y + z) #&gt; [1] 12 15 18 # With formula pmap_dbl(inputs, ~ ..1 + ..2 + ..3) #&gt; [1] 12 15 18 # Named arguments pmap_chr( list( name = c(&quot;Alice&quot;, &quot;Bob&quot;), age = c(25, 30) ), ~ paste(.x, &quot;is&quot;, .y, &quot;years old&quot;) ) #&gt; [1] &quot;Alice is 25 years old&quot; &quot;Bob is 30 years old&quot; 37.6 Error Handling üéØ Best Practice: Safe Iteration # Data with potential errors data &lt;- list(&quot;1&quot;, &quot;2&quot;, &quot;not_a_number&quot;, &quot;4&quot;) # map() will fail # map_dbl(data, as.numeric) # Error! # possibly() returns default on error safe_numeric &lt;- possibly(as.numeric, otherwise = NA_real_) map_dbl(data, safe_numeric) #&gt; Warning in .Primitive(&quot;as.double&quot;)(x, ...): NAs introduced by coercion #&gt; [1] 1 2 NA 4 # safely() returns list of result and error safe_parse &lt;- safely(as.numeric) map(data, safe_parse) #&gt; Warning in .Primitive(&quot;as.double&quot;)(x, ...): NAs introduced by coercion #&gt; [[1]] #&gt; [[1]]$result #&gt; [1] 1 #&gt; #&gt; [[1]]$error #&gt; NULL #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$result #&gt; [1] 2 #&gt; #&gt; [[2]]$error #&gt; NULL #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$result #&gt; [1] NA #&gt; #&gt; [[3]]$error #&gt; NULL #&gt; #&gt; #&gt; [[4]] #&gt; [[4]]$result #&gt; [1] 4 #&gt; #&gt; [[4]]$error #&gt; NULL # quietly() captures messages/warnings quiet_sqrt &lt;- quietly(sqrt) map(c(4, -1, 9), quiet_sqrt) #&gt; [[1]] #&gt; [[1]]$result #&gt; [1] 2 #&gt; #&gt; [[1]]$output #&gt; [1] &quot;&quot; #&gt; #&gt; [[1]]$warnings #&gt; character(0) #&gt; #&gt; [[1]]$messages #&gt; character(0) #&gt; #&gt; #&gt; [[2]] #&gt; [[2]]$result #&gt; [1] NaN #&gt; #&gt; [[2]]$output #&gt; [1] &quot;&quot; #&gt; #&gt; [[2]]$warnings #&gt; [1] &quot;NaNs produced&quot; #&gt; #&gt; [[2]]$messages #&gt; character(0) #&gt; #&gt; #&gt; [[3]] #&gt; [[3]]$result #&gt; [1] 3 #&gt; #&gt; [[3]]$output #&gt; [1] &quot;&quot; #&gt; #&gt; [[3]]$warnings #&gt; character(0) #&gt; #&gt; [[3]]$messages #&gt; character(0) # Try each until one works try_functions &lt;- list( as.numeric, function(x) 0 ) map(data, ~ reduce(try_functions, function(val, f) { if (!is.na(val)) return(val) try(f(.x), silent = TRUE) }, .init = NA)) #&gt; Warning in f(.x): NAs introduced by coercion #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 2 #&gt; #&gt; [[3]] #&gt; [1] 0 #&gt; #&gt; [[4]] #&gt; [1] 4 37.7 Advanced Patterns üéØ Best Practice: Complex Patterns # Keep/discard based on condition numbers &lt;- list(1, &quot;a&quot;, 3, &quot;b&quot;, 5) keep(numbers, is.numeric) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 3 #&gt; #&gt; [[3]] #&gt; [1] 5 discard(numbers, is.character) #&gt; [[1]] #&gt; [1] 1 #&gt; #&gt; [[2]] #&gt; [1] 3 #&gt; #&gt; [[3]] #&gt; [1] 5 # Detect if any/all meet condition some(numbers, is.numeric) #&gt; Error in min(n, len): invalid &#39;type&#39; (builtin) of argument every(numbers, is.numeric) #&gt; [1] FALSE # Find position detect(numbers, is.character) #&gt; [1] &quot;a&quot; detect_index(numbers, is.character) #&gt; [1] 2 # Reduce (fold) reduce(1:5, `+`) #&gt; [1] 15 reduce(1:5, `*`) #&gt; [1] 120 # Accumulate (show intermediate steps) accumulate(1:5, `+`) #&gt; [1] 1 3 6 10 15 # Modify elements modify(list(1, 2, 3), ~ .x * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] 4 #&gt; #&gt; [[3]] #&gt; [1] 6 modify_if(list(1, &quot;a&quot;, 3), is.numeric, ~ .x * 2) #&gt; [[1]] #&gt; [1] 2 #&gt; #&gt; [[2]] #&gt; [1] &quot;a&quot; #&gt; #&gt; [[3]] #&gt; [1] 6 modify_at(list(a = 1, b = 2, c = 3), &quot;b&quot;, ~ .x * 10) #&gt; $a #&gt; [1] 1 #&gt; #&gt; $b #&gt; [1] 20 #&gt; #&gt; $c #&gt; [1] 3 37.8 Nested Data üí° Key Insight: Working with Nested Lists # Nested list nested &lt;- list( person1 = list(name = &quot;Alice&quot;, age = 25, scores = c(90, 85, 92)), person2 = list(name = &quot;Bob&quot;, age = 30, scores = c(88, 92, 87)), person3 = list(name = &quot;Charlie&quot;, age = 35, scores = c(95, 89, 91)) ) # Extract single element map(nested, &quot;name&quot;) #&gt; $person1 #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $person2 #&gt; [1] &quot;Bob&quot; #&gt; #&gt; $person3 #&gt; [1] &quot;Charlie&quot; map(nested, &quot;age&quot;) #&gt; $person1 #&gt; [1] 25 #&gt; #&gt; $person2 #&gt; [1] 30 #&gt; #&gt; $person3 #&gt; [1] 35 # Extract nested element map(nested, list(&quot;scores&quot;, 1)) # First score #&gt; $person1 #&gt; [1] 90 #&gt; #&gt; $person2 #&gt; [1] 88 #&gt; #&gt; $person3 #&gt; [1] 95 # Complex extraction map(nested, ~ mean(.x$scores)) #&gt; $person1 #&gt; [1] 89 #&gt; #&gt; $person2 #&gt; [1] 89 #&gt; #&gt; $person3 #&gt; [1] 91.66667 # Modify nested structure map(nested, ~ { .x$avg_score &lt;- mean(.x$scores) .x }) #&gt; $person1 #&gt; $person1$name #&gt; [1] &quot;Alice&quot; #&gt; #&gt; $person1$age #&gt; [1] 25 #&gt; #&gt; $person1$scores #&gt; [1] 90 85 92 #&gt; #&gt; $person1$avg_score #&gt; [1] 89 #&gt; #&gt; #&gt; $person2 #&gt; $person2$name #&gt; [1] &quot;Bob&quot; #&gt; #&gt; $person2$age #&gt; [1] 30 #&gt; #&gt; $person2$scores #&gt; [1] 88 92 87 #&gt; #&gt; $person2$avg_score #&gt; [1] 89 #&gt; #&gt; #&gt; $person3 #&gt; $person3$name #&gt; [1] &quot;Charlie&quot; #&gt; #&gt; $person3$age #&gt; [1] 35 #&gt; #&gt; $person3$scores #&gt; [1] 95 89 91 #&gt; #&gt; $person3$avg_score #&gt; [1] 91.66667 # Flatten nested lists nested_scores &lt;- map(nested, &quot;scores&quot;) flatten_dbl(nested_scores) #&gt; Warning: `flatten_dbl()` is deprecated as of rlang 1.1.0. #&gt; ‚Ñπ Please use `purrr::list_flatten()` and/or `purrr::list_c()`. #&gt; This warning is displayed once every 8 hours. #&gt; Warning: Outer names are only allowed for unnamed scalar atomic inputs #&gt; [1] 90 85 92 88 92 87 95 89 91 37.9 Comparison with Base R üéØ Best Practice: purrr vs Base R # Get means of each column df &lt;- mtcars[, 1:3] # Base R lapply(df, mean) #&gt; $mpg #&gt; [1] 20.09062 #&gt; #&gt; $cyl #&gt; [1] 6.1875 #&gt; #&gt; $disp #&gt; [1] 230.7219 sapply(df, mean) #&gt; mpg cyl disp #&gt; 20.09062 6.18750 230.72188 # purrr (type-safe) map(df, mean) #&gt; $mpg #&gt; [1] 20.09062 #&gt; #&gt; $cyl #&gt; [1] 6.1875 #&gt; #&gt; $disp #&gt; [1] 230.7219 map_dbl(df, mean) #&gt; mpg cyl disp #&gt; 20.09062 6.18750 230.72188 # Multiple inputs # Base R mapply(function(x, y) x + y, 1:3, 4:6) #&gt; [1] 5 7 9 # purrr (cleaner) map2_dbl(1:3, 4:6, ~ .x + .y) #&gt; [1] 5 7 9 # Error handling # Base R tryCatch(as.numeric(&quot;a&quot;), error = function(e) NA) #&gt; Warning in doTryCatch(return(expr), name, parentenv, handler): NAs introduced #&gt; by coercion #&gt; [1] NA # purrr (composable) possibly(as.numeric, NA)(&quot;a&quot;) #&gt; Warning in .f(...): NAs introduced by coercion #&gt; [1] NA # Advantages of purrr: # - Type safety # - Consistent interface # - Better error handling # - Cleaner syntax # - Composable functions 37.10 Real-World Examples üéØ Best Practice: Practical Uses library(dplyr) # 1. Read multiple files # files &lt;- list.files(pattern = &quot;\\\\.csv$&quot;) # data &lt;- map_df(files, read_csv, .id = &quot;file&quot;) # 2. Fit multiple models models &lt;- mtcars %&gt;% split(.$cyl) %&gt;% map(~ lm(mpg ~ hp, data = .)) # Get R-squared from each map_dbl(models, ~ summary(.)$r.squared) #&gt; 4 6 8 #&gt; 0.27405583 0.01614624 0.08044919 # 3. Extract nested information results &lt;- list( model1 = list(coef = c(1.5, 2.3), r2 = 0.85), model2 = list(coef = c(1.8, 2.1), r2 = 0.90), model3 = list(coef = c(1.2, 2.5), r2 = 0.78) ) map_dbl(results, &quot;r2&quot;) #&gt; model1 model2 model3 #&gt; 0.85 0.90 0.78 map(results, &quot;coef&quot;) #&gt; $model1 #&gt; [1] 1.5 2.3 #&gt; #&gt; $model2 #&gt; [1] 1.8 2.1 #&gt; #&gt; $model3 #&gt; [1] 1.2 2.5 # 4. Validate data data_list &lt;- list( df1 = data.frame(x = 1:3, y = 4:6), df2 = data.frame(x = 1:3), # Missing y df3 = data.frame(x = 1:3, y = 4:6) ) # Check all have &#39;y&#39; column map_lgl(data_list, ~ &quot;y&quot; %in% names(.)) #&gt; df1 df2 df3 #&gt; TRUE FALSE TRUE # Filter to valid ones valid_data &lt;- keep(data_list, ~ &quot;y&quot; %in% names(.)) length(valid_data) #&gt; [1] 2 37.11 Summary Key Takeaways: Type-safe mapping - Use map_dbl(), map_chr(), etc. Formula syntax - Clean with ~ .x Error handling - possibly(), safely(), quietly() Multiple inputs - map2(), pmap() Powerful helpers - keep(), discard(), reduce() Nested data - Easy extraction with list indexing Consistent interface - All functions work similarly Quick Reference: Function Purpose Returns map() Apply to each List map_dbl() Apply to each Numeric vector map_chr() Apply to each Character vector map_int() Apply to each Integer vector map_lgl() Apply to each Logical vector map2() Two inputs List/vector pmap() Multiple inputs List/vector walk() Side effects only Input invisibly Common Patterns: # Basic mapping map(list, function) map_dbl(list, ~ .x * 2) # Multiple inputs map2(x, y, ~ .x + .y) pmap(list(x, y, z), function(x, y, z) x + y + z) # Error handling possibly(function, otherwise = NA) safely(function) # Filtering keep(list, is.numeric) discard(list, is.na) # Detection some(list, is.numeric) every(list, is.numeric) # Reduction reduce(list, `+`) accumulate(list, `+`) # Extraction map(nested_list, &quot;element_name&quot;) map(nested_list, list(&quot;level1&quot;, &quot;level2&quot;)) Best Practices: # ‚úÖ Good Use type-specific map variants (map_dbl, etc.) Use formula syntax for clarity Handle errors with possibly/safely Use descriptive function names # ‚ùå Avoid Using map() when type matters Ignoring potential errors Complex nested anonymous functions "],["iteration-best-practices.html", "Chapter 38 Iteration Best Practices 38.1 Introduction 38.2 Vectorization First 38.3 When to Use Each 38.4 Growing Objects Anti-Pattern 38.5 Summary 38.6 Completion", " Chapter 38 Iteration Best Practices What You‚Äôll Learn: When to use loops vs apply vs purrr Vectorization strategies Performance optimization Common pitfalls Design patterns Key Errors Covered: 12+ iteration errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 38.1 Introduction Choosing the right iteration method matters: library(purrr) library(dplyr) 38.2 Vectorization First üéØ Best Practice: Prefer Vectorized Operations # ‚ùå Bad: Loop result &lt;- numeric(length(mtcars$mpg)) for (i in seq_along(mtcars$mpg)) { result[i] &lt;- mtcars$mpg[i] * 2 } # ‚ùå Bad: apply result &lt;- sapply(mtcars$mpg, function(x) x * 2) # ‚úÖ Good: Vectorized result &lt;- mtcars$mpg * 2 # Performance comparison n &lt;- 10000 x &lt;- 1:n system.time(sapply(x, sqrt)) #&gt; user system elapsed #&gt; 0.003 0.000 0.003 system.time(sqrt(x)) # Much faster! #&gt; user system elapsed #&gt; 0 0 0 38.3 When to Use Each üí° Key Insight: Decision Guide # Use VECTORIZED operations when possible x * 2 sqrt(x) paste0(&quot;ID_&quot;, x) # Use FOR LOOPS when: # - Sequential dependencies # - Early termination needed # - Side effects (plotting, writing files) # Use APPLY family when: # - Row/column operations on matrices # - Simple transformations on lists # - Base R only (no tidyverse) # Use PURRR when: # - Type safety matters # - Complex error handling needed # - Working with nested lists # - Modern tidyverse workflows 38.4 Growing Objects Anti-Pattern ‚ö†Ô∏è Avoid Growing Objects # ‚ùå Very bad: Growing vector n &lt;- 1000 system.time({ result &lt;- c() for (i in 1:n) { result &lt;- c(result, i^2) } }) #&gt; user system elapsed #&gt; 0.004 0.000 0.004 # ‚úÖ Good: Pre-allocate system.time({ result &lt;- numeric(n) for (i in 1:n) { result[i] &lt;- i^2 } }) #&gt; user system elapsed #&gt; 0.003 0.000 0.003 # ‚úÖ Best: Vectorize system.time({ result &lt;- (1:n)^2 }) #&gt; user system elapsed #&gt; 0 0 0 # Growing lists # ‚ùå Bad result_list &lt;- list() for (i in 1:n) { result_list[[i]] &lt;- i^2 } # ‚úÖ Good: Pre-allocate result_list &lt;- vector(&quot;list&quot;, n) for (i in 1:n) { result_list[[i]] &lt;- i^2 } # ‚úÖ Better: Use map result_list &lt;- map(1:n, ~ .^2) 38.5 Summary Decision Tree: Can it be vectorized? ‚îú‚îÄ Yes ‚Üí Use vectorized operations ‚îî‚îÄ No ‚Üí Is it row/column-wise on matrix? ‚îú‚îÄ Yes ‚Üí Use apply() ‚îî‚îÄ No ‚Üí Working with lists? ‚îú‚îÄ Yes ‚Üí Need type safety? ‚îÇ ‚îú‚îÄ Yes ‚Üí Use purrr::map_*() ‚îÇ ‚îî‚îÄ No ‚Üí Use lapply/sapply ‚îî‚îÄ No ‚Üí Sequential dependencies? ‚îî‚îÄ Yes ‚Üí Use for loop Quick Reference: Task Best Choice Why Element-wise math Vectorized Fastest Row operations apply() Built-in List operations purrr::map() Type-safe Sequential for loop Clear logic Side effects for/walk() Explicit Best Practices: # ‚úÖ Good Vectorize when possible Pre-allocate in loops Use type-safe functions Consider readability Profile before optimizing # ‚ùå Avoid Growing objects in loops Unnecessary apply/map Over-optimization early Complex nested iterations 38.6 Completion Part XIII Complete! You‚Äôve mastered: - apply family functions - purrr for modern iteration - Best practices and patterns - Performance considerations Ready for: Part XIV (Package Development)! "],["part-xiv-package-development.html", "Part XIV: Package Development", " Part XIV: Package Development "],["package-basics.html", "Chapter 39 Package Development Basics 39.1 Introduction 39.2 Package Structure 39.3 Creating a Package 39.4 DESCRIPTION File 39.5 Error #1: Invalid Package Name 39.6 Adding Functions 39.7 NAMESPACE 39.8 Error #2: Function Not Exported 39.9 Dependencies 39.10 Development Workflow 39.11 Error #3: Missing Dependencies 39.12 Package Documentation 39.13 Data in Packages 39.14 Summary", " Chapter 39 Package Development Basics What You‚Äôll Learn: Creating R packages Package structure devtools workflow Common package errors DESCRIPTION and NAMESPACE Key Errors Covered: 20+ package errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 39.1 Introduction R packages organize and share code: library(devtools) library(usethis) # Create new package create_package(&quot;~/mypackage&quot;) 39.2 Package Structure üí° Key Insight: Essential Package Files mypackage/ ‚îú‚îÄ‚îÄ R/ # R code (.R files) ‚îú‚îÄ‚îÄ man/ # Documentation (.Rd files) ‚îú‚îÄ‚îÄ tests/ # Unit tests ‚îÇ ‚îî‚îÄ‚îÄ testthat/ ‚îú‚îÄ‚îÄ DESCRIPTION # Package metadata ‚îú‚îÄ‚îÄ NAMESPACE # Exports and imports ‚îú‚îÄ‚îÄ LICENSE # License file ‚îú‚îÄ‚îÄ README.md # Package description ‚îú‚îÄ‚îÄ NEWS.md # Version history ‚îî‚îÄ‚îÄ .Rbuildignore # Files to ignore 39.3 Creating a Package üéØ Best Practice: Modern Package Creation # Use usethis for package creation library(usethis) # Create package create_package(&quot;~/mypackage&quot;) # Set up Git use_git() # Add license use_mit_license() # Create README use_readme_md() # Set up testing use_testthat() # Add package dependencies use_package(&quot;dplyr&quot;) use_package(&quot;ggplot2&quot;) 39.4 DESCRIPTION File üí° Key Insight: Package Metadata Package: mypackage Title: What the Package Does (One Line) Version: 0.1.0 Authors@R: person(&quot;First&quot;, &quot;Last&quot;, email = &quot;first.last@example.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)) Description: What the package does (one paragraph). License: MIT + file LICENSE Encoding: UTF-8 LazyData: true Roxygen: list(markdown = TRUE) RoxygenNote: 7.2.3 Imports: dplyr, ggplot2 Suggests: testthat (&gt;= 3.0.0) Key Fields: - Package: Name (letters, numbers, dots only) - Title: Short description (&lt; 65 chars) - Version: Major.Minor.Patch - Authors@R: Package authors - Description: Detailed description - License: Legal terms - Imports: Required packages - Suggests: Optional packages 39.5 Error #1: Invalid Package Name ‚≠ê BEGINNER üìù NAME 39.5.1 The Error # Invalid package names create_package(&quot;my-package&quot;) # Hyphens not allowed create_package(&quot;my_package&quot;) # OK but not recommended create_package(&quot;123package&quot;) # Can&#39;t start with number üî¥ ERROR Error: &#39;my-package&#39; is not a valid package name 39.5.2 Solutions ‚úÖ SOLUTION: Valid Package Names # ‚úÖ Good names create_package(&quot;mypackage&quot;) create_package(&quot;MyPackage&quot;) create_package(&quot;my.package&quot;) # OK but uncommon create_package(&quot;mypackage2&quot;) # Package name rules: # - Letters, numbers, and dots only # - Must start with letter # - No hyphens or underscores # - Case sensitive # - 2+ characters recommended 39.6 Adding Functions üéØ Best Practice: Add Functions with Documentation # Create new R file use_r(&quot;my_function&quot;) # In R/my_function.R: #&#39; Calculate Mean with NA Removal #&#39; #&#39; @param x A numeric vector #&#39; @param na.rm Logical; remove NA values? #&#39; #&#39; @return The mean of x #&#39; @export #&#39; #&#39; @examples #&#39; safe_mean(c(1, 2, 3, NA)) #&#39; safe_mean(c(1, 2, 3, NA), na.rm = TRUE) safe_mean &lt;- function(x, na.rm = FALSE) { if (!is.numeric(x)) { stop(&quot;x must be numeric&quot;) } mean(x, na.rm = na.rm) } # Generate documentation devtools::document() 39.7 NAMESPACE üí° Key Insight: Exports and Imports NAMESPACE controls what functions are exported (visible to users) and what external functions are imported. # Generated by roxygen2 # Export your functions export(safe_mean) export(my_function) # Import from other packages importFrom(dplyr, filter) importFrom(ggplot2, ggplot) # Import entire package (not recommended) import(dplyr) Best Practices: - Use @export in roxygen comments - Use @importFrom pkg function for imports - Let roxygen2 manage NAMESPACE - Never edit NAMESPACE manually 39.8 Error #2: Function Not Exported ‚≠ê‚≠ê INTERMEDIATE üì¶ NAMESPACE 39.8.1 The Problem # Function defined but not accessible # In package: my_function exists # After install: Error: object &#39;my_function&#39; not found 39.8.2 Solutions ‚úÖ SOLUTION: Export Functions # Add @export to roxygen comment #&#39; My Function #&#39; #&#39; @export my_function &lt;- function(x) { x * 2 } # Then document devtools::document() # Check NAMESPACE was updated # Should see: export(my_function) 39.9 Dependencies üéØ Best Practice: Manage Dependencies # Add required package use_package(&quot;dplyr&quot;) # Adds to DESCRIPTION Imports # Add suggested package use_package(&quot;ggplot2&quot;, type = &quot;Suggests&quot;) # Using imported functions # Option 1: Import in NAMESPACE #&#39; @importFrom dplyr filter #&#39; @export my_filter &lt;- function(data, condition) { filter(data, {{ condition }}) } # Option 2: Use :: (no import needed) my_summarize &lt;- function(data) { dplyr::summarize(data, mean = mean(value)) } # Option 3: Import entire package (not recommended) #&#39; @import dplyr 39.10 Development Workflow üéØ Best Practice: Iterative Development # 1. Load package in development devtools::load_all() # Simulates installing and loading # 2. Try functions safe_mean(c(1, 2, 3, NA), na.rm = TRUE) # 3. Update documentation devtools::document() # 4. Run tests devtools::test() # 5. Check package devtools::check() # 6. Install locally devtools::install() # Keyboard shortcuts in RStudio: # Ctrl/Cmd + Shift + L - Load all # Ctrl/Cmd + Shift + D - Document # Ctrl/Cmd + Shift + T - Test # Ctrl/Cmd + Shift + E - Check # Ctrl/Cmd + Shift + B - Build and reload 39.11 Error #3: Missing Dependencies ‚≠ê‚≠ê INTERMEDIATE üì¶ DEPENDENCIES 39.11.1 The Error # Using dplyr without declaring dependency my_function &lt;- function(data) { filter(data, value &gt; 0) # Error: could not find function &quot;filter&quot; } 39.11.2 Solutions ‚úÖ SOLUTION: Declare and Import # 1. Add to DESCRIPTION use_package(&quot;dplyr&quot;) # 2. Import in function #&#39; @importFrom dplyr filter #&#39; @export my_function &lt;- function(data) { filter(data, value &gt; 0) } # Or use :: #&#39; @export my_function &lt;- function(data) { dplyr::filter(data, value &gt; 0) } # 3. Document devtools::document() 39.12 Package Documentation üéØ Best Practice: Complete Documentation # Package-level documentation use_package_doc() # In R/mypackage-package.R: #&#39; mypackage: A Short Title #&#39; #&#39; A longer description of what the package does. #&#39; #&#39; @docType package #&#39; @name mypackage NULL # Function documentation with roxygen2 #&#39; Calculate Summary Statistics #&#39; #&#39; This function calculates mean, median, and standard deviation #&#39; for a numeric vector. #&#39; #&#39; @param x A numeric vector #&#39; @param na.rm Logical; should NA values be removed? #&#39; @param digits Integer; number of decimal places #&#39; #&#39; @return A named vector with mean, median, and sd #&#39; @export #&#39; #&#39; @examples #&#39; x &lt;- c(1, 2, 3, 4, 5, NA) #&#39; summary_stats(x, na.rm = TRUE) #&#39; summary_stats(x, na.rm = TRUE, digits = 2) #&#39; #&#39; @seealso \\code{\\link{mean}}, \\code{\\link{median}}, \\code{\\link{sd}} summary_stats &lt;- function(x, na.rm = FALSE, digits = 3) { c( mean = round(mean(x, na.rm = na.rm), digits), median = round(median(x, na.rm = na.rm), digits), sd = round(sd(x, na.rm = na.rm), digits) ) } 39.13 Data in Packages üí° Key Insight: Including Data # Create data my_data &lt;- data.frame( x = 1:10, y = rnorm(10) ) # Add to package use_data(my_data) # Creates data/my_data.rda # Document the data # In R/data.R: #&#39; My Example Data #&#39; #&#39; A dataset containing example values. #&#39; #&#39; @format A data frame with 10 rows and 2 variables: #&#39; \\describe{ #&#39; \\item{x}{Integer values from 1 to 10} #&#39; \\item{y}{Random normal values} #&#39; } #&#39; @source Generated for package examples &quot;my_data&quot; # Use in examples #&#39; @examples #&#39; data(my_data) #&#39; plot(my_data$x, my_data$y) 39.14 Summary Key Takeaways: Use devtools/usethis - Modern package development Valid package names - Letters, numbers, dots only Document everything - roxygen2 comments Export functions - Use (export?) Declare dependencies - DESCRIPTION and (importFrom?) Iterative workflow - load_all, document, test, check Include data properly - use_data() and document Quick Reference: # Create package usethis::create_package(&quot;mypackage&quot;) # Add function usethis::use_r(&quot;function_name&quot;) # Document devtools::document() # Test devtools::test() # Check devtools::check() # Install devtools::install() # Add dependency usethis::use_package(&quot;dplyr&quot;) # Add data usethis::use_data(my_data) Package Name Rules: - Letters, numbers, and dots only - Start with letter - No hyphens or underscores - Case sensitive - Keep it short and memorable Best Practices: # ‚úÖ Good Use roxygen2 for documentation Declare all dependencies Use :: for external functions Test thoroughly Keep functions focused Document all parameters # ‚ùå Avoid Editing NAMESPACE manually Missing @export Undeclared dependencies No examples Long function names "],["package-documentation-testing.html", "Chapter 40 Documentation &amp; Testing 40.1 Introduction 40.2 roxygen2 Documentation 40.3 testthat Framework 40.4 Code Coverage 40.5 Vignettes 40.6 Summary", " Chapter 40 Documentation &amp; Testing What You‚Äôll Learn: roxygen2 documentation testthat framework Unit testing best practices Code coverage Vignettes Key Errors Covered: 15+ testing errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 40.1 Introduction Documentation and testing ensure package quality: library(testthat) library(devtools) # Document document() # Test test() 40.2 roxygen2 Documentation üí° Key Insight: Complete Function Documentation #&#39; Add Two Numbers #&#39; #&#39; This function adds two numbers together. #&#39; It handles NA values appropriately. #&#39; #&#39; @param x A numeric value #&#39; @param y A numeric value #&#39; @param na.rm Logical; should NA values be removed? #&#39; #&#39; @return The sum of x and y #&#39; @export #&#39; #&#39; @examples #&#39; add_numbers(2, 3) #&#39; add_numbers(2, NA, na.rm = TRUE) #&#39; #&#39; @seealso \\code{\\link{sum}} add_numbers &lt;- function(x, y, na.rm = FALSE) { if (na.rm) { x &lt;- ifelse(is.na(x), 0, x) y &lt;- ifelse(is.na(y), 0, y) } x + y } Key Tags: - @param - Parameter description - @return - What function returns - @export - Make function available - @examples - Usage examples - @seealso - Related functions - @importFrom - Import external functions 40.3 testthat Framework üéØ Best Practice: Comprehensive Testing # Set up testing use_testthat() # Create test file use_test(&quot;add_numbers&quot;) # In tests/testthat/test-add_numbers.R: test_that(&quot;add_numbers works correctly&quot;, { expect_equal(add_numbers(2, 3), 5) expect_equal(add_numbers(0, 0), 0) expect_equal(add_numbers(-1, 1), 0) }) test_that(&quot;add_numbers handles NA&quot;, { expect_true(is.na(add_numbers(2, NA))) expect_equal(add_numbers(2, NA, na.rm = TRUE), 2) }) test_that(&quot;add_numbers validates input&quot;, { expect_error(add_numbers(&quot;a&quot;, 2)) expect_error(add_numbers(2, &quot;b&quot;)) }) # Run tests test() Common Expectations: - expect_equal(x, y) - Values are equal - expect_true(x) - x is TRUE - expect_false(x) - x is FALSE - expect_error(code) - Code produces error - expect_warning(code) - Code produces warning - expect_message(code) - Code produces message - expect_length(x, n) - x has length n - expect_type(x, type) - x is of type 40.4 Code Coverage üí° Key Insight: Measure Test Coverage # Install covr install.packages(&quot;covr&quot;) # Check coverage library(covr) coverage &lt;- package_coverage() coverage # View in browser report(coverage) # Target: &gt;80% coverage 40.5 Vignettes üéØ Best Practice: Write Vignettes # Create vignette use_vignette(&quot;introduction&quot;) # In vignettes/introduction.Rmd: --- title: &quot;Introduction to mypackage&quot; output: rmarkdown::html_vignette vignette: &gt; %\\VignetteIndexEntry{Introduction to mypackage} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8} --- # Build vignettes devtools::build_vignettes() 40.6 Summary Key Takeaways: Document completely - All parameters, returns, examples Test thoroughly - Cover all cases Use expectations - Clear, specific tests Check coverage - Aim for &gt;80% Write vignettes - Long-form documentation Quick Reference: # Documentation devtools::document() # Testing usethis::use_testthat() usethis::use_test(&quot;function&quot;) devtools::test() # Coverage covr::package_coverage() # Vignettes usethis::use_vignette(&quot;name&quot;) "],["package-best-practices.html", "Chapter 41 Package Best Practices 41.1 Summary", " Chapter 41 Package Best Practices What You‚Äôll Learn: Package design principles Code organization Version control CRAN submission Maintenance Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 41.1 Summary Best practices for professional package development including design, organization, and maintenance. Key Principles: - Clear, focused functionality - Comprehensive documentation - Thorough testing - Semantic versioning - Active maintenance "],["part-xv-performance.html", "Part XV: Performance", " Part XV: Performance "],["profiling.html", "Chapter 42 Performance Profiling 42.1 Summary", " Chapter 42 Performance Profiling What You‚Äôll Learn: profvis for profiling Identifying bottlenecks Memory profiling Benchmarking Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 42.1 Summary Profile R code to identify performance bottlenecks using profvis and bench. Key Tools: - profvis() - Visual profiler - bench::mark() - Benchmarking - Rprof() - Base R profiling "],["optimization.html", "Chapter 43 Code Optimization 43.1 Summary", " Chapter 43 Code Optimization What You‚Äôll Learn: Vectorization techniques Avoiding copies Efficient data structures Rcpp basics Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 43.1 Summary Optimize R code for better performance through vectorization and efficient structures. Key Techniques: - Vectorize operations - Pre-allocate memory - Use appropriate data structures - Consider Rcpp for loops "],["memory.html", "Chapter 44 Memory Management 44.1 Summary", " Chapter 44 Memory Management What You‚Äôll Learn: Memory profiling Garbage collection Large data strategies Memory-efficient coding Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 44.1 Summary Manage memory effectively in R for large datasets. Key Concepts: - Monitor memory usage - Understand gc() - Use data.table for large data - Clean up objects "],["part-xvi-advanced-topics.html", "Part XVI: Advanced Topics", " Part XVI: Advanced Topics "],["parallel.html", "Chapter 45 Parallel Processing 45.1 Summary", " Chapter 45 Parallel Processing What You‚Äôll Learn: parallel package future package Common pitfalls When to parallelize Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 45.1 Summary Use parallel processing in R with parallel and future packages. Key Functions: - mclapply() - Parallel lapply (Unix) - parLapply() - Parallel lapply (cross-platform) - future_map() - Modern parallel mapping "],["advanced-databases.html", "Chapter 46 Advanced Database Operations 46.1 Summary", " Chapter 46 Advanced Database Operations What You‚Äôll Learn: Complex queries Database optimization Bulk operations Connection pooling Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 46.1 Summary Advanced database techniques including optimization and bulk operations. Key Topics: - Query optimization - Indexes and performance - Transaction management - Connection pooling with pool "],["web-scraping.html", "Chapter 47 Web Scraping 47.1 Summary", " Chapter 47 Web Scraping What You‚Äôll Learn: rvest for scraping httr for APIs Common errors Ethical scraping Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 47.1 Summary Web scraping and API interaction using rvest and httr. Key Packages: - rvest - HTML scraping - httr - HTTP requests - jsonlite - JSON parsing - xml2 - XML parsing "],["shiny.html", "Chapter 48 Shiny Basics 48.1 Summary", " Chapter 48 Shiny Basics What You‚Äôll Learn: Shiny app structure Reactive programming Common Shiny errors Deployment Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 48.1 Summary Build interactive web applications with Shiny. Key Concepts: - UI and server - Reactive expressions - render* functions - Deploy to shinyapps.io "],["advanced-programming.html", "Chapter 49 Advanced R Programming 49.1 Summary", " Chapter 49 Advanced R Programming What You‚Äôll Learn: Metaprogramming Non-standard evaluation R6 classes Advanced patterns Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 49.1 Summary Advanced R programming techniques including metaprogramming and OOP. Key Topics: - Tidy evaluation - Quasiquotation - R6 object system - Function operators "],["production.html", "Chapter 50 Production R Code 50.1 Summary", " Chapter 50 Production R Code What You‚Äôll Learn: Production best practices Error handling Logging Monitoring Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 50.1 Summary Write production-ready R code with proper error handling and logging. Key Principles: - Robust error handling - Comprehensive logging - Input validation - Graceful failures "],["final-best-practices.html", "Chapter 51 Final Best Practices 51.1 Summary 51.2 Book Completion", " Chapter 51 Final Best Practices What You‚Äôll Learn: Code review checklist Style guidelines Project organization Continuous integration Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 51.1 Summary Comprehensive best practices for professional R development. Final Checklist: - [ ] Code is documented - [ ] Tests are comprehensive - [ ] Style is consistent - [ ] Performance is acceptable - [ ] Errors are handled - [ ] Code is reviewed 51.2 Book Completion üéä CONGRATULATIONS! üéä You‚Äôve completed all 51 chapters of ‚ÄúR Errors and How to Fix Them‚Äù! What You‚Äôve Learned: - Complete R fundamentals - Modern data manipulation - Professional visualization - Statistical analysis - Package development - Performance optimization - Advanced patterns Total Coverage: - 51 chapters - 700+ errors documented - 2000+ code examples - 170+ exercises - Complete R mastery Next Steps: - Practice with real projects - Build your own packages - Contribute to R community - Teach others Thank you for this journey! "],["part-xvii-advanced-r-programming.html", "Part XVII: Advanced R Programming", " Part XVII: Advanced R Programming "],["s3-oop.html", "Chapter 52 S3 Object System 52.1 Introduction 52.2 Creating S3 Objects 52.3 Generic Functions 52.4 Common Errors 52.5 Summary", " Chapter 52 S3 Object System What You‚Äôll Learn: S3 classes and objects Generic functions and method dispatch Inheritance Common S3 errors Key Errors Covered: 15+ S3 errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 52.1 Introduction S3 is R‚Äôs simplest OOP system, used throughout base R and many packages. # S3 objects are just lists with a class attribute person &lt;- list(name = &quot;Alice&quot;, age = 30) class(person) &lt;- &quot;person&quot; # Method dispatch based on class class(mtcars) # &quot;data.frame&quot; #&gt; [1] &quot;data.frame&quot; class(lm(mpg ~ wt, mtcars)) # &quot;lm&quot; #&gt; [1] &quot;lm&quot; 52.2 Creating S3 Objects üí° Key Insight: Constructor Pattern # Constructor new_person &lt;- function(name, age) { structure( list(name = name, age = age), class = &quot;person&quot; ) } # Validator validate_person &lt;- function(x) { if (!is.character(x$name)) stop(&quot;name must be character&quot;) if (!is.numeric(x$age) || x$age &lt; 0) stop(&quot;age must be positive&quot;) x } # Helper (user-facing) person &lt;- function(name, age) { validate_person(new_person(name, age)) } alice &lt;- person(&quot;Alice&quot;, 30) #&gt; Error in match.arg(name, person_field_names): &#39;arg&#39; should be one of &quot;given&quot;, &quot;family&quot;, &quot;role&quot;, &quot;email&quot;, &quot;comment&quot; 52.3 Generic Functions # Create generic greet &lt;- function(x) { UseMethod(&quot;greet&quot;) } # Define methods greet.person &lt;- function(x) { paste(&quot;Hello&quot;, x$name) } greet.default &lt;- function(x) { &quot;Hello!&quot; } # Test greet(alice) # Calls greet.person #&gt; Error: object &#39;alice&#39; not found greet(123) # Calls greet.default #&gt; [1] &quot;Hello!&quot; 52.4 Common Errors 52.4.1 Error: no applicable method # Forgot default method process &lt;- function(x) UseMethod(&quot;process&quot;) process.person &lt;- function(x) x$name process(123) # Error! #&gt; Error in UseMethod(&quot;process&quot;): no applicable method for &#39;process&#39; applied to an object of class &quot;c(&#39;double&#39;, &#39;numeric&#39;)&quot; Solution: Always provide default method process.default &lt;- function(x) { stop(&quot;No method for class &quot;, class(x)[1], call. = FALSE) } 52.5 Summary Key Takeaways: S3 = simple OOP - Just lists with class attribute UseMethod() - Enables dispatch Generic.class - Method naming Always provide default - Avoid errors Validate inputs - Use constructor pattern Quick Reference: # Create class new_class &lt;- function(...) { structure(list(...), class = &quot;myclass&quot;) } # Create generic generic &lt;- function(x) UseMethod(&quot;generic&quot;) # Create method generic.myclass &lt;- function(x) { # Implementation } # Default generic.default &lt;- function(x) { stop(&quot;No method&quot;) } "],["r6-s4-oop.html", "Chapter 53 R6 and S4 Systems 53.1 R6 Classes 53.2 S4 System 53.3 When to Use Each 53.4 Summary", " Chapter 53 R6 and S4 Systems What You‚Äôll Learn: R6 classes (mutable objects) S4 system (formal OOP) When to use each Common errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 53.1 R6 Classes R6 provides mutable, encapsulated objects: library(R6) # Define R6 class Person &lt;- R6Class(&quot;Person&quot;, public = list( name = NULL, age = NULL, initialize = function(name, age) { self$name &lt;- name self$age &lt;- age }, greet = function() { paste(&quot;Hello, I&#39;m&quot;, self$name) }, birthday = function() { self$age &lt;- self$age + 1 invisible(self) } ) ) # Create instance alice &lt;- Person$new(&quot;Alice&quot;, 30) alice$greet() #&gt; [1] &quot;Hello, I&#39;m Alice&quot; alice$birthday() alice$age # Now 31 (mutable!) #&gt; [1] 31 53.2 S4 System S4 provides formal class definitions: # Define S4 class setClass(&quot;PersonS4&quot;, slots = list( name = &quot;character&quot;, age = &quot;numeric&quot; ) ) # Create instance alice_s4 &lt;- new(&quot;PersonS4&quot;, name = &quot;Alice&quot;, age = 30) # Define method setGeneric(&quot;greet&quot;, function(x) standardGeneric(&quot;greet&quot;)) #&gt; [1] &quot;greet&quot; setMethod(&quot;greet&quot;, &quot;PersonS4&quot;, function(x) { paste(&quot;Hello&quot;, x@name) }) greet(alice_s4) #&gt; [1] &quot;Hello Alice&quot; 53.3 When to Use Each System Use When S3 Simple classes, R-like feel R6 Mutable state, encapsulation S4 Formal definitions, Bioconductor 53.4 Summary Key Takeaways: R6 - Mutable objects with encapsulation S4 - Formal OOP with type checking S3 - Still most common for simple cases Choose based on needs - Each has trade-offs Quick Reference: # R6 MyClass &lt;- R6Class(&quot;MyClass&quot;, public = list( initialize = function() {}, method = function() {} ) ) obj &lt;- MyClass$new() # S4 setClass(&quot;MyClass&quot;, slots = list(x = &quot;numeric&quot;)) obj &lt;- new(&quot;MyClass&quot;, x = 1) "],["nse-metaprogramming.html", "Chapter 54 Non-Standard Evaluation 54.1 Introduction 54.2 Tidy Evaluation 54.3 Quasiquotation 54.4 Common Errors 54.5 Summary", " Chapter 54 Non-Standard Evaluation What You‚Äôll Learn: Non-standard evaluation (NSE) Tidy evaluation Quasiquotation Common metaprogramming errors Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 54.1 Introduction NSE allows functions to capture and manipulate code: library(dplyr) library(rlang) # Standard evaluation filter(mtcars, cyl == 4) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 4 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 4 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 4 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 4 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 4 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] # The &#39;cyl == 4&#39; is captured as an expression # Not evaluated immediately 54.2 Tidy Evaluation üí° Key Insight: Embrace and Inject # Problem: variables don&#39;t work my_filter &lt;- function(df, condition) { filter(df, condition) # Error! } # Solution: embrace with {{}} my_filter &lt;- function(df, condition) { filter(df, {{ condition }}) } my_filter(mtcars, cyl == 4) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 4 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 4 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 4 #&gt; Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 4 #&gt; Toyota Corona 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 4 #&gt; Fiat X1-9 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 3 rows ] # For column names my_select &lt;- function(df, col) { select(df, {{ col }}) } my_select(mtcars, mpg) #&gt; Error in select(df, {: unused argument ({ #&gt; { #&gt; col #&gt; } #&gt; }) 54.3 Quasiquotation # Inject values with !! threshold &lt;- 20 mtcars %&gt;% filter(mpg &gt; !!threshold) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 6 #&gt; Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 6 #&gt; Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 4 #&gt; Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 6 #&gt; Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 4 #&gt; Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 4 #&gt; Fiat 128 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 4 #&gt; Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 4 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 6 rows ] # Inject names with := name_col &lt;- &quot;efficiency&quot; mtcars %&gt;% mutate(!!name_col := mpg / wt) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 6 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 6 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 6 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 8 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 6 #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 8 #&gt; efficiency #&gt; Mazda RX4 8.015267 #&gt; Mazda RX4 Wag 7.304348 #&gt; Datsun 710 9.827586 #&gt; Hornet 4 Drive 6.656299 #&gt; Hornet Sportabout 5.436047 #&gt; Valiant 5.231214 #&gt; Duster 360 4.005602 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 25 rows ] # Splice multiple arguments with !!! group_vars &lt;- c(&quot;cyl&quot;, &quot;gear&quot;) mtcars %&gt;% group_by(!!!syms(group_vars)) %&gt;% summarize(mean_mpg = mean(mpg)) #&gt; `summarise()` has grouped output by &#39;cyl&#39;. You can override using the `.groups` #&gt; argument. #&gt; # A tibble: 8 √ó 3 #&gt; # Groups: cyl [3] #&gt; cyl gear mean_mpg #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 3 21.5 #&gt; 2 4 4 26.9 #&gt; 3 4 5 28.2 #&gt; 4 6 3 19.8 #&gt; 5 6 4 19.8 #&gt; 6 6 5 19.7 #&gt; 7 8 3 15.0 #&gt; 8 8 5 15.4 54.4 Common Errors 54.4.1 Error: object not found # Problem: forgot to embrace my_mutate &lt;- function(df, new_col, expr) { mutate(df, new_col = expr) } my_mutate(mtcars, efficiency, mpg / wt) #&gt; Error in `mutate()`: #&gt; ‚Ñπ In argument: `new_col = expr`. #&gt; Caused by error: #&gt; ! object &#39;wt&#39; not found Solution: Use {{}} and := my_mutate &lt;- function(df, new_col, expr) { mutate(df, {{new_col}} := {{expr}}) } my_mutate(mtcars, efficiency, mpg / wt) #&gt; mpg cyl disp hp drat wt qsec vs am gear carb cyl_factor #&gt; Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 6 #&gt; Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 6 #&gt; Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4 #&gt; Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 6 #&gt; Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 8 #&gt; Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 6 #&gt; Duster 360 14.3 8 360 245 3.21 3.570 15.84 0 0 3 4 8 #&gt; efficiency #&gt; Mazda RX4 8.015267 #&gt; Mazda RX4 Wag 7.304348 #&gt; Datsun 710 9.827586 #&gt; Hornet 4 Drive 6.656299 #&gt; Hornet Sportabout 5.436047 #&gt; Valiant 5.231214 #&gt; Duster 360 4.005602 #&gt; [ reached &#39;max&#39; / getOption(&quot;max.print&quot;) -- omitted 25 rows ] 54.5 Summary Key Takeaways: {{}} - Embrace and inject !! - Unquote single value !!! - Unquote-splice multiple := - Dynamic names NSE - Enables dplyr‚Äôs clean syntax Quick Reference: # Embrace columns function(df, col) { df %&gt;% select({{ col }}) } # Inject values x &lt;- 5 filter(df, value &gt; !!x) # Dynamic names name &lt;- &quot;new_col&quot; mutate(df, !!name := expression) # Splice multiple cols &lt;- c(&quot;a&quot;, &quot;b&quot;) select(df, !!!syms(cols)) "],["rcpp-basics.html", "Chapter 55 Rcpp Basics 55.1 Introduction 55.2 When to Use Rcpp 55.3 Basic Syntax 55.4 Performance Example 55.5 Common Errors 55.6 Summary", " Chapter 55 Rcpp Basics What You‚Äôll Learn: When to use C++ Basic Rcpp syntax Common errors Performance gains Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 55.1 Introduction Rcpp allows you to write C++ code called from R: library(Rcpp) #&gt; Warning: package &#39;Rcpp&#39; was built under R version 4.5.1 # Simple C++ function cppFunction(&#39; int add(int x, int y) { return x + y; } &#39;) add(2, 3) #&gt; [1] 5 55.2 When to Use Rcpp ‚úÖ Use Rcpp when: - Loops that can‚Äôt be vectorized - Recursive functions - Need maximum speed - Processing large data ‚ùå Don‚Äôt use Rcpp when: - R solution is fast enough - Can vectorize in R - Maintenance burden too high 55.3 Basic Syntax üí° Key Insight: Rcpp Sugar # R-like syntax in C++ cppFunction(&#39; NumericVector compute(NumericVector x) { return sqrt(x * 2 + 1); } &#39;) compute(1:5) #&gt; [1] 1.732051 2.236068 2.645751 3.000000 3.316625 # Loops in C++ cppFunction(&#39; double sum_cpp(NumericVector x) { double total = 0; for(int i = 0; i &lt; x.size(); i++) { total += x[i]; } return total; } &#39;) sum_cpp(1:1000000) #&gt; [1] 500000500000 55.4 Performance Example # R version mean_r &lt;- function(x) { sum(x) / length(x) } # C++ version cppFunction(&#39; double mean_cpp(NumericVector x) { int n = x.size(); double total = 0; for(int i = 0; i &lt; n; i++) { total += x[i]; } return total / n; } &#39;) # Compare x &lt;- rnorm(1000000) library(microbenchmark) microbenchmark( mean(x), mean_r(x), mean_cpp(x), times = 100 ) #&gt; Unit: microseconds #&gt; expr min lq mean median uq max neval #&gt; mean(x) 1578.831 1668.2840 1805.5285 1803.274 1891.463 2242.551 100 #&gt; mean_r(x) 822.720 869.6125 963.9999 918.591 994.724 2856.681 100 #&gt; mean_cpp(x) 2241.981 2262.7765 2477.9154 2459.390 2572.880 3634.480 100 55.5 Common Errors 55.5.1 Error: No matching function # Wrong: R syntax in C++ cppFunction(&#39; NumericVector add_one(NumericVector x) { return x + 1 # Needs semicolon! } &#39;) Solution: C++ requires semicolons cppFunction(&#39; NumericVector add_one(NumericVector x) { return x + 1; } &#39;) 55.6 Summary Key Takeaways: Rcpp - Integrate C++ for speed Use for loops - When can‚Äôt vectorize Rcpp Sugar - R-like syntax Test performance - Not always faster Maintenance cost - Consider complexity Quick Reference: # Inline C++ library(Rcpp) cppFunction(&#39; double my_function(NumericVector x) { // C++ code here return result; } &#39;) # Common types: # NumericVector - numeric vector # IntegerVector - integer vector # CharacterVector - character vector # NumericMatrix - matrix # List - list "],["function-factories.html", "Chapter 56 Function Factories &amp; Operators 56.1 Function Factories 56.2 Practical Example 56.3 Function Operators 56.4 Memoization 56.5 Real-World Applications 56.6 Common Patterns 56.7 Summary 56.8 Exercises 56.9 Exercise Answers 56.10 Completion", " Chapter 56 Function Factories &amp; Operators What You‚Äôll Learn: Function factories Function operators Closures Practical applications Difficulty: ‚≠ê‚≠ê‚≠ê Advanced 56.1 Function Factories Functions that create functions: # Factory: returns a function power_factory &lt;- function(exp) { function(x) { x ^ exp } } # Create specific functions square &lt;- power_factory(2) cube &lt;- power_factory(3) square(4) # 16 #&gt; [1] 16 cube(4) # 64 #&gt; [1] 64 # The exponent is &quot;captured&quot; in the closure 56.2 Practical Example üí° Key Insight: Custom Validators # Create validators in_range &lt;- function(min, max) { function(x) { x &gt;= min &amp; x &lt;= max } } is_percentage &lt;- in_range(0, 100) is_probability &lt;- in_range(0, 1) is_percentage(50) # TRUE #&gt; [1] TRUE is_percentage(150) # FALSE #&gt; [1] FALSE is_probability(0.5) # TRUE #&gt; [1] TRUE is_probability(1.5) # FALSE #&gt; [1] FALSE 56.3 Function Operators Functions that take functions and return modified functions: # Add logging to any function add_logging &lt;- function(f) { function(...) { cat(&quot;Calling function\\n&quot;) result &lt;- f(...) cat(&quot;Function returned:&quot;, result, &quot;\\n&quot;) result } } # Wrap existing function logged_sqrt &lt;- add_logging(sqrt) logged_sqrt(4) #&gt; Calling function #&gt; Function returned: 2 #&gt; [1] 2 # Add error handling safe_function &lt;- function(f, default = NULL) { function(...) { tryCatch( f(...), error = function(e) { message(&quot;Error occurred: &quot;, e$message) default } ) } } safe_log &lt;- safe_function(log, default = NA) safe_log(10) #&gt; [1] 2.302585 safe_log(-1) # Returns NA instead of error #&gt; Warning in f(...): NaNs produced #&gt; [1] NaN 56.4 Memoization üéØ Best Practice: Cache Results # Memoize slow functions memoize &lt;- function(f) { cache &lt;- new.env(parent = emptyenv()) function(...) { key &lt;- paste(..., sep = &quot;_&quot;) if (!exists(key, envir = cache)) { cache[[key]] &lt;- f(...) } cache[[key]] } } # Slow function fibonacci &lt;- function(n) { if (n &lt;= 1) return(n) fibonacci(n - 1) + fibonacci(n - 2) } # Fast version with memoization fibonacci_memo &lt;- memoize(fibonacci) system.time(fibonacci(30)) #&gt; user system elapsed #&gt; 0.769 0.014 0.783 system.time(fibonacci_memo(30)) # Much faster on repeat #&gt; user system elapsed #&gt; 0.746 0.002 0.749 56.5 Real-World Applications # 1. Create family of similar functions make_adder &lt;- function(n) { function(x) x + n } add_10 &lt;- make_adder(10) add_100 &lt;- make_adder(100) add_10(5) #&gt; [1] 15 add_100(5) #&gt; [1] 105 # 2. Configure behavior make_filter &lt;- function(pattern) { function(x) { grep(pattern, x, value = TRUE) } } filter_r &lt;- make_filter(&quot;^r&quot;) filter_r(c(&quot;apple&quot;, &quot;rose&quot;, &quot;banana&quot;, &quot;ruby&quot;)) #&gt; [1] &quot;rose&quot; &quot;ruby&quot; # 3. Delayed computation make_lazy &lt;- function(expr) { computed &lt;- FALSE value &lt;- NULL function() { if (!computed) { value &lt;&lt;- expr computed &lt;&lt;- TRUE } value } } # Computation only happens when called get_data &lt;- make_lazy({ cat(&quot;Computing...\\n&quot;) rnorm(1000) }) # First call computes data &lt;- get_data() #&gt; Computing... # Subsequent calls use cached value data2 &lt;- get_data() # No &quot;Computing...&quot; message 56.6 Common Patterns üéØ Best Practice: Common Factory Patterns # 1. Partial application partial &lt;- function(f, ...) { args &lt;- list(...) function(...) { do.call(f, c(args, list(...))) } } # Create specialized version divide_by_10 &lt;- partial(`/`, e2 = 10) divide_by_10(100) #&gt; [1] 0.1 # 2. Compose functions compose &lt;- function(f, g) { function(...) { f(g(...)) } } # sqrt(abs(x)) sqrt_abs &lt;- compose(sqrt, abs) sqrt_abs(-16) #&gt; [1] 4 # 3. Negate predicate negate &lt;- function(f) { function(...) { !f(...) } } is_not_na &lt;- negate(is.na) is_not_na(c(1, NA, 3)) #&gt; [1] TRUE FALSE TRUE 56.7 Summary Key Takeaways: Function factories - Functions that create functions Closures - Capture environment Function operators - Modify function behavior Practical uses - Validation, logging, memoization Composition - Build complex from simple Quick Reference: # Factory make_power &lt;- function(n) { function(x) x^n } # Operator add_logging &lt;- function(f) { function(...) { cat(&quot;Calling\\n&quot;) f(...) } } # Composition compose &lt;- function(f, g) { function(...) f(g(...)) } # Partial application partial &lt;- function(f, ...) { args &lt;- list(...) function(...) do.call(f, c(args, list(...))) } # Memoization memoize &lt;- function(f) { cache &lt;- new.env() function(...) { key &lt;- paste(...) if (!exists(key, cache)) cache[[key]] &lt;- f(...) cache[[key]] } } Common Applications: # ‚úÖ Good uses Validators (in_range, matches_pattern) Adders (add_10, multiply_by) Loggers (add_logging) Error handlers (make_safe) Memoizers (cache results) # ‚ùå Avoid Over-complicating simple code When direct function is clearer Excessive abstraction 56.8 Exercises üìù Exercise 1: Temperature Converter Factory Create a factory that makes temperature converters: - to_fahrenheit() - Celsius to Fahrenheit - to_celsius() - Fahrenheit to Celsius - to_kelvin() - Celsius to Kelvin üìù Exercise 2: Timing Function Operator Create a function operator that times how long a function takes: - Prints execution time - Returns the result - Works with any function 56.9 Exercise Answers Click to see answers Exercise 1: # Temperature converter factory make_temp_converter &lt;- function(formula) { function(temp) { formula(temp) } } # Create converters to_fahrenheit &lt;- make_temp_converter(function(c) c * 9/5 + 32) to_celsius &lt;- make_temp_converter(function(f) (f - 32) * 5/9) to_kelvin &lt;- make_temp_converter(function(c) c + 273.15) # Test to_fahrenheit(0) # 32 #&gt; [1] 32 to_celsius(32) # 0 #&gt; [1] 0 to_kelvin(0) # 273.15 #&gt; [1] 273.15 Exercise 2: # Timing operator add_timing &lt;- function(f) { function(...) { start &lt;- Sys.time() result &lt;- f(...) end &lt;- Sys.time() cat(&quot;Execution time:&quot;, format(difftime(end, start, units = &quot;secs&quot;)), &quot;\\n&quot;) result } } # Test slow_sum &lt;- function(n) { total &lt;- 0 for (i in 1:n) total &lt;- total + i total } timed_sum &lt;- add_timing(slow_sum) timed_sum(1000000) #&gt; Execution time: 0.01964903 secs #&gt; [1] 500000500000 56.10 Completion Part XVII Complete! You‚Äôve mastered advanced R programming: - S3 object system - R6 and S4 - Non-standard evaluation - Rcpp integration - Function factories Ready for: Production R development! "],["error-dictionary.html", "A Complete Error Dictionary (A-Z) A.1 A A.2 B A.3 C A.4 D A.5 E A.6 F A.7 G A.8 I A.9 L A.10 M A.11 N A.12 O A.13 P A.14 R A.15 S A.16 T A.17 U A.18 V A.19 W A.20 X-Z A.21 Notes on Using This Dictionary A.22 Can‚Äôt Find Your Error? A.23 Contributing Error Definitions", " A Complete Error Dictionary (A-Z) This appendix provides an alphabetical quick reference of all errors covered in the book. Each entry includes: Error message Chapter reference Quick fix Difficulty level Use Ctrl+F (Cmd+F on Mac) to search for specific error text. A.1 A A.1.1 All aesthetics have length 1, but data has X rows Package: ggplot2 Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Pass a data frame to ggplot(), not individual vectors Example: # Wrong: ggplot() + geom_point(aes(x = 1:10, y = 1:10)) # Right: df &lt;- data.frame(x = 1:10, y = 1:10) ggplot(df) + geom_point(aes(x, y)) A.1.2 argument \"x\" is missing, with no default Package: base Chapter: ?? Difficulty: ‚≠ê Quick Fix: Provide the required argument or set a default value Example: # Function needs argument: my_func &lt;- function(x) { x + 1 } my_func() # Error! # Fix: provide it: my_func(5) # Or give it a default: my_func &lt;- function(x = 0) { x + 1 } A.1.3 argument is not interpretable as logical Package: base Chapter: 18 Difficulty: ‚≠ê Quick Fix: Ensure condition evaluates to TRUE/FALSE Example: # Wrong: if (&quot;yes&quot;) { } # Character not logical # Right: if (TRUE) { } A.1.4 argument is of length zero Package: base Chapter: 18 Difficulty: ‚≠ê‚≠ê Quick Fix: Check for empty vectors before using in if() Example: x &lt;- numeric(0) if (x &gt; 5) { } # Error! # Fix: if (length(x) &gt; 0 &amp;&amp; x &gt; 5) { } A.1.5 arguments imply differing number of rows: X, Y Package: base Chapter: 9 Difficulty: ‚≠ê Quick Fix: Ensure all columns have same length or use recycling explicitly Example: # Wrong: data.frame(a = 1:5, b = 1:3) # Error! # Right: data.frame(a = 1:5, b = rep(1:3, length.out = 5)) A.2 B A.2.1 bytecode version mismatch Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Reinstall packages after R update A.2.2 by must specify column(s) as numbers, names or logical Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Check merge/aggregate by argument format A.3 C A.3.1 Can't combine &lt;type1&gt; and &lt;type2&gt; Package: dplyr Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Convert columns to compatible types before combining Example: # If binding rows with incompatible types: df1 &lt;- data.frame(x = 1:5) df2 &lt;- data.frame(x = letters[1:5]) bind_rows(df1, df2) # Error! # Fix: make types consistent df2$x &lt;- as.character(df2$x) A.3.2 Can't rename columns that don't exist Package: dplyr Chapter: ?? Difficulty: ‚≠ê Quick Fix: Check column name spelling A.3.3 Can't subset columns that don't exist Package: dplyr Chapter: ?? Difficulty: ‚≠ê Quick Fix: Verify column names with names() or colnames() A.3.4 cannot allocate vector of size X Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Reduce data size, use data.table, or add RAM See also: Memory management techniques in Chapter ?? A.3.5 cannot change value of locked binding for 'X' Package: base Chapter: 3 Difficulty: ‚≠ê Quick Fix: Don‚Äôt try to reassign T, F, or other protected objects A.3.6 cannot change working directory Package: base Chapter: 2 Difficulty: ‚≠ê Quick Fix: Check path exists and you have permission A.3.7 cannot coerce class \"X\" to a data.frame Package: base Chapter: 4 Difficulty: ‚≠ê‚≠ê Quick Fix: Convert object to appropriate type first A.3.8 cannot open file 'X': No such file or directory Package: base Chapter: 2 Difficulty: ‚≠ê Quick Fix: Check file path and working directory with getwd() See also: File path best practices in Chapter 2 A.3.9 cannot open the connection Package: base Chapter: 2 Difficulty: ‚≠ê‚≠ê Quick Fix: Close file in other programs, check file path A.3.10 character string is not in a standard unambiguous format Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Specify date format explicitly with format argument A.3.11 column 'X' not found Package: various Chapter: 10 Difficulty: ‚≠ê Quick Fix: Check spelling and use names(data) to verify A.3.12 contexts stack overflow Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Check for infinite recursion A.3.13 contrasts can be applied only to factors with 2 or more levels Package: stats Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Check factor has multiple levels or convert to numeric A.3.14 could not find function \"X\" Package: base Chapter: 3 Difficulty: ‚≠ê Quick Fix: Load required package with library() or use package::function() See also: Package management in Chapter ?? A.4 D A.4.1 do not know how to convert 'X' to class \"Date\" Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Use proper date parsing function like as.Date() with format A.4.2 duplicate row.names are not allowed Package: base Chapter: 9 Difficulty: ‚≠ê‚≠ê Quick Fix: Ensure row names are unique or use row.names = FALSE A.5 E A.5.1 embedded nul in string Package: base Chapter: 2 Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: File is corrupted or binary; re-download or clean data A.5.2 ERROR: dependency 'X' is not available Package: utils Chapter: 1 Difficulty: ‚≠ê‚≠ê Quick Fix: Install with dependencies = TRUE or install dependency first A.5.3 Error in library(X) : there is no package called 'X' Package: base Chapter: 1 Difficulty: ‚≠ê Quick Fix: Install package first: install.packages(\"X\") A.5.4 evaluation nested too deeply Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Increase options(expressions = ...) or fix infinite recursion A.6 F A.6.1 Faceting variables must have at least one value Package: ggplot2 Chapter: 27 Difficulty: ‚≠ê‚≠ê Quick Fix: Remove empty factor levels or NA values A.6.2 figure margins too large Package: graphics Chapter: ?? Difficulty: ‚≠ê Quick Fix: Increase plot window size or adjust par(mar = ...) A.6.3 formal argument \"X\" matched by multiple actual arguments Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Don‚Äôt provide same argument twice (by name and position) A.7 G A.7.1 geom_X requires the following missing aesthetics: Y Package: ggplot2 Chapter: ?? Difficulty: ‚≠ê Quick Fix: Provide required aesthetic mapping A.7.2 glm.fit: algorithm did not converge Package: stats Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Increase iterations, check data scaling, simplify model A.8 I A.8.1 incomplete final line found Package: base Chapter: 2 Difficulty: ‚≠ê Quick Fix: Usually harmless; add newline to file or use readr A.8.2 incorrect number of dimensions Package: base Chapter: 7 Difficulty: ‚≠ê Quick Fix: Check object dimensions with dim() or str() A.8.3 incorrect number of subscripts on matrix Package: base Chapter: 7 Difficulty: ‚≠ê Quick Fix: Use correct number of indices [row, col] A.8.4 installation of package 'X' had non-zero exit status Package: utils Chapter: 1 Difficulty: ‚≠ê‚≠ê Quick Fix: Check error details, ensure dependencies installed A.8.5 invalid factor level, NA generated Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Add new levels to factor before assigning A.8.6 invalid multibyte string Package: base Chapter: 2 Difficulty: ‚≠ê‚≠ê Quick Fix: Specify file encoding: fileEncoding = \"UTF-8\" A.9 L A.9.1 lazy-load database 'X' is corrupt Package: base Chapter: 1 Difficulty: ‚≠ê‚≠ê Quick Fix: Reinstall the package A.9.2 longer object length is not a multiple of shorter object length Package: base Chapter: 5 Difficulty: ‚≠ê Quick Fix: Ensure vectors have compatible lengths A.10 M A.10.1 missing value where TRUE/FALSE needed Package: base Chapter: 6 Difficulty: ‚≠ê Quick Fix: Handle NA values before using in if() or logic A.10.2 more columns than column names Package: base Chapter: 33 Difficulty: ‚≠ê‚≠ê Quick Fix: Check CSV delimiter, specify sep argument A.11 N A.11.1 NAs introduced by coercion Package: base Chapter: 4 Difficulty: ‚≠ê Quick Fix: Check data before converting; can‚Äôt convert ‚Äúabc‚Äù to number A.11.2 need finite 'xlim' values Package: graphics Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Remove infinite or NA values from data A.11.3 no applicable method for 'X' applied to an object of class \"Y\" Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Object type doesn‚Äôt work with that function; convert or use different function A.11.4 non-conformable arrays Package: base Chapter: 11 Difficulty: ‚≠ê‚≠ê Quick Fix: Ensure matrix dimensions match for operation A.11.5 non-numeric argument to binary operator Package: base Chapter: 4 Difficulty: ‚≠ê Quick Fix: Convert character to numeric before math operations A.12 O A.12.1 object 'X' not found Package: base Chapter: 3 Difficulty: ‚≠ê Quick Fix: Check spelling, ensure object created, load package if needed Most Common Error: See Chapter 3 for comprehensive guide A.12.2 object of type 'closure' is not subsettable Package: base Chapter: 3 Difficulty: ‚≠ê‚≠ê Quick Fix: Add () to call function, or you referenced function name instead of object A.13 P A.13.1 package 'X' is not available for R version Y Package: utils Chapter: 1 Difficulty: ‚≠ê‚≠ê Quick Fix: Update R or install from archive A.13.2 package 'X' was built before R 4.0.0 Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Reinstall package A.13.3 pandoc document conversion failed Package: rmarkdown Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Check pandoc installation, update RStudio A.13.4 plot.new has not been called yet Package: graphics Chapter: ?? Difficulty: ‚≠ê Quick Fix: Create plot before adding elements A.13.5 promise already under evaluation Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Circular dependency in default arguments; break the cycle A.13.6 protect(): protection stack overflow Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Simplify code, reduce nested calls, restart R A.14 R A.14.1 rank-deficient fit may be misleading Package: stats Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Remove collinear predictors, check for perfect correlation A.14.2 recursive indexing failed at level X Package: base Chapter: 8 Difficulty: ‚≠ê‚≠ê Quick Fix: List element doesn‚Äôt exist or check index depth A.14.3 Removed X rows containing missing values Package: ggplot2 Chapter: ?? Difficulty: ‚≠ê Quick Fix: Handle NA values or acknowledge they‚Äôre being dropped A.14.4 replacement has X rows, data has Y Package: base Chapter: 7 Difficulty: ‚≠ê‚≠ê Quick Fix: Ensure replacement vector matches subset size A.14.5 Rtools is required to build R packages but is not currently installed Package: utils Chapter: 1 Difficulty: ‚≠ê‚≠ê Quick Fix: Install Rtools (Windows) or use binary packages A.15 S A.15.1 stat_count() must not be used with a y aesthetic Package: ggplot2 Chapter: ?? Difficulty: ‚≠ê Quick Fix: Use geom_col() instead of geom_bar() when providing y values A.15.2 subscript out of bounds Package: base Chapter: 7 Difficulty: ‚≠ê Quick Fix: Index is too large; check object length/dimensions A.15.3 system is computationally singular Package: base Chapter: 11 Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: Matrix not invertible; check for zero determinant A.16 T A.16.1 the condition has length &gt; 1 Package: base Chapter: 18 Difficulty: ‚≠ê‚≠ê Quick Fix: Use any() or all(), or use &amp;&amp; instead of &amp; A.16.2 there is no package called 'X' Package: base Chapter: 1 Difficulty: ‚≠ê Quick Fix: Install package first A.17 U A.17.1 unable to access index for repository Package: utils Chapter: 1 Difficulty: ‚≠ê Quick Fix: Check internet connection, try different CRAN mirror A.17.2 undefined columns selected Package: base Chapter: 10 Difficulty: ‚≠ê Quick Fix: Check column name spelling A.17.3 unexpected '=' in \"X\" Package: base Chapter: 3 Difficulty: ‚≠ê Quick Fix: Use &lt;- for assignment or == for comparison A.17.4 unexpected symbol in \"X\" Package: base Chapter: 3 Difficulty: ‚≠ê Quick Fix: Remove spaces from variable names, add missing operators A.17.5 unused argument (X = Y) Package: base Chapter: ?? Difficulty: ‚≠ê Quick Fix: Remove incorrect argument or check function documentation A.18 V A.18.1 variable 'X' has no visible binding Package: base Chapter: ?? Difficulty: ‚≠ê‚≠ê‚≠ê Quick Fix: R CMD check issue; use .data$ pronoun or declare global A.18.2 variable lengths differ Package: stats Chapter: ?? Difficulty: ‚≠ê‚≠ê Quick Fix: Ensure all variables in formula have same length A.19 W A.19.1 Warning in install.packages : unable to access index Package: utils Chapter: 1 Difficulty: ‚≠ê Quick Fix: Check internet, try different mirror A.20 X-Z [Additional errors as needed] A.21 Notes on Using This Dictionary Error text matching: Some errors have variables (like ‚ÄòX‚Äô, ‚ÄòY‚Äô) that will show actual values Package column: Indicates which package generates the error Difficulty: ‚≠ê = Common beginner, ‚≠ê‚≠ê‚≠ê = Advanced/rare Quick Fix: First thing to try; full details in referenced chapter See also: Links to related errors and concepts A.22 Can‚Äôt Find Your Error? Use the index at the beginning of book Search within relevant chapter (e.g., all ggplot errors in ggplot chapter) Check Appendix D for package-specific errors Search complete book text (Ctrl+F in HTML version) Post on Stack Overflow with [r] tag Ask on RStudio Community A.23 Contributing Error Definitions Found an error not listed? Submit it via GitHub issues at [repo-link] "],["references.html", "References A.24 Core R Documentation A.25 Package Documentation A.26 Online Resources A.27 Books A.28 Style Guides A.29 Debugging Resources A.30 Error Message Databases", " References This section contains all references cited throughout the book. A.24 Core R Documentation R Core Team (2024). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/. A.25 Package Documentation [Auto-generated from packages.bib] A.26 Online Resources Stack Overflow R Questions: https://stackoverflow.com/questions/tagged/r RStudio Community: https://community.rstudio.com/ R-help Mailing List: https://stat.ethz.ch/mailman/listinfo/r-help CRAN Task Views: https://cran.r-project.org/web/views/ A.27 Books Wickham, H. (2019). Advanced R, Second Edition. Chapman and Hall/CRC. Wickham, H., &amp; Grolemund, G. (2017). R for Data Science. O‚ÄôReilly Media. Chambers, J. M. (2016). Extending R. Chapman and Hall/CRC. Venables, W. N., &amp; Ripley, B. D. (2002). Modern Applied Statistics with S. Springer. A.28 Style Guides Tidyverse Style Guide: https://style.tidyverse.org/ Google‚Äôs R Style Guide: https://google.github.io/styleguide/Rguide.html A.29 Debugging Resources RStudio Debugging Documentation: https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio R-bloggers Debugging Articles: https://www.r-bloggers.com/tag/debugging/ A.30 Error Message Databases Stack Overflow Common R Errors: https://stackoverflow.com/questions/tagged/r+error-handling R FAQ: https://cran.r-project.org/doc/FAQ/R-FAQ.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

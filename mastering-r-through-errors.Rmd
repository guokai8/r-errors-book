---
title: "Mastering R Through Errors and Warnings"
subtitle: "A Comprehensive Guide to Learning R by Understanding What Goes Wrong"
author: "Kai Guo"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
description: "Learn R by understanding errors and warnings. This comprehensive guide organizes R learning around the errors you'll encounter, helping you not just fix them, but truly understand R's behavior."
url: 'https://guokai8.github.io/r-errors-book'
github-repo: guokai8/r-errors-book
cover-image: images/cover.png
---

# Welcome {-}

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  error = TRUE,  # Allow errors to be shown
  warning = TRUE,
  message = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = FALSE,
  out.width = "100%",
  fig.align = "center",
  fig.width = 7,
  fig.asp = 0.618,  # Golden ratio
  fig.show = "hold"
)

# Set options for error display
options(
  width = 80,
  max.print = 100,
  warnPartialMatchArgs = TRUE,
  warnPartialMatchAttr = TRUE,
  warnPartialMatchDollar = TRUE
)

# Custom error/warning/message styling functions
error_box <- function(text) {
  cat(paste0('<div class="error-box">üî¥ **ERROR**\n\n```\n', text, '\n```\n</div>'))
}

warning_box <- function(text) {
  cat(paste0('<div class="warning-box">üü° **WARNING**\n\n```\n', text, '\n```\n</div>'))
}

message_box <- function(text) {
  cat(paste0('<div class="message-box">üîµ **MESSAGE**\n\n```\n', text, '\n```\n</div>'))
}

solution_box <- function(text) {
  cat(paste0('<div class="solution-box">‚úÖ **SOLUTION**\n\n', text, '\n</div>'))
}
```

## Why This Book Exists {-}

**You will make errors in R. Lots of them.**

That's not a prediction‚Äîit's a promise. And it's exactly how learning works.

Most R books teach you how to do things *right*. This book teaches you what happens when things go *wrong*, because:

1. **You learn more from errors than successes** - Each error is a teaching moment
2. **Errors reveal R's internal logic** - Understanding why something fails helps you understand how R thinks
3. **You'll spend more time debugging than writing new code** - Better to learn it systematically
4. **Error messages are often cryptic** - But they follow patterns once you know what to look for

## How This Book Works {-}

### The Error-First Approach {-}

Each chapter follows this structure:

1. **Show the error/warning** - You'll see it in a red/yellow box
2. **Explain what causes it** - The underlying R behavior
3. **Demonstrate the solution** - Multiple approaches when applicable
4. **Provide practice problems** - Intentionally broken code for you to fix

### Organization System {-}

We use visual indicators throughout:

- üî¥ **ERROR**: Stops execution completely
- üü° **WARNING**: Continues but alerts you to potential issues
- üîµ **MESSAGE**: Informational only
- ‚úÖ **SOLUTION**: The fix

**Difficulty Levels:**

- ‚≠ê Beginner - Everyone encounters these
- ‚≠ê‚≠ê Intermediate - Common with experience
- ‚≠ê‚≠ê‚≠ê Advanced - Edge cases and complex scenarios

**Error Categories:**

- üî§ Syntax/Typo
- üì¶ Package Issue
- üî¢ Type Mismatch
- üìè Dimension/Length
- üíæ File/Path
- üßÆ Mathematical
- üîó Scoping/Environment

## Who This Book Is For {-}

- **Complete beginners** who want to understand R deeply from the start
- **Self-taught R users** who've been "googling errors" and want systematic knowledge
- **Python/MATLAB/SAS users** transitioning to R and confused by its quirks
- **Data scientists** who use R daily but want to master debugging
- **Teachers** looking for a new pedagogical approach

## What You'll Need {-}

- R (version 4.0 or higher recommended)
- RStudio (latest version)
- Patience and curiosity
- Willingness to intentionally break things

## Book Structure {-}

This book is organized into 16 parts:

**Part I: Foundation & Environment** - Installation, paths, basic objects

**Part II: Data Types & Coercion** - Understanding R's type system through errors

**Part III: Indexing & Subsetting** - The most common source of errors

**Part IV: Data Frames & Matrices** - Rectangular data structures

**Part V: Factors** - R's most misunderstood data type

**Part VI: Strings & Characters** - Text manipulation errors

**Part VII: Functions & Programming** - Control flow and function errors

**Part VIII: Data Manipulation** - base R, tidyverse, and data.table

**Part IX: Graphics** - Base graphics and ggplot2 errors

**Part X: Statistical Operations** - Math and modeling errors

**Part XI: File I/O** - Reading and writing data

**Part XII: Packages & Namespaces** - Installation and loading issues

**Part XIII: Memory & Performance** - Resource limitations

**Part XIV: Date/Time** - Temporal data challenges

**Part XV: Advanced Topics** - OOP, parallel processing, Shiny, etc.

**Part XVI: Debugging & Best Practices** - Tools and strategies

## Conventions Used {-}

### Code Blocks {-}

Code that produces an error:

```{r eval=FALSE}
# This will error
x <- c(1, 2, 3)
x[5]  # Subscript out of bounds? No! It returns NA
```

Expected output or error:

```
#> [1] NA
```

### Icons and Symbols {-}

- `üí°` Key insight
- `‚ö†Ô∏è` Common pitfall
- `üéØ` Best practice
- `üîç` Deep dive
- `üìù` Exercise
- `üöÄ` Performance tip

## Companion Materials {-}

All code is available at: [github.com/guokai8/r-errors-book](https://github.com/guokai8/r-errors-book)

- Practice datasets
- Additional exercises
- Error reference cards
- Community forum for questions

## How to Read This Book {-}

### For Beginners {-}

Read sequentially. Part I and II are foundational. Don't skip ahead‚Äîthe errors build on each other.

### For Intermediate Users {-}

Use the error index (Appendix A) to find specific errors, but read the related chapters for context.

### For Advanced Users {-}

Focus on Parts VIII-XV for package-specific and advanced errors. The appendices are your quick reference.

### For Teachers {-}

Each chapter has exercises at the end. The "Try It Yourself" sections contain intentionally broken code for students to fix.

## Acknowledgments {-}

This book wouldn't exist without the thousands of confused R users who've posted their errors on Stack Overflow, the R-help mailing list, and various forums. Every error message in this book has frustrated someone‚Äîprobably multiple people. This is for all of us.

## Feedback {-}

Find an error in the book about errors? See an error we haven't covered? Open an issue on GitHub or email [guokai8@gmail.com](mailto:guokai8@gmail.com).

---

**Now, let's start breaking things...**

```{r include=FALSE}
# Automatically create a bib database for R packages used
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'tidyverse', 
  'data.table', 'ggplot2', 'dplyr', 'readr'
), 'packages.bib')
```

<!--chapter:end:index.Rmd-->

# Part I: Foundation & Environment {-}

# Installation & Environment Setup {#installation-environment}

<div class="chapter-summary">
**What You'll Learn:**

- Package installation errors and how to fix them
- Understanding repository and connection issues
- Compilation errors on different operating systems
- Version compatibility problems

**Key Errors Covered:** 15+ installation-related errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Before you can make interesting errors in R, you need to install R and packages. Unfortunately, this is where many learners encounter their first frustrations. Installation errors are particularly annoying because they prevent you from even starting.

The good news: most installation errors follow predictable patterns and have standard solutions.

## Error #1: Package Installation Failed {#pkg-install-failed}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r eval=FALSE}
install.packages("ggplot2")
```

<div class="error-box">
üî¥ **ERROR**

```
Warning in install.packages :
  installation of package 'ggplot2' had non-zero exit status
```
</div>

### What It Means

The installation process failed at some point. This is a generic error that can have many causes.

### Common Causes and Solutions

#### Cause 1: No Internet Connection

**Symptom:** Cannot reach CRAN mirror

<div class="solution-box">
‚úÖ **SOLUTION**

1. Check your internet connection
2. Try a different CRAN mirror:
```{r eval=FALSE}
# See available mirrors
getCRANmirrors()

# Set a specific mirror
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Then try again
install.packages("ggplot2")
```
</div>

#### Cause 2: Firewall or Proxy

**Symptom:** Connection times out

<div class="solution-box">
‚úÖ **SOLUTION**

```{r eval=FALSE}
# Configure proxy (if behind corporate firewall)
Sys.setenv(http_proxy = "http://proxy.company.com:8080")
Sys.setenv(https_proxy = "https://proxy.company.com:8080")

# Or download package manually and install from file
install.packages("path/to/package.tar.gz", repos = NULL, type = "source")
```
</div>

#### Cause 3: Insufficient Permissions

**Symptom:** Permission denied errors on Windows/Mac/Linux

<div class="solution-box">
‚úÖ **SOLUTION**

**On Windows:**
- Run RStudio as Administrator
- Or install to user library:

```{r eval=FALSE}
# Check library paths
.libPaths()

# Install to user library (first in list)
install.packages("ggplot2", lib = .libPaths()[1])
```

**On Mac/Linux:**
```{bash eval=FALSE}
# If needed, create user library directory
mkdir -p ~/R/library
```

```{r eval=FALSE}
# Then set it in R
.libPaths(c("~/R/library", .libPaths()))
install.packages("ggplot2")
```
</div>

#### Cause 4: Disk Space

**Symptom:** No space left on device

<div class="solution-box">
‚úÖ **SOLUTION**

1. Check disk space
2. Clean up old packages:
```{r eval=FALSE}
# See what's installed
installed.packages()[, c("Package", "Version")]

# Remove old packages
remove.packages("old_package_name")

# Clean up temporary files
unlink(tempdir(), recursive = TRUE)
```
</div>

## Error #2: Unable to Access Index for Repository {#repo-access}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r eval=FALSE}
install.packages("dplyr")
```

<div class="warning-box">
üü° **WARNING**

```
Warning: unable to access index for repository https://cran.rstudio.com/src/contrib
  cannot open URL 'https://cran.rstudio.com/src/contrib/PACKAGES'
```
</div>

### What It Means

R cannot reach the CRAN repository to download package information.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Check CRAN status:**
- Visit https://cran.r-project.org/ in browser
- If down, try different mirror

**2. Change repository:**
```{r eval=FALSE}
# Use RStudio's mirror
options(repos = c(CRAN = "https://cloud.r-project.org"))

# Or choose interactively
chooseCRANmirror()
```

**3. Force HTTP instead of HTTPS:**
```{r eval=FALSE}
# If SSL issues
options(repos = c(CRAN = "http://cran.r-project.org"))
```

**4. Check .Rprofile:**
```{r eval=FALSE}
# See if repos are hardcoded
file.edit("~/.Rprofile")
# Remove or update any repos settings
```
</div>

## Error #3: Package Not Available for R Version {#version-mismatch}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r eval=FALSE}
install.packages("newpackage")
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
package 'newpackage' is not available for R version 4.0.0
```
</div>

### What It Means

The package either:
1. Requires a newer R version
2. Is not on CRAN (wrong name or removed)
3. Has been archived

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Check R version:**
```{r}
R.version.string
```

**2. Update R if needed:**
- Download from https://cran.r-project.org/
- Or use `installr` package (Windows):
```{r eval=FALSE}
install.packages("installr")
installr::updateR()
```

**3. Check package name:**
```{r eval=FALSE}
# Search for package
available.packages()[grep("package_name", 
                          available.packages()[, "Package"]), ]
```

**4. Install from archive:**
```{r eval=FALSE}
# If package was archived
packageurl <- "https://cran.r-project.org/src/contrib/Archive/package/package_1.0.tar.gz"
install.packages(packageurl, repos = NULL, type = "source")
```

**5. Install from GitHub:**
```{r eval=FALSE}
# Many packages in development
install.packages("devtools")
devtools::install_github("author/package")
```
</div>

<div class="insight-box">
üí° **Key Insight: Package Lifecycle**

Packages can be:
- **On CRAN**: Current and maintained
- **Archived**: Old version still available but removed from current CRAN
- **On GitHub only**: Development version or not submitted to CRAN
- **Superseded**: Replaced by another package (e.g., `reshape` ‚Üí `reshape2` ‚Üí `tidyr`)
</div>

## Error #4: Dependencies Not Available {#dependencies}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r eval=FALSE}
install.packages("complexpackage")
```

<div class="error-box">
üî¥ **ERROR**

```
ERROR: dependencies 'pkgA', 'pkgB' are not available for package 'complexpackage'
```
</div>

### What It Means

The package needs other packages (dependencies) that aren't available or can't be installed.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Install dependencies first:**
```{r eval=FALSE}
# R usually does this automatically, but sometimes fails
install.packages("pkgA")
install.packages("pkgB")
install.packages("complexpackage")
```

**2. Force dependency installation:**
```{r eval=FALSE}
install.packages("complexpackage", dependencies = TRUE)
```

**3. Check for Bioconductor packages:**
```{r eval=FALSE}
# Some dependencies are on Bioconductor, not CRAN
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("dependencyPackage")
```

**4. Manual dependency resolution:**
```{r eval=FALSE}
# See what's needed
tools::package_dependencies("complexpackage", recursive = TRUE)

# Install each one
sapply(deps, install.packages)
```
</div>

## Error #5: Lazy Loading Failed {#lazy-load}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r eval=FALSE}
library(ggplot2)
```

<div class="error-box">
üî¥ **ERROR**

```
Error: package or namespace load failed for 'ggplot2':
 .onLoad failed in loadNamespace() for 'ggplot2', details:
  call: NULL
  error: lazy-load database 'path/to/ggplot2/R/ggplot2.rdb' is corrupt
```
</div>

### What It Means

The package installation is corrupted or incomplete.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Reinstall the package:**
```{r eval=FALSE}
remove.packages("ggplot2")
install.packages("ggplot2")
```

**2. Restart R session:**
```{r eval=FALSE}
# In RStudio: Session > Restart R
.rs.restartR()

# Or from command line
q()  # Then restart R
```

**3. Check for partial installation:**
```{r eval=FALSE}
# See package status
library(ggplot2)
packageVersion("ggplot2")

# Compare to CRAN version
available.packages()["ggplot2", "Version"]
```

**4. Install from source:**
```{r eval=FALSE}
install.packages("ggplot2", type = "source")
```

**5. Clear package cache:**
```{r eval=FALSE}
# Sometimes helps
unlink(.libPaths()[1], recursive = TRUE)
dir.create(.libPaths()[1])
install.packages("ggplot2")
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Interrupted Installation**

If you interrupt package installation (Ctrl+C or ESC):
1. The package may be partially installed
2. Loading it will fail with lazy-load errors
3. Always reinstall after interruption

**Prevention:**
- Let installations complete
- If it's taking too long, check your internet connection first
</div>

## Error #6: Package Built Under R Version {#version-built}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Warning

```{r eval=FALSE}
library(dplyr)
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
package 'dplyr' was built under R version 4.2.3
```
</div>

### What It Means

You're using R 4.2.0, but the package was compiled for R 4.2.3. Usually this is fine, but can cause issues.

### Should You Worry?

**Usually NO** - Minor version differences (4.2.0 vs 4.2.3) rarely cause problems.

**Maybe YES** - If you experience:
- Strange errors from that package
- Crashes
- Unexpected behavior

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Ignore it (usually fine):**
Most of the time, this warning is harmless.

**2. Update R:**
```{r eval=FALSE}
# Check your version
R.version

# Update if significantly behind
# Windows: use installr
# Mac: download from CRAN
# Linux: use system package manager
```

**3. Reinstall package from source:**
```{r eval=FALSE}
install.packages("dplyr", type = "source")
```

**4. Suppress warning:**
```{r eval=FALSE}
# Only if you're sure it's fine
suppressWarnings(library(dplyr))

# Or globally
options(warn = -1)  # Not recommended!
```
</div>

## Error #7: Rtools Required But Not Installed {#rtools}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

**Platform:** Windows only

### The Warning

```{r eval=FALSE}
install.packages("package_with_cpp", type = "source")
```

<div class="warning-box">
üü° **WARNING**

```
WARNING: Rtools is required to build R packages but is not currently installed.
Please download and install Rtools from https://cran.r-project.org/bin/windows/Rtools/
```
</div>

### What It Means

You're trying to install a package that needs compilation (C/C++/Fortran code), but Windows doesn't have the necessary compilers.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Install binary instead:**
```{r eval=FALSE}
# Use pre-compiled version
install.packages("package_name")  # default uses binary
```

**2. Install Rtools:**
1. Download from https://cran.r-project.org/bin/windows/Rtools/
2. Run installer (default options usually work)
3. Restart R/RStudio
4. Verify installation:

```{r eval=FALSE}
Sys.which("make")
# Should show path like: C:\\rtools43\\usr\\bin\\make.exe
```

**3. Configure PATH:**
Sometimes Rtools doesn't add itself to PATH:

```{r eval=FALSE}
# Add to .Renviron
writeLines('PATH="${RTOOLS43_HOME}\\usr\\bin;${PATH}"', 
           con = "~/.Renviron")

# Restart R
.rs.restartR()
```
</div>

<div class="insight-box">
üí° **Key Insight: Source vs Binary Packages**

**Binary packages:**
- Pre-compiled for your OS
- Fast to install
- Can't modify source code

**Source packages:**
- Raw R + C/C++ code
- Requires compilation tools
- Necessary for package development
- Sometimes more up-to-date

**On Windows:** Use binaries unless you need source
**On Mac/Linux:** Source compilation more common
</div>

## Error #8: Library Not Found for -lX {#library-not-found}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

**Platform:** Mac/Linux

### The Error

```{r eval=FALSE}
install.packages("XML")
```

<div class="error-box">
üî¥ **ERROR**

```
ld: library not found for -lxml2
clang: error: linker command failed with exit code 1
```
</div>

### What It Means

The package requires external libraries (system dependencies) that aren't installed.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**Mac (using Homebrew):**
```{bash eval=FALSE}
# Install Homebrew if needed
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Install required library
brew install libxml2

# Then in R
install.packages("XML")
```

**Ubuntu/Debian:**
```{bash eval=FALSE}
sudo apt-get update
sudo apt-get install libxml2-dev
```

**Fedora/RedHat:**
```{bash eval=FALSE}
sudo yum install libxml2-devel
```

**Common Dependencies:**
```{bash eval=FALSE}
# For common R packages
# Ubuntu/Debian:
sudo apt-get install \
  libcurl4-openssl-dev \
  libssl-dev \
  libxml2-dev \
  libgit2-dev \
  libharfbuzz-dev \
  libfribidi-dev

# Mac:
brew install libgit2 openssl libxml2
```
</div>

<div class="bestpractice-box">
üéØ **Best Practice: Document System Requirements**

If you're sharing code that requires specific packages:

```{r eval=FALSE}
# Create a requirements file
cat("# System requirements (Ubuntu/Debian):
# sudo apt-get install libcurl4-openssl-dev libssl-dev

# R packages:
required_packages <- c('dplyr', 'ggplot2', 'readr')
install.packages(required_packages)
", file = "requirements.txt")
```
</div>

## Error #9: Replacing Previous Import {#replacing-import}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Warning

```{r eval=FALSE}
library(dplyr)
library(plyr)
```

<div class="warning-box">
üü° **WARNING**

```
Attaching package: 'plyr'

The following objects are masked from 'package:dplyr':

    arrange, count, desc, failwith, id, mutate, rename, summarise, summarize
```
</div>

### What It Means

Both packages have functions with the same names. The later-loaded package's functions will be used by default.

### Should You Worry?

**YES** - This can cause confusing behavior if you expect dplyr's `mutate()` but get plyr's version.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Load packages in correct order:**
```{r eval=FALSE}
library(plyr)   # Load first
library(dplyr)  # Load second (masks plyr)

# Now dplyr functions take precedence
```

**2. Use package::function notation:**
```{r eval=FALSE}
dplyr::mutate(data, new_col = x + 1)  # Explicit
plyr::mutate(data, new_col = x + 1)   # Explicit
```

**3. Avoid loading conflicting packages:**
```{r eval=FALSE}
# Don't load plyr if you're using dplyr
# dplyr supersedes most plyr functionality
library(dplyr)
```

**4. Check for conflicts:**
```{r eval=FALSE}
# See all conflicts
conflicts()

# With details
library(conflicted)
conflict_scout()
```
</div>

## Debugging Installation Issues

### General Troubleshooting Steps

<div class="bestpractice-box">
üéØ **Systematic Approach**

1. **Restart R**
```{r eval=FALSE}
.rs.restartR()  # RStudio
# Or: Session > Restart R
```

2. **Update R**
```{r}
R.version.string
# Compare to https://cran.r-project.org/
```

3. **Update packages**
```{r eval=FALSE}
update.packages(ask = FALSE)
```

4. **Check installation details**
```{r eval=FALSE}
# Verbose output
install.packages("package", verbose = TRUE)

# Keep source for inspection
install.packages("package", INSTALL_opts = "--no-clean-on-error")
```

5. **Check session info**
```{r}
sessionInfo()
# Shows R version, platform, loaded packages
```

6. **Test in clean session**
```{r eval=FALSE}
# Start R with no saved data
R --vanilla
```
</div>

### Getting Help

<div class="insight-box">
üí° **When Asking for Help, Provide:**

1. **Error message** (complete, not summary)
2. **R version:** `R.version.string`
3. **Platform:** `Sys.info()["sysname"]`
4. **What you tried:** Your code
5. **Session info:** `sessionInfo()`

**Good question format:**
```
I'm trying to install package X on Windows 11 with R 4.3.0.

Error message:
[paste complete error]

I tried:
- Updating R
- Different CRAN mirror
- Installing dependencies

sessionInfo() output:
[paste]
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Most installation errors are environmental**, not code-related
2. **Binary vs source** matters on Windows
3. **System dependencies** are common on Mac/Linux
4. **Package conflicts** happen - use `package::function()`
5. **Reinstalling** solves many issues
6. **Update regularly** but cautiously

**Quick Reference:**

| Error | First Try |
|-------|-----------|
| Installation failed | Restart R, try again |
| Repository access | Change CRAN mirror |
| Version mismatch | Update R |
| Dependencies missing | Install with `dependencies = TRUE` |
| Lazy-load corruption | Reinstall package |
| Rtools (Windows) | Install Rtools |
| Library not found (Mac/Linux) | Install system library |
| Package conflicts | Load order or use `::` |
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Diagnosis Practice**

What's wrong with each scenario?

```{r eval=FALSE}
# Scenario 1
install.packages("dplyr")
# Warning: unable to access index for repository

# Scenario 2
library(ggplot2)
# Error: package 'ggplot2' was built before R 4.0.0

# Scenario 3  
install.packages("devtools")
# ERROR: dependency 'usethis' is not available
```

**Answers at end of chapter**
</div>

<div class="exercise-box">
üìù **Exercise 2: Prevention**

Set up your R environment for smooth package installation:

1. Configure a reliable CRAN mirror
2. Set up a user library path
3. Install essential build tools for your OS
4. Create a package installation script

Try writing this setup code.
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

*Scenario 1:* Cannot reach CRAN repository
- Solution: Check internet, try different mirror

*Scenario 2:* R version too old
- Solution: Update R to 4.0.0 or higher

*Scenario 3:* Missing dependency
- Solution: `install.packages("devtools", dependencies = TRUE)`

**Exercise 2:**

```{r eval=FALSE}
# Setup script
setup_r_environment <- function() {
  # 1. Set CRAN mirror
  options(repos = c(CRAN = "https://cloud.r-project.org"))
  
  # 2. Set user library
  user_lib <- "~/R/library"
  if (!dir.exists(user_lib)) dir.create(user_lib, recursive = TRUE)
  .libPaths(c(user_lib, .libPaths()))
  
  # 3. Install essential packages
  essentials <- c("devtools", "tidyverse", "rmarkdown")
  new_packages <- essentials[!(essentials %in% installed.packages()[,"Package"])]
  if(length(new_packages)) install.packages(new_packages)
  
  # 4. Save to .Rprofile for future sessions
  cat('options(repos = c(CRAN = "https://cloud.r-project.org"))\n', 
      file = "~/.Rprofile", append = TRUE)
  
  message("R environment configured!")
}
```
</details>

<!--chapter:end:01-installation-environment.Rmd-->

# Working Directory & Path Errors {#working-directory-paths}

<div class="chapter-summary">
**What You'll Learn:**

- Understanding R's working directory concept
- Common file path errors and solutions
- Absolute vs relative paths
- Cross-platform path compatibility
- File encoding issues

**Key Errors Covered:** 12+ path and file-related errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

"It worked on my computer!" 

This famous phrase often stems from working directory and path issues. R needs to know *where* your files are, and this seemingly simple concept causes endless frustration.

In this chapter, you'll master:
- How R finds files
- Why paths break across systems
- Encoding nightmares
- Connection errors

## Error #1: Cannot Open File - No Such File or Directory {#no-such-file}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Error

```{r error=TRUE, eval=FALSE}
data <- read.csv("mydata.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error in file(file, "rt") : cannot open the connection
In addition: Warning message:
In file(file, "rt") :
  cannot open file 'mydata.csv': No such file or directory
```
</div>

### What It Means

R looked for `mydata.csv` in the current working directory and didn't find it.

### Understanding Working Directory

```{r}
# Where is R looking?
getwd()
```

This is your **working directory** - R's current location in your file system.

### Common Causes

#### Cause 1: File is Elsewhere

```{r eval=FALSE}
# Your file is here: ~/Documents/project/data/mydata.csv
# But R is looking here:
getwd()
#> [1] "/Users/username/Documents"

# R won't find it!
read.csv("mydata.csv")  # Error!
```

#### Cause 2: Wrong Working Directory

```{r eval=FALSE}
# You opened R in wrong folder
getwd()
#> [1] "/Users/username"

# But your file is in:
# /Users/username/Documents/R_projects/project1/
```

#### Cause 3: Typo in Filename

```{r error=TRUE, eval=FALSE}
# File is named: "mydata.csv"
read.csv("myData.csv")  # Wrong case!
read.csv("my_data.csv")  # Wrong underscore!
read.csv("mydata.txt")  # Wrong extension!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Change Working Directory**

```{r eval=FALSE}
# Set working directory to where file is
setwd("/Users/username/Documents/R_projects/project1")
getwd()  # Verify

# Now this works:
read.csv("mydata.csv")
```

**In RStudio:**
- Session > Set Working Directory > Choose Directory
- Or use Files pane > More > Set As Working Directory
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Full Path**

```{r eval=FALSE}
# Absolute path (always works, regardless of wd)
data <- read.csv("/Users/username/Documents/R_projects/project1/mydata.csv")

# Windows:
data <- read.csv("C:/Users/username/Documents/project1/mydata.csv")
# Note: Forward slashes! or escaped backslashes: "C:\\Users\\..."
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Relative Path**

```{r eval=FALSE}
# If working directory is: /Users/username/Documents/R_projects
# And file is in:          /Users/username/Documents/R_projects/project1/data/

# Relative path:
data <- read.csv("project1/data/mydata.csv")

# Go up one directory:
data <- read.csv("../other_project/data.csv")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 4: Use RStudio Projects**

**Best Practice!**

1. File > New Project > New Directory
2. Place all files in project directory
3. Always use relative paths
4. Working directory auto-set to project root

```{r eval=FALSE}
# With project structure:
# myproject/
#   ‚îú‚îÄ‚îÄ myproject.Rproj
#   ‚îú‚îÄ‚îÄ scripts/
#   ‚îÇ   ‚îî‚îÄ‚îÄ analysis.R
#   ‚îî‚îÄ‚îÄ data/
#       ‚îî‚îÄ‚îÄ mydata.csv

# In any script:
data <- read.csv("data/mydata.csv")  # Always works!
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 5: Use here Package**

```{r eval=FALSE}
library(here)

# Automatically finds project root
here()

# Build paths relative to project root
data <- read.csv(here("data", "mydata.csv"))

# Works everywhere, across all systems!
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: setwd() in Scripts**

**DON'T DO THIS:**
```{r eval=FALSE}
# hardcoded-badscript.R
setwd("/Users/alice/Documents/my_project")  # Only works on Alice's computer!
data <- read.csv("data.csv")
```

**DO THIS INSTEAD:**
```{r eval=FALSE}
# Use R Projects + relative paths
# Or use here package
library(here)
data <- read.csv(here("data", "data.csv"))
```

**Why?**
- Your path won't work on others' computers
- Breaks reproducibility
- Fails when you move project
</div>

### Checking If File Exists

<div class="bestpractice-box">
üéØ **Best Practice: Defensive File Reading**

```{r eval=FALSE}
filename <- "data/mydata.csv"

# Check before reading
if (file.exists(filename)) {
  data <- read.csv(filename)
  message("File loaded successfully!")
} else {
  stop("File not found: ", filename, "\n",
       "Current directory: ", getwd(), "\n",
       "Files available: ", paste(list.files(), collapse = ", "))
}
```
</div>

## Error #2: Cannot Change Working Directory {#cannot-change-wd}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Error

```{r error=TRUE, eval=FALSE}
setwd("/path/that/doesnt/exist")
```

<div class="error-box">
üî¥ **ERROR**

```
Error in setwd("/path/that/doesnt/exist") : 
  cannot change working directory
```
</div>

### Common Causes

#### Cause 1: Directory Doesn't Exist

```{r eval=FALSE}
setwd("/Users/alice/Documents/nonexistent")  # Typo or not created
```

#### Cause 2: Permission Denied

```{r eval=FALSE}
# Trying to access restricted directory
setwd("/private/var/root")  # No permission!
```

#### Cause 3: Wrong Path Format

```{r eval=FALSE}
# Windows: backslashes need escaping
setwd("C:\Users\alice\Documents")  # ERROR!

# Should be:
setwd("C:/Users/alice/Documents")     # Forward slashes
setwd("C:\\Users\\alice\\Documents")  # Escaped backslashes
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Verify directory exists:**
```{r eval=FALSE}
path <- "/Users/alice/Documents/project"
dir.exists(path)  # Check first

if (dir.exists(path)) {
  setwd(path)
} else {
  dir.create(path, recursive = TRUE)  # Create if needed
  setwd(path)
}
```

**2. List available directories:**
```{r eval=FALSE}
# See what's in current location
list.dirs(getwd(), recursive = FALSE)
```

**3. Use correct path separators:**
```{r eval=FALSE}
# Cross-platform path building
path <- file.path("Users", "alice", "Documents", "project")
setwd(file.path("/", path))  # Works on all systems
```

**4. Check permissions:**
```{r eval=FALSE}
# See if you can write to directory
test_file <- file.path(path, "test.txt")
tryCatch({
  writeLines("test", test_file)
  file.remove(test_file)
  message("Directory is writable")
}, error = function(e) {
  message("Permission denied or directory doesn't exist")
})
```
</div>

## Error #3: Invalid Multibyte String {#invalid-multibyte}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Error

```{r error=TRUE, eval=FALSE}
data <- read.csv("donn√©es.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error in read.table(file = file, header = header, sep = sep, quote = quote,  : 
  invalid multibyte string at '<...>'
```
</div>

### What It Means

The file contains characters that R can't interpret with the current encoding. Common with:
- Accented characters (√©, √±, √º)
- Non-Latin scripts (‰∏≠Êñá, ÿßŸÑÿπÿ±ÿ®Ÿäÿ©, —Ä—É—Å—Å–∫–∏–π)
- Special symbols (‚Ç¨, ¬£, ¬©)

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Specify Encoding**

```{r eval=FALSE}
# Try different encodings
data <- read.csv("donn√©es.csv", fileEncoding = "UTF-8")
data <- read.csv("donn√©es.csv", fileEncoding = "latin1")
data <- read.csv("donn√©es.csv", fileEncoding = "ISO-8859-1")

# For readr (tidyverse)
library(readr)
data <- read_csv("donn√©es.csv", locale = locale(encoding = "UTF-8"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Detect Encoding**

```{r eval=FALSE}
# Auto-detect encoding
library(readr)
guess_encoding("donn√©es.csv")

# Use detected encoding
encoding_info <- guess_encoding("donn√©es.csv")
data <- read_csv("donn√©es.csv", 
                locale = locale(encoding = encoding_info$encoding[1]))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Handle in Filename**

```{r eval=FALSE}
# Rename file to avoid non-ASCII characters
file.rename("donn√©es.csv", "donnees.csv")
data <- read.csv("donnees.csv")
```
</div>

<div class="insight-box">
üí° **Key Insight: Common Encodings**

- **UTF-8**: Universal, handles all languages (use this!)
- **Latin1 (ISO-8859-1)**: Western European languages
- **Windows-1252**: Windows default (similar to Latin1)
- **ASCII**: Basic English only

**Best Practice:** Always save files in UTF-8
</div>

## Error #4: Embedded Nul in String {#embedded-nul}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Error

```{r error=TRUE, eval=FALSE}
data <- read.csv("corrupted.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error in read.table(file = file, header = header, sep = sep, quote = quote,  : 
  embedded nul in string: '<text>\0more_text'
```
</div>

### What It Means

The file contains null bytes (`\0`), indicating file corruption or wrong file type.

### Common Causes

1. File is corrupted
2. File is not actually text/CSV (might be binary)
3. Encoding issues
4. Incomplete download

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Verify file type:**
```{r eval=FALSE}
# Check file
file.info("corrupted.csv")

# Try to read first few bytes
readBin("corrupted.csv", "raw", n = 100)
# If you see lots of 00, it's binary or corrupted
```

**2. Remove null bytes:**
```{r eval=FALSE}
# Read as binary and clean
con <- file("corrupted.csv", "rb")
raw_data <- readBin(con, "raw", n = file.info("corrupted.csv")$size)
close(con)

# Remove null bytes
clean_data <- raw_data[raw_data != 0]

# Write cleaned file
writeBin(clean_data, "cleaned.csv")

# Now try reading
data <- read.csv("cleaned.csv")
```

**3. Re-download file:**
If downloaded from internet, download again - might have been interrupted.

**4. Use readr (more robust):**
```{r eval=FALSE}
library(readr)
data <- read_csv("corrupted.csv")  # Often handles better
```
</div>

## Error #5: Cannot Open the Connection {#cannot-open-connection}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Error

```{r error=TRUE, eval=FALSE}
con <- file("data.csv", "r")
data <- read.csv(con)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in file(file, "rt") : cannot open the connection
```
</div>

### Common Causes

#### Cause 1: File is Open in Another Program

```{r eval=FALSE}
# File open in Excel - Windows locks it
read.csv("data.csv")  # Error!
```

**Solution:** Close the file in other programs

#### Cause 2: File is Being Written By Another Process

```{r eval=FALSE}
# One R process writing, another trying to read
writeLines(text, "file.txt")  # Process 1
data <- readLines("file.txt")  # Process 2 - might fail
```

**Solution:** Wait or use proper locking

#### Cause 3: Connection Already Open

```{r eval=FALSE}
con <- file("data.csv", "r")
# ... forgot to close ...
con <- file("data.csv", "r")  # Error! Already connected
```

**Solution:** 
```{r eval=FALSE}
close(con)  # Close first
con <- file("data.csv", "r")  # Now works
```

#### Cause 4: Network Path Issues

```{r eval=FALSE}
# Reading from network drive
read.csv("//server/share/data.csv")  # Might fail if not connected
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Close all connections:**
```{r eval=FALSE}
# See open connections
showConnections()

# Close all
closeAllConnections()
```

**2. Use on.exit() for cleanup:**
```{r eval=FALSE}
read_file_safely <- function(filename) {
  con <- file(filename, "r")
  on.exit(close(con))  # Always closes, even if error
  
  data <- readLines(con)
  return(data)
}
```

**3. Use tryCatch:**
```{r eval=FALSE}
tryCatch({
  data <- read.csv("data.csv")
}, error = function(e) {
  message("Could not read file. Is it open in another program?")
  message("Error: ", e$message)
  closeAllConnections()
})
```

**4. Check file accessibility:**
```{r eval=FALSE}
check_file_accessible <- function(filename) {
  # Check exists
  if (!file.exists(filename)) {
    stop("File doesn't exist: ", filename)
  }
  
  # Check readable
  if (file.access(filename, mode = 4) != 0) {
    stop("File not readable: ", filename)
  }
  
  # Try to open
  tryCatch({
    con <- file(filename, "r")
    close(con)
    return(TRUE)
  }, error = function(e) {
    stop("Cannot open file (locked or in use?): ", filename)
  })
}
```
</div>

## Error #6: Incomplete Final Line Found {#incomplete-final-line}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-file">üíæ FILE/PATH</span>

### The Warning

```{r eval=FALSE}
data <- read.csv("data.csv")
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In read.table(file = file, header = header, sep = sep, quote = quote,  : 
  incomplete final line found by readTableHeader on 'data.csv'
```
</div>

### What It Means

The file doesn't end with a newline character. Text files should end with `\n`, but this one doesn't.

### Should You Worry?

**Usually NO** - R still reads the file correctly. It's just being pedantic about file format.

**Maybe YES** - If you notice missing data from last line.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Ignore it (if data looks complete):**
Data is usually fine, just suppress warning if annoying:

```{r eval=FALSE}
suppressWarnings(data <- read.csv("data.csv"))
```

**2. Fix the file:**
```{r eval=FALSE}
# Read file
lines <- readLines("data.csv")

# Add final newline
writeLines(lines, "data.csv")

# Now reads without warning
data <- read.csv("data.csv")
```

**3. Use readr (no warning):**
```{r eval=FALSE}
library(readr)
data <- read_csv("data.csv")  # No warning
```
</div>

## Path Construction Best Practices

<div class="bestpractice-box">
üéØ **Cross-Platform Paths**

**Problem:** Paths differ across operating systems
- Windows: `C:\Users\alice\Documents`
- Mac/Linux: `/Users/alice/Documents`

**Solution: Use `file.path()`**

```{r}
# Works on ALL systems
project_path <- file.path("Users", "alice", "Documents", "project")
data_file <- file.path(project_path, "data", "mydata.csv")
print(data_file)

# Compare to manual (breaks on Windows):
wrong <- "Users/alice/Documents/project/data/mydata.csv"
```

**Benefits:**
- Automatic path separator
- No escaping needed
- Works everywhere
</div>

<div class="bestpractice-box">
üéØ **Project Structure**

Organize files consistently:

```
myproject/
‚îú‚îÄ‚îÄ myproject.Rproj        # RStudio project file
‚îú‚îÄ‚îÄ README.md              # Project documentation
‚îú‚îÄ‚îÄ .gitignore            # Git ignore file
‚îú‚îÄ‚îÄ data/                 # Data files
‚îÇ   ‚îú‚îÄ‚îÄ raw/             # Original, unmodified data
‚îÇ   ‚îî‚îÄ‚îÄ processed/       # Cleaned data
‚îú‚îÄ‚îÄ scripts/             # R scripts
‚îÇ   ‚îú‚îÄ‚îÄ 01-import.R
‚îÇ   ‚îú‚îÄ‚îÄ 02-clean.R
‚îÇ   ‚îî‚îÄ‚îÄ 03-analyze.R
‚îú‚îÄ‚îÄ functions/           # Custom functions
‚îÇ   ‚îî‚îÄ‚îÄ helpers.R
‚îú‚îÄ‚îÄ output/              # Results
‚îÇ   ‚îú‚îÄ‚îÄ figures/
‚îÇ   ‚îî‚îÄ‚îÄ tables/
‚îî‚îÄ‚îÄ reports/             # Rmarkdown documents
    ‚îî‚îÄ‚îÄ analysis.Rmd
```

**Then use:**
```{r eval=FALSE}
library(here)

# Always works, regardless of working directory
data <- read.csv(here("data", "raw", "mydata.csv"))
source(here("functions", "helpers.R"))
ggsave(here("output", "figures", "plot1.png"))
```
</div>

## Debugging Path Issues

<div class="insight-box">
üí° **Diagnosis Toolkit**

```{r eval=FALSE}
# Where am I?
getwd()

# What's here?
list.files()
list.files(recursive = TRUE)  # Include subdirectories

# Can I read this file?
file.exists("data.csv")
file.access("data.csv", mode = 4)  # 4 = read

# What's the full path?
normalizePath("data.csv")

# Get file info
file.info("data.csv")

# Open connections?
showConnections()

# Project root (with here package)
library(here)
here()
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Use R Projects** - Auto-manages working directory
2. **Use `here` package** - Build paths that work everywhere
3. **Avoid `setwd()`** in scripts - Breaks portability
4. **Use `file.path()`** - Cross-platform compatibility
5. **Handle encodings** - UTF-8 for everything
6. **Close connections** - Use `on.exit()` for safety
7. **Check files exist** before reading

**Quick Reference:**

| Problem | Solution |
|---------|----------|
| File not found | Check with `file.exists()`, verify working directory |
| Can't change directory | Verify path exists with `dir.exists()` |
| Encoding issues | Specify `fileEncoding = "UTF-8"` |
| Embedded nul | File corrupted or binary; re-download |
| Can't open connection | Close other programs; use `closeAllConnections()` |
| Incomplete final line | Usually harmless; use `readr` to avoid |

**The Golden Rule:**
```{r eval=FALSE}
# Setup once (in project)
library(here)
data <- read.csv(here("data", "mydata.csv"))
# Works everywhere, every time!
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Path Detective**

You receive this error:
```{r eval=FALSE}
data <- read.csv("../../data/experiment1/results.csv")
# Error: cannot open file
```

Your working directory is: `/Users/bob/projects/analysis/scripts/R`

1. Where is R looking for the file?
2. What's the full path it's trying?
3. Write three different ways to fix it.
</div>

<div class="exercise-box">
üìù **Exercise 2: Cross-Platform Script**

Write a script that:
1. Works on Windows, Mac, and Linux
2. Reads data from `data/input.csv`
3. Saves output to `results/output.csv`
4. Creates directories if they don't exist
5. Handles errors gracefully

Use best practices from this chapter.
</div>

<div class="exercise-box">
üìù **Exercise 3: Encoding Hunter**

You have a CSV with French text that produces encoding errors.

1. How do you detect the encoding?
2. How do you read it correctly?
3. How do you convert it to UTF-8?
4. How do you prevent this issue in future?
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

1-2. R looks for: `/Users/bob/projects/data/experiment1/results.csv`

3. Three solutions:
```{r eval=FALSE}
# Solution 1: Change working directory
setwd("/Users/bob/projects")
data <- read.csv("data/experiment1/results.csv")

# Solution 2: Full path
data <- read.csv("/Users/bob/projects/data/experiment1/results.csv")

# Solution 3: Use here (BEST)
library(here)
here()  # Finds project root
data <- read.csv(here("data", "experiment1", "results.csv"))
```

**Exercise 2:**

```{r eval=FALSE}
# cross_platform_script.R
library(here)

# Function with error handling
read_and_process <- function() {
  # Define paths
  input_file <- here("data", "input.csv")
  output_dir <- here("results")
  output_file <- here("results", "output.csv")
  
  # Create output directory if needed
  if (!dir.exists(output_dir)) {
    dir.create(output_dir, recursive = TRUE)
    message("Created directory: ", output_dir)
  }
  
  # Check input file exists
  if (!file.exists(input_file)) {
    stop("Input file not found: ", input_file)
  }
  
  # Read data
  data <- tryCatch({
    read.csv(input_file)
  }, error = function(e) {
    stop("Could not read input file: ", e$message)
  })
  
  # Process (example)
  results <- data  # Your processing here
  
  # Write results
  tryCatch({
    write.csv(results, output_file, row.names = FALSE)
    message("Results saved to: ", output_file)
  }, error = function(e) {
    stop("Could not write output file: ", e$message)
  })
  
  return(results)
}

# Run
read_and_process()
```

**Exercise 3:**

```{r eval=FALSE}
library(readr)

# 1. Detect encoding
encoding_info <- guess_encoding("french_data.csv")
print(encoding_info)

# 2. Read with correct encoding
data <- read_csv("french_data.csv", 
                locale = locale(encoding = encoding_info$encoding[1]))

# 3. Convert to UTF-8
write_csv(data, "french_data_utf8.csv")

# 4. Prevention:
# - Always save files as UTF-8
# - Document encoding in README
# - Use readr::write_csv() which always uses UTF-8
# - Add encoding check in data import scripts
```
</details>

<!--chapter:end:02-working-directory-paths.Rmd-->

# Objects and Variables {#objects-variables}

<div class="chapter-summary">
**What You'll Learn:**

- How R stores and finds objects
- The most common beginner errors
- Understanding R's case sensitivity and naming rules
- Scoping basics that prevent errors

**Key Errors Covered:** 10+ object-related errors

**Difficulty:** ‚≠ê Beginner
</div>

## Introduction

Every R session starts with creating objects. And every R learner's journey starts with `object 'x' not found`. This error is so universal that it deserves deep understanding.

```{r}
# Your first R command
x <- 42
x
```

Simple, right? Until it's not. Let's explore what goes wrong.

## Error #1: `object 'x' not found` {#error-object-not-found}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-scope">üîó SCOPING</span>

### The Error

```{r error=TRUE}
# Try to use an object that doesn't exist
my_number + 5
```

<div class="error-box">
üî¥ **ERROR**

```
Error: object 'my_number' not found
```
</div>

### What It Means

R looked for an object named `my_number` in:
1. The current environment (`.GlobalEnv`)
2. All loaded packages (in search path order)
3. The base environment

...and couldn't find it anywhere.

### Common Causes

#### Cause 1: Typo in Object Name

```{r error=TRUE}
my_variable <- 10
my_varaible + 5  # Notice the typo: varaible vs variable
```

üí° **Key Insight:** R is case-sensitive!

```{r error=TRUE}
Temperature <- 98.6
temperature  # Wrong case!
```

```{r}
# These are THREE different objects:
myVariable <- 1
MyVariable <- 2
myvariable <- 3

ls()  # All three exist
```

#### Cause 2: Never Created the Object

```{r error=TRUE}
# Forgot to run this line:
# result <- 100 * 2

# Trying to use it:
result / 4
```

#### Cause 3: Object Created in Different Scope

```{r error=TRUE}
my_function <- function() {
  local_var <- 42
  print(local_var)  # Works inside function
}

my_function()
local_var  # Doesn't exist outside function!
```

#### Cause 4: Cleared Environment

```{r}
x <- 10
x  # Exists

rm(x)  # Removed it

# Now:
```

```{r error=TRUE}
x  # Gone!
```

#### Cause 5: Running Lines Out of Order

```{r eval=FALSE}
# If you run line 10 before line 5:

# Line 5
my_data <- read.csv("data.csv")

# Line 10 (run this first by mistake)
summary(my_data)  # Error! my_data doesn't exist yet
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Check spelling carefully:**
```{r}
my_variable <- 10
my_variable + 5  # Correct spelling
```

**2. Verify object exists:**
```{r}
# List all objects
ls()

# Check if specific object exists
exists("my_variable")

# Search in environment
grep("var", ls(), value = TRUE)  # Find objects with "var"
```

**3. Use RStudio's autocomplete:**
- Type the first few letters
- Press Tab to see available objects

**4. Check your environment pane:**
In RStudio, look at the Environment pane (top-right) to see all objects.

**5. Run all necessary code:**
Make sure you've executed all lines that create the objects you need.

**6. Restart and run from top:**
```{r eval=FALSE}
# Clear everything and start fresh
rm(list = ls())
# Or: Ctrl+Shift+F10 in RStudio (restart R)
```
</div>

<div class="bestpractice-box">
üéØ **Best Practices**

1. **Use consistent naming:** Choose a style and stick to it
   - `snake_case` (recommended for R)
   - `camelCase`
   - Avoid `dot.case` (can be confusing with S3 methods)

2. **Meaningful names:** `temperature_celsius` > `temp` > `t`

3. **Avoid similar names:** 
```{r eval=FALSE}
# Confusing:
data1 <- ...
data2 <- ...
data_new <- ...
data_final <- ...
data_final2 <- ...

# Better:
raw_data <- ...
clean_data <- ...
analyzed_data <- ...
```

4. **Run scripts top-to-bottom:** Your script should work when run fresh
</div>

## Error #2: `could not find function "x"` {#error-function-not-found}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-package">üì¶ PACKAGE</span>

### The Error

```{r error=TRUE}
# Try to use a function from unloaded package
read_csv("data.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error: could not find function "read_csv"
```
</div>

### What It Means

R can't find a function with that name. Functions are searched in:
1. The current environment
2. All loaded packages
3. **NOT** inside unloaded packages

### Common Causes

#### Cause 1: Package Not Loaded

```{r eval=FALSE}
# tidyverse not loaded
read_csv("data.csv")  # Error!

# Solution:
library(readr)
read_csv("data.csv")  # Works!
```

#### Cause 2: Package Not Installed

```{r eval=FALSE, error=TRUE}
library(somepackage)  # If not installed, this errors
```

```
Error in library(somepackage) : 
  there is no package called 'somepackage'
```

#### Cause 3: Typo in Function Name

```{r error=TRUE}
# Base R function is read.csv (dot), not read_csv (underscore)
meen(c(1, 2, 3))  # Typo: mean
```

#### Cause 4: Object Overwrote Function

```{r}
# Created an object with same name as a function
mean <- 42
mean
```

```{r error=TRUE}
# Now the function is gone!
mean(c(1, 2, 3))  
```

<div class="error-box">
üî¥ **ERROR**

```
Error in mean(c(1, 2, 3)) : could not find function "mean"
```

Wait, what? We just used `mean`! But we overwrote it with the number 42.
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Load the required package:**
```{r eval=FALSE}
library(readr)
read_csv("data.csv")
```

**2. Install then load:**
```{r eval=FALSE}
install.packages("readr")
library(readr)
```

**3. Use package::function notation:**
```{r eval=FALSE}
# Use function without loading entire package
readr::read_csv("data.csv")

# Always works, no library() needed
dplyr::mutate(data, new_col = x + 1)
```

**4. Check function spelling:**
```{r eval=FALSE}
# Base R uses dots
read.csv("data.csv")  # Note the dot

# tidyverse uses underscores  
library(readr)
read_csv("data.csv")  # Note the underscore
```

**5. Remove conflicting object:**
```{r}
# If you accidentally overwrote:
mean <- 42  # Bad!
rm(mean)    # Remove the object
mean(c(1, 2, 3))  # Now the function works
```

**6. Find where function lives:**
```{r eval=FALSE}
# Search for functions
??read_csv
help.search("read_csv")

# Find package
find("read_csv")
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Overwriting Functions**

Never name objects after common functions:

**Avoid naming objects:**
- `mean`, `sum`, `length`, `data`, `df`, `c`, `t`, `T`, `F`
- `matrix`, `list`, `vector`, `table`
- `plot`, `points`, `lines`
- Any function you use regularly!

**If you accidentally do it:**
```{r eval=FALSE}
# You created: sum <- 100
sum(1:10)  # Error!

# Fix:
rm(sum)  # Remove it
sum(1:10)  # Works now

# Or restart R session: Ctrl+Shift+F10
```
</div>

## Error #3: `unexpected symbol in "x"` {#error-unexpected-symbol}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
my variable <- 10
```

<div class="error-box">
üî¥ **ERROR**

```
Error: unexpected symbol in "my variable"
```
</div>

### What It Means

R's parser encountered something it didn't expect. Usually a space or character where it shouldn't be.

### Common Causes

#### Cause 1: Space in Variable Name

```{r error=TRUE}
my variable <- 10  # Spaces not allowed!
```

```{r}
# Solutions:
my_variable <- 10  # underscore
myVariable <- 10   # camelCase
my.variable <- 10  # dot (less recommended)
```

#### Cause 2: Missing Operator

```{r error=TRUE}
x <- 5
y <- 10
result <- x y  # Missing operator!
```

```{r}
# Fix:
result <- x * y  # or +, -, /, etc.
```

#### Cause 3: Two Statements on One Line

```{r error=TRUE}
x <- 5 y <- 10  # Two assignments without separator
```

```{r}
# Solutions:
x <- 5; y <- 10  # Semicolon separator

# Or on separate lines (preferred):
x <- 5
y <- 10
```

#### Cause 4: Incorrect String Quotes

```{r error=TRUE}
text <- "Hello world"  # Unmatched quotes
```

```{r}
# Fix:
text <- "Hello world"  # Matching quotes
```

#### Cause 5: Copying from Formatted Text

```{r eval=FALSE}
# Copying from Word/PDF might include smart quotes or special characters
name <- "John"  # These aren't regular quotes!
```

```{r}
# Should be:
name <- "John"  # Regular ASCII quotes
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Use underscores for multi-word names:**
```{r}
total_sales <- 1000
average_temperature <- 72.5
```

**2. Add missing operators:**
```{r}
a <- 10
b <- 5
c <- a + b  # Not: c <- a b
```

**3. Separate statements:**
```{r}
# One per line:
x <- 1
y <- 2

# Or use semicolon:
x <- 1; y <- 2
```

**4. Use consistent quotes:**
```{r}
# Choose one style and stick to it:
text1 <- "double quotes"  # More common in R
text2 <- 'single quotes'  # Also fine

# They're equivalent:
identical(text1, "double quotes")
identical(text2, 'single quotes')
```
</div>

## Error #4: `unexpected '=' in "x"` {#error-unexpected-equal}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
x = 5 = y
```

<div class="error-box">
üî¥ **ERROR**

```
Error: unexpected '=' in "x = 5 ="
```
</div>

### What It Means

You used `=` where R didn't expect it.

### Common Causes

#### Cause 1: Chained Assignment (doesn't work like math)

```{r error=TRUE}
# Trying to set x and y to 5 (like math: x = y = 5)
x = 5 = y  # Doesn't work!
```

```{r}
# Solutions:
x <- y <- 5  # This works
# Or:
x <- 5
y <- 5
```

#### Cause 2: Using = Instead of ==

```{r error=TRUE}
x <- 10
if (x = 10) {  # Assignment, not comparison!
  print("yes")
}
```

```{r}
# Fix: use == for comparison
if (x == 10) {
  print("yes")
}
```

#### Cause 3: Wrong Context for =

```{r eval=FALSE}
# Inside function arguments, = is fine:
mean(x = c(1, 2, 3))  # OK

# For assignment, <- is clearer:
x <- c(1, 2, 3)  # Better style
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Use <- for assignment:**
```{r}
# Preferred in R
x <- 10
```

**2. Use == for comparison:**
```{r}
x <- 10
x == 10  # TRUE
x == 5   # FALSE
```

**3. Use = only in function arguments:**
```{r}
# Good:
mean(x = c(1, 2, 3), na.rm = TRUE)

# Also fine, but <- preferred for assignment:
x <- c(1, 2, 3)
mean(x, na.rm = TRUE)
```
</div>

<div class="insight-box">
üí° **Key Insight: <- vs = **

```{r}
# Both work for assignment:
x <- 10
x = 10

# But <- is preferred because:
# 1. Clearer intent (unambiguous assignment)
# 2. Works everywhere
# 3. R community standard

# = can be ambiguous:
mean(x = 1:10)  # Named argument (good)
x = 1:10        # Assignment (works, but <- preferred)
```

**Best Practice:** Use `<-` for assignment, `=` for function arguments
</div>

## Error #5: `object of type 'closure' is not subsettable` {#error-closure-not-subsettable}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
mean[1]  # Trying to subset the mean function
```

<div class="error-box">
üî¥ **ERROR**

```
Error in mean[1] : object of type 'closure' is not subsettable
```
</div>

### What It Means

"Closure" = function. You're trying to use `[` on a function, which doesn't make sense.

### Common Causes

#### Cause 1: Forgot to Call the Function

```{r error=TRUE}
data <- c(1, 2, 3, 4, 5)
result <- mean  # Forgot parentheses!
result[1]  # Trying to subset the function itself
```

```{r}
# Fix:
result <- mean(data)  # Call the function
result  # Now it's a number
```

#### Cause 2: Accidentally Accessed Function Instead of Object

```{r error=TRUE}
# You have an object named 'data'
data <- data.frame(x = 1:5, y = 6:10)

# But there's also a function called 'data'
data[1, ]  # If you somehow reference the function...
```

This is rare, but shows why naming is important.

#### Cause 3: Function Name Typo Leads to Another Function

```{r error=TRUE}
c <- c(1, 2, 3)  # Bad! 'c' is a function
c[1]  # Now trying to subset the c() function
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Call the function:**
```{r}
# Wrong:
data <- c(1, 2, 3)
result <- mean
result[1]  # Error

# Right:
result <- mean(data)  # Call it
result  # Number, can't subset but don't need to
```

**2. Check if it's a function:**
```{r}
is.function(mean)  # TRUE
is.function(c(1,2,3))  # FALSE
```

**3. Don't overwrite function names:**
```{r eval=FALSE}
# Bad:
c <- c(1, 2, 3)
t <- read.csv("data.csv")
data <- process_data()

# Good:
my_vector <- c(1, 2, 3)
my_data <- read.csv("data.csv")
processed_data <- process_data()
```
</div>

## Error #6: `cannot change value of locked binding` {#error-locked-binding}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-scope">üîó SCOPING</span>

### The Error

```{r error=TRUE}
T <- FALSE  # Trying to change T
```

<div class="error-box">
üî¥ **ERROR**

```
Error in T <- FALSE : cannot change value of locked binding for 'T'
```
</div>

### What It Means

You're trying to modify a protected object. Some objects are locked to prevent accidental changes.

### Common Protected Objects

```{r eval=FALSE}
# These are locked:
T  # TRUE
F  # FALSE
pi
letters
LETTERS
month.name
month.abb
```

### Why This Protection Exists

```{r eval=FALSE}
# Imagine if you could do this:
T <- FALSE
F <- TRUE

# Now:
if (T) {  # But T is FALSE!
  print("This won't print")
}

# Chaos!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Use a different name:**
```{r}
# Don't:
# T <- FALSE

# Do:
my_test <- FALSE
temperature <- 72
```

**2. Use full names (better practice anyway):**
```{r}
# Instead of T/F:
my_var <- TRUE   # Not T
other_var <- FALSE  # Not F

# More readable and no risk of confusion
```

**3. Never use T/F in code:**
```{r}
# Bad:
if (x > 0) T else F

# Good:
if (x > 0) TRUE else FALSE
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: T and F**

**Never use `T` and `F` as shortcuts for `TRUE` and `FALSE`**

Why?
- They can be overwritten (in older R)
- Less readable
- Can cause subtle bugs

```{r eval=FALSE}
# Dangerous:
result <- T  # What if someone changed T?

# Safe:
result <- TRUE  # Can never be changed
```
</div>

## Understanding Variable Scope

<div class="insight-box">
üí° **Key Insight: Where Variables Live**

```{r}
# Global environment
x <- 10

my_function <- function() {
  # Function environment
  y <- 20
  
  # Can see global x
  print(x)
  
  # Can see local y
  print(y)
}

my_function()

# Global can't see local y
```

```{r error=TRUE}
print(y)  # Error!
```

**Scoping Rules:**
1. Look in current environment
2. Look in parent environment
3. Keep going up until found (or not)
</div>

## Naming Conventions

<div class="bestpractice-box">
üéØ **R Naming Best Practices**

**Valid names:**
```{r eval=FALSE}
# Letters, numbers, dots, underscores
my_variable
myVariable
my.variable
my_variable2
var_123
.hidden_var  # Starts with dot (not shown by ls())
```

**Invalid names:**
```{r eval=FALSE}
# Can't start with number
2var <- 10  # ERROR

# Can't have spaces
my var <- 10  # ERROR

# Can't use special characters
my-var <- 10  # ERROR (minus sign)
my$var <- 10  # ERROR
my@var <- 10  # ERROR
```

**Reserved words (can't use):**
```{r eval=FALSE}
# These are taken:
if, else, repeat, while, function, for, in, next, break
TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_
```

**Recommended style:**
```{r}
# Snake case (recommended for R)
total_sales <- 1000
avg_temperature <- 72
customer_age <- 35

# CamelCase (also fine)
totalSales <- 1000
avgTemperature <- 72
customerAge <- 35

# Whatever you choose, be consistent!
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **R is case-sensitive**: `X` ‚â† `x`
2. **Check spelling**: Most "object not found" errors are typos
3. **Load packages**: Functions need `library()` or `::`
4. **Don't overwrite functions**: Avoid naming objects after functions
5. **Use `<-` for assignment**: Clearer than `=`
6. **No spaces in names**: Use `_` or camelCase
7. **Check environment**: Use `ls()` and RStudio's Environment pane
8. **Never use T/F**: Always write TRUE/FALSE

**Quick Fixes:**

| Error | Likely Cause | Fix |
|-------|--------------|-----|
| object not found | Typo or not created | Check spelling, use `ls()` |
| function not found | Package not loaded | `library()` or `package::function()` |
| unexpected symbol | Space in name | Use `_` instead |
| unexpected = | Used = instead of == | Use `==` for comparison |
| closure not subsettable | Forgot () on function | Add parentheses |
| locked binding | Tried to change T/F | Use different name |
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Spot the Errors**

What's wrong with each line?

```{r eval=FALSE}
# 1
my result <- 100

# 2
Mean <- mean(c(1, 2, 3))
meen(c(4, 5, 6))

# 3
x = 10
if (x = 10) print("yes")

# 4
c <- c(1, 2, 3)
c[1]

# 5
library(dplyr)
select(data, column1)  # data doesn't exist

# 6
T <- FALSE
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Debug This Script**

Fix all errors:

```{r eval=FALSE}
# Load data
my data <- read.csv("results.csv")

# Calculate mean
average <- Mean(my data$value)

# Compare
if (average = 50) {
  print("Average is 50")
}

# Store result
T <- average > 50
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Good Names**

Rename these variables following best practices:

```{r eval=FALSE}
# Current (bad) names:
x <- data.frame(...)
data <- read.csv("sales.csv")
t <- TRUE
result1 <- ...
result2 <- ...
finaldata <- ...
```
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r eval=FALSE}
# 1 - Space in name
my_result <- 100  # or myResult

# 2 - Typo in function name
Mean <- mean(c(1, 2, 3))  # OK (but confusing name)
mean(c(4, 5, 6))  # Fix: mean not meen

# 3 - Used = instead of ==
x <- 10
if (x == 10) print("yes")

# 4 - Overwrote c() function
my_vector <- c(1, 2, 3)
my_vector[1]

# 5 - Object 'data' doesn't exist (need to create first)
# Also need to create it before this line

# 6 - Can't change T
my_test <- FALSE  # Use different name
```

**Exercise 2:**

```{r eval=FALSE}
# Load data
my_data <- read.csv("results.csv")  # Underscore, not space

# Calculate mean
average <- mean(my_data$value)  # mean not Mean

# Compare
if (average == 50) {  # == not =
  print("Average is 50")
}

# Store result
is_above_50 <- average > 50  # Don't use T
```

**Exercise 3:**

```{r eval=FALSE}
# Better names:
sales_dataframe <- data.frame(...)  # or just sales_data
sales_data <- read.csv("sales.csv")
is_valid <- TRUE  # or use full TRUE
raw_results <- ...
clean_results <- ...
final_sales_data <- ...  # or analyzed_sales
```
</details>

<!--chapter:end:03-objects-variables.Rmd-->

# Part II: Data Types & Coercion {-}

# Type Mismatch Errors {#type-mismatch}

<div class="chapter-summary">
**What You'll Learn:**

- Understanding R's type system
- How coercion works (and fails)
- Type checking and conversion
- Common type mismatch scenarios
- How to prevent type errors

**Key Errors Covered:** 20+ type-related errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

R is **dynamically typed** but **strongly typed**. This means:
- You don't declare types (dynamic)
- But types matter for operations (strong)

```{r}
x <- 5        # R figures out it's numeric
y <- "5"      # R figures out it's character
```

But try to mix them:

```{r error=TRUE}
x + y  # Error!
```

Understanding type errors is fundamental to R mastery. This chapter covers every type mismatch you'll encounter.

## R's Basic Types

<div class="insight-box">
üí° **Key Insight: The Six Atomic Types**

R has six atomic (fundamental) types:

```{r}
# 1. Logical
is_true <- TRUE
typeof(is_true)

# 2. Integer
age <- 25L  # Note the L
typeof(age)

# 3. Double (numeric)
price <- 19.99
typeof(price)

# 4. Character
name <- "Alice"
typeof(name)

# 5. Complex
z <- 3 + 2i
typeof(z)

# 6. Raw (rarely used)
raw_byte <- charToRaw("A")
typeof(raw_byte)
```

**Most common:** logical, integer, double, character
</div>

## Error #1: `non-numeric argument to binary operator` {#non-numeric-binary}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
"10" + 5
```

<div class="error-box">
üî¥ **ERROR**

```
Error in "10" + 5 : non-numeric argument to binary operator
```
</div>

### What It Means

You tried to use a mathematical operator (+, -, *, /, ^, %%, %/%) with something that isn't a number.

**Binary operator** = operator that works on two things (left + right)

### Common Causes

#### Cause 1: Character That Looks Like Number

```{r error=TRUE}
# Read from CSV without proper type specification
age <- "25"  # Actually character!
age + 10     # Error
```

```{r}
# Check type
class(age)
is.numeric(age)
is.character(age)
```

#### Cause 2: Factor Instead of Numeric

```{r error=TRUE}
# Factors are secretly integers with labels
scores <- factor(c("90", "85", "95"))
scores + 10  # Error!
```

```{r}
class(scores)
typeof(scores)  # "integer" but can't do math on it!
```

#### Cause 3: Missing Data Coerced to Character

```{r error=TRUE}
# One NA can turn everything to character
values <- c(10, 20, NA, 40)
values <- as.character(values)  # Accidentally
values[1] + 5  # Error!
```

#### Cause 4: Logical in Math (This Actually Works!)

```{r}
# Wait, this works?
TRUE + 5   # TRUE becomes 1
FALSE + 5  # FALSE becomes 0

# This is by design - logical coerces to numeric
sum(c(TRUE, FALSE, TRUE))  # Counts TRUEs
```

But mixing with character doesn't:

```{r error=TRUE}
"TRUE" + 5  # Character, not logical
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert to Numeric**

```{r}
# Basic conversion
age <- "25"
age <- as.numeric(age)
age + 10

# Check before converting
if (is.character(age)) {
  age <- as.numeric(age)
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Handle Factors Correctly**

```{r}
# Wrong way:
scores <- factor(c("90", "85", "95"))
as.numeric(scores)  # Gives factor levels (1,2,3), not values!

# Right way:
as.numeric(as.character(scores))  # Convert to char first

# Better way:
as.numeric(levels(scores)[scores])
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Read Data with Correct Types**

```{r eval=FALSE}
# Base R - specify column types
data <- read.csv("file.csv", 
                colClasses = c("numeric", "character", "numeric"))

# tidyverse - specify on read
library(readr)
data <- read_csv("file.csv",
                col_types = cols(
                  age = col_double(),
                  name = col_character(),
                  score = col_double()
                ))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 4: Safe Conversion with Error Handling**

```{r}
safe_as_numeric <- function(x) {
  result <- suppressWarnings(as.numeric(x))
  
  if (all(is.na(result)) && !all(is.na(x))) {
    warning("Conversion produced all NAs - check your data")
  }
  
  return(result)
}

# Test
safe_as_numeric("25")      # Works
safe_as_numeric("abc")     # Warning + NA
safe_as_numeric(c("1", "2", "three"))  # Partial conversion
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Silent Failures**

```{r}
# This looks like it worked...
x <- c("1", "2", "3", "four")
x <- as.numeric(x)
x
```

**Problem:** "four" became NA silently!

**Solution:** Check for NAs after conversion:
```{r}
if (any(is.na(x))) {
  warning("Some values couldn't be converted")
}
```
</div>

## Error #2: `non-numeric argument to mathematical function` {#non-numeric-math}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
sqrt("16")
```

<div class="error-box">
üî¥ **ERROR**

```
Error in sqrt("16") : non-numeric argument to mathematical function
```
</div>

### What It Means

Mathematical functions (sqrt, log, exp, sin, cos, etc.) need numbers, not characters or other types.

### Common Functions That Give This Error

```{r error=TRUE}
# All of these error with character input:
sqrt("16")
log("10")
exp("2")
abs("-5")
round("3.14")
floor("4.7")
ceiling("4.2")
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Convert before calling function:**
```{r}
sqrt(as.numeric("16"))
log(as.numeric("10"))
```

**2. Vectorized conversion and operation:**
```{r}
values <- c("16", "25", "36")
sqrt(as.numeric(values))
```

**3. Use type-safe reading:**
```{r eval=FALSE}
# When reading data
data <- read.csv("data.csv", stringsAsFactors = FALSE)
data$numeric_col <- as.numeric(data$numeric_col)
```
</div>

## Error #3: `(list) object cannot be coerced to type 'double'` {#list-coerce-double}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
my_list <- list(a = 1, b = 2, c = 3)
sum(my_list)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in sum(my_list) : invalid 'type' (list) of argument
```
</div>

### What It Means

You're trying to do mathematical operations on a list, which is a container that can hold anything. R can't automatically convert a list to numbers.

### Common Causes

#### Cause 1: Using List Instead of Vector

```{r error=TRUE}
# List (wrong for math)
numbers_list <- list(1, 2, 3, 4, 5)
mean(numbers_list)  # Error!
```

```{r}
# Vector (right for math)
numbers_vec <- c(1, 2, 3, 4, 5)
mean(numbers_vec)  # Works!
```

#### Cause 2: Extracting From Data Frame Incorrectly

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)

# Single bracket returns data frame (list-based)
sum(df[1])  # Error - still a data frame

# Double bracket returns vector
sum(df[[1]])  # Works!

# Dollar sign returns vector
sum(df$x)  # Works!
```

#### Cause 3: List Column in Data Frame

```{r error=TRUE}
# Modern R can have list columns
df <- data.frame(id = 1:3)
df$values <- list(c(1,2), c(3,4), c(5,6))

# Can't do math on list column
sum(df$values)  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert List to Vector**

```{r}
my_list <- list(a = 1, b = 2, c = 3)

# Unlist to vector
unlist(my_list)
sum(unlist(my_list))

# Or use do.call
do.call(sum, my_list)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Correct Extraction**

```{r}
df <- data.frame(x = 1:5, y = 6:10)

# Good ways:
sum(df$x)      # Dollar sign
sum(df[[1]])   # Double bracket
sum(df[, 1])   # Bracket with comma

# Bad way:
# sum(df[1])   # Single bracket = data frame
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Handle List Columns**

```{r}
df <- data.frame(id = 1:3)
df$values <- list(c(1,2), c(3,4), c(5,6))

# Apply operation to each list element
sapply(df$values, sum)
lapply(df$values, mean)

# Or unnest first (tidyverse)
library(tidyr)
df %>% unnest(values)
```
</div>

<div class="insight-box">
üí° **Key Insight: List vs Vector**

```{r}
# Vector: All same type
vec <- c(1, 2, 3)
typeof(vec)
class(vec)

# List: Can mix types
lst <- list(1, "two", TRUE)
typeof(lst)
class(lst)

# Data frame: Special list of vectors
df <- data.frame(x = 1:3, y = 4:6)
typeof(df)  # "list"!
class(df)   # "data.frame"

# Single bracket keeps structure
df[1]      # Data frame (list)
df[[1]]    # Vector
```
</div>

## Error #4: `invalid type (closure) for variable 'X'` {#invalid-type-closure}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Accidentally using a function as data
data <- data.frame(x = 1:5)
plot(mean, data$x)  # mean is the function!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in plot.xy(xy.coords(x, y), type = type, ...) : 
  invalid type (closure) for variable 'mean'
```
</div>

### What It Means

"Closure" = function. You passed a function where R expected data.

### Common Causes

#### Cause 1: Forgot to Call Function

```{r error=TRUE}
numbers <- 1:10
plot(mean, numbers)  # Passed function itself
```

```{r}
# Fix: Call the function
plot(mean(numbers), numbers)
```

#### Cause 2: Variable Name Same as Function

```{r error=TRUE}
# Created variable named 'c'
c <- 100
data <- c(1, 2, 3)  # Now c() function is masked!

# Later, someone tries to use the function
# But 'c' is now the number 100
```

```{r}
# Check what something is
is.function(mean)
is.function(100)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Call the function (add parentheses):**
```{r eval=FALSE}
# Wrong:
plot(mean, data)

# Right:
plot(mean(data), ...)
```

**2. Don't name variables after functions:**
```{r}
# Bad:
# mean <- 42
# sum <- 100
# data <- my_data

# Good:
average_value <- 42
total_sum <- 100
my_data <- ...
```

**3. Remove conflicting variable:**
```{r}
# If you accidentally created:
# sum <- 100

# Remove it:
rm(sum)

# Now sum() function works again
sum(1:10)
```
</div>

## Error #5: `cannot coerce class "X" to a data.frame` {#cannot-coerce-df}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Trying to convert incompatible type
my_func <- function() { return(42) }
as.data.frame(my_func)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in as.data.frame.default(my_func) : 
  cannot coerce class '"function"' to a data.frame
```
</div>

### Common Causes

#### Cause 1: Wrong Object Type

```{r error=TRUE}
# Can't convert function
as.data.frame(mean)

# Can't convert environment
as.data.frame(.GlobalEnv)
```

#### Cause 2: Wrong List Structure

```{r error=TRUE}
# Uneven list lengths
bad_list <- list(a = 1:3, b = 1:5)
as.data.frame(bad_list)  # Error - different lengths!
```

```{r}
# Must be same length or length 1
good_list <- list(a = 1:3, b = 4:6)
as.data.frame(good_list)

# Or use recycling
recycled_list <- list(a = 1:3, b = 1)  # b recycled
as.data.frame(recycled_list)
```

#### Cause 3: Matrix With Wrong Type

```{r error=TRUE}
# Some object types don't convert cleanly
nested <- list(list(1, 2), list(3, 4))
as.data.frame(nested)  # Error - nested lists!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Fix List Structure**

```{r}
# Uneven lengths - fix it
bad_list <- list(a = 1:3, b = 1:5)

# Option 1: Trim to shortest
min_len <- min(lengths(bad_list))
fixed_list <- lapply(bad_list, function(x) x[1:min_len])
as.data.frame(fixed_list)

# Option 2: Pad with NA
max_len <- max(lengths(bad_list))
fixed_list <- lapply(bad_list, function(x) {
  c(x, rep(NA, max_len - length(x)))
})
as.data.frame(fixed_list)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert Correctly**

```{r}
# From matrix
mat <- matrix(1:6, nrow = 2)
as.data.frame(mat)

# From vector with names
vec <- c(a = 1, b = 2, c = 3)
as.data.frame(as.list(vec))

# From nested list - flatten first
nested <- list(list(1, 2), list(3, 4))
flat <- unlist(nested, recursive = FALSE)
# Or handle differently depending on structure
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check Before Converting**

```{r}
safe_as_df <- function(x) {
  # Check if it's already a data frame
  if (is.data.frame(x)) return(x)
  
  # Check if it's a matrix
  if (is.matrix(x)) return(as.data.frame(x))
  
  # Check if it's a list with equal lengths
  if (is.list(x)) {
    lens <- lengths(x)
    if (length(unique(lens)) == 1 || all(lens == 1 | lens == max(lens))) {
      return(as.data.frame(x))
    } else {
      stop("List elements have incompatible lengths: ", 
           paste(lens, collapse = ", "))
    }
  }
  
  # Try generic conversion
  tryCatch(
    as.data.frame(x),
    error = function(e) {
      stop("Cannot convert ", class(x), " to data.frame: ", e$message)
    }
  )
}

# Test
safe_as_df(list(a = 1:3, b = 4:6))  # Works
```
</div>

## Error #6: `NAs introduced by coercion` {#nas-coercion}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Warning (Usually)

```{r}
as.numeric(c("1", "2", "three", "4"))
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
NAs introduced by coercion
```
</div>

### What It Means

R tried to convert something to numeric, but some values couldn't be converted, so they became NA.

### Common Scenarios

#### Scenario 1: Text in Numeric Column

```{r}
# Data entry errors
scores <- c("90", "85", "N/A", "92", "absent")
as.numeric(scores)

# Check which became NA
is.na(as.numeric(scores))
```

#### Scenario 2: Special Characters

```{r}
# Currency symbols
prices <- c("$10.99", "$25.50", "$8.75")
as.numeric(prices)  # All become NA!

# Need to remove $ first
as.numeric(gsub("\\$", "", prices))
```

#### Scenario 3: Scientific Notation Issues

```{r}
# Usually these work fine
as.numeric("1.5e-10")  # Scientific notation OK

# But typos don't
as.numeric("1.5E-10a")  # Typo creates NA
```

#### Scenario 4: Factors with Text Levels

```{r}
# Factor with non-numeric levels
responses <- factor(c("Yes", "No", "Yes", "Maybe"))
as.numeric(responses)  # Gives factor codes (1,2,1,3), not what you want

# And trying to convert to the levels gives NA
as.numeric(as.character(responses))
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Clean Data First**

```{r}
# Remove non-numeric characters
dirty <- c("$10.99", "‚Ç¨25.50", "8.75")

# Remove currency symbols
clean <- gsub("[^0-9.]", "", dirty)
as.numeric(clean)

# More robust cleaning
clean_numeric <- function(x) {
  # Remove everything except numbers, decimal, minus
  cleaned <- gsub("[^0-9.-]", "", x)
  as.numeric(cleaned)
}

clean_numeric(c("$10.99", "-25.5%", "8 dollars"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Handle NAs Explicitly**

```{r}
values <- c("1", "2", "three", "4")
converted <- as.numeric(values)

# Check which failed
failed <- is.na(converted) & !is.na(values)
if (any(failed)) {
  message("Could not convert: ", paste(values[failed], collapse = ", "))
}

# Or replace NAs with default
converted[is.na(converted)] <- 0
converted
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use readr's parse_number()**

```{r}
library(readr)

# Automatically extracts numbers
parse_number("$10.99")
parse_number("Price: $25.50")
parse_number("8.75%")

# Vector
parse_number(c("$10.99", "‚Ç¨25.50", "8.75"))
```
</div>

<div class="bestpractice-box">
üéØ **Best Practice: Validate After Coercion**

```{r}
coerce_with_validation <- function(x, to = "numeric") {
  original <- x
  
  if (to == "numeric") {
    converted <- as.numeric(x)
  } else if (to == "integer") {
    converted <- as.integer(x)
  } else {
    stop("Unsupported conversion type")
  }
  
  # Count NAs
  original_nas <- sum(is.na(original))
  new_nas <- sum(is.na(converted))
  introduced_nas <- new_nas - original_nas
  
  if (introduced_nas > 0) {
    warning(introduced_nas, " NAs introduced by coercion")
    failed_values <- original[is.na(converted) & !is.na(original)]
    message("Failed to convert: ", 
            paste(head(failed_values, 5), collapse = ", "),
            if(length(failed_values) > 5) "..." else "")
  }
  
  return(converted)
}

# Test
coerce_with_validation(c("1", "2", "three", "4"))
```
</div>

## Error #7: `character string is not in a standard unambiguous format` {#date-parse-error}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
as.Date("2024/13/01")  # Month 13 doesn't exist
```

<div class="error-box">
üî¥ **ERROR**

```
Error in charToDate(x) : 
  character string is not in a standard unambiguous format
```
</div>

### What It Means

You're trying to convert a string to a Date, but R can't figure out the format, or the date is invalid.

### Common Causes

#### Cause 1: Wrong Date Format

```{r error=TRUE}
# American format (month/day/year)
as.Date("12/25/2024")  # R expects YYYY-MM-DD
```

```{r}
# Specify format
as.Date("12/25/2024", format = "%m/%d/%Y")
```

#### Cause 2: Invalid Date

```{r error=TRUE}
as.Date("2024-02-30")  # February doesn't have 30 days
as.Date("2024-13-01")  # Month 13 doesn't exist
```

#### Cause 3: Ambiguous Format

```{r error=TRUE}
# Is this Jan 2 or Feb 1?
as.Date("01/02/2024")  # R gets confused
```

```{r}
# Be explicit
as.Date("01/02/2024", format = "%m/%d/%Y")  # Jan 2
as.Date("01/02/2024", format = "%d/%m/%Y")  # Feb 1
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Specify Format**

```{r}
# Common formats
as.Date("2024-12-25")  # ISO format (default)
as.Date("12/25/2024", format = "%m/%d/%Y")
as.Date("25/12/2024", format = "%d/%m/%Y")
as.Date("Dec 25, 2024", format = "%b %d, %Y")
as.Date("December 25, 2024", format = "%B %d, %Y")
```

**Format codes:**
- `%Y` = 4-digit year (2024)
- `%y` = 2-digit year (24)
- `%m` = numeric month (12)
- `%d` = day of month (25)
- `%b` = abbreviated month (Dec)
- `%B` = full month (December)
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use lubridate (Easier!)**

```{r}
library(lubridate)

# Auto-detect common formats
ymd("2024-12-25")
mdy("12/25/2024")
dmy("25/12/2024")
mdy("Dec 25, 2024")

# Vector of dates
dates <- c("2024-12-25", "2024/01/15", "2024.06.30")
ymd(dates)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Handle Parse Failures**

```{r}
dates <- c("2024-12-25", "invalid", "2024-02-30", "2024-01-15")

# Base R - NAs for failures
parsed <- as.Date(dates)  # Warnings
parsed

# lubridate - shows which failed
library(lubridate)
parsed <- ymd(dates, quiet = FALSE)
parsed

# Custom handling
safe_parse_date <- function(x, format = "%Y-%m-%d") {
  result <- as.Date(x, format = format)
  
  # Report failures
  failed <- is.na(result) & !is.na(x)
  if (any(failed)) {
    message("Failed to parse ", sum(failed), " dates:")
    message(paste(x[failed], collapse = ", "))
  }
  
  return(result)
}

safe_parse_date(dates)
```
</div>

## Type Checking Functions

<div class="bestpractice-box">
üéØ **Best Practice: Check Types Before Operating**

```{r}
# Checking functions
is.numeric(5)       # TRUE for integer or double
is.integer(5L)      # TRUE only for integer
is.double(5.0)      # TRUE only for double
is.character("5")   # TRUE for character
is.logical(TRUE)    # TRUE for logical
is.factor(factor(1:3))  # TRUE for factor

# Getting type info
typeof(5)           # "double"
class(5)            # "numeric"
mode(5)             # "numeric"

# More specific checks
is.na(NA)           # TRUE for NA
is.null(NULL)       # TRUE for NULL
is.nan(NaN)         # TRUE for NaN (not a number)
is.infinite(Inf)    # TRUE for Inf
is.finite(5)        # TRUE for normal numbers

# Structure checks
is.vector(c(1,2,3))      # TRUE
is.list(list(1,2))       # TRUE
is.matrix(matrix(1:4, 2, 2))  # TRUE
is.data.frame(data.frame(x=1:3))  # TRUE
is.array(array(1:8, dim=c(2,2,2)))  # TRUE
```
</div>

## Type Conversion Functions

<div class="insight-box">
üí° **Key Insight: Conversion Functions**

```{r}
# To numeric
as.numeric("5")
as.integer("5")
as.double("5.5")

# To character
as.character(5)
as.character(TRUE)

# To logical
as.logical(1)        # TRUE
as.logical(0)        # FALSE
as.logical("TRUE")   # TRUE
as.logical("T")      # TRUE

# To factor
as.factor(c("A", "B", "A"))

# Special conversions
as.Date("2024-01-15")
as.POSIXct("2024-01-15 10:30:00")
```

**Coercion Hierarchy:**
logical ‚Üí integer ‚Üí double ‚Üí character

Everything can become character!
```{r}
c(TRUE, 1L, 1.5, "text")  # All become character
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **R has 6 atomic types**: logical, integer, double, character, complex, raw
2. **Check types before operations**: Use `typeof()`, `class()`, `is.*()` functions
3. **Explicit is better than implicit**: Use `as.numeric()` rather than hoping
4. **Watch for silent failures**: Check for NAs after coercion
5. **Factors are tricky**: Convert to character before numeric
6. **Lists aren't vectors**: Use `unlist()` or `[[]]` extraction
7. **Specify date formats**: Don't rely on auto-detection
8. **Use lubridate for dates**: Much easier than base R

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| non-numeric argument to binary operator | Character in math | `as.numeric()` |
| non-numeric argument to math function | Character in function | `as.numeric()` |
| (list) cannot be coerced | Wrong structure | `unlist()` or `[[]]` |
| invalid type (closure) | Function instead of data | Call function or rename variable |
| cannot coerce to data.frame | Incompatible type | Fix structure or use correct conversion |
| NAs introduced by coercion | Invalid values | Clean data first |
| character string not in standard format | Date parse failure | Specify format or use lubridate |

**Type Checking Checklist:**
```{r eval=FALSE}
# Before doing math:
is.numeric(x)

# Before subsetting:
is.vector(x) || is.list(x)

# Before data frame operations:
is.data.frame(df)

# After conversion:
any(is.na(result))
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Type Detective**

What's wrong and how do you fix it?

```{r eval=FALSE}
# Scenario 1
age <- "25"
next_year <- age + 1

# Scenario 2
scores <- factor(c("90", "85", "95"))
average <- mean(as.numeric(scores))

# Scenario 3
df <- data.frame(x = 1:5)
total <- sum(df[1])

# Scenario 4
dates <- c("2024-01-15", "15/01/2024", "Jan 15 2024")
parsed <- as.Date(dates)
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Type Conversion**

Write a function that:
1. Takes a vector of any type
2. Tries to convert to numeric
3. Reports which values failed
4. Returns numeric vector with NAs for failures
5. Provides a summary of conversions
</div>

<div class="exercise-box">
üìù **Exercise 3: Real Data**

You receive this data:

```{r eval=FALSE}
sales <- c("$1,234.56", "$987.65", "N/A", "$2,345.67", "pending")
dates <- c("01/15/2024", "2024-02-20", "Mar 15, 2024")
```

Clean and convert both to appropriate types.
</div>

<div class="exercise-box">
üìù **Exercise 4: Data Frame Types**

Debug this code:

```{r eval=FALSE}
df <- data.frame(
  id = 1:3,
  value = c("100", "200", "300"),
  date = c("2024-01-15", "2024-02-20", "2024-03-25")
)

# Want to do:
df$value_doubled <- df$value * 2
df$days_since <- Sys.Date() - df$date
```

Fix the types so operations work.
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r eval=FALSE}
# Scenario 1 - Character in math
age <- "25"
age <- as.numeric(age)  # Fix
next_year <- age + 1

# Scenario 2 - Factor to numeric wrong way
scores <- factor(c("90", "85", "95"))
# Wrong: as.numeric(scores) gives 1,2,3
# Right:
scores_num <- as.numeric(as.character(scores))
average <- mean(scores_num)

# Scenario 3 - Single bracket returns data frame
df <- data.frame(x = 1:5)
# Wrong: df[1] is still data frame
# Right:
total <- sum(df[[1]])  # or sum(df$x)

# Scenario 4 - Mixed date formats
dates <- c("2024-01-15", "15/01/2024", "Jan 15 2024")
# Need different formats for each
library(lubridate)
parsed <- c(ymd("2024-01-15"), 
            dmy("15/01/2024"),
            mdy("Jan 15 2024"))
```

**Exercise 2:**

```{r}
smart_numeric_convert <- function(x) {
  # Store original
  original <- x
  original_class <- class(x)
  
  # Attempt conversion
  converted <- suppressWarnings(as.numeric(x))
  
  # Identify failures
  original_na <- is.na(original)
  new_na <- is.na(converted)
  failures <- new_na & !original_na
  
  # Report
  cat("Conversion Summary:\n")
  cat("  Original type:", original_class, "\n")
  cat("  Total values:", length(x), "\n")
  cat("  Successful:", sum(!new_na), "\n")
  cat("  Failed:", sum(failures), "\n")
  cat("  Already NA:", sum(original_na), "\n\n")
  
  if (any(failures)) {
    cat("Failed values:\n")
    print(head(original[failures], 10))
  }
  
  return(converted)
}

# Test
smart_numeric_convert(c("1", "2", "three", "4", "five"))
```

**Exercise 3:**

```{r}
library(readr)
library(lubridate)

# Clean sales
sales <- c("$1,234.56", "$987.65", "N/A", "$2,345.67", "pending")

# Remove currency and commas, handle text
sales_clean <- gsub("[$,]", "", sales)
sales_num <- suppressWarnings(as.numeric(sales_clean))
sales_num[is.na(sales_num)]  <- 0  # Or handle differently

# Clean dates
dates <- c("01/15/2024", "2024-02-20", "Mar 15, 2024")

# Try multiple formats
dates_parsed <- as.Date(parse_date_time(dates, 
                                        orders = c("mdy", "ymd", "bdy")))

# Result
data.frame(
  sales = sales_num,
  date = dates_parsed
)
```

**Exercise 4:**

```{r}
df <- data.frame(
  id = 1:3,
  value = c("100", "200", "300"),
  date = c("2024-01-15", "2024-02-20", "2024-03-25"),
  stringsAsFactors = FALSE
)

# Fix types
df$value <- as.numeric(df$value)
df$date <- as.Date(df$date)

# Now operations work
df$value_doubled <- df$value * 2
df$days_since <- as.numeric(Sys.Date() - df$date)

df
```
</details>

<!--chapter:end:04-type-mismatch.Rmd-->

# Vectors & Recycling {#vectors-recycling}

<div class="chapter-summary">
**What You'll Learn:**

- How R's vector recycling works
- When recycling helps and when it hurts
- Length mismatch errors
- Replacement length errors
- Vectorization best practices

**Key Errors Covered:** 15+ recycling and length errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

R's superpower is **vectorization** - operations work on entire vectors at once. But with this power comes a quirky feature called **recycling** that causes endless confusion.

```{r}
# Simple vectorization
c(1, 2, 3) + c(10, 20, 30)
```

But what about this?

```{r}
# Different lengths!
c(1, 2, 3, 4) + c(10, 20)
```

It works! But is this what you wanted? Let's explore when recycling helps and when it causes errors.

## Understanding Recycling

<div class="insight-box">
üí° **Key Insight: The Recycling Rule**

When vectors of different lengths are used together, **R repeats the shorter one** to match the longer one.

```{r}
# What happens:
c(1, 2, 3, 4) + c(10, 20)

# R expands to:
c(1, 2, 3, 4) + c(10, 20, 10, 20)
#                        ‚Üë   ‚Üë  recycled!
```

**Works smoothly when:**
- One vector is length 1 (scalar)
- Lengths are multiples (2 and 4, 3 and 6)

**Warns when:**
- Lengths aren't multiples (3 and 5)

**Errors when:**
- Replacement context and lengths don't match
</div>

## Error #1: `longer object length is not a multiple` {#recycling-warning}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Warning

```{r}
c(1, 2, 3) + c(10, 20, 30, 40, 50)
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In c(1, 2, 3) + c(10, 20, 30, 40, 50) :
  longer object length is not a multiple of shorter object length
```
</div>

### What It Means

R is recycling, but the lengths don't match evenly. This usually indicates a mistake.

### Common Causes

#### Cause 1: Data Mismatch

```{r}
# You have 100 observations
data <- rnorm(100)

# But only 3 group labels
groups <- c("A", "B", "C")

# Recycling happens
combined <- data.frame(value = data, group = groups)
```

The warning tells you: "Hey, are you sure about this?"

#### Cause 2: Filtering Gone Wrong

```{r}
x <- 1:10
y <- 1:7  # Oops, lost some values

# Operations warn
x + y
x * y
```

#### Cause 3: Unintended Partial Matching

```{r}
treatment <- c("Drug", "Placebo")
outcomes <- rnorm(25)  # 25 subjects

# Assigning treatment to outcomes
data.frame(outcome = outcomes, treatment = treatment)
```

Warning: 25 is not a multiple of 2!

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Fix the Lengths**

```{r}
# Original problem
x <- 1:10
y <- 1:7

# Option A: Trim to match
min_len <- min(length(x), length(y))
x[1:min_len] + y[1:min_len]

# Option B: Extend with NA
y_extended <- c(y, rep(NA, length(x) - length(y)))
x + y_extended

# Option C: Explicit recycling (if intentional)
y_recycled <- rep(y, length.out = length(x))
x + y_recycled
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Lengths Before Operating**

```{r}
safe_operation <- function(x, y, op = `+`) {
  if (length(x) != length(y)) {
    # Check if one is length 1 (scalar - OK)
    if (length(x) == 1 || length(y) == 1) {
      return(op(x, y))
    }
    
    # Check if lengths are multiples
    if (max(length(x), length(y)) %% min(length(x), length(y)) != 0) {
      warning("Lengths are not multiples: ", 
              length(x), " and ", length(y))
    }
  }
  
  return(op(x, y))
}

# Test
safe_operation(1:10, 1:7, `+`)  # Warns
safe_operation(1:10, 1:5, `+`)  # No warning (10/5 = 2)
safe_operation(1:10, 2, `+`)    # No warning (scalar)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use rep() Explicitly**

```{r}
# Make intention clear
x <- 1:12
pattern <- c(1, 2, 3)

# Explicit recycling
y <- rep(pattern, length.out = length(x))
x + y

# Or with times
y <- rep(pattern, times = length(x) / length(pattern))
x + y
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Silent Recycling with Multiples**

```{r}
# No warning when lengths are multiples!
x <- 1:6
y <- c(10, 20, 30)  # 6 is multiple of 3

result <- x + y
result

# R expanded y to: c(10, 20, 30, 10, 20, 30)
# Was this intended?
```

**Always check:** Just because it doesn't warn doesn't mean it's correct!
</div>

## Error #2: `replacement has X rows, data has Y` {#replacement-rows}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Error

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
df$z <- 1:3  # Wrong length!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `$<-.data.frame`(`*tmp*`, z, value = 1:3) : 
  replacement has 3 rows, data has 5
```
</div>

### What It Means

You're trying to add/replace a column, but the number of values doesn't match the number of rows.

### Common Causes

#### Cause 1: Wrong Length Column

```{r error=TRUE}
df <- data.frame(id = 1:10)

# Calculated something with wrong length
summary_values <- c(100, 200, 300)  # Only 3 values

# Try to add as column
df$summary <- summary_values  # Error!
```

#### Cause 2: Filtered Data Reassignment

```{r error=TRUE}
df <- data.frame(x = 1:10, y = rnorm(10))

# Filter
subset_df <- df[df$y > 0, ]  # Maybe 6 rows

# Create column for subset
new_values <- 1:6

# Try to add to original
df$new <- new_values  # Error! Original has 10 rows
```

#### Cause 3: Aggregation Length Mismatch

```{r error=TRUE}
# 20 observations
df <- data.frame(
  id = 1:20,
  group = rep(c("A", "B"), each = 10)
)

# Aggregate to 2 values (one per group)
group_means <- tapply(df$id, df$group, mean)

# Try to add back to original
df$group_mean <- group_means  # Error! 2 values, 20 rows
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Match the Length**

```{r}
df <- data.frame(id = 1:10)
summary_values <- c(100, 200, 300)

# Recycle explicitly
df$summary <- rep(summary_values, length.out = nrow(df))

# Or extend with NA
df$summary <- c(summary_values, rep(NA, nrow(df) - length(summary_values)))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Merge/Join for Aggregates**

```{r}
# Original data
df <- data.frame(
  id = 1:20,
  group = rep(c("A", "B"), each = 10),
  value = rnorm(20)
)

# Aggregate
group_summary <- aggregate(value ~ group, df, mean)
names(group_summary)[2] <- "group_mean"

# Merge back
df <- merge(df, group_summary, by = "group")
head(df)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: dplyr Way (Cleaner)**

```{r}
library(dplyr)

df <- data.frame(
  id = 1:20,
  group = rep(c("A", "B"), each = 10),
  value = rnorm(20)
)

# Add group mean to each row
df <- df %>%
  group_by(group) %>%
  mutate(group_mean = mean(value)) %>%
  ungroup()

head(df)
```
</div>

## Error #3: `number of items to replace is not a multiple` {#replacement-multiple}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Error

```{r error=TRUE}
x <- 1:10
x[1:7] <- c(100, 200)  # 7 positions, 2 values
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x[1:7] <- c(100, 200) : 
  number of items to replace is not a multiple of replacement length
```
</div>

### What It Means

You're replacing a subset, but the lengths don't match evenly (not multiples).

### When This Happens

```{r error=TRUE}
# Replacing 10 items with 3 values
x <- 1:10
x[] <- c(1, 2, 3)  # 10 is not a multiple of 3

# Replacing 7 items with 2 values
x[1:7] <- c(10, 20)  # 7 is not a multiple of 2
```

But these work:

```{r}
# Length 1 always works
x <- 1:10
x[1:7] <- 99
x

# Multiples work
x <- 1:10
x[1:6] <- c(10, 20, 30)  # 6 is multiple of 3
x
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Make Lengths Match**

```{r}
x <- 1:10

# Option A: Recycle explicitly
replacement <- rep(c(100, 200), length.out = 7)
x[1:7] <- replacement
x

# Option B: Subset to match
x <- 1:10
x[1:2] <- c(100, 200)  # Only replace 2
x
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use ifelse() for Conditional Replacement**

```{r}
x <- 1:10

# Replace first 7 with pattern
x <- ifelse(seq_along(x) <= 7, 
            rep(c(100, 200), length.out = length(x))[seq_along(x)], 
            x)
x
```
</div>

## Error #4: `replacement has length zero` {#replacement-zero}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Error

```{r error=TRUE}
x <- 1:5
x[3] <- c()  # Empty vector!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x[3] <- c() : replacement has length zero
```
</div>

### What It Means

You're trying to replace elements with an empty vector (length 0).

### Common Causes

#### Cause 1: Empty Filter Result

```{r error=TRUE}
df <- data.frame(x = 1:10, y = letters[1:10])

# Filter returns empty
subset_values <- df$x[df$y == "z"]  # No "z", returns numeric(0)

# Try to use for replacement
df$new[1:5] <- subset_values  # Error!
```

#### Cause 2: Function Returns Empty

```{r error=TRUE}
get_values <- function(condition) {
  if (condition) {
    return(1:5)
  } else {
    return(numeric(0))  # Oops!
  }
}

x <- 1:10
x[1:5] <- get_values(FALSE)  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Before Replacing**

```{r}
x <- 1:10
replacement <- numeric(0)  # Empty

# Check first
if (length(replacement) > 0) {
  x[1:length(replacement)] <- replacement
} else {
  message("No replacement values")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use NA as Default**

```{r}
get_values_safe <- function(condition) {
  if (condition) {
    return(1:5)
  } else {
    return(NA)  # Or a default value
  }
}

x <- 1:10
x[1:5] <- get_values_safe(FALSE)  # Works, assigns NA
x
```
</div>

## Vectorization Best Practices

<div class="bestpractice-box">
üéØ **Best Practice: Length-Safe Operations**

```{r}
# 1. Check lengths match
operate_safely <- function(x, y, fun) {
  if (length(x) != length(y)) {
    stop("Vectors must be same length. Got ", 
         length(x), " and ", length(y))
  }
  fun(x, y)
}

# 2. Use recycling intentionally (scalars only)
add_scalar <- function(vec, scalar) {
  stopifnot(length(scalar) == 1)
  vec + scalar
}

# 3. Document recycling behavior
#' Add vectors with explicit recycling
#' @param x numeric vector
#' @param y numeric vector (will be recycled to length of x)
add_with_recycling <- function(x, y) {
  if (length(y) == 1) {
    return(x + y)  # Scalar - always OK
  }
  
  y_recycled <- rep(y, length.out = length(x))
  return(x + y_recycled)
}
```
</div>

## Understanding Vector Operations

<div class="insight-box">
üí° **Key Insight: What Gets Recycled**

```{r}
# Arithmetic operators
1:4 + c(10, 20)           # Addition
1:4 - c(10, 20)           # Subtraction
1:4 * c(2, 3)             # Multiplication
1:4 / c(2, 4)             # Division

# Logical operators
c(TRUE, FALSE) & c(TRUE, TRUE, FALSE, FALSE)
c(TRUE, FALSE) | c(FALSE, FALSE, TRUE, TRUE)

# Comparison operators
1:6 > c(2, 4, 6)          # Recycles both

# Assignment
x <- 1:12
x[] <- c(1, 2, 3)         # Recycles to 12
x
```

**Key point:** Recycling happens in MANY contexts!
</div>

## Edge Cases and Gotchas

### Gotcha #1: Matrix Recycling

```{r}
# Matrices recycle by column!
matrix(1:2, nrow = 3, ncol = 4)
```

Warning appears because 12 (3√ó4) is not multiple of 2.

### Gotcha #2: Data Frame Column Recycling

```{r}
# This works - length 1 always recycles
df <- data.frame(
  x = 1:5,
  y = 10  # Recycled to 5
)
df

# This works - multiple lengths
df <- data.frame(
  x = 1:6,
  y = c(1, 2)  # Recycled to 6
)
df
```

```{r error=TRUE}
# This fails - not a multiple
df <- data.frame(
  x = 1:5,
  y = c(1, 2)  # 5 is not multiple of 2
)
```

### Gotcha #3: List Operations Don't Recycle

```{r error=TRUE}
# Vectors recycle
c(1, 2) + c(10, 20, 30)  # Works (with warning)

# Lists don't
list(1, 2) + list(10, 20, 30)  # Error!
```

Lists need explicit handling:

```{r}
x <- list(1, 2, 3)
y <- list(10, 20)

# Use Map or mapply
Map(`+`, x, rep(y, length.out = length(x)))
```

## Debugging Recycling Issues

<div class="insight-box">
üí° **Debugging Checklist**

```{r}
# 1. Check lengths
x <- 1:10
y <- 1:7
length(x)
length(y)

# 2. Check if they're multiples
max(length(x), length(y)) %% min(length(x), length(y))
# 0 = clean multiple, anything else = partial recycling

# 3. Visualize recycling
rep(y, length.out = length(x))

# 4. Test operation
tryCatch(
  x + y,
  warning = function(w) {
    message("Warning caught: ", w$message)
  }
)

# 5. Check for unexpected conversions
class(x); typeof(x)
class(y); typeof(y)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Recycling is automatic**: R repeats shorter vectors to match longer ones
2. **Warnings appear**: When lengths aren't multiples (except scalars)
3. **Scalars always work**: Length 1 recycles to any length
4. **Check before operating**: Use `length()` to verify matches
5. **Explicit is better**: Use `rep()` to show intent
6. **Data frames are strict**: Column lengths must match (or be length 1)
7. **Errors vs warnings**: Replacement operations error, arithmetic operations warn

**Quick Reference:**

| Situation | Behavior |
|-----------|----------|
| Same length | No recycling needed |
| One is length 1 | Silent recycling (scalar) |
| Lengths are multiples | Silent recycling (e.g., 2 and 6) |
| Lengths not multiples | Warning + recycling (e.g., 3 and 7) |
| Replacement, wrong length | Error (not multiples) |
| Replacement, length 0 | Error |
| Data frame column | Error if not length 1 or nrow |

**Prevention:**

```{r eval=FALSE}
# Always check
stopifnot(length(x) == length(y))

# Or use scalars only
stopifnot(length(y) == 1)

# Or recycle explicitly
y <- rep(y, length.out = length(x))
```

**Remember:** No warning doesn't mean correct! Multiples recycle silently.
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Predict the Outcome**

What will happen? Will it work, warn, or error?

```{r eval=FALSE}
# A
c(1, 2, 3, 4) + c(10, 20)

# B
c(1, 2, 3, 4, 5) + c(10, 20)

# C
df <- data.frame(x = 1:10)
df$y <- c(1, 2, 3, 4, 5)

# D
x <- 1:12
x[] <- c(1, 2, 3, 4)

# E
matrix(1:5, nrow = 5, ncol = 5)
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Fix the Code**

Debug these recycling problems:

```{r eval=FALSE}
# Problem 1
students <- 1:25
groups <- c("A", "B", "C")
data.frame(student = students, group = groups)

# Problem 2
values <- rnorm(100)
weights <- c(1, 2, 3)
weighted <- values * weights

# Problem 3
df <- data.frame(id = 1:20)
summary_stats <- c(mean = 50, sd = 10, n = 20)
df$mean <- summary_stats["mean"]
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Operations**

Write a function `safe_add(x, y)` that:
1. Checks if lengths match
2. If not, asks user what to do:
   - Error
   - Recycle shorter
   - Trim longer
   - Extend with NA
3. Performs the operation
4. Returns result with attribute showing what was done
</div>

<div class="exercise-box">
üìù **Exercise 4: Real World**

You have exam scores for 100 students across 4 quarters:

```{r eval=FALSE}
scores_q1 <- rnorm(100, mean = 75, sd = 10)
scores_q2 <- rnorm(98, mean = 78, sd = 10)   # 2 students dropped
scores_q3 <- rnorm(102, mean = 80, sd = 10)  # 2 new students
scores_q4 <- rnorm(100, mean = 82, sd = 10)
```

Create a data frame with:
- All students who completed at least one quarter
- NA for missing scores
- Calculate average score per student
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# A - Works, silent (4 is multiple of 2)
c(1, 2, 3, 4) + c(10, 20)

# B - Works, warns (5 not multiple of 2)
c(1, 2, 3, 4, 5) + c(10, 20)

# C - Errors (10 not multiple of 5)
tryCatch(
  data.frame(x = 1:10, y = c(1, 2, 3, 4, 5)),
  error = function(e) message("Error: ", e$message)
)

# D - Works, silent (12 is multiple of 4)
x <- 1:12
x[] <- c(1, 2, 3, 4)
x

# E - Works, silent (25 is multiple of 5)
matrix(1:5, nrow = 5, ncol = 5)
```

**Exercise 2:**

```{r}
# Problem 1 - Recycle groups explicitly
students <- 1:25
groups <- c("A", "B", "C")
data.frame(
  student = students, 
  group = rep(groups, length.out = length(students))
)

# Problem 2 - Make intention clear
values <- rnorm(100)
weights <- c(1, 2, 3)
weights_full <- rep(weights, length.out = length(values))
weighted <- values * weights_full

# Problem 3 - Extract scalar properly
df <- data.frame(id = 1:20)
summary_stats <- c(mean = 50, sd = 10, n = 20)
df$mean <- summary_stats[["mean"]]  # Single value
```

**Exercise 3:**

```{r}
safe_add <- function(x, y, action = c("error", "recycle", "trim", "extend")) {
  action <- match.arg(action)
  
  if (length(x) == length(y)) {
    result <- x + y
    attr(result, "action") <- "none_needed"
    return(result)
  }
  
  if (action == "error") {
    stop("Lengths don't match: ", length(x), " vs ", length(y))
  }
  
  if (action == "recycle") {
    max_len <- max(length(x), length(y))
    x <- rep(x, length.out = max_len)
    y <- rep(y, length.out = max_len)
    result <- x + y
    attr(result, "action") <- "recycled"
  }
  
  if (action == "trim") {
    min_len <- min(length(x), length(y))
    result <- x[1:min_len] + y[1:min_len]
    attr(result, "action") <- "trimmed"
  }
  
  if (action == "extend") {
    max_len <- max(length(x), length(y))
    x <- c(x, rep(NA, max_len - length(x)))
    y <- c(y, rep(NA, max_len - length(y)))
    result <- x + y
    attr(result, "action") <- "extended"
  }
  
  return(result)
}

# Test
safe_add(1:5, 1:3, "recycle")
```

**Exercise 4:**

```{r}
# Create scores with different lengths
set.seed(123)
scores_q1 <- rnorm(100, mean = 75, sd = 10)
scores_q2 <- rnorm(98, mean = 78, sd = 10)
scores_q3 <- rnorm(102, mean = 80, sd = 10)
scores_q4 <- rnorm(100, mean = 82, sd = 10)

# Find max number of students
max_students <- max(length(scores_q1), length(scores_q2), 
                   length(scores_q3), length(scores_q4))

# Extend all to max length with NA
extend_with_na <- function(x, target_len) {
  c(x, rep(NA, target_len - length(x)))
}

# Create data frame
df <- data.frame(
  student_id = 1:max_students,
  q1 = extend_with_na(scores_q1, max_students),
  q2 = extend_with_na(scores_q2, max_students),
  q3 = extend_with_na(scores_q3, max_students),
  q4 = extend_with_na(scores_q4, max_students)
)

# Calculate average (ignoring NAs)
df$average <- rowMeans(df[, c("q1", "q2", "q3", "q4")], na.rm = TRUE)

# Keep only students with at least one score
df <- df[!is.nan(df$average), ]

head(df)
```
</details>

<!--chapter:end:05-vectors-recycling.Rmd-->

# NA, NULL, NaN, Inf {#na-null-nan-inf}

<div class="chapter-summary">
**What You'll Learn:**

- The four "missing" value types in R
- Critical differences between NA, NULL, NaN, and Inf
- Common errors with missing data
- How to handle missing values properly
- Testing and detecting special values

**Key Errors Covered:** 15+ missing data errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

R has **four special "non-values"** that trip up everyone:

```{r}
NA    # Not Available
NULL  # Nothing
NaN   # Not a Number
Inf   # Infinity
```

They look similar but behave very differently, and confusing them causes endless errors.

<div class="insight-box">
üí° **Key Insight: The Four Special Values**

```{r}
# NA - Missing data (most common)
ages <- c(25, 30, NA, 35)  # One age is missing

# NULL - Absence of value (empty)
result <- NULL  # No result yet

# NaN - Invalid math result
0 / 0  # Undefined

# Inf - Infinite value
1 / 0  # Positive infinity
-1 / 0 # Negative infinity
```

**Think of it this way:**
- **NA**: "I don't know what this is"
- **NULL**: "There's nothing here"
- **NaN**: "This calculation doesn't make sense"
- **Inf**: "This is beyond measurement"
</div>

## NA: Not Available

### What is NA?

```{r}
# NA is a placeholder for missing data
x <- c(1, 2, NA, 4, 5)
x

# It has a type!
typeof(NA)              # logical
typeof(NA_real_)        # double
typeof(NA_integer_)     # integer
typeof(NA_character_)   # character
```

## Error #1: `missing values where TRUE/FALSE needed` {#na-logical}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
x <- NA
if (x > 5) {
  print("Large")
}
```

<div class="error-box">
üî¥ **ERROR**

```
Error in if (x > 5) { : missing value where TRUE/FALSE needed
```
</div>

### What It Means

`if()` needs TRUE or FALSE, but got NA. R won't guess which branch to take.

### Common Causes

#### Cause 1: Comparison with NA

```{r}
x <- c(1, 2, NA, 4, 5)

# Comparisons with NA give NA
x > 3

# Using in if()
```

```{r error=TRUE}
if (x[3] > 3) {  # x[3] is NA
  print("yes")
}
```

#### Cause 2: Missing Data in Condition

```{r error=TRUE}
df <- data.frame(
  age = c(25, NA, 35),
  name = c("Alice", "Bob", "Charlie")
)

# This creates NA in condition
if (df$age[2] > 30) {
  print("Senior")
}
```

#### Cause 3: Function Returns NA

```{r error=TRUE}
get_value <- function() {
  return(NA)
}

if (get_value() == 10) {
  print("Ten!")
}
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Test for NA First**

```{r}
x <- NA

# Check for NA before using
if (!is.na(x) && x > 5) {
  print("Large")
} else {
  print("Not large or is NA")
}

# Or handle NA explicitly
if (is.na(x)) {
  print("Missing value")
} else if (x > 5) {
  print("Large")
} else {
  print("Small")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use isTRUE()**

```{r}
x <- NA

# isTRUE() converts NA to FALSE
if (isTRUE(x > 5)) {
  print("Large")
}

# Equivalent to:
if (!is.na(x) && x > 5) {
  print("Large")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use %in% for Comparisons**

```{r}
x <- NA

# == with NA gives NA
x == 5  # NA

# %in% handles NA better
x %in% c(5)  # FALSE

# But still need to check:
5 %in% c(NA, 5)  # TRUE
NA %in% c(NA, 5) # TRUE
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: && vs &**

```{r}
x <- c(NA, 2, 3)

# Single & returns vector with NA
x > 1 & x < 5

# Double && errors on vector
```

```{r error=TRUE}
if (x > 1 && x < 5) {  # Error!
  print("yes")
}
```

**For if():** Use `&&` but check for NA first

**For vectorized ops:** Use `&` and handle NAs appropriately
</div>

## Error #2: `missing values and NaN's not allowed` {#na-not-allowed}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Error

```{r error=TRUE}
x <- c(1, 2, NA, 4, 5)
var(x)  # Without na.rm
```

<div class="error-box">
üî¥ **ERROR**

```
Error in var(x) : missing values and NaN's not allowed if 'na.rm' is FALSE
```
</div>

### What It Means

Some functions refuse to work with NA unless you explicitly tell them how to handle it.

### Common Functions With This Error

```{r error=TRUE}
x <- c(1, 2, NA, 4, 5)

# These error without na.rm:
var(x)
sd(x)
cov(x, x)
cor(x, x)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use na.rm = TRUE**

```{r}
x <- c(1, 2, NA, 4, 5)

# Remove NAs for calculation
var(x, na.rm = TRUE)
sd(x, na.rm = TRUE)
mean(x, na.rm = TRUE)
sum(x, na.rm = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Remove NAs First**

```{r}
x <- c(1, 2, NA, 4, 5)

# Complete cases only
x_complete <- x[!is.na(x)]
var(x_complete)

# Or use na.omit()
x_complete <- na.omit(x)
var(x_complete)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Replace NAs**

```{r}
x <- c(1, 2, NA, 4, 5)

# Replace with mean
x_filled <- x
x_filled[is.na(x_filled)] <- mean(x, na.rm = TRUE)
var(x_filled)

# Replace with median (more robust)
x_filled <- x
x_filled[is.na(x_filled)] <- median(x, na.rm = TRUE)
var(x_filled)
```
</div>

## Error #3: `'x' contains missing values` {#x-contains-na}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Error

```{r error=TRUE}
x <- c(1, 2, NA, 4)
y <- c(2, 3, 4, 5)
t.test(x, y)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in t.test.default(x, y) : 'x' contains missing values
```
</div>

### What It Means

Statistical tests often require complete data and won't work with NAs.

### Common Functions

```{r error=TRUE}
x <- c(1, 2, NA, 4, 5)
y <- c(2, 3, 4, 5, 6)

# These need complete data:
t.test(x, y)
wilcox.test(x, y)
chisq.test(x, y)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Remove NAs from both vectors:**
```{r}
x <- c(1, 2, NA, 4, 5)
y <- c(2, 3, 4, 5, 6)

# Find complete cases
complete <- complete.cases(x, y)
x_clean <- x[complete]
y_clean <- y[complete]

t.test(x_clean, y_clean)
```

**2. Use na.action:**
```{r}
# For functions that support it
df <- data.frame(x = c(1, 2, NA, 4), y = c(2, 3, 4, 5))
t.test(x ~ 1, data = df, na.action = na.omit)
```

**3. Impute missing values (advanced):**
```{r eval=FALSE}
library(mice)
imputed <- mice(data, m = 5, method = "pmm")
```
</div>

## NULL: The Absence of Value

### What is NULL?

```{r}
# NULL means "nothing"
x <- NULL
x

# Length zero
length(NULL)

# NULL disappears in vectors
c(1, 2, NULL, 4)

# Different from NA
c(1, 2, NA, 4)
```

## Error #4: `argument is of length zero` {#length-zero}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Error

```{r error=TRUE}
x <- NULL
if (x > 5) {
  print("yes")
}
```

<div class="error-box">
üî¥ **ERROR**

```
Error in if (x > 5) { : argument is of length zero
```
</div>

### What It Means

You're trying to use NULL in a context that needs at least one value.

### Common Causes

#### Cause 1: Uninitialized Variable

```{r error=TRUE}
# Forgot to assign
result <- NULL

# Try to use
if (result == 100) {
  print("success")
}
```

#### Cause 2: Empty Subset

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)

# Filter returns nothing
subset_val <- df$x[df$x > 10]  # numeric(0)
subset_val <- NULL  # Or explicitly NULL

# Try to use
if (subset_val > 0) {
  print("positive")
}
```

#### Cause 3: Function Returns NULL

```{r error=TRUE}
get_value <- function(x) {
  if (x > 10) {
    return(x * 2)
  }
  # Implicitly returns NULL when x <= 10
}

result <- get_value(5)  # NULL

if (result > 0) {
  print("positive")
}
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check for NULL**

```{r}
x <- NULL

# Check before using
if (!is.null(x) && x > 5) {
  print("Large")
} else {
  print("NULL or not large")
}

# Or use default
if (is.null(x)) {
  x <- 0  # Default value
}

if (x > 5) {
  print("Large")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Length**

```{r}
x <- NULL

# Check length instead
if (length(x) > 0 && x > 5) {
  print("Large")
}

# Works for both NULL and empty vectors
y <- numeric(0)
if (length(y) > 0 && y[1] > 5) {
  print("Large")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Default Values**

```{r}
get_value_safe <- function(x) {
  if (x > 10) {
    return(x * 2)
  } else {
    return(0)  # Default instead of NULL
  }
}

result <- get_value_safe(5)
if (result > 0) {
  print("positive")
}
```
</div>

## NaN: Not a Number

### What is NaN?

```{r}
# Result of invalid math
0 / 0
Inf - Inf
Inf / Inf

# NaN is a special type of NA
is.na(NaN)   # TRUE
is.nan(NA)   # FALSE
```

## Error #5: `NaNs produced` {#nans-produced}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Warning

```{r}
sqrt(-1)
log(-1)
0/0
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In sqrt(-1) : NaNs produced
```
</div>

### What It Means

You performed a mathematically invalid operation. Result is NaN.

### Common Causes

#### Cause 1: Negative Square Root

```{r}
# Real square root of negative number doesn't exist
sqrt(-1)
sqrt(c(1, 4, -9, 16))
```

#### Cause 2: Log of Negative/Zero

```{r}
# Log of negative or zero
log(0)   # -Inf
log(-1)  # NaN

# Log of vector with negatives
values <- c(1, 10, -5, 100)
log(values)
```

#### Cause 3: Invalid Division

```{r}
# 0/0 is undefined
0 / 0

# Inf operations
Inf - Inf
Inf / Inf
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Input Before Operation**

```{r}
safe_sqrt <- function(x) {
  if (any(x < 0, na.rm = TRUE)) {
    warning("Negative values found, returning NA for those")
  }
  result <- sqrt(x)
  return(result)
}

safe_sqrt(c(1, 4, -9, 16))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Handle NaN After Operation**

```{r}
x <- c(1, -4, 9, -16)
result <- sqrt(x)

# Replace NaN with NA (more standard)
result[is.nan(result)] <- NA
result

# Or with a specific value
result <- sqrt(x)
result[is.nan(result)] <- 0
result
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Complex Numbers for Sqrt**

```{r}
# For genuinely needing complex results
x <- -1
sqrt(as.complex(x))  # 0+1i

# Vector
x <- c(1, -4, 9, -16)
sqrt(as.complex(x))
```
</div>

## Inf: Infinity

### What is Inf?

```{r}
# Division by zero (non-zero)
1 / 0   # Inf
-1 / 0  # -Inf

# Very large calculations
exp(1000)  # Inf

# Inf in comparisons
Inf > 1e100  # TRUE
-Inf < -1e100  # TRUE
```

## Error #6: `infinite or missing values in 'x'` {#inf-in-x}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Error

```{r error=TRUE}
x <- c(1, 2, Inf, 4)
y <- c(2, 3, 4, 5)
cor(x, y)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in cor(x, y) : infinite or missing values in 'x'
```
</div>

### What It Means

Some functions can't handle infinite values and need finite numbers.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTIONS**

**1. Check for and remove Inf:**
```{r}
x <- c(1, 2, Inf, 4, -Inf, 5)

# Find finite values
is.finite(x)

# Keep only finite
x_finite <- x[is.finite(x)]
y_finite <- y[is.finite(x)]
cor(x_finite, y_finite)
```

**2. Replace Inf with large number:**
```{r}
x <- c(1, 2, Inf, 4, -Inf, 5)

# Replace Inf with max/min of finite values
x_fixed <- x
x_fixed[x == Inf] <- max(x[is.finite(x)]) * 10
x_fixed[x == -Inf] <- min(x[is.finite(x)]) * 10
x_fixed
```

**3. Check before calculation:**
```{r}
safe_cor <- function(x, y) {
  finite_both <- is.finite(x) & is.finite(y)
  
  if (sum(finite_both) < 2) {
    stop("Need at least 2 finite pairs")
  }
  
  cor(x[finite_both], y[finite_both])
}
```
</div>

## Testing for Special Values

<div class="bestpractice-box">
üéØ **Best Practice: Comprehensive Testing**

```{r}
# Test functions
x <- c(1, NA, NaN, Inf, -Inf, 0)

# Individual tests
is.na(x)       # TRUE for NA and NaN
is.nan(x)      # TRUE only for NaN
is.infinite(x) # TRUE for Inf and -Inf
is.finite(x)   # TRUE for normal numbers

# NULL is different
y <- NULL
is.null(y)     # TRUE
is.na(y)       # logical(0) - no value to test

# Combined checks
is_valid <- function(x) {
  !is.na(x) & !is.nan(x) & is.finite(x)
}

is_valid(x)
```

**Decision Tree:**
```{r eval=FALSE}
if (is.null(x)) {
  # Handle NULL - no value at all
} else if (is.nan(x)) {
  # Handle NaN - invalid math result
} else if (is.infinite(x)) {
  # Handle Inf/-Inf - beyond limits
} else if (is.na(x)) {
  # Handle NA - missing data
} else {
  # Normal value
}
```
</div>

## Handling Missing Data Strategies

<div class="insight-box">
üí° **Key Insight: Missing Data Strategies**

**1. Complete Case Analysis (Listwise Deletion)**
```{r}
df <- data.frame(
  x = c(1, 2, NA, 4, 5),
  y = c(10, NA, 30, 40, 50)
)

# Keep only complete rows
complete.cases(df)
df_complete <- df[complete.cases(df), ]
df_complete
```

**2. Available Case Analysis (Pairwise Deletion)**
```{r}
# Use all available data for each calculation
cor(df, use = "pairwise.complete.obs")
```

**3. Imputation (Replacing with Estimates)**
```{r}
# Replace with mean (simple)
df$x[is.na(df$x)] <- mean(df$x, na.rm = TRUE)

# Replace with median (robust to outliers)
df$y[is.na(df$y)] <- median(df$y, na.rm = TRUE)
```

**4. Keep as NA (Most Honest)**
```{r}
# Just handle NAs in analysis
mean(df$x, na.rm = TRUE)
```

**When to use each:**
- **Complete case**: When data missing completely at random (MCAR)
- **Pairwise**: When you want to use all available information
- **Imputation**: When you have good reason to estimate missing values
- **Keep NA**: When missingness is informative
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Four special values**: NA (missing), NULL (nothing), NaN (invalid math), Inf (infinite)
2. **NA vs NULL**: NA is a placeholder in a vector, NULL is absence of vector
3. **Test before using**: Always check `is.na()`, `is.null()`, `is.finite()`
4. **Use isTRUE()**: For conditions that might be NA
5. **na.rm = TRUE**: Most statistical functions need this with NAs
6. **NaN from invalid math**: sqrt(-1), 0/0, etc.
7. **Inf from overflow**: 1/0, exp(1000), etc.

**Quick Reference:**

| Value | Test | Meaning | Example |
|-------|------|---------|---------|
| NA | `is.na()` | Missing data | Survey non-response |
| NULL | `is.null()` | No value | Uninitialized variable |
| NaN | `is.nan()` | Invalid math | 0/0 |
| Inf | `is.infinite()` | Infinite | 1/0 |

**In if() statements:**

```{r eval=FALSE}
# ‚ùå Dangerous
if (x > 5) { }  # Errors if x is NA or NULL

# ‚úÖ Safe
if (!is.na(x) && x > 5) { }
if (isTRUE(x > 5)) { }
if (length(x) > 0 && !is.na(x) && x > 5) { }
```

**With functions:**

```{r eval=FALSE}
# ‚ùå May error
mean(x)
var(x)
cor(x, y)

# ‚úÖ Handle missing
mean(x, na.rm = TRUE)
var(x[is.finite(x)])
cor(x, y, use = "complete.obs")
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Identify the Type**

What are these and why?

```{r eval=FALSE}
# A
x <- c()
typeof(x)

# B  
y <- sqrt(-1)
class(y)

# C
z <- 1/0
is.finite(z)

# D
w <- c(1, 2, NA, 4)
w == NA
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Fix the Code**

Debug these:

```{r eval=FALSE}
# Problem 1
data <- c(1, 2, NA, 4, 5)
if (mean(data) > 3) {
  print("High average")
}

# Problem 2
get_score <- function(x) {
  if (x > 10) {
    return(x * 2)
  }
}
score <- get_score(5)
if (score > 10) {
  print("High score")
}

# Problem 3
values <- c(10, 20, 0, 30)
log_values <- log(values)
mean(log_values)
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Robust Function**

Write `robust_mean(x)` that:
1. Handles NA, NULL, NaN, Inf
2. Reports how many of each were found
3. Calculates mean of valid values
4. Returns list with mean and diagnostics
</div>

<div class="exercise-box">
üìù **Exercise 4: Data Cleaning**

You have survey data:

```{r eval=FALSE}
survey <- data.frame(
  age = c(25, NA, 35, -999, 40),  # -999 = missing
  income = c(50000, 75000, 0, 80000, NA),  # 0 = refused
  satisfaction = c(5, 3, NA, 4, 99)  # 99 = invalid
)
```

Clean it:
1. Convert -999 to NA
2. Convert 0 in income to NA
3. Convert 99 in satisfaction to NA
4. Calculate complete case statistics
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# A - Empty vector
x <- c()
typeof(x)  # "logical" (default empty type)

# B - NaN from invalid math
y <- sqrt(-1)
class(y)  # "numeric"
is.nan(y)  # TRUE

# C - Inf from division by zero
z <- 1/0
is.finite(z)  # FALSE (Inf is not finite)

# D - Comparison with NA gives NA
w <- c(1, 2, NA, 4)
w == NA  # All NA! Use is.na() instead
is.na(w)  # Correct way
```

**Exercise 2:**

```{r}
# Problem 1 - Need na.rm
data <- c(1, 2, NA, 4, 5)
mean_val <- mean(data, na.rm = TRUE)
if (!is.na(mean_val) && mean_val > 3) {
  print("High average")
}

# Problem 2 - Check for NULL
get_score <- function(x) {
  if (x > 10) {
    return(x * 2)
  } else {
    return(0)  # Return 0 instead of NULL
  }
}
score <- get_score(5)
if (!is.null(score) && score > 10) {
  print("High score")
}

# Problem 3 - Handle -Inf from log(0)
values <- c(10, 20, 0, 30)
log_values <- log(values)
log_values[is.infinite(log_values)] <- NA
mean(log_values, na.rm = TRUE)
```

**Exercise 3:**

```{r}
robust_mean <- function(x) {
  # Initialize diagnostics
  diagnostics <- list(
    total = length(x),
    null = is.null(x),
    na = 0,
    nan = 0,
    inf = 0,
    valid = 0
  )
  
  # Check for NULL
  if (is.null(x)) {
    return(list(mean = NULL, diagnostics = diagnostics))
  }
  
  # Count special values
  diagnostics$na <- sum(is.na(x) & !is.nan(x))
  diagnostics$nan <- sum(is.nan(x))
  diagnostics$inf <- sum(is.infinite(x))
  
  # Find valid values
  valid <- x[!is.na(x) & !is.nan(x) & is.finite(x)]
  diagnostics$valid <- length(valid)
  
  # Calculate mean
  if (length(valid) == 0) {
    mean_val <- NA
  } else {
    mean_val <- mean(valid)
  }
  
  # Return
  list(
    mean = mean_val,
    diagnostics = diagnostics
  )
}

# Test
robust_mean(c(1, 2, NA, NaN, Inf, 5, -Inf))
```

**Exercise 4:**

```{r}
survey <- data.frame(
  age = c(25, NA, 35, -999, 40),
  income = c(50000, 75000, 0, 80000, NA),
  satisfaction = c(5, 3, NA, 4, 99)
)

# Clean data
clean_survey <- survey

# Convert -999 to NA in age
clean_survey$age[clean_survey$age == -999] <- NA

# Convert 0 to NA in income
clean_survey$income[clean_survey$income == 0] <- NA

# Convert 99 to NA in satisfaction
clean_survey$satisfaction[clean_survey$satisfaction == 99] <- NA

# Complete case analysis
clean_survey_complete <- clean_survey[complete.cases(clean_survey), ]

# Statistics
list(
  n_complete = nrow(clean_survey_complete),
  mean_age = mean(clean_survey_complete$age),
  mean_income = mean(clean_survey_complete$income),
  mean_satisfaction = mean(clean_survey_complete$satisfaction)
)
```
</details>

<!--chapter:end:06-na-null-nan-inf.Rmd-->

# Part III: Indexing & Subsetting {-}

# Subscript & Dimension Errors {#subscript-dimension}

<div class="chapter-summary">
**What You'll Learn:**

- How R's indexing system works
- Understanding dimensions and subscripts
- Common indexing mistakes
- Negative vs positive indexing
- Logical indexing pitfalls
- Matrix and array subsetting

**Key Errors Covered:** 18+ indexing errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

R's indexing system is powerful but confusing. You'll see these errors constantly:

```{r error=TRUE}
x <- 1:5
x[10]  # Wait, this works?
```

```{r}
x[10]  # Returns NA, not an error!
```

But this doesn't:

```{r error=TRUE}
x[[10]]  # Now it's an error
```

Understanding R's indexing is **critical** for avoiding errors. Let's master it.

## R's Indexing Methods

<div class="insight-box">
üí° **Key Insight: Five Ways to Index**

```{r}
x <- c(10, 20, 30, 40, 50)

# 1. Positive integers (positions)
x[c(1, 3, 5)]

# 2. Negative integers (exclusion)
x[-c(2, 4)]

# 3. Logical vectors
x[c(TRUE, FALSE, TRUE, FALSE, TRUE)]

# 4. Names (if vector has names)
names(x) <- c("a", "b", "c", "d", "e")
x[c("a", "c", "e")]

# 5. Empty (returns all)
x[]
```

**Each method has different error patterns!**
</div>

## Error #1: `subscript out of bounds` {#subscript-out-bounds}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
x <- 1:5
x[[10]]  # Double bracket
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x[[10]] : subscript out of bounds
```
</div>

### What It Means

You're trying to access an element beyond the vector's length using `[[]]`.

### Single vs Double Bracket

```{r}
x <- 1:5

# Single bracket: Returns NA, no error
x[10]

# Double bracket: Errors
```

```{r error=TRUE}
x[[10]]
```

**Why the difference?**
- `[` can return multiple elements or NA
- `[[` must return exactly one element

### Common Causes

#### Cause 1: Off-by-One Error

```{r error=TRUE}
scores <- c(85, 90, 95)

# Loop goes too far
for (i in 1:4) {  # Only 3 elements!
  print(scores[[i]])
}
```

#### Cause 2: Wrong Length Assumption

```{r error=TRUE}
data <- c(10, 20, 30)

# Assumed it had 5 elements
first_five <- data[[1:5]]  # Error on 4th
```

#### Cause 3: After Filtering

```{r error=TRUE}
values <- 1:10
large_values <- values[values > 100]  # Empty!

# Try to access first element
large_values[[1]]  # Out of bounds (length 0)
```

#### Cause 4: List Indexing

```{r error=TRUE}
my_list <- list(a = 1, b = 2, c = 3)

# Trying to access 4th element
my_list[[4]]  # Only 3 elements
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Length First**

```{r}
x <- 1:5
index <- 10

# Safe access
if (index <= length(x)) {
  x[[index]]
} else {
  message("Index ", index, " is out of bounds")
  NA
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Single Bracket**

```{r}
x <- 1:5

# Single bracket returns NA instead of error
x[10]  # NA

# Good for loops where you want to continue
for (i in 1:10) {
  val <- x[i]
  if (!is.na(val)) {
    print(val)
  }
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Safe Indexing Function**

```{r}
safe_extract <- function(x, i, default = NA) {
  if (i < 1 || i > length(x)) {
    return(default)
  }
  return(x[[i]])
}

# Test
x <- 1:5
safe_extract(x, 3)   # 3
safe_extract(x, 10)  # NA
safe_extract(x, 10, default = 0)  # 0
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 4: Use seq_along() in Loops**

```{r}
values <- c(10, 20, 30)

# Wrong: assumes length
for (i in 1:5) {
  # Error on 4th iteration
}

# Right: uses actual length
for (i in seq_along(values)) {
  print(values[[i]])  # Safe
}

# Even safer: iterate over values directly
for (val in values) {
  print(val)
}
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Empty Vectors**

```{r error=TRUE}
# Filter returns empty
x <- 1:10
big_numbers <- x[x > 100]  # numeric(0)

length(big_numbers)  # 0

# This errors!
big_numbers[[1]]

# Always check
if (length(big_numbers) > 0) {
  big_numbers[[1]]
} else {
  NA
}
```
</div>

## Error #2: `undefined columns selected` {#undefined-columns}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
df[, "z"]  # Column doesn't exist
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `[.data.frame`(df, , "z") : undefined columns selected
```
</div>

### What It Means

You're trying to select columns that don't exist in the data frame.

### Common Causes

#### Cause 1: Typo in Column Name

```{r error=TRUE}
df <- data.frame(age = c(25, 30, 35), name = c("A", "B", "C"))

# Typo: "agee" instead of "age"
df[, "agee"]
```

#### Cause 2: Case Sensitivity

```{r error=TRUE}
df <- data.frame(Age = c(25, 30, 35))

# Wrong case
df[, "age"]  # Error! It's "Age" not "age"
```

#### Cause 3: Column Doesn't Exist Yet

```{r error=TRUE}
df <- data.frame(x = 1:5)

# Trying to select column before creating it
df[, c("x", "y")]  # "y" doesn't exist
```

#### Cause 4: After Subsetting

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10, z = 11:15)

# Select some columns
df_subset <- df[, c("x", "y")]

# Try to access z (no longer exists)
df_subset[, "z"]
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Column Names**

```{r}
df <- data.frame(age = c(25, 30, 35), name = c("A", "B", "C"))

# List all columns
names(df)
colnames(df)

# Check if column exists
"age" %in% names(df)  # TRUE
"agee" %in% names(df) # FALSE

# Safe selection
col_name <- "age"
if (col_name %in% names(df)) {
  df[, col_name]
} else {
  message("Column ", col_name, " not found")
  NULL
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use exists in dplyr**

```{r}
library(dplyr)

df <- data.frame(x = 1:5, y = 6:10)

# Select only existing columns
cols_to_select <- c("x", "z", "y")
existing_cols <- cols_to_select[cols_to_select %in% names(df)]

df %>% select(all_of(existing_cols))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Safe Column Selection Function**

```{r}
safe_select_cols <- function(df, cols) {
  # Check which columns exist
  existing <- cols[cols %in% names(df)]
  missing <- cols[!cols %in% names(df)]
  
  if (length(missing) > 0) {
    warning("Columns not found: ", paste(missing, collapse = ", "))
  }
  
  if (length(existing) == 0) {
    return(data.frame())  # Empty data frame
  }
  
  return(df[, existing, drop = FALSE])
}

# Test
df <- data.frame(x = 1:5, y = 6:10)
safe_select_cols(df, c("x", "z", "y"))
```
</div>

## Error #3: `incorrect number of dimensions` {#incorrect-dimensions}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
x <- 1:5  # Vector (1D)
x[1, 2]   # Using 2D indexing on 1D object
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x[1, 2] : incorrect number of dimensions
```
</div>

### What It Means

You're using the wrong number of indices for the object's dimensions.

### Understanding Dimensions

```{r}
# Vector: 1 dimension
vec <- 1:5
length(vec)
dim(vec)  # NULL

# Matrix: 2 dimensions
mat <- matrix(1:6, nrow = 2, ncol = 3)
dim(mat)  # 2 3

# Array: 3+ dimensions
arr <- array(1:24, dim = c(2, 3, 4))
dim(arr)  # 2 3 4

# Data frame: 2 dimensions (special)
df <- data.frame(x = 1:3, y = 4:6)
dim(df)  # 3 2
```

### Common Causes

#### Cause 1: Treating Vector as Matrix

```{r error=TRUE}
x <- c(10, 20, 30, 40, 50)

# Vector needs 1 index
x[3]  # Correct

# Not 2 indices
x[1, 3]  # Error!
```

#### Cause 2: Treating Matrix as Vector

```{r error=TRUE}
mat <- matrix(1:6, nrow = 2, ncol = 3)

# Matrix needs 2 indices
mat[1, 2]  # Correct

# Or can use 1 index (treats as vector)
mat[5]  # Also works! (column-major order)

# But this is confusing:
mat[1]  # First element, not first row
```

#### Cause 3: After Subsetting

```{r error=TRUE}
mat <- matrix(1:12, nrow = 3, ncol = 4)

# Extract one column (becomes vector!)
col1 <- mat[, 1]
class(col1)  # "numeric" (not matrix)

# Now 1D, can't use 2D indexing
col1[1, 1]  # Error!
```

#### Cause 4: List vs Data Frame Confusion

```{r error=TRUE}
# List: 1D (use single bracket or [[]])
my_list <- list(a = 1:3, b = 4:6)
my_list[[1]]     # Correct
my_list[1, 2]    # Error!

# Data frame: 2D (use row, col)
df <- data.frame(a = 1:3, b = 4:6)
df[1, 2]         # Correct
df[[1]]          # Also works (returns column)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Dimensions Before Indexing**

```{r}
x <- 1:5

# Check what you have
ndims <- length(dim(x))  # 0 for vector

if (is.null(dim(x))) {
  # Vector: use 1 index
  x[3]
} else if (length(dim(x)) == 2) {
  # Matrix/data frame: use 2 indices
  x[1, 3]
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Preserve Dimensions with drop = FALSE**

```{r}
mat <- matrix(1:12, nrow = 3, ncol = 4)

# Default: drops to vector
col1 <- mat[, 1]
class(col1)  # "numeric"

# Preserve matrix structure
col1 <- mat[, 1, drop = FALSE]
class(col1)  # "matrix"
dim(col1)    # 3 1

# Now can still use 2D indexing
col1[1, 1]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Appropriate Functions**

```{r}
mat <- matrix(1:12, nrow = 3, ncol = 4)

# For vectors: use vector operations
vec <- 1:5
vec[3]
vec[c(1, 3, 5)]

# For matrices: use matrix operations
mat[1, ]      # First row
mat[, 2]      # Second column
mat[1:2, 3:4] # Submatrix

# For data frames: mix of both
df <- data.frame(x = 1:5, y = 6:10)
df[, "x"]     # Column (becomes vector)
df[, "x", drop = FALSE]  # Column (stays data frame)
df$x          # Column (vector)
```
</div>

## Error #4: `incorrect number of subscripts on matrix` {#incorrect-subscripts-matrix}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
mat <- matrix(1:6, nrow = 2, ncol = 3)
mat[1, 2, 3]  # Too many indices!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in mat[1, 2, 3] : incorrect number of subscripts on matrix
```
</div>

### What It Means

Matrix needs exactly 2 indices (or 1), but you provided a different number.

### Correct Matrix Indexing

```{r}
mat <- matrix(1:6, nrow = 2, ncol = 3)
mat

# Correct ways:
mat[1, 2]      # Single element
mat[1, ]       # Entire row
mat[, 2]       # Entire column
mat[1:2, 2:3]  # Submatrix

# Also works (treats as vector):
mat[5]         # 5th element (column-major)

# Wrong:
# mat[1, 2, 3]  # Too many indices
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use Correct Number of Indices**

```{r}
mat <- matrix(1:6, nrow = 2, ncol = 3)

# For matrix: [row, col]
mat[1, 2]

# For array: [dim1, dim2, dim3, ...]
arr <- array(1:24, dim = c(2, 3, 4))
arr[1, 2, 3]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Object Type First**

```{r}
check_and_subset <- function(x, ...) {
  indices <- list(...)
  
  if (is.matrix(x)) {
    if (length(indices) > 2) {
      stop("Matrix needs 1 or 2 indices, got ", length(indices))
    }
    return(do.call(`[`, c(list(x), indices)))
  } else if (is.array(x)) {
    expected <- length(dim(x))
    if (length(indices) != expected) {
      stop("Array needs ", expected, " indices, got ", length(indices))
    }
    return(do.call(`[`, c(list(x), indices)))
  } else {
    return(x[[indices[[1]]]])
  }
}
```
</div>

## Error #5: `only 0's may be mixed with negative subscripts` {#zero-negative-mix}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
x <- 1:10
x[c(-1, 5)]  # Can't mix negative and positive!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x[c(-1, 5)] : only 0's may be mixed with negative subscripts
```
</div>

### What It Means

R won't let you mix negative indices (exclusion) with positive indices (selection).

### Negative Indexing Rules

```{r}
x <- 1:10

# Positive: select elements
x[c(1, 3, 5)]

# Negative: exclude elements
x[-c(1, 3, 5)]

# Zero: ignored
x[c(0, 1, 3)]  # Same as x[c(1, 3)]

# Can mix zero with negative
x[c(0, -1, -3)]  # Same as x[-c(1, 3)]
```

```{r error=TRUE}
# CANNOT mix positive and negative
x[c(-1, 5)]  # Error!
x[c(1, -5)]  # Error!
```

### Why This Rule?

```{r eval=FALSE}
# Ambiguous meaning:
x[c(-1, 5)]

# Does this mean:
# "Select 5th, excluding 1st"?
# "Exclude 1st, but also select 5th"?

# R refuses to guess!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use Only Positive or Only Negative**

```{r}
x <- 1:10

# Want elements 2-10 (exclude 1st)?
# Use negative:
x[-1]

# Want elements except 1 and 3?
# Use negative:
x[-c(1, 3)]

# Want only 1, 3, 5?
# Use positive:
x[c(1, 3, 5)]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert to Logical**

```{r}
x <- 1:10

# Want: "not 1, not 3, but yes 5"
# Create logical vector
indices <- rep(TRUE, length(x))
indices[c(1, 3)] <- FALSE  # Exclude these
indices[5] <- TRUE          # Include this (already TRUE)

x[indices]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use setdiff()**

```{r}
x <- 1:10

# Want all except positions 1 and 3
exclude <- c(1, 3)
keep <- setdiff(seq_along(x), exclude)
x[keep]

# More complex: all except 1 and 3, but must include 5
exclude <- c(1, 3)
include <- 5
keep <- union(setdiff(seq_along(x), exclude), include)
keep <- sort(unique(keep))
x[keep]
```
</div>

## Error #6: `negative length vectors are not allowed` {#negative-length}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè LENGTH</span>

### The Error

```{r error=TRUE}
n <- -5
x <- numeric(n)  # Can't have negative length!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in numeric(n) : negative length vectors are not allowed
```
</div>

### What It Means

You're trying to create a vector with negative length, which is impossible.

### Common Causes

#### Cause 1: Calculation Error

```{r error=TRUE}
n_start <- 5
n_end <- 3

# Calculation gives negative
n <- n_end - n_start  # -2
result <- numeric(n)  # Error!
```

#### Cause 2: User Input

```{r error=TRUE}
create_vector <- function(n) {
  numeric(n)
}

create_vector(-5)  # Error!
```

#### Cause 3: Filtering Gone Wrong

```{r error=TRUE}
data <- c(10, 20, 30)
threshold <- 50

# No values meet criteria
n_above <- sum(data > threshold)  # 0

# Then you subtract
n_below <- length(data) - n_above - 5  # Negative!

result <- numeric(n_below)  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Validate Before Creating**

```{r}
create_vector_safe <- function(n, default_value = 0) {
  if (n < 0) {
    warning("Negative length requested: ", n, ". Using 0.")
    n <- 0
  }
  
  if (n == 0) {
    return(numeric(0))
  }
  
  return(rep(default_value, n))
}

# Test
create_vector_safe(5)
create_vector_safe(-5)
create_vector_safe(0)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use max() for Safety**

```{r}
n_start <- 5
n_end <- 3

# Ensure non-negative
n <- max(0, n_end - n_start)
result <- numeric(n)  # Safe
result
```
</div>

## Logical Indexing

<div class="insight-box">
üí° **Key Insight: Logical Indexing**

```{r}
x <- c(10, 20, 30, 40, 50)

# Logical vector
x > 25

# Use for indexing
x[x > 25]

# Multiple conditions
x[x > 25 & x < 45]

# With which()
which(x > 25)
x[which(x > 25)]
```

**Important:** Logical indexing with NA creates NA in result!

```{r}
x <- c(10, NA, 30, 40)
x > 25  # Has NA

# Result includes NA
x[x > 25]

# Remove NA from condition
x[which(x > 25)]  # which() drops NA
```
</div>

## Error #7: `[ ] with missing values only allowed for atomic vectors` {#bracket-missing-values}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
my_list <- list(a = 1, b = 2, c = 3)
indices <- c(1, NA, 3)
my_list[indices]
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_list[indices] : 
  [ ] with missing values only allowed for atomic vectors
```
</div>

### What It Means

You can use NA in indices for vectors, but not for lists or data frames without special handling.

### Atomic vs Non-Atomic

```{r}
# Atomic vector: NA indexing works
vec <- c(10, 20, 30)
vec[c(1, NA, 3)]  # Returns with NA

# List: NA indexing fails
my_list <- list(a = 1, b = 2, c = 3)
```

```{r error=TRUE}
my_list[c(1, NA, 3)]  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Remove NAs from Indices**

```{r}
my_list <- list(a = 1, b = 2, c = 3)
indices <- c(1, NA, 3)

# Remove NAs
clean_indices <- indices[!is.na(indices)]
my_list[clean_indices]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Logical Indexing**

```{r}
my_list <- list(a = 1, b = 2, c = 3)
indices <- c(1, NA, 3)

# Convert to logical
logical_indices <- seq_along(my_list) %in% indices
my_list[logical_indices]
```
</div>

## Matrix Indexing Special Cases

<div class="bestpractice-box">
üéØ **Best Practice: Matrix Indexing Mastery**

```{r}
mat <- matrix(1:12, nrow = 3, ncol = 4)
mat

# Single index: column-major order
mat[5]  # Row 2, Column 2

# Row, column
mat[2, 2]

# Entire row
mat[2, ]

# Entire column
mat[, 2]

# Multiple rows/columns
mat[1:2, 2:3]

# Logical indexing (rows)
mat[mat[, 1] > 1, ]

# Negative indexing
mat[-1, ]     # All but first row
mat[, -c(1, 4)]  # All but first and last column

# Preserve matrix structure
mat[, 2]              # Becomes vector
mat[, 2, drop = FALSE]  # Stays matrix
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **[ ] vs [[]]**: Single bracket is lenient (returns NA), double bracket is strict (errors)
2. **Check bounds**: Always validate indices before using [[]]
3. **Dimensions matter**: Vectors (1D), matrices (2D), arrays (3D+)
4. **Negative indexing**: Can't mix with positive (except 0)
5. **Logical indexing**: Watch for NA in conditions
6. **drop = FALSE**: Preserves matrix structure
7. **seq_along()**: Safer than 1:length() for loops

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| subscript out of bounds | Index > length with [[]] | Check length first |
| undefined columns | Column name doesn't exist | Check with `%in% names()` |
| incorrect number of dimensions | Wrong # of indices | Match object dimensions |
| incorrect number of subscripts | Too many/few indices | Matrix needs 2, array needs n |
| only 0's may be mixed with negative | Positive + negative indices | Use one or the other |
| negative length vectors | Tried length < 0 | Validate with `max(0, n)` |
| [ ] with missing values | NA index on list | Remove NAs or use logical |

**Safe Indexing Checklist:**

```{r eval=FALSE}
# Before indexing:
length(x)              # Check size
dim(x)                 # Check dimensions
names(x)               # Check names (if using)
seq_along(x)           # Safe iteration
index %in% seq_along(x)  # Validate index

# For conditional indexing:
which(condition)       # Drops NA automatically
x[!is.na(x) & x > 0]  # Handle NA explicitly
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Predict the Outcome**

What happens? Error, NA, or value?

```{r eval=FALSE}
# A
x <- 1:5
x[10]

# B
x[[10]]

# C
mat <- matrix(1:6, nrow = 2)
mat[3, 1]

# D
x[c(-1, 5)]

# E
my_list <- list(a = 1, b = 2)
my_list[c(1, NA)]
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Fix the Code**

Debug these indexing problems:

```{r eval=FALSE}
# Problem 1
scores <- c(85, 90, 95)
top_score <- scores[[4]]

# Problem 2
df <- data.frame(x = 1:5, y = 6:10)
result <- df[, "z"]

# Problem 3
vec <- 1:10
subset <- vec[c(-1, -2, 5, 6)]

# Problem 4
mat <- matrix(1:6, nrow = 2)
col2 <- mat[, 2]
element <- col2[1, 1]
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Indexing Function**

Write `safe_index(x, i)` that:
1. Works with vectors, lists, matrices
2. Never errors on out-of-bounds
3. Returns NA for invalid indices
4. Handles both [ ] and [[ ]] style
5. Reports what went wrong
</div>

<div class="exercise-box">
üìù **Exercise 4: Matrix Subsetting**

Given a matrix, write functions to:
1. Get elements on the diagonal
2. Get upper triangle (above diagonal)
3. Get lower triangle (below diagonal)
4. Get border elements (edges only)
5. Handle any matrix size
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# A - Returns NA (single bracket is lenient)
x <- 1:5
x[10]

# B - Errors (double bracket is strict)
tryCatch(x[[10]], error = function(e) "ERROR")

# C - Errors (only 2 rows)
mat <- matrix(1:6, nrow = 2)
tryCatch(mat[3, 1], error = function(e) "ERROR")

# D - Errors (can't mix positive and negative)
tryCatch(x[c(-1, 5)], error = function(e) "ERROR")

# E - Errors (lists don't allow NA indices)
my_list <- list(a = 1, b = 2)
tryCatch(my_list[c(1, NA)], error = function(e) "ERROR")
```

**Exercise 2:**

```{r}
# Problem 1 - Out of bounds
scores <- c(85, 90, 95)
# Fix: Check length
if (4 <= length(scores)) {
  top_score <- scores[[4]]
} else {
  top_score <- NA
}

# Problem 2 - Column doesn't exist
df <- data.frame(x = 1:5, y = 6:10)
# Fix: Check column exists
if ("z" %in% names(df)) {
  result <- df[, "z"]
} else {
  result <- NULL
}

# Problem 3 - Mixing positive and negative
vec <- 1:10
# Fix: Use only negative
subset <- vec[-c(1, 2)]
# Or only positive
subset <- vec[c(5, 6)]

# Problem 4 - Vector can't use 2D indexing
mat <- matrix(1:6, nrow = 2)
col2 <- mat[, 2, drop = FALSE]  # Keep as matrix
element <- col2[1, 1]
# Or:
col2 <- mat[, 2]  # Vector
element <- col2[1]  # 1D indexing
```

**Exercise 3:**

```{r}
safe_index <- function(x, i, double_bracket = FALSE) {
  # Handle different object types
  if (is.null(x)) {
    message("Object is NULL")
    return(NULL)
  }
  
  # Get valid range
  max_index <- if (is.list(x)) {
    length(x)
  } else if (!is.null(dim(x))) {
    length(x)  # For matrices, treat as vector
  } else {
    length(x)
  }
  
  # Check index validity
  if (any(is.na(i))) {
    message("Index contains NA")
    i <- i[!is.na(i)]
  }
  
  if (length(i) == 0) {
    message("No valid indices")
    return(if (double_bracket) NA else x[integer(0)])
  }
  
  if (any(i < 1 | i > max_index)) {
    invalid <- i[i < 1 | i > max_index]
    message("Invalid indices: ", paste(invalid, collapse = ", "))
    i <- i[i >= 1 & i <= max_index]
  }
  
  if (length(i) == 0) {
    return(NA)
  }
  
  # Extract
  if (double_bracket) {
    if (length(i) > 1) {
      message("Double bracket with multiple indices, using first")
      i <- i[1]
    }
    return(x[[i]])
  } else {
    return(x[i])
  }
}

# Test
x <- 1:5
safe_index(x, 3)
safe_index(x, 10)
safe_index(x, c(1, 10, 3))
```

**Exercise 4:**

```{r}
# Get diagonal elements
get_diagonal <- function(mat) {
  if (!is.matrix(mat)) stop("Input must be a matrix")
  n <- min(nrow(mat), ncol(mat))
  mat[cbind(1:n, 1:n)]
}

# Get upper triangle
get_upper_tri <- function(mat, include_diag = FALSE) {
  if (!is.matrix(mat)) stop("Input must be a matrix")
  mat[upper.tri(mat, diag = include_diag)]
}

# Get lower triangle
get_lower_tri <- function(mat, include_diag = FALSE) {
  if (!is.matrix(mat)) stop("Input must be a matrix")
  mat[lower.tri(mat, diag = include_diag)]
}

# Get border elements
get_border <- function(mat) {
  if (!is.matrix(mat)) stop("Input must be a matrix")
  nr <- nrow(mat)
  nc <- ncol(mat)
  
  if (nr == 1 || nc == 1) {
    return(as.vector(mat))
  }
  
  c(
    mat[1, ],                    # Top row
    mat[nr, ],                   # Bottom row
    mat[2:(nr-1), 1],           # Left column (excluding corners)
    mat[2:(nr-1), nc]           # Right column (excluding corners)
  )
}

# Test
mat <- matrix(1:20, nrow = 4, ncol = 5)
mat
get_diagonal(mat)
get_upper_tri(mat)
get_lower_tri(mat)
get_border(mat)
```
</details>

<!--chapter:end:07-subscript-dimension.Rmd-->

# $ and [[ Operator Errors {#dollar-double-bracket}

<div class="chapter-summary">
**What You'll Learn:**

- Differences between $, [[]], and []
- When each operator works (and fails)
- Recursive indexing in lists
- Partial matching pitfalls
- Atomic vector vs list extraction

**Key Errors Covered:** 12+ operator-specific errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

R has three main extraction operators that confuse everyone:

```{r}
my_list <- list(name = "Alice", age = 25, scores = c(85, 90, 95))

# Three ways to get the same thing:
my_list$name
my_list[["name"]]
my_list["name"]  # Wait, this is different!
```

```{r}
# Check the types
class(my_list$name)        # "character"
class(my_list[["name"]])   # "character"
class(my_list["name"])     # "list" - different!
```

Understanding these differences prevents endless frustration.

<div class="insight-box">
üí° **Key Insight: The Three Operators**

```{r}
lst <- list(x = 1:3, y = "text", z = list(a = 10))

# $ - Extract by name (partial matching!)
lst$x        # c(1, 2, 3)
lst$x        # Same as lst[["x"]]

# [[ ]] - Extract single element (no partial matching)
lst[["x"]]   # c(1, 2, 3)
lst[[1]]     # Can use position too

# [ ] - Extract sub-list (keeps structure)
lst["x"]     # list(x = 1:3)
lst[1]       # list(x = 1:3)
lst[1:2]     # list(x = 1:3, y = "text")
```

**Rule of thumb:**
- **$** : Quick named access (interactive use)
- **[[]]** : Safe programmatic access
- **[]** : When you need to keep list structure
</div>

## Error #1: `$ operator is invalid for atomic vectors` {#dollar-atomic-vector}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
x <- c(a = 1, b = 2, c = 3)  # Named vector
x$a  # $ doesn't work on vectors!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in x$a : $ operator is invalid for atomic vectors
```
</div>

### What It Means

The `$` operator only works on recursive objects (lists, data frames, environments). It doesn't work on atomic vectors.

### Understanding the Difference

```{r}
# Atomic vector (1D, all same type)
vec <- c(a = 1, b = 2, c = 3)
is.atomic(vec)     # TRUE
is.recursive(vec)  # FALSE

# Use names indexing instead
vec["a"]
vec[["a"]]

# List (recursive)
lst <- list(a = 1, b = 2, c = 3)
is.atomic(lst)     # FALSE
is.recursive(lst)  # TRUE

# $ works here
lst$a
```

### Common Causes

#### Cause 1: Confusion Between Vector and List

```{r error=TRUE}
# Created a vector
values <- c(x = 10, y = 20)

# Treating it like a list
values$x  # Error!
```

#### Cause 2: After Extracting from Data Frame

```{r error=TRUE}
df <- data.frame(x = 1:3, y = 4:6)

# Extract column (becomes vector!)
col <- df$x
class(col)  # "integer" (atomic vector)

# Can't use $ on result
col$something  # Error!
```

#### Cause 3: Function Returns Vector

```{r error=TRUE}
get_values <- function() {
  c(a = 1, b = 2)  # Returns atomic vector
}

result <- get_values()
result$a  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use Correct Indexing for Vectors**

```{r}
vec <- c(a = 1, b = 2, c = 3)

# Right way for vectors:
vec["a"]     # Single bracket
vec[["a"]]   # Double bracket

# Get multiple elements
vec[c("a", "c")]

# All names
names(vec)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert to List if Needed**

```{r}
vec <- c(a = 1, b = 2, c = 3)

# Convert to list
lst <- as.list(vec)

# Now $ works
lst$a
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check Object Type First**

```{r}
safe_dollar <- function(x, name) {
  if (is.atomic(x) && !is.null(names(x))) {
    message("Using [[ ]] for atomic vector")
    return(x[[name]])
  } else if (is.recursive(x)) {
    return(x[[name]])
  } else {
    stop("Cannot extract '", name, "' from ", class(x)[1])
  }
}

# Test
vec <- c(a = 1, b = 2)
safe_dollar(vec, "a")

lst <- list(a = 1, b = 2)
safe_dollar(lst, "a")
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Data Frame Columns**

```{r}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Extracting a column
col <- df$x         # Vector (atomic)
col$something       # Error!

# Selecting columns keeps data frame
subset <- df["x"]   # Data frame (recursive)
subset$x            # Works!

# Rule: Single column with $ or [[ ]] ‚Üí vector
#       One or more columns with [ ] ‚Üí data frame
```
</div>

## Error #2: `recursive indexing failed at level X` {#recursive-indexing-failed}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
my_list <- list(a = list(b = 1))
my_list[[c("a", "b", "c")]]  # Too deep!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_list[[c("a", "b", "c")]] : 
  recursive indexing failed at level 3
```
</div>

### What It Means

You're trying to index deeper into a nested list than it actually goes.

### Recursive Indexing

```{r}
# Nested list
nested <- list(
  a = list(
    b = list(
      c = 42
    )
  )
)

# Recursive indexing with vector
nested[[c("a", "b", "c")]]

# Equivalent to:
nested[["a"]][["b"]][["c"]]

# But this fails (only 3 levels deep):
```

```{r error=TRUE}
nested[[c("a", "b", "c", "d")]]  # Level 4 doesn't exist!
```

### Common Causes

#### Cause 1: Wrong Path

```{r error=TRUE}
data <- list(
  user = list(
    name = "Alice",
    age = 25
  )
)

# Typo in path
data[[c("user", "email")]]  # "email" doesn't exist
```

#### Cause 2: Mixed Types

```{r error=TRUE}
data <- list(
  values = c(10, 20, 30)  # Atomic vector, not list!
)

# Can't recurse into atomic vector
data[[c("values", "1")]]  # Error at level 2
```

#### Cause 3: Dynamic Path Too Long

```{r error=TRUE}
data <- list(a = list(b = 1))
path <- c("a", "b", "c")  # Path too long

data[[path]]  # Error
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Path Exists**

```{r}
nested <- list(a = list(b = list(c = 42)))

safe_deep_extract <- function(x, path) {
  for (i in seq_along(path)) {
    if (!is.list(x) && !is.environment(x)) {
      stop("Cannot recurse at level ", i, 
           ": object is ", class(x)[1], ", not list")
    }
    
    if (!path[i] %in% names(x)) {
      stop("Name '", path[i], "' not found at level ", i)
    }
    
    x <- x[[path[i]]]
  }
  return(x)
}

# Test
safe_deep_extract(nested, c("a", "b", "c"))  # Works
```

```{r error=TRUE}
safe_deep_extract(nested, c("a", "b", "c", "d"))  # Informative error
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use purrr::pluck()**

```{r}
library(purrr)

nested <- list(a = list(b = list(c = 42)))

# Safe extraction with default
pluck(nested, "a", "b", "c")
pluck(nested, "a", "b", "c", "d")  # Returns NULL, not error
pluck(nested, "a", "b", "c", "d", .default = NA)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Step-by-Step Extraction**

```{r}
nested <- list(a = list(b = list(c = 42)))
path <- c("a", "b", "c")

# Extract step by step with checking
result <- nested
for (step in path) {
  if (is.null(result)) {
    message("Path ended at NULL")
    break
  }
  
  if (!step %in% names(result)) {
    message("'", step, "' not found")
    result <- NULL
    break
  }
  
  result <- result[[step]]
}

result
```
</div>

## Error #3: `attempt to select less than one element` {#select-less-than-one}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
my_list <- list(a = 1, b = 2)
my_list[[integer(0)]]  # Empty index!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_list[[integer(0)]] : 
  attempt to select less than one element in integerOneIndex
```
</div>

### What It Means

`[[]]` must select exactly one element, but you provided an empty index.

### Common Causes

#### Cause 1: Empty Which() Result

```{r error=TRUE}
my_list <- list(a = 1, b = 2, c = 3)

# Find elements meeting condition
indices <- which(sapply(my_list, function(x) x > 10))
length(indices)  # 0

# Try to extract
my_list[[indices]]  # Error!
```

#### Cause 2: Filtered Index

```{r error=TRUE}
values <- list(a = 5, b = 10, c = 15)

# Filter for values > 20
big_ones <- which(sapply(values, function(x) x > 20))

# Try to get first
values[[big_ones[1]]]  # NA[1] ‚Üí error!
```

#### Cause 3: Off-by-One with Subtraction

```{r error=TRUE}
my_list <- list(a = 1, b = 2)
index <- 1 - 1  # 0

my_list[[index]]  # Can't select 0th element
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Before Extracting**

```{r}
my_list <- list(a = 1, b = 2, c = 3)
indices <- which(sapply(my_list, function(x) x > 10))

# Check first
if (length(indices) > 0) {
  my_list[[indices[1]]]
} else {
  message("No elements found")
  NULL
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use [ ] for Multiple/Zero Elements**

```{r}
my_list <- list(a = 1, b = 2, c = 3)
indices <- which(sapply(my_list, function(x) x > 10))

# [ ] handles empty gracefully
my_list[indices]  # Returns empty list
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Safe Extraction Function**

```{r}
safe_extract_one <- function(x, i, default = NULL) {
  if (length(i) == 0) {
    message("No index provided")
    return(default)
  }
  
  if (is.na(i)) {
    message("Index is NA")
    return(default)
  }
  
  if (i < 1 || i > length(x)) {
    message("Index out of bounds: ", i)
    return(default)
  }
  
  return(x[[i]])
}

# Test
my_list <- list(a = 1, b = 2)
safe_extract_one(my_list, integer(0))
safe_extract_one(my_list, 1)
safe_extract_one(my_list, 10)
```
</div>

## Error #4: `attempt to select more than one element` {#select-more-than-one}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
my_list <- list(a = 1, b = 2, c = 3)
my_list[[c(1, 2)]]  # Multiple indices!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_list[[c(1, 2)]] : 
  attempt to select more than one element in integerOneIndex
```
</div>

### What It Means

`[[]]` extracts exactly one element. For multiple elements, use `[]`.

### Single vs Multiple Selection

```{r}
my_list <- list(a = 1, b = 2, c = 3)

# [[ ]] - One element
my_list[[1]]      # Element 1
my_list[["a"]]    # By name

# [ ] - Multiple elements (returns list)
my_list[1]        # List with element 1
my_list[1:2]      # List with elements 1 and 2
my_list[c("a", "c")]  # By names
```

### Common Causes

#### Cause 1: Meant to Use [ ]

```{r error=TRUE}
data <- list(x = 1:5, y = 6:10, z = 11:15)

# Want first two elements
data[[1:2]]  # Error!
```

```{r}
# Use [ ] instead
data[1:2]
```

#### Cause 2: Vector of Names

```{r error=TRUE}
data <- list(name = "Alice", age = 25, city = "NYC")

# Try to get multiple by name
cols <- c("name", "age")
data[[cols]]  # Error!
```

```{r}
# Use [ ] for multiple
data[cols]

# Or extract separately
lapply(cols, function(col) data[[col]])
```

#### Cause 3: Recursive Indexing Confusion

```{r}
nested <- list(a = list(b = 1, c = 2))

# This works (recursive indexing)
nested[[c("a", "b")]]  # Goes to nested$a$b

# But not multiple at one level
```

```{r error=TRUE}
nested[[c("a"), c("b", "c")]]  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use [ ] for Multiple Elements**

```{r}
my_list <- list(a = 1, b = 2, c = 3, d = 4)

# Multiple elements - use single bracket
my_list[c(1, 3)]
my_list[c("a", "c")]

# Single element - use double bracket
my_list[[1]]
my_list[["a"]]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Loop or Apply for Multiple**

```{r}
data <- list(x = 1:3, y = 4:6, z = 7:9)
elements_wanted <- c("x", "z")

# Extract each separately
result <- lapply(elements_wanted, function(name) data[[name]])
names(result) <- elements_wanted
result

# Or use [ ] and unlist if needed
data[elements_wanted]
```
</div>

## Partial Matching with $

<div class="pitfall-box">
‚ö†Ô∏è **Dangerous Pitfall: Partial Matching**

The `$` operator does **partial matching** by default:

```{r}
my_list <- list(name = "Alice", age = 25)

# Exact match
my_list$name

# Partial match (DANGEROUS!)
my_list$n     # Matches "name"
my_list$na    # Matches "name"
my_list$nam   # Matches "name"

# Ambiguous partial match returns NULL
my_list$a     # Could be "age" - but only one letter, returns NULL

# [[ ]] does NOT partial match (SAFER)
my_list[["n"]]      # NULL
my_list[["name"]]   # Works
```

**Best Practice:** Use `[[]]` in production code to avoid partial matching surprises.

```{r}
# Instead of:
# data$col

# Use:
data[["col"]]  # Exact match required
```
</div>

## Comparing Operators

<div class="insight-box">
üí° **Key Insight: Complete Comparison**

```{r}
lst <- list(x = 1:3, y = "text", z = list(a = 10, b = 20))

# Extraction comparison
lst$x           # c(1, 2, 3) - vector
lst[["x"]]      # c(1, 2, 3) - vector
lst["x"]        # list(x = c(1, 2, 3)) - list

# Type returned
class(lst$x)      # "integer"
class(lst[["x"]]) # "integer"
class(lst["x"])   # "list"

# Multiple elements
# lst$c("x", "y")     # Can't do this
# lst[[c("x", "y")]]  # Error
lst[c("x", "y")]      # Works - returns list

# Nested access
# lst$z$a            # 10
lst[["z"]]$a         # 10
lst[["z"]][["a"]]    # 10
lst[[c("z", "a")]]   # 10 (recursive indexing)
# lst[c("z", "a")]   # list with both z and a (different!)
```

**Decision Tree:**

```
Need to extract from list/data frame?
‚îú‚îÄ One element?
‚îÇ  ‚îú‚îÄ Known name, interactive? ‚Üí use $
‚îÇ  ‚îú‚îÄ Programmatic, exact name? ‚Üí use [[]]
‚îÇ  ‚îî‚îÄ By position? ‚Üí use [[]]
‚îî‚îÄ Multiple elements?
   ‚îî‚îÄ Use []
```
</div>

## Data Frame Special Cases

<div class="bestpractice-box">
üéØ **Best Practice: Data Frame Extraction**

```{r}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Column extraction
df$x              # Vector (drops to 1D)
df[["x"]]         # Vector (drops to 1D)
df["x"]           # Data frame (keeps 2D)
df[, "x"]         # Vector (drops by default)
df[, "x", drop = FALSE]  # Data frame (preserved)

# Multiple columns
# df$c("x", "y")  # Can't do
# df[[c("x", "y")]]  # Error
df[c("x", "y")]    # Data frame with 2 columns
df[, c("x", "y")]  # Data frame with 2 columns

# With dplyr (clearest!)
library(dplyr)
df %>% pull(x)       # Vector
df %>% select(x)     # Data frame
df %>% select(x, y)  # Data frame
```

**Rule:**
- `$` and `[[]]` ‚Üí Drop to vector (single column)
- `[]` ‚Üí Keep as data frame
- `[, , drop = FALSE]` ‚Üí Force data frame
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **$ only works on lists/data frames** - Not atomic vectors
2. **[[ ]] requires exact names** - No partial matching
3. **[[ ]] extracts one element** - Use [] for multiple
4. **Recursive indexing** - [[c("a", "b")]] goes deep
5. **$ does partial matching** - Dangerous, use [[ ]] in code
6. **[] keeps structure** - Returns list/data frame
7. **[[ ]] and $ simplify** - Return element itself

**Quick Reference:**

| Operator | Structure | Elements | Partial Match | Use Case |
|----------|-----------|----------|---------------|----------|
| `$` | List/DF | One | Yes | Interactive |
| `[[]]` | Any | One | No | Programmatic |
| `[]` | Any | Multiple | No | Subsetting |

**Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| $ invalid for atomic vectors | Used $ on vector | Use [[ ]] or [] |
| recursive indexing failed | Path too deep | Check structure |
| select less than one | Empty index in [[ ]] | Check length first |
| select more than one | Multiple indices in [[ ]] | Use [] instead |

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
data[["column"]]           # Exact, no partial matching
data[c("col1", "col2")]    # Multiple columns
if (length(idx) > 0) data[[idx]]  # Check before [[]]

# ‚ùå Avoid in production
data$col                   # Partial matching risk
data[[multiple_indices]]   # Will error
data[[empty_vector]]       # Will error
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Operator Selection**

Which operator(s) work for each scenario?

```{r eval=FALSE}
vec <- c(a = 1, b = 2)
lst <- list(a = 1, b = 2)
df <- data.frame(a = 1:3, b = 4:6)

# A: Get element "a" from vec
# B: Get element "a" from lst
# C: Get column "a" from df as vector
# D: Get column "a" from df as data frame
# E: Get elements "a" and "b" from lst
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Debug the Extraction**

Fix these extraction errors:

```{r eval=FALSE}
# Problem 1
numbers <- c(x = 10, y = 20, z = 30)
result <- numbers$x

# Problem 2
data <- list(values = c(1, 2, 3))
item <- data[[c("values", "1")]]

# Problem 3
my_list <- list(a = 1, b = 2, c = 3)
subset <- my_list[[c(1, 3)]]

# Problem 4
nested <- list(level1 = list(level2 = 10))
value <- nested$level1$level2$level3
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Accessor**

Write `safe_get(x, path, default = NULL)` that:
1. Works with nested lists
2. Handles missing names gracefully
3. Returns default if path doesn't exist
4. Works with both character names and numeric indices
5. Provides helpful error messages
</div>

<div class="exercise-box">
üìù **Exercise 4: Extraction Comparison**

For this structure, show what each extraction returns:

```{r eval=FALSE}
data <- list(
  user = list(
    name = "Alice",
    scores = c(85, 90, 95)
  )
)

# What does each return? (value and type)
data$user
data[["user"]]
data["user"]
data$user$name
data[[c("user", "name")]]
data[["user"]][["scores"]][[2]]
```
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
vec <- c(a = 1, b = 2)
lst <- list(a = 1, b = 2)
df <- data.frame(a = 1:3, b = 4:6)

# A: Get "a" from vector
vec["a"]      # ‚úÖ Works
vec[["a"]]    # ‚úÖ Works
# vec$a       # ‚ùå Error (atomic vector)

# B: Get "a" from list
lst$a         # ‚úÖ Works
lst[["a"]]    # ‚úÖ Works
lst["a"]      # ‚úÖ Works (but returns list)

# C: Get column "a" as vector
df$a          # ‚úÖ Works
df[["a"]]     # ‚úÖ Works
df[, "a"]     # ‚úÖ Works
# df["a"]     # ‚ùå Returns data frame, not vector

# D: Get column "a" as data frame
df["a"]       # ‚úÖ Works
df[, "a", drop = FALSE]  # ‚úÖ Works
# df$a        # ‚ùå Returns vector
# df[["a"]]   # ‚ùå Returns vector

# E: Get multiple elements from list
lst[c("a", "b")]  # ‚úÖ Only this works
# lst$c("a", "b")  # ‚ùå Syntax error
# lst[[c("a", "b")]]  # ‚ùå Error
```

**Exercise 2:**

```{r}
# Problem 1 - $ on atomic vector
numbers <- c(x = 10, y = 20, z = 30)
result <- numbers[["x"]]  # or numbers["x"]

# Problem 2 - Can't recurse into atomic vector
data <- list(values = c(1, 2, 3))
item <- data[["values"]][1]  # or data$values[1]

# Problem 3 - Multiple indices in [[]]
my_list <- list(a = 1, b = 2, c = 3)
subset <- my_list[c(1, 3)]  # Use single bracket

# Problem 4 - Path doesn't exist
nested <- list(level1 = list(level2 = 10))
# Check if exists first
if (!is.null(nested$level1$level2)) {
  value <- nested$level1$level2
} else {
  value <- NA
}
# Or just:
value <- nested$level1$level2  # This is 10
# nested$level1$level2$level3 would be NULL
```

**Exercise 3:**

```{r}
safe_get <- function(x, path, default = NULL) {
  # Handle empty path
  if (length(path) == 0) {
    return(x)
  }
  
  # Iterate through path
  current <- x
  for (i in seq_along(path)) {
    step <- path[i]
    
    # Check if current is indexable
    if (!is.list(current) && !is.environment(current)) {
      message("Cannot index into ", class(current)[1], " at step ", i)
      return(default)
    }
    
    # Check if step exists
    if (is.character(step)) {
      if (!step %in% names(current)) {
        message("Name '", step, "' not found at step ", i)
        return(default)
      }
      current <- current[[step]]
    } else if (is.numeric(step)) {
      if (step < 1 || step > length(current)) {
        message("Index ", step, " out of bounds at step ", i)
        return(default)
      }
      current <- current[[step]]
    } else {
      stop("Path element must be character or numeric")
    }
  }
  
  return(current)
}

# Test
nested <- list(a = list(b = list(c = 42)))
safe_get(nested, c("a", "b", "c"))        # 42
safe_get(nested, c("a", "b", "c", "d"))   # NULL
safe_get(nested, c("a", "x"), default = NA)  # NA
safe_get(nested, c(1, 1, 1))              # 42 (by index)
```

**Exercise 4:**

```{r}
data <- list(
  user = list(
    name = "Alice",
    scores = c(85, 90, 95)
  )
)

# data$user
# Returns: list(name = "Alice", scores = c(85, 90, 95))
# Type: list

# data[["user"]]
# Returns: list(name = "Alice", scores = c(85, 90, 95))
# Type: list

# data["user"]
# Returns: list(user = list(name = "Alice", scores = c(85, 90, 95)))
# Type: list (wrapped in another list!)

# data$user$name
# Returns: "Alice"
# Type: character

# data[[c("user", "name")]]
# Returns: "Alice"
# Type: character

# data[["user"]][["scores"]][[2]]
# Returns: 90
# Type: numeric

# Show them
data$user
data[["user"]]
data["user"]
data$user$name
data[[c("user", "name")]]
data[["user"]][["scores"]][[2]]
```
</details>

<!--chapter:end:08-dollar-double-bracket.Rmd-->

# Part IV: Data Frames & Matrices {-}

# Data Frame Construction {#dataframe-construction}

<div class="chapter-summary">
**What You'll Learn:**

- How data frames are constructed
- Row and column length requirements
- Type coercion during construction
- Row names and their pitfalls
- Converting between structures

**Key Errors Covered:** 15+ construction errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Data frames are R's workhorse for tabular data. But creating them can be tricky:

```{r error=TRUE}
# This looks innocent...
data.frame(x = 1:3, y = 1:5)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in data.frame(x = 1:3, y = 1:5) : 
  arguments imply differing number of rows: 3, 5
```
</div>

Let's master data frame construction and avoid all the common pitfalls.

## Data Frame Basics

<div class="insight-box">
üí° **Key Insight: What is a Data Frame?**

A data frame is a **list of vectors** with special properties:

```{r}
# Create a data frame
df <- data.frame(
  name = c("Alice", "Bob", "Charlie"),
  age = c(25, 30, 35),
  score = c(85, 90, 95)
)

# It's actually a list!
typeof(df)
is.list(df)

# But special
class(df)
is.data.frame(df)

# Each column is a vector
df$name
df$age

# All columns must have same length
length(df$name)
length(df$age)
```

**Key requirements:**
1. All columns must be same length (or length 1)
2. Each column must be a vector (atomic or list)
3. Row names must be unique
4. Column names should be unique (R allows duplicates but it's confusing)
</div>

## Error #1: `arguments imply differing number of rows` {#differing-rows}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
data.frame(
  x = 1:5,
  y = 1:3
)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in data.frame(x = 1:5, y = 1:3) : 
  arguments imply differing number of rows: 5, 3
```
</div>

### What It Means

You're trying to create a data frame with columns of different lengths that aren't compatible.

### The Recycling Rule

Data frames allow recycling, but only in specific cases:

```{r}
# Length 1 always recycles
data.frame(
  x = 1:5,
  y = 10      # Recycled to 5
)

# Multiples work
data.frame(
  x = 1:6,
  y = c(1, 2)  # Recycled to 6 (multiple of 2)
)
```

```{r error=TRUE}
# Non-multiples fail
data.frame(
  x = 1:5,
  y = 1:3      # 5 is not a multiple of 3
)
```

### Common Causes

#### Cause 1: Filtered Data

```{r error=TRUE}
# Start with same length
ids <- 1:10
values <- rnorm(10)

# Filter one but not the other
filtered_values <- values[values > 0]  # Might be 6 elements

# Try to combine
data.frame(id = ids, value = filtered_values)  # Error!
```

#### Cause 2: Calculation Gone Wrong

```{r error=TRUE}
# Generate data
x <- 1:5
y <- x * 2

# Accidentally modify one
y <- y[-3]  # Remove one element

# Try to create data frame
data.frame(x = x, y = y)
```

#### Cause 3: Reading Different Sources

```{r error=TRUE}
# Simulating reading from different sources
col1 <- readLines(textConnection("a\nb\nc\nd\ne"))
col2 <- readLines(textConnection("1\n2\n3"))  # Shorter!

# Try to combine
data.frame(col1 = col1, col2 = col2)
```

#### Cause 4: List Column with Wrong Length

```{r error=TRUE}
# Regular columns
df <- data.frame(id = 1:5)

# Try to add list column of wrong length
df$nested <- list(a = 1:3, b = 4:6)  # Length 2, not 5!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Match Lengths Before Creating**

```{r}
ids <- 1:10
values <- rnorm(10)
filtered_values <- values[values > 0]

# Option A: Filter both the same way
keep <- values > 0
data.frame(
  id = ids[keep],
  value = filtered_values
)

# Option B: Extend shorter with NA
max_len <- max(length(ids), length(filtered_values))
ids_ext <- c(ids, rep(NA, max_len - length(ids)))
val_ext <- c(filtered_values, rep(NA, max_len - length(filtered_values)))
data.frame(id = ids_ext, value = val_ext)

# Option C: Trim longer to match
min_len <- min(length(ids), length(filtered_values))
data.frame(
  id = ids[1:min_len],
  value = filtered_values[1:min_len]
)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Lengths First**

```{r}
safe_data_frame <- function(...) {
  # Get all arguments
  args <- list(...)
  
  # Get lengths
  lens <- sapply(args, length)
  
  # Check compatibility
  max_len <- max(lens)
  valid <- lens == 1 | lens == max_len | max_len %% lens == 0
  
  if (!all(valid)) {
    invalid_lens <- unique(lens[!valid])
    stop("Incompatible lengths: ", paste(lens, collapse = ", "))
  }
  
  # Create data frame
  data.frame(..., stringsAsFactors = FALSE)
}

# Test
safe_data_frame(x = 1:5, y = 10)      # Works
safe_data_frame(x = 1:6, y = c(1,2))  # Works
```

```{r error=TRUE}
safe_data_frame(x = 1:5, y = 1:3)     # Clear error
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use tidyverse for Better Errors**

```{r}
library(tibble)

# tibble is stricter - no recycling except length 1
tibble(
  x = 1:5,
  y = 10      # Length 1 OK
)
```

```{r error=TRUE}
# Doesn't allow multiple recycling
tibble(
  x = 1:6,
  y = c(1, 2)  # Error! Clearer message
)
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Silent Recycling**

```{r}
# This works but may not be intended!
df <- data.frame(
  group = 1:12,
  label = c("A", "B", "C")  # Recycled 4 times
)
df

# Was this intended? Hard to tell!
# Explicit is better:
df <- data.frame(
  group = 1:12,
  label = rep(c("A", "B", "C"), times = 4)
)
```
</div>

## Error #2: `row names supplied are of wrong length` {#rownames-wrong-length}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
data.frame(
  x = 1:5,
  y = 6:10,
  row.names = c("a", "b", "c")  # Only 3 names for 5 rows!
)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in data.frame(x = 1:5, y = 6:10, row.names = c("a", "b", "c")) : 
  row names supplied are of wrong length
```
</div>

### What It Means

Row names must be exactly one per row. No more, no less.

### Row Names Basics

```{r}
# Row names are optional
df <- data.frame(x = 1:3, y = 4:6)
rownames(df)  # Default: "1", "2", "3"

# Can set custom row names
df <- data.frame(
  x = 1:3,
  y = 4:6,
  row.names = c("first", "second", "third")
)
rownames(df)

# Or set after creation
df <- data.frame(x = 1:3, y = 4:6)
rownames(df) <- c("a", "b", "c")
rownames(df)
```

### Common Causes

#### Cause 1: Wrong Count

```{r error=TRUE}
df <- data.frame(x = 1:10, y = 11:20)

# Too few row names
rownames(df) <- c("a", "b", "c")
```

#### Cause 2: After Subsetting

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
original_names <- c("a", "b", "c", "d", "e")
rownames(df) <- original_names

# Subset data frame
df_subset <- df[1:3, ]
rownames(df_subset)  # Kept original names (good)

# But if you try to reuse original names on subset:
rownames(df_subset) <- original_names  # Error! 5 names for 3 rows
```

#### Cause 3: From External Source

```{r error=TRUE}
data_values <- data.frame(x = 1:5, y = 6:10)
labels <- c("a", "b", "c")  # From somewhere else, wrong length

rownames(data_values) <- labels
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Match Length**

```{r}
df <- data.frame(x = 1:5, y = 6:10)
names_available <- c("a", "b", "c")

# Option A: Extend with numbers
all_names <- c(names_available, 
               paste0("row", (length(names_available)+1):nrow(df)))
rownames(df) <- all_names

# Option B: Use only available, add column instead
df$label <- c(names_available, rep(NA, nrow(df) - length(names_available)))
df
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Before Assigning**

```{r}
safe_set_rownames <- function(df, names) {
  if (length(names) != nrow(df)) {
    warning("Row names length (", length(names), 
            ") doesn't match rows (", nrow(df), ")")
    return(df)
  }
  
  rownames(df) <- names
  return(df)
}

# Test
df <- data.frame(x = 1:5, y = 6:10)
df <- safe_set_rownames(df, c("a", "b", "c"))  # Warning, unchanged
df <- safe_set_rownames(df, letters[1:5])      # Works
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Column Instead**

```{r}
# Modern best practice: avoid row names
df <- data.frame(
  id = c("a", "b", "c", "d", "e"),
  x = 1:5,
  y = 6:10
)

# Use first column as identifier
df

# Can still use for indexing
df[df$id == "c", ]
```
</div>

<div class="bestpractice-box">
üéØ **Best Practice: Avoid Row Names**

Row names are a legacy feature. Modern R style:

```{r}
# Old style (avoid)
df <- data.frame(x = 1:3, y = 4:6, row.names = c("a", "b", "c"))

# New style (prefer)
df <- data.frame(
  id = c("a", "b", "c"),
  x = 1:3,
  y = 4:6
)

# Tibbles don't even support row names!
library(tibble)
tibble(id = c("a", "b", "c"), x = 1:3, y = 4:6)
```

**Why?**
- Row names are easily lost in operations
- Harder to work with programmatically
- Not supported by modern tidyverse
- Column is more explicit and flexible
</div>

## Error #3: `duplicate row.names are not allowed` {#duplicate-rownames}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
data.frame(
  x = 1:3,
  y = 4:6,
  row.names = c("a", "b", "a")  # Duplicate!
)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in data.frame(x = 1:3, y = 4:6, row.names = c("a", "b", "a")) : 
  duplicate row.names: a
```
</div>

### What It Means

Row names must be unique identifiers. Duplicates aren't allowed.

### Common Causes

#### Cause 1: Non-Unique IDs

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
ids <- c("sample1", "sample2", "sample2", "sample3", "sample4")

rownames(df) <- ids  # Error!
```

#### Cause 2: After Combining Data Frames

```{r error=TRUE}
df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(x = 4:6, row.names = c("c", "d", "e"))  # "c" repeats!

# rbind checks for this
rbind(df1, df2)  # Error!
```

#### Cause 3: Default Row Names from Subsetting

```{r error=TRUE}
df <- data.frame(x = 1:10, row.names = letters[1:10])

# Take rows
df1 <- df[1:3, ]
df2 <- df[2:4, ]  # Overlaps with df1

# Try to combine
rbind(df1, df2)  # Error! "b" and "c" appear twice
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Make Unique**

```{r}
df <- data.frame(x = 1:5, y = 6:10)
ids <- c("sample1", "sample2", "sample2", "sample3", "sample4")

# Make unique automatically
unique_ids <- make.unique(ids, sep = "_")
unique_ids

rownames(df) <- unique_ids
df
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Reset Row Names When Combining**

```{r}
df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(x = 4:6, row.names = c("c", "d", "e"))

# Remove row names before combining
rownames(df1) <- NULL
rownames(df2) <- NULL
rbind(df1, df2)

# Or use row.names = FALSE
df_combined <- rbind(df1, df2)  # Still errors

# Better: let R assign new row names
df1_clean <- df1
df2_clean <- df2
rownames(df1_clean) <- NULL
rownames(df2_clean) <- NULL
rbind(df1_clean, df2_clean)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check for Duplicates First**

```{r}
safe_set_rownames_unique <- function(df, names) {
  if (anyDuplicated(names)) {
    dupes <- names[duplicated(names)]
    warning("Duplicate row names found: ", 
            paste(unique(dupes), collapse = ", "))
    names <- make.unique(names, sep = "_")
  }
  
  rownames(df) <- names
  return(df)
}

# Test
df <- data.frame(x = 1:5)
df <- safe_set_rownames_unique(df, c("a", "b", "a", "c", "d"))
rownames(df)
```
</div>

## Error #4: `invalid type (list) for variable` {#invalid-type-list}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Trying to create column from nested list
data.frame(
  id = 1:3,
  values = list(1:3, 4:6, 7:9)  # List column - old data.frame rejects
)
```

<div class="error-box">
üî¥ **ERROR** (in older R versions or strict mode)

```
Error in data.frame(...) : invalid type (list) for variable 'values'
```
</div>

### What It Means

Traditional `data.frame()` doesn't easily support list columns. Each column should be an atomic vector.

### Modern Solution: List Columns

```{r}
# Modern R allows this with I()
df <- data.frame(
  id = 1:3,
  values = I(list(1:3, 4:6, 7:9))
)
df

# Access list column
df$values[[1]]

# Tibbles make it easier
library(tibble)
tibble(
  id = 1:3,
  values = list(1:3, 4:6, 7:9)
)
```

### Common Causes

#### Cause 1: Nested Data

```{r error=TRUE}
# Have nested data
nested <- list(
  list(x = 1, y = 2),
  list(x = 3, y = 4),
  list(x = 5, y = 6)
)

# Try to put in data frame
data.frame(
  id = 1:3,
  data = nested  # Old error
)
```

#### Cause 2: Split/Group Result

```{r error=TRUE}
# Split creates list
values <- 1:12
groups <- rep(1:3, each = 4)
split_data <- split(values, groups)

# Try to put in data frame directly
data.frame(
  group = 1:3,
  values = split_data  # May error
)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use I() to Protect List**

```{r}
# Wrap in I() to inhibit conversion
df <- data.frame(
  id = 1:3,
  values = I(list(1:3, 4:6, 7:9))
)

# Or use list column explicitly
df <- data.frame(id = 1:3)
df$values <- list(1:3, 4:6, 7:9)
df
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Tibble (Easier)**

```{r}
library(tibble)

# Tibbles naturally support list columns
tib <- tibble(
  id = 1:3,
  values = list(1:3, 4:6, 7:9),
  nested = list(
    list(a = 1, b = 2),
    list(a = 3, b = 4),
    list(a = 5, b = 6)
  )
)
tib

# Clean syntax
tib$values
tib$nested[[1]]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Unnest if Possible**

```{r}
# If you don't need list column, unnest
library(tidyr)

# Start with list column
df <- tibble(
  id = 1:3,
  values = list(1:3, 4:6, 7:9)
)

# Unnest to regular columns
unnest(df, values)
```
</div>

## Error #5: `cannot coerce class X to a data.frame` {#cannot-coerce-df-dataframe}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Try to convert function to data frame
my_func <- function(x) x + 1
as.data.frame(my_func)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in as.data.frame.default(my_func) : 
  cannot coerce class '"function"' to a data.frame
```
</div>

### What It Means

You're trying to convert something to a data frame that can't be converted.

### Common Causes

#### Cause 1: Wrong Object Type

```{r error=TRUE}
# Can't convert these:
as.data.frame(mean)           # Function
as.data.frame(environment())  # Environment
```

#### Cause 2: Incompatible Structure

```{r error=TRUE}
# Uneven list
irregular <- list(
  a = 1:3,
  b = 1:5,  # Different length!
  c = 1:2
)

as.data.frame(irregular)
```

#### Cause 3: After Failed Operation

```{r error=TRUE}
# Operation returns something unexpected
result <- try(stop("Error"), silent = TRUE)
class(result)  # "try-error"

as.data.frame(result)  # Can't convert error object
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Type First**

```{r}
safe_as_dataframe <- function(x) {
  # Check if already data frame
  if (is.data.frame(x)) {
    return(x)
  }
  
  # Check if matrix
  if (is.matrix(x)) {
    return(as.data.frame(x))
  }
  
  # Check if list with equal lengths
  if (is.list(x)) {
    lens <- lengths(x)
    if (length(unique(lens)) == 1 || all(lens == 1 | lens == max(lens))) {
      return(as.data.frame(x, stringsAsFactors = FALSE))
    } else {
      stop("List has incompatible lengths: ", paste(lens, collapse = ", "))
    }
  }
  
  # Check if vector
  if (is.atomic(x)) {
    return(data.frame(value = x, stringsAsFactors = FALSE))
  }
  
  stop("Cannot convert ", class(x)[1], " to data frame")
}

# Test
safe_as_dataframe(1:5)
safe_as_dataframe(matrix(1:6, 2, 3))
safe_as_dataframe(list(a = 1:3, b = 4:6))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Fix Structure First**

```{r}
# Uneven list
irregular <- list(
  a = 1:3,
  b = 1:5,
  c = 1:2
)

# Option A: Pad with NA
max_len <- max(lengths(irregular))
regular <- lapply(irregular, function(x) {
  c(x, rep(NA, max_len - length(x)))
})
as.data.frame(regular)

# Option B: Trim to shortest
min_len <- min(lengths(irregular))
regular <- lapply(irregular, function(x) x[1:min_len])
as.data.frame(regular)
```
</div>

## Stringsasfactors Historical Issue

<div class="pitfall-box">
‚ö†Ô∏è **Historical Pitfall: stringsAsFactors**

In R < 4.0.0, `stringsAsFactors = TRUE` was default:

```{r}
# R < 4.0.0 behavior
df_old <- data.frame(
  name = c("Alice", "Bob"),
  age = c(25, 30),
  stringsAsFactors = TRUE  # Was default
)
class(df_old$name)  # "factor" (was default)

# R >= 4.0.0 behavior
df_new <- data.frame(
  name = c("Alice", "Bob"),
  age = c(25, 30)
  # stringsAsFactors = FALSE is now default
)
class(df_new$name)  # "character"
```

**Best Practice:** Always specify explicitly:

```{r eval=FALSE}
# For compatibility across R versions
data.frame(..., stringsAsFactors = FALSE)

# Or use tibble (never converts to factor)
tibble(...)
```
</div>

## Creating Data Frames: All Methods

<div class="bestpractice-box">
üéØ **Best Practice: Data Frame Creation Methods**

```{r}
# Method 1: data.frame() - base R
df1 <- data.frame(
  x = 1:3,
  y = 4:6,
  stringsAsFactors = FALSE
)

# Method 2: tibble() - modern tidyverse
library(tibble)
df2 <- tibble(
  x = 1:3,
  y = 4:6
)

# Method 3: From matrix
mat <- matrix(1:6, nrow = 2, ncol = 3)
df3 <- as.data.frame(mat)

# Method 4: From list
lst <- list(x = 1:3, y = 4:6)
df4 <- as.data.frame(lst)

# Method 5: From vectors
x <- 1:3
y <- 4:6
df5 <- data.frame(x, y)

# Method 6: Reading data
df6 <- read.csv("file.csv")  # Base R
# df7 <- read_csv("file.csv")  # readr (tibble)

# Method 7: tribble() - row-wise
library(tibble)
df8 <- tribble(
  ~x, ~y,
   1,  4,
   2,  5,
   3,  6
)
```

**When to use each:**
- `data.frame()`: Base R compatibility needed
- `tibble()`: Modern code, better defaults
- `as.data.frame()`: Converting from other structures
- `tribble()`: Small data, readable layout
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **All columns must be same length** (or length 1 for recycling)
2. **Row names must be unique** (if used at all)
3. **Avoid row names** in modern code - use column instead
4. **List columns need I()** in data.frame(), or use tibble
5. **stringsAsFactors = FALSE** for compatibility
6. **Check lengths before construction**
7. **tibble is stricter** and usually better

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| differing number of rows | Unequal lengths | Match lengths or use length 1 |
| row names wrong length | Row names ‚â† nrows | Provide correct number |
| duplicate row.names | Non-unique names | Use make.unique() or remove |
| invalid type (list) | List column in old data.frame | Use I() or tibble |
| cannot coerce to data.frame | Wrong structure | Check type and fix structure |

**Construction Checklist:**

```{r eval=FALSE}
# Before creating data frame:
lengths(list_of_vectors)     # Check all lengths
anyDuplicated(row_names)     # Check for duplicates
class(each_column)           # Verify types

# Safe construction:
tibble(...)                  # Stricter checking
data.frame(..., stringsAsFactors = FALSE)  # Explicit

# After construction:
str(df)                      # Verify structure
anyDuplicated(rownames(df))  # Check row names
```

**Modern Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
tibble(x = 1:5, y = 10)                    # Stricter
data.frame(x = 1:5, stringsAsFactors = FALSE)  # Explicit

# ‚ùå Avoid
data.frame(x = 1:5)                        # stringsAsFactors unclear
df <- data.frame(x = 1:5, row.names = names)  # Row names fragile
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Diagnose the Error**

What's wrong and how do you fix it?

```{r eval=FALSE}
# Scenario 1
df <- data.frame(
  id = 1:10,
  group = c("A", "B", "C")
)

# Scenario 2
df <- data.frame(
  x = 1:5,
  y = 6:10,
  row.names = c("a", "b", "c", "a", "e")
)

# Scenario 3
df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(x = 4:6, row.names = c("b", "c", "d"))
combined <- rbind(df1, df2)

# Scenario 4
data.frame(
  id = 1:3,
  data = list(
    c(1, 2, 3),
    c(4, 5),
    c(6, 7, 8, 9)
  )
)
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Safe Constructor**

Write `safe_df(...)` that:
1. Checks all vectors are same length or length 1
2. Warns about recycling
3. Checks for duplicate names
4. Returns tibble or data.frame
5. Handles list columns properly
</div>

<div class="exercise-box">
üìù **Exercise 3: Fix Irregular Data**

You have:
```{r eval=FALSE}
data <- list(
  id = 1:5,
  name = c("Alice", "Bob", "Charlie"),
  score = c(85, 90, 95, 88)
)
```

Create a data frame handling the unequal lengths gracefully.
</div>

<div class="exercise-box">
üìù **Exercise 4: Combine with Row Names**

You have multiple data frames with overlapping row names:
```{r eval=FALSE}
df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(y = 4:6, row.names = c("b", "c", "d"))
df3 <- data.frame(z = 7:9, row.names = c("c", "d", "e"))
```

Combine them into one data frame keeping all data.
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# Scenario 1 - Length mismatch (10 vs 3)
# Fix: Recycle explicitly or trim
df <- data.frame(
  id = 1:10,
  group = rep(c("A", "B", "C"), length.out = 10)
)

# Scenario 2 - Duplicate row name "a"
df <- data.frame(
  x = 1:5,
  y = 6:10,
  row.names = make.unique(c("a", "b", "c", "a", "e"))
)

# Scenario 3 - Overlapping row names
df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(x = 4:6, row.names = c("b", "c", "d"))
# Option A: Remove row names
combined <- rbind(
  data.frame(x = df1$x),
  data.frame(x = df2$x)
)
# Option B: Keep as column
combined <- rbind(
  data.frame(id = rownames(df1), x = df1$x),
  data.frame(id = rownames(df2), x = df2$x)
)

# Scenario 4 - List column (different lengths within)
# Use tibble or I()
library(tibble)
df <- tibble(
  id = 1:3,
  data = list(
    c(1, 2, 3),
    c(4, 5),
    c(6, 7, 8, 9)
  )
)
# Or with data.frame:
df <- data.frame(id = 1:3)
df$data <- list(c(1,2,3), c(4,5), c(6,7,8,9))
```

**Exercise 2:**

```{r}
safe_df <- function(..., use_tibble = TRUE) {
  args <- list(...)
  
  # Get lengths
  lens <- sapply(args, length)
  
  # Check for issues
  max_len <- max(lens)
  
  # Check compatibility
  recyclable <- lens == 1 | lens == max_len
  
  if (!all(recyclable)) {
    # Check if multiples
    multiples <- max_len %% lens == 0
    if (!all(recyclable | multiples)) {
      stop("Incompatible lengths: ", paste(lens, collapse = ", "),
           "\nMax length: ", max_len)
    }
    warning("Recycling vectors of length ", 
            paste(unique(lens[!recyclable]), collapse = ", "),
            " to length ", max_len)
  }
  
  # Check names
  arg_names <- names(args)
  if (!is.null(arg_names) && anyDuplicated(arg_names)) {
    warning("Duplicate column names: ",
            paste(arg_names[duplicated(arg_names)], collapse = ", "))
  }
  
  # Create data frame
  if (use_tibble) {
    library(tibble)
    result <- tibble(...)
  } else {
    result <- data.frame(..., stringsAsFactors = FALSE)
  }
  
  return(result)
}

# Test
safe_df(x = 1:5, y = 10)
safe_df(x = 1:6, y = c(1, 2))  # Warning about recycling
```

**Exercise 3:**

```{r}
data <- list(
  id = 1:5,
  name = c("Alice", "Bob", "Charlie"),
  score = c(85, 90, 95, 88)
)

# Option A: Extend shorter with NA
max_len <- max(lengths(data))
data_fixed <- lapply(data, function(x) {
  c(x, rep(NA, max_len - length(x)))
})
df <- as.data.frame(data_fixed, stringsAsFactors = FALSE)
df

# Option B: Trim all to shortest
min_len <- min(lengths(data))
data_fixed <- lapply(data, function(x) x[1:min_len])
df <- as.data.frame(data_fixed, stringsAsFactors = FALSE)
df

# Option C: Use only complete cases
# (more complex - requires pairing)
```

**Exercise 4:**

```{r}
library(tibble)

df1 <- data.frame(x = 1:3, row.names = c("a", "b", "c"))
df2 <- data.frame(y = 4:6, row.names = c("b", "c", "d"))
df3 <- data.frame(z = 7:9, row.names = c("c", "d", "e"))

# Convert row names to column
df1_with_id <- tibble(id = rownames(df1), x = df1$x)
df2_with_id <- tibble(id = rownames(df2), y = df2$y)
df3_with_id <- tibble(id = rownames(df3), z = df3$z)

# Full join to keep all
library(dplyr)
result <- df1_with_id %>%
  full_join(df2_with_id, by = "id") %>%
  full_join(df3_with_id, by = "id")

result

# Alternative: using merge
result <- merge(df1_with_id, df2_with_id, by = "id", all = TRUE)
result <- merge(result, df3_with_id, by = "id", all = TRUE)
result
```
</details>

<!--chapter:end:09-dataframe-construction.Rmd-->

# Column Manipulation {#column-manipulation}

<div class="chapter-summary">
**What You'll Learn:**

- Adding and removing columns safely
- Column name handling
- Type preservation during operations
- Renaming strategies
- Common manipulation pitfalls

**Key Errors Covered:** 12+ column manipulation errors

**Difficulty:** ‚≠ê Beginner to ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Working with data frame columns is a daily task, but it's full of traps:

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
df[, "z"]  # Typo in column name
```

```{r error=TRUE}
# Or this:
df$new_column <- 1:3  # Wrong length!
```

Let's master column manipulation to avoid these common errors.

## Column Basics

<div class="insight-box">
üí° **Key Insight: Data Frame is a List**

Understanding this is key to column operations:

```{r}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Data frame is a special list
is.list(df)
length(df)  # Number of columns!

# Each column is a list element
df[[1]]     # First column (vector)
df[1]       # First column (data frame)

# Three ways to access columns:
df$x        # Dollar sign
df[["x"]]   # Double bracket
df["x"]     # Single bracket (returns data frame)

# Column names
names(df)
colnames(df)
```
</div>

## Error #1: `undefined columns selected` {#undefined-columns-select}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
df <- data.frame(age = c(25, 30, 35), name = c("Alice", "Bob", "Charlie"))
df[, "salary"]  # Column doesn't exist
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `[.data.frame`(df, , "salary") : undefined columns selected
```
</div>

### What It Means

You're trying to select a column that doesn't exist in the data frame.

### Common Causes

#### Cause 1: Typo

```{r error=TRUE}
df <- data.frame(temperature = c(20, 25, 30))

# Typo
df[, "tempurature"]
```

#### Cause 2: Case Sensitivity

```{r error=TRUE}
df <- data.frame(Name = c("Alice", "Bob"))

# Wrong case
df[, "name"]  # It's "Name" not "name"
```

#### Cause 3: Column Doesn't Exist Yet

```{r error=TRUE}
df <- data.frame(x = 1:5)

# Trying to select before creating
df[, c("x", "y")]  # "y" doesn't exist
```

#### Cause 4: After Transformation

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10, z = 11:15)

# Select some columns
df_subset <- df[, c("x", "y")]

# Try to access original column
df_subset[, "z"]  # No longer exists
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Column Exists**

```{r}
df <- data.frame(age = c(25, 30, 35), name = c("Alice", "Bob", "Charlie"))

# Check before accessing
if ("salary" %in% names(df)) {
  df[, "salary"]
} else {
  message("Column 'salary' not found")
  NULL
}

# Or for multiple columns
cols_wanted <- c("age", "salary", "name")
cols_available <- cols_wanted[cols_wanted %in% names(df)]
df[, cols_available]
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use dplyr's select() with Helpers**

```{r}
library(dplyr)

df <- data.frame(age = c(25, 30, 35), name = c("Alice", "Bob", "Charlie"))

# Select only existing columns
df %>% select(any_of(c("age", "salary", "name")))

# Or with error on missing
```

```{r error=TRUE}
df %>% select(all_of(c("age", "salary")))  # Errors on missing
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Safe Column Selection Function**

```{r}
safe_select <- function(df, cols, warn = TRUE) {
  existing <- cols[cols %in% names(df)]
  missing <- cols[!cols %in% names(df)]
  
  if (length(missing) > 0 && warn) {
    warning("Columns not found: ", paste(missing, collapse = ", "))
  }
  
  if (length(existing) == 0) {
    return(data.frame())  # Empty data frame
  }
  
  return(df[, existing, drop = FALSE])
}

# Test
df <- data.frame(x = 1:5, y = 6:10)
safe_select(df, c("x", "z", "y"))
```
</div>

## Error #2: `replacement has X rows, data has Y` {#replacement-rows-column}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10)
df$z <- 1:3  # Wrong length!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `$<-.data.frame`(`*tmp*`, z, value = 1:3) : 
  replacement has 3 rows, data has 5
```
</div>

### What It Means

When adding/replacing a column, the new values must match the number of rows (or be length 1).

### The Recycling Rule for Columns

```{r}
df <- data.frame(x = 1:5)

# Length 1: recycles
df$y <- 10
df

# Same length: works
df$z <- 11:15
df
```

```{r error=TRUE}
# Wrong length: errors
df$w <- 1:3
```

### Common Causes

#### Cause 1: Calculation Resulted in Wrong Length

```{r error=TRUE}
df <- data.frame(id = 1:10, value = rnorm(10))

# Filter creates shorter vector
high_values <- df$value[df$value > 0]  # Maybe 6 elements

# Try to add back
df$high <- high_values  # Error! 6 vs 10
```

#### Cause 2: Using Summary on Column

```{r error=TRUE}
df <- data.frame(
  group = rep(c("A", "B"), each = 5),
  value = 1:10
)

# Calculate group means (2 values)
group_means <- tapply(df$value, df$group, mean)

# Try to add as column
df$mean <- group_means  # Error! 2 vs 10
```

#### Cause 3: After Subsetting

```{r error=TRUE}
df <- data.frame(x = 1:10, y = 11:20)

# Subset rows
df_sub <- df[1:5, ]

# Create column for full df
new_col <- 1:5

# Try to add to original
df$new <- new_col  # Error! 5 vs 10
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Match Lengths**

```{r}
df <- data.frame(id = 1:10, value = rnorm(10))
high_values <- df$value[df$value > 0]

# Option A: Use NA for missing
df$high <- NA
df$high[df$value > 0] <- high_values
df

# Option B: Use ifelse
df$high <- ifelse(df$value > 0, df$value, NA)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Merge for Aggregates**

```{r}
df <- data.frame(
  group = rep(c("A", "B"), each = 5),
  value = 1:10
)

# Calculate group means
group_summary <- aggregate(value ~ group, df, mean)
names(group_summary)[2] <- "group_mean"

# Merge back
df <- merge(df, group_summary, by = "group")
df
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use dplyr (Cleaner)**

```{r}
library(dplyr)

df <- data.frame(
  group = rep(c("A", "B"), each = 5),
  value = 1:10
)

# Add group mean to each row
df <- df %>%
  group_by(group) %>%
  mutate(group_mean = mean(value)) %>%
  ungroup()

df
```
</div>

## Error #3: `duplicate column names` {#duplicate-columns}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Warning/Problem

```{r}
df <- data.frame(x = 1:3, x = 4:6, check.names = FALSE)
names(df)
```

R allows duplicate column names (with warning), but it causes problems:

```{r}
# Which x?
df$x  # Gets first one

# Confusion!
df[, "x"]  # Gets first one
```

### Why It's Dangerous

```{r}
# Create with duplicates
df <- data.frame(value = 1:3, value = 4:6, check.names = FALSE)

# Operations become unpredictable
df$value <- df$value * 2  # Which one gets modified?
df

# Selection is confusing
df[, c("value", "value")]  # Gets same column twice
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Let R Fix Names**

```{r}
# Default: R makes names unique
df <- data.frame(x = 1:3, x = 4:6)  # check.names = TRUE by default
names(df)  # "x" and "x.1"

# Or manually
names_original <- c("value", "value", "score")
names_fixed <- make.names(names_original, unique = TRUE)
names_fixed
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check and Fix Names**

```{r}
fix_duplicate_names <- function(df) {
  col_names <- names(df)
  
  if (anyDuplicated(col_names)) {
    dupes <- col_names[duplicated(col_names)]
    warning("Duplicate column names found: ", 
            paste(unique(dupes), collapse = ", "))
    names(df) <- make.names(col_names, unique = TRUE)
  }
  
  return(df)
}

# Test
df <- data.frame(x = 1:3, x = 4:6, check.names = FALSE)
df <- fix_duplicate_names(df)
names(df)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Prevent Duplicates**

```{r}
safe_add_column <- function(df, name, values) {
  if (name %in% names(df)) {
    stop("Column '", name, "' already exists. ",
         "Use a different name or remove the existing column first.")
  }
  
  df[[name]] <- values
  return(df)
}

# Test
df <- data.frame(x = 1:3)
df <- safe_add_column(df, "y", 4:6)  # Works
```

```{r error=TRUE}
df <- safe_add_column(df, "x", 7:9)  # Errors
```
</div>

## Error #4: `names attribute must be same length as vector` {#names-length-mismatch}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
df <- data.frame(x = 1:5, y = 6:10, z = 11:15)
names(df) <- c("a", "b")  # Only 2 names for 3 columns!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in names(df) <- c("a", "b") : 
  'names' attribute must be the same length as the vector (3)
```
</div>

### What It Means

When setting column names, you must provide exactly one name per column.

### Common Causes

#### Cause 1: Wrong Count

```{r error=TRUE}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Too few
names(df) <- c("first", "second")

# Too many
names(df) <- c("first", "second", "third", "fourth")
```

#### Cause 2: After Adding Columns

```{r error=TRUE}
df <- data.frame(x = 1:3, y = 4:6)
new_names <- c("a", "b")

# Add a column
df$z <- 7:9

# Try to use old names
names(df) <- new_names  # Error! Now 3 columns
```

#### Cause 3: From External Source

```{r error=TRUE}
df <- data.frame(matrix(1:12, nrow = 3, ncol = 4))
column_labels <- c("ID", "Value")  # Wrong number

names(df) <- column_labels
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Match Number of Names**

```{r}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Provide all names
names(df) <- c("first", "second", "third")

# Or rename specific columns
names(df)[1] <- "id"
names(df)[3] <- "score"
names(df)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Named Vector for Partial Rename**

```{r}
library(dplyr)

df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Rename specific columns
df <- df %>% rename(id = x, score = z)
names(df)

# Or base R
names(df)[names(df) == "y"] <- "value"
names(df)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Safe Rename Function**

```{r}
safe_rename <- function(df, ...) {
  name_mapping <- list(...)
  
  for (old_name in names(name_mapping)) {
    new_name <- name_mapping[[old_name]]
    
    if (!old_name %in% names(df)) {
      warning("Column '", old_name, "' not found, skipping")
      next
    }
    
    if (new_name %in% names(df) && new_name != old_name) {
      warning("Column '", new_name, "' already exists, skipping")
      next
    }
    
    names(df)[names(df) == old_name] <- new_name
  }
  
  return(df)
}

# Test
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)
df <- safe_rename(df, x = "id", z = "score", w = "missing")
names(df)
```
</div>

## Removing Columns

<div class="bestpractice-box">
üéØ **Best Practice: Removing Columns**

```{r}
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)

# Method 1: Set to NULL
df$y <- NULL
df

# Method 2: Subset (keep what you want)
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)
df <- df[, c("x", "z")]
df

# Method 3: Subset (exclude what you don't want)
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)
df <- df[, !names(df) %in% c("y")]
df

# Method 4: dplyr select with minus
library(dplyr)
df <- data.frame(x = 1:3, y = 4:6, z = 7:9)
df <- df %>% select(-y)
df

# Method 5: Remove multiple
df <- data.frame(x = 1:3, y = 4:6, z = 7:9, w = 10:12)
df <- df %>% select(-c(y, w))
df
```

**Never do this:**
```{r eval=FALSE}
# ‚ùå Bad: modifies in place
df[, "y"] <- NULL  # Doesn't work as expected!

# ‚úÖ Good: explicit assignment
df$y <- NULL
```
</div>

## Column Reordering

<div class="insight-box">
üí° **Key Insight: Reordering Columns**

```{r}
df <- data.frame(z = 7:9, x = 1:3, y = 4:6)
names(df)

# Method 1: Specify order explicitly
df <- df[, c("x", "y", "z")]
names(df)

# Method 2: Sort alphabetically
df <- df[, sort(names(df))]
names(df)

# Method 3: Move specific columns first
df <- data.frame(z = 7:9, x = 1:3, y = 4:6)
df <- df[, c("x", setdiff(names(df), "x"))]
names(df)

# Method 4: dplyr relocate
library(dplyr)
df <- data.frame(z = 7:9, x = 1:3, y = 4:6)
df <- df %>% relocate(x, y, z)
names(df)

# Or move to front/end
df <- data.frame(z = 7:9, x = 1:3, y = 4:6)
df <- df %>% relocate(x, .before = everything())
df %>% relocate(z, .after = everything())
```
</div>

## Type Preservation

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Type Changes**

```{r}
# Start with factors
df <- data.frame(
  id = 1:3,
  category = c("A", "B", "C"),
  stringsAsFactors = TRUE
)
class(df$category)  # "factor"

# Select columns - type changes!
df_subset <- df[, "category"]
class(df_subset)  # "factor" (still)

# But extract as vector
vec <- df$category
class(vec)  # "factor"

# With drop = TRUE (default)
df_subset <- df[, "category", drop = TRUE]
class(df_subset)  # "factor" - becomes vector

# With drop = FALSE
df_subset <- df[, "category", drop = FALSE]
class(df_subset)  # "data.frame" - stays data frame
```

**Best practice:**
```{r}
# Use drop = FALSE when you want to keep data frame structure
df[, "category", drop = FALSE]

# Or use $ when you explicitly want a vector
df$category
```
</div>

## Adding Multiple Columns

<div class="bestpractice-box">
üéØ **Best Practice: Adding Multiple Columns**

```{r}
df <- data.frame(x = 1:5)

# Method 1: One at a time
df$y <- 6:10
df$z <- 11:15

# Method 2: cbind
df <- data.frame(x = 1:5)
df <- cbind(df, data.frame(y = 6:10, z = 11:15))

# Method 3: dplyr mutate
library(dplyr)
df <- data.frame(x = 1:5)
df <- df %>%
  mutate(
    y = x + 5,
    z = y + 5
  )

# Method 4: Transform base R
df <- data.frame(x = 1:5)
df <- transform(df,
  y = x + 5,
  z = y + 5  # Can reference previous
)

# Method 5: within
df <- data.frame(x = 1:5)
df <- within(df, {
  y <- x + 5
  z <- y + 5
})
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Check column exists** before accessing with `%in% names()`
2. **Match row count** when adding columns (or use length 1)
3. **Avoid duplicate names** - check with `anyDuplicated()`
4. **Provide all names** when renaming - one per column
5. **Use drop = FALSE** to preserve data frame structure
6. **$ sets to NULL** removes columns cleanly
7. **dplyr is clearer** for complex column operations

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| undefined columns selected | Column doesn't exist | Check with `%in% names()` |
| replacement has X rows | Wrong length column | Match nrows or use length 1 |
| duplicate column names | Non-unique names | Use `make.names(unique=TRUE)` |
| names attribute wrong length | Wrong # of names | Provide one per column |

**Column Operations Checklist:**

```{r eval=FALSE}
# Before accessing:
"colname" %in% names(df)      # Check exists
anyDuplicated(names(df))      # Check no duplicates

# When adding column:
length(new_values) == nrow(df) || length(new_values) == 1

# When renaming:
length(new_names) == ncol(df)
!anyDuplicated(new_names)

# Safe patterns:
df$col <- NULL                # Remove column
df[, cols, drop = FALSE]      # Keep as data frame
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
df %>% select(any_of(c("a", "b", "c")))  # Safe selection
df %>% mutate(new = old * 2)             # Add column
names(df)[names(df) == "old"] <- "new"   # Rename one

# ‚ùå Avoid
df[, "missing_col"]           # No check
df$new <- wrong_length_vector # No validation
names(df) <- c("a", "b")      # Partial names
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Safe Column Access**

Write a function that safely gets a column:
- Returns the column if it exists
- Returns default value if it doesn't
- Warns user about missing columns
- Handles both $ and [[ ]] style access
</div>

<div class="exercise-box">
üìù **Exercise 2: Batch Rename**

You have:
```{r eval=FALSE}
df <- data.frame(
  old_name_1 = 1:5,
  old_name_2 = 6:10,
  old_name_3 = 11:15
)
```

Write a function to rename all columns matching a pattern.
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Column Addition**

Write `add_column(df, name, values)` that:
1. Checks if name already exists
2. Validates values length
3. Handles recycling appropriately
4. Returns modified data frame
5. Gives informative errors
</div>

<div class="exercise-box">
üìù **Exercise 4: Column Audit**

Write a function that audits a data frame and reports:
- Missing column names
- Duplicate column names
- Invalid column names (non-syntactic)
- Columns with NA names
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
safe_get_column <- function(df, col, default = NULL, warn = TRUE) {
  if (!col %in% names(df)) {
    if (warn) {
      warning("Column '", col, "' not found in data frame")
    }
    return(default)
  }
  
  return(df[[col]])
}

# Test
df <- data.frame(x = 1:5, y = 6:10)
safe_get_column(df, "x")         # Returns column
safe_get_column(df, "z")         # Returns NULL with warning
safe_get_column(df, "z", default = NA, warn = FALSE)
```

**Exercise 2:**

```{r}
rename_pattern <- function(df, pattern, replacement) {
  old_names <- names(df)
  new_names <- gsub(pattern, replacement, old_names)
  
  if (identical(old_names, new_names)) {
    message("No columns matched pattern '", pattern, "'")
    return(df)
  }
  
  # Check for duplicates after rename
  if (anyDuplicated(new_names)) {
    warning("Renaming would create duplicate names, using make.unique()")
    new_names <- make.unique(new_names)
  }
  
  names(df) <- new_names
  
  # Report changes
  changed <- old_names != new_names
  if (any(changed)) {
    message("Renamed ", sum(changed), " columns:")
    for (i in which(changed)) {
      message("  ", old_names[i], " -> ", new_names[i])
    }
  }
  
  return(df)
}

# Test
df <- data.frame(
  old_name_1 = 1:5,
  old_name_2 = 6:10,
  old_name_3 = 11:15
)
df <- rename_pattern(df, "old_name_", "new_col_")
names(df)
```

**Exercise 3:**

```{r}
add_column <- function(df, name, values, overwrite = FALSE) {
  # Check if name exists
  if (name %in% names(df) && !overwrite) {
    stop("Column '", name, "' already exists. ",
         "Use overwrite = TRUE to replace.")
  }
  
  # Check length
  n_rows <- nrow(df)
  n_values <- length(values)
  
  if (n_values == n_rows) {
    # Perfect match
    df[[name]] <- values
  } else if (n_values == 1) {
    # Recycle single value
    message("Recycling single value to ", n_rows, " rows")
    df[[name]] <- values
  } else if (n_rows %% n_values == 0) {
    # Multiple recycling
    message("Recycling ", n_values, " values to ", n_rows, " rows")
    df[[name]] <- rep(values, length.out = n_rows)
  } else {
    stop("Length mismatch: values has ", n_values, 
         " elements but data frame has ", n_rows, " rows")
  }
  
  return(df)
}

# Test
df <- data.frame(x = 1:5)
df <- add_column(df, "y", 10)           # Recycles
df <- add_column(df, "z", 11:15)        # Matches
```

```{r error=TRUE}
df <- add_column(df, "w", 1:3)          # Errors
```

**Exercise 4:**

```{r}
audit_columns <- function(df) {
  col_names <- names(df)
  issues <- list()
  
  # Check for missing names
  if (any(is.na(col_names) | col_names == "")) {
    issues$missing <- which(is.na(col_names) | col_names == "")
  }
  
  # Check for duplicates
  if (anyDuplicated(col_names)) {
    dupes <- col_names[duplicated(col_names)]
    issues$duplicates <- unique(dupes)
  }
  
  # Check for invalid names (non-syntactic)
  valid <- make.names(col_names) == col_names
  if (!all(valid)) {
    issues$invalid <- col_names[!valid]
  }
  
  # Report
  if (length(issues) == 0) {
    message("‚úì All column names are valid")
    return(invisible(TRUE))
  }
  
  message("Column name issues found:")
  
  if (!is.null(issues$missing)) {
    message("  Missing names at positions: ", 
            paste(issues$missing, collapse = ", "))
  }
  
  if (!is.null(issues$duplicates)) {
    message("  Duplicate names: ", 
            paste(issues$duplicates, collapse = ", "))
  }
  
  if (!is.null(issues$invalid)) {
    message("  Invalid names: ", 
            paste(issues$invalid, collapse = ", "))
    message("  Suggested: ", 
            paste(make.names(issues$invalid), collapse = ", "))
  }
  
  return(invisible(issues))
}

# Test
df_good <- data.frame(x = 1:3, y = 4:6)
audit_columns(df_good)

df_bad <- data.frame(x = 1:3, x = 4:6, `2bad` = 7:9, 
                     check.names = FALSE)
audit_columns(df_bad)
```
</details>

<!--chapter:end:10-column-manipulation.Rmd-->

# Matrix Operations {#matrix-operations}

<div class="chapter-summary">
**What You'll Learn:**

- Matrix creation and structure
- Matrix algebra operations
- Dimension requirements
- Transpose and multiplication
- Common matrix errors

**Key Errors Covered:** 12+ matrix operation errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Matrices are fundamental to many R operations, especially statistics and linear algebra:

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)

# Try to add them
A + B
```

<div class="error-box">
üî¥ **ERROR**

```
Error in A + B : non-conformable arrays
```
</div>

Let's master matrix operations and avoid dimension mismatches.

## Matrix Basics

<div class="insight-box">
üí° **Key Insight: Matrices vs Data Frames**

```{r}
# Matrix: all same type
mat <- matrix(1:6, nrow = 2, ncol = 3)
typeof(mat)      # "integer"
is.matrix(mat)
is.data.frame(mat)

# Data frame: can mix types
df <- data.frame(
  x = 1:2,
  y = c("a", "b")
)
is.matrix(df)
is.data.frame(df)

# Can convert
as.matrix(df)    # Coerces to character!
as.data.frame(mat)

# Matrix properties
dim(mat)         # 2 3 (rows, cols)
nrow(mat)
ncol(mat)
length(mat)      # 6 (total elements)
```

**Key differences:**
- Matrices: All same type, 2D array
- Data frames: Can mix types, list of vectors
</div>

## Error #1: `non-conformable arrays` {#non-conformable-arrays}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:10, nrow = 2, ncol = 5)

A + B  # Different dimensions!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in A + B : non-conformable arrays
```
</div>

### What It Means

For element-wise operations (+, -, *, /), matrices must have the same dimensions.

### Conformability Rules

```{r}
# Same dimensions - OK
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(7:12, nrow = 2, ncol = 3)
A + B

# Scalar - OK (recycled)
A + 10

# Vector recycling
A + c(1, 2)  # Recycles down columns

# But these fail:
```

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)
A + B  # Different dimensions
```

### Common Causes

#### Cause 1: Transposed Matrix

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)

# B is transpose of A shape
A + B  # Error
```

```{r}
# Fix: transpose one
A + t(B)
```

#### Cause 2: Wrong Construction

```{r error=TRUE}
# Meant to be same size
A <- matrix(1:6, nrow = 2)  # 2x3
B <- matrix(1:8, nrow = 2)  # 2x4

A + B  # Error
```

#### Cause 3: After Subsetting

```{r error=TRUE}
A <- matrix(1:12, nrow = 3, ncol = 4)
B <- matrix(1:12, nrow = 3, ncol = 4)

# Subset changes dimensions
A_sub <- A[, 1:2]  # Now 3x2
B_sub <- B[, 1:3]  # Now 3x3

A_sub + B_sub  # Error!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Dimensions First**

```{r}
safe_matrix_add <- function(A, B) {
  if (!identical(dim(A), dim(B))) {
    stop("Matrices have different dimensions: ",
         paste(dim(A), collapse = "x"), " vs ",
         paste(dim(B), collapse = "x"))
  }
  
  return(A + B)
}

# Test
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(7:12, nrow = 2, ncol = 3)
safe_matrix_add(A, B)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Reshape to Match**

```{r}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)

# Transpose B to match
B_matched <- t(B)
A + B_matched

# Or reshape
B_reshaped <- matrix(B, nrow = 2, ncol = 3)
A + B_reshaped
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Extract Common Dimensions**

```{r}
A <- matrix(1:12, nrow = 3, ncol = 4)
B <- matrix(1:15, nrow = 3, ncol = 5)

# Find common dimensions
common_rows <- min(nrow(A), nrow(B))
common_cols <- min(ncol(A), ncol(B))

# Extract submatrices
A_sub <- A[1:common_rows, 1:common_cols]
B_sub <- B[1:common_rows, 1:common_cols]

A_sub + B_sub
```
</div>

## Error #2: `non-conformable arguments` {#non-conformable-arguments}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-dimension">üìè DIMENSION</span>

### The Error

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 2, ncol = 3)

# Try matrix multiplication
A %*% B
```

<div class="error-box">
üî¥ **ERROR**

```
Error in A %*% B : non-conformable arguments
```
</div>

### What It Means

For matrix multiplication (`%*%`), the number of columns in A must equal the number of rows in B.

### Matrix Multiplication Rules

<div class="insight-box">
üí° **Matrix Multiplication Requirements**

For `A %*% B`:
- A must be `m √ó n`
- B must be `n √ó p`
- Result will be `m √ó p`

```{r}
# A is 2√ó3, B is 3√ó2 - OK
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)
dim(A)  # 2 3
dim(B)  # 3 2

result <- A %*% B
dim(result)  # 2 2 (outer dimensions)
```

**Rule:** Inner dimensions must match, outer dimensions form result.

```
(2 √ó 3) %*% (3 √ó 2) = (2 √ó 2)
     ‚Üë       ‚Üë
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò must match
```
</div>

### Common Causes

#### Cause 1: Wrong Order

```{r error=TRUE}
A <- matrix(1:6, nrow = 2, ncol = 3)   # 2√ó3
B <- matrix(1:10, nrow = 2, ncol = 5)  # 2√ó5

# A has 3 cols, B has 2 rows - mismatch!
A %*% B
```

```{r}
# But reverse works!
B %*% A  # 2√ó5 times 5√ó3... wait, A is 2√ó3

# Need to transpose A
B %*% t(A)  # 2√ó5 times 5√ó2 = 2√ó2
```

#### Cause 2: Using Element-wise Instead

```{r}
A <- matrix(1:4, nrow = 2)
B <- matrix(5:8, nrow = 2)

# Element-wise multiplication (different!)
A * B  # Hadamard product

# Matrix multiplication
A %*% t(B)  # Need to transpose
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Conformability**

```{r}
can_multiply <- function(A, B) {
  ncol(A) == nrow(B)
}

safe_matrix_mult <- function(A, B) {
  if (!can_multiply(A, B)) {
    stop("Cannot multiply: A is ", nrow(A), "√ó", ncol(A),
         ", B is ", nrow(B), "√ó", ncol(B),
         "\nNeed ncol(A) = nrow(B)")
  }
  
  return(A %*% B)
}

# Test
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)
safe_matrix_mult(A, B)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Auto-transpose if Needed**

```{r}
smart_mult <- function(A, B) {
  # Try as-is
  if (ncol(A) == nrow(B)) {
    return(A %*% B)
  }
  
  # Try transposing B
  if (ncol(A) == ncol(B)) {
    message("Transposing B")
    return(A %*% t(B))
  }
  
  # Try transposing A
  if (nrow(A) == nrow(B)) {
    message("Transposing A")
    return(t(A) %*% B)
  }
  
  stop("Matrices not conformable in any configuration")
}

# Test
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 2, ncol = 3)
smart_mult(A, B)  # Transposes B
```
</div>

## Error #3: `system is computationally singular` {#computationally-singular}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Error

```{r error=TRUE}
# Singular matrix (not invertible)
A <- matrix(c(1, 2, 2, 4), nrow = 2)
A

solve(A)  # Try to invert
```

<div class="error-box">
üî¥ **ERROR**

```
Error in solve.default(A) : 
  system is computationally singular: reciprocal condition number = 0
```
</div>

### What It Means

The matrix is singular (non-invertible). Its determinant is 0 (or very close to 0).

### Why Matrices Become Singular

```{r}
# Linearly dependent rows
A <- matrix(c(1, 2, 2, 4), nrow = 2)
A
# Row 2 = 2 * Row 1

det(A)  # 0 (singular)

# Compare to invertible matrix
B <- matrix(c(1, 2, 3, 4), nrow = 2)
det(B)  # -2 (non-zero, invertible)
solve(B)  # Works
```

### Common Causes

#### Cause 1: Perfect Collinearity

```{r error=TRUE}
# Data with perfect correlation
x1 <- 1:5
x2 <- 2 * x1  # Perfectly correlated

X <- cbind(1, x1, x2)  # Design matrix
A <- t(X) %*% X  # X'X matrix

solve(A)  # Singular!
```

#### Cause 2: More Variables Than Observations

```{r error=TRUE}
# 3 observations, 5 variables
X <- matrix(rnorm(15), nrow = 3, ncol = 5)
A <- t(X) %*% X  # 5√ó5 matrix

solve(A)  # Singular!
```

#### Cause 3: Numerical Issues

```{r error=TRUE}
# Very small numbers can cause numerical singularity
A <- matrix(c(1, 1e-10, 1e-10, 1), nrow = 2)
solve(A)  # May fail due to numerical precision
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Before Inverting**

```{r}
safe_solve <- function(A, tol = 1e-10) {
  # Check if square
  if (nrow(A) != ncol(A)) {
    stop("Matrix must be square")
  }
  
  # Check determinant
  d <- det(A)
  
  if (abs(d) < tol) {
    stop("Matrix is singular (det = ", d, ")")
  }
  
  return(solve(A))
}

# Test
B <- matrix(c(1, 2, 3, 4), nrow = 2)
safe_solve(B)  # Works

A <- matrix(c(1, 2, 2, 4), nrow = 2)
```

```{r error=TRUE}
safe_solve(A)  # Clear error message
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Generalized Inverse**

```{r}
library(MASS)

# Singular matrix
A <- matrix(c(1, 2, 2, 4), nrow = 2)

# Moore-Penrose generalized inverse
A_inv <- ginv(A)
A_inv

# Check: A %*% ginv(A) %*% A = A
all.equal(A, A %*% A_inv %*% A)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Remove Collinear Variables**

```{r}
# Detect and remove collinear columns
remove_collinear <- function(X, threshold = 0.99) {
  cor_matrix <- cor(X)
  
  # Find highly correlated pairs
  high_cor <- which(abs(cor_matrix) > threshold & 
                    upper.tri(cor_matrix, diag = FALSE),
                    arr.ind = TRUE)
  
  if (nrow(high_cor) > 0) {
    # Remove second column of correlated pairs
    remove_cols <- unique(high_cor[, 2])
    message("Removing collinear columns: ", 
            paste(remove_cols, collapse = ", "))
    X <- X[, -remove_cols]
  }
  
  return(X)
}

# Test
x1 <- 1:5
x2 <- 2 * x1
x3 <- rnorm(5)
X <- cbind(x1, x2, x3)

X_clean <- remove_collinear(X)
ncol(X_clean)  # One less column
```
</div>

## Matrix Creation Errors

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Matrix Filling**

```{r}
# Matrix fills by COLUMN (default)
matrix(1:6, nrow = 2, ncol = 3)

# To fill by row:
matrix(1:6, nrow = 2, ncol = 3, byrow = TRUE)

# This catches many people!
matrix(c(1, 2, 3,
         4, 5, 6), nrow = 2, ncol = 3)
# NOT what you might expect!

# Want row-wise? Use byrow:
matrix(c(1, 2, 3,
         4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)
```
</div>

## Matrix Operations Reference

<div class="bestpractice-box">
üéØ **Best Practice: Common Matrix Operations**

```{r}
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)

# Transpose
t(A)

# Matrix multiplication
A %*% B  # Result: 2√ó2

# Element-wise operations (same dimensions needed)
C <- matrix(7:12, nrow = 2, ncol = 3)
A + C
A - C
A * C  # Hadamard product (element-wise)
A / C

# Cross product
crossprod(A)    # t(A) %*% A
tcrossprod(A)   # A %*% t(A)

# Determinant
D <- matrix(c(1, 2, 3, 4), nrow = 2)
det(D)

# Inverse (square matrices only)
solve(D)

# Diagonal
diag(D)          # Extract diagonal
diag(c(1, 2, 3)) # Create diagonal matrix

# Eigenvalues and eigenvectors
eigen(D)

# Singular value decomposition
svd(A)
```
</div>

## Dimension Preservation

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Dropping Dimensions**

```{r}
A <- matrix(1:12, nrow = 3, ncol = 4)

# Extract row (becomes vector!)
row1 <- A[1, ]
dim(row1)  # NULL (it's a vector now)

# Extract column (becomes vector!)
col1 <- A[, 1]
dim(col1)  # NULL

# Preserve matrix structure
row1 <- A[1, , drop = FALSE]
dim(row1)  # 1 3

col1 <- A[, 1, drop = FALSE]
dim(col1)  # 3 1
```

**When it matters:**
```{r error=TRUE}
A <- matrix(1:12, nrow = 3, ncol = 4)
B <- matrix(1:3, nrow = 3, ncol = 1)

# Extract column from A (becomes vector)
A_col <- A[, 1]

# Try to multiply
A_col %*% B  # Error! A_col is vector
```

```{r}
# Fix: preserve dimensions
A_col <- A[, 1, drop = FALSE]
A_col %*% t(B)  # Works!
```
</div>

## Converting Between Structures

<div class="insight-box">
üí° **Key Insight: Conversions**

```{r}
# Vector to matrix
vec <- 1:12
mat <- matrix(vec, nrow = 3, ncol = 4)

# Matrix to vector
as.vector(mat)  # Column-major order

# Matrix to data frame
df <- as.data.frame(mat)
class(df)

# Data frame to matrix
mat2 <- as.matrix(df)
class(mat2)

# List to matrix (if all same length)
lst <- list(a = 1:3, b = 4:6, c = 7:9)
mat3 <- do.call(cbind, lst)
mat3

# Matrix to list (by column)
lst2 <- as.list(as.data.frame(mat))
```

**Warning: Type coercion**
```{r}
# Data frame with mixed types
df_mixed <- data.frame(
  x = 1:3,
  y = c("a", "b", "c")
)

# Converting to matrix coerces to common type
as.matrix(df_mixed)  # All become character!
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Element-wise operations**: Need identical dimensions
2. **Matrix multiplication**: Inner dimensions must match
3. **Singular matrices**: Cannot be inverted (det = 0)
4. **Filling order**: Column-major by default (use `byrow = TRUE`)
5. **drop = FALSE**: Preserves matrix structure
6. **Type coercion**: Converting mixed-type df to matrix coerces all
7. **Check dimensions**: Always verify before operations

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| non-conformable arrays | Different dimensions for +,-,*,/ | Match dimensions |
| non-conformable arguments | ncol(A) ‚â† nrow(B) for %*% | Transpose or reshape |
| computationally singular | Matrix not invertible | Check det(), use ginv() |
| incorrect number of dimensions | Wrong subscripts | Match matrix structure |

**Matrix Operations Checklist:**

```{r eval=FALSE}
# Before operations:
dim(A)                    # Check dimensions
det(A)                    # Check if invertible
ncol(A) == nrow(B)        # Check for multiplication

# Safe extraction:
A[i, , drop = FALSE]      # Preserve row
A[, j, drop = FALSE]      # Preserve column

# Matrix multiplication:
A %*% B                   # Matrix product
A * B                     # Element-wise (Hadamard)
crossprod(A, B)           # t(A) %*% B
tcrossprod(A, B)          # A %*% t(B)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
identical(dim(A), dim(B))      # Check before adding
ncol(A) == nrow(B)             # Check before multiply
det(A) != 0                    # Check before invert
A[i, , drop = FALSE]           # Preserve structure

# ‚ùå Avoid
A + B                          # Without checking dims
solve(A)                       # Without checking singular
A[i, ]                         # Drops to vector unexpectedly
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Matrix Dimension Checker**

Write a function that checks if two matrices can be:
1. Added/subtracted
2. Multiplied (A %*% B)
3. Multiplied (B %*% A)

Return TRUE/FALSE for each operation.
</div>

<div class="exercise-box">
üìù **Exercise 2: Safe Matrix Operations**

Create `matrix_op(A, B, op)` that:
- Checks dimensions before operation
- Supports: "add", "subtract", "multiply", "divide"
- Gives clear error messages
- Returns result or NULL
</div>

<div class="exercise-box">
üìù **Exercise 3: Matrix Inversion Check**

Write `safe_invert(A)` that:
1. Checks if matrix is square
2. Checks if singular
3. Warns if near-singular
4. Returns inverse or NULL
5. Provides diagnostic information
</div>

<div class="exercise-box">
üìù **Exercise 4: Matrix Creation Helper**

Write `make_matrix(...)` that:
- Takes values and shape (nrow, ncol)
- Handles different input formats (vector, list, data frame)
- Validates dimensions
- Allows byrow specification
- Returns matrix with informative errors
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
check_matrix_ops <- function(A, B) {
  result <- list(
    can_add = identical(dim(A), dim(B)),
    can_multiply_AB = ncol(A) == nrow(B),
    can_multiply_BA = ncol(B) == nrow(A)
  )
  
  # Add details
  result$dim_A <- paste(dim(A), collapse = "√ó")
  result$dim_B <- paste(dim(B), collapse = "√ó")
  
  if (result$can_multiply_AB) {
    result$result_dim_AB <- paste(c(nrow(A), ncol(B)), collapse = "√ó")
  }
  
  if (result$can_multiply_BA) {
    result$result_dim_BA <- paste(c(nrow(B), ncol(A)), collapse = "√ó")
  }
  
  class(result) <- "matrix_ops_check"
  return(result)
}

print.matrix_ops_check <- function(x, ...) {
  cat("Matrix A:", x$dim_A, "\n")
  cat("Matrix B:", x$dim_B, "\n\n")
  cat("Can add/subtract:", x$can_add, "\n")
  cat("Can multiply A %*% B:", x$can_multiply_AB)
  if (x$can_multiply_AB) {
    cat(" (result:", x$result_dim_AB, ")")
  }
  cat("\n")
  cat("Can multiply B %*% A:", x$can_multiply_BA)
  if (x$can_multiply_BA) {
    cat(" (result:", x$result_dim_BA, ")")
  }
  cat("\n")
}

# Test
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)
check_matrix_ops(A, B)
```

**Exercise 2:**

```{r}
matrix_op <- function(A, B, op = c("add", "subtract", "multiply", "divide")) {
  op <- match.arg(op)
  
  # Validate inputs
  if (!is.matrix(A) || !is.matrix(B)) {
    stop("Both A and B must be matrices")
  }
  
  # Check dimensions based on operation
  if (op %in% c("add", "subtract", "divide")) {
    if (!identical(dim(A), dim(B))) {
      stop("For ", op, ", matrices must have same dimensions. ",
           "A is ", paste(dim(A), collapse = "√ó"),
           ", B is ", paste(dim(B), collapse = "√ó"))
    }
    
    result <- switch(op,
      add = A + B,
      subtract = A - B,
      divide = A / B
    )
  } else if (op == "multiply") {
    if (ncol(A) != nrow(B)) {
      stop("For multiplication, ncol(A) must equal nrow(B). ",
           "A is ", paste(dim(A), collapse = "√ó"),
           ", B is ", paste(dim(B), collapse = "√ó"))
    }
    
    result <- A %*% B
  }
  
  return(result)
}

# Test
A <- matrix(1:6, nrow = 2, ncol = 3)
B <- matrix(1:6, nrow = 3, ncol = 2)
matrix_op(A, B, "multiply")
```

**Exercise 3:**

```{r}
safe_invert <- function(A, tol = 1e-10, warn_threshold = 1e-8) {
  # Check if matrix
  if (!is.matrix(A)) {
    message("Input is not a matrix")
    return(NULL)
  }
  
  # Check if square
  if (nrow(A) != ncol(A)) {
    message("Matrix is not square: ", 
            paste(dim(A), collapse = "√ó"))
    return(NULL)
  }
  
  # Calculate determinant
  d <- det(A)
  
  # Check if singular
  if (abs(d) < tol) {
    message("Matrix is singular (det = ", d, ")")
    message("Consider using MASS::ginv() for generalized inverse")
    return(NULL)
  }
  
  # Warn if near-singular
  if (abs(d) < warn_threshold) {
    warning("Matrix is near-singular (det = ", d, "). ",
            "Results may be numerically unstable.")
  }
  
  # Compute inverse
  A_inv <- solve(A)
  
  # Verify (optional)
  check <- A %*% A_inv
  is_identity <- all(abs(check - diag(nrow(A))) < 1e-10)
  
  if (!is_identity) {
    warning("Inversion may be inaccurate (A %*% A^-1 != I)")
  }
  
  # Return with diagnostics
  attr(A_inv, "determinant") <- d
  attr(A_inv, "condition_number") <- kappa(A)
  
  return(A_inv)
}

# Test
A <- matrix(c(1, 2, 3, 4), nrow = 2)
A_inv <- safe_invert(A)
A_inv

# Singular
B <- matrix(c(1, 2, 2, 4), nrow = 2)
safe_invert(B)
```

**Exercise 4:**

```{r}
make_matrix <- function(x, nrow, ncol, byrow = FALSE) {
  # Handle different input types
  if (is.matrix(x)) {
    if (missing(nrow) && missing(ncol)) {
      return(x)
    }
    x <- as.vector(x)
  } else if (is.data.frame(x)) {
    x <- as.matrix(x)
    if (missing(nrow) && missing(ncol)) {
      return(x)
    }
    x <- as.vector(x)
  } else if (is.list(x)) {
    # Check if all elements same length
    lens <- lengths(x)
    if (length(unique(lens)) != 1) {
      stop("List elements have different lengths")
    }
    x <- unlist(x)
  }
  
  # Validate dimensions
  n_elements <- length(x)
  
  if (missing(nrow) && missing(ncol)) {
    stop("Must provide nrow, ncol, or both")
  }
  
  if (missing(nrow)) {
    nrow <- ceiling(n_elements / ncol)
  } else if (missing(ncol)) {
    ncol <- ceiling(n_elements / nrow)
  }
  
  expected_elements <- nrow * ncol
  
  if (n_elements != expected_elements) {
    if (n_elements < expected_elements) {
      warning("Data length (", n_elements, 
              ") is less than matrix size (", expected_elements,
              "). Recycling values.")
    } else {
      warning("Data length (", n_elements,
              ") is greater than matrix size (", expected_elements,
              "). Truncating values.")
      x <- x[1:expected_elements]
    }
  }
  
  # Create matrix
  result <- matrix(x, nrow = nrow, ncol = ncol, byrow = byrow)
  
  return(result)
}

# Test
make_matrix(1:6, nrow = 2, ncol = 3)
make_matrix(1:6, nrow = 2, byrow = TRUE)
make_matrix(list(a = 1:3, b = 4:6), ncol = 3)
```
</details>

<!--chapter:end:11-matrix-operations.Rmd-->

# Part V: Factors {-}

# Factor Creation & Levels {#factor-creation-levels}

<div class="chapter-summary">
**What You'll Learn:**

- What factors are and why they exist
- Creating factors correctly
- Understanding levels and labels
- Ordered vs unordered factors
- Common factor creation pitfalls

**Key Errors Covered:** 15+ factor errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Factors are R's way of representing categorical data, but they're confusing:

```{r error=TRUE}
# This looks like it should work...
grades <- factor(c("A", "B", "C"))
grades[1] <- "D"
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In `[<-.factor`(`*tmp*`, 1, value = "D") :
  invalid factor level, NA generated
```
</div>

```{r}
grades  # First element became NA!
```

Let's understand factors to avoid these surprises.

## What Are Factors?

<div class="insight-box">
üí° **Key Insight: Factors Are Integers in Disguise**

```{r}
# Create a factor
colors <- factor(c("red", "blue", "red", "green"))
colors

# But underneath, it's integers!
typeof(colors)    # "integer"
as.integer(colors)  # 3 1 3 2

# The labels are stored separately
levels(colors)

# Structure revealed
str(colors)
```

**Key points:**
- Factors store data as integers (1, 2, 3, ...)
- Each integer maps to a level (label)
- Levels are stored once, data stores references
- More memory-efficient for repeated values
- Used extensively in statistical modeling

**Why factors exist:**
1. Memory efficiency (repeated strings)
2. Statistical modeling (R knows it's categorical)
3. Ordering (can be ordered or unordered)
4. Validation (only valid levels allowed)
</div>

## Factor vs Character

<div class="insight-box">
üí° **Factor vs Character Comparison**

```{r}
# Character vector
char_vec <- c("red", "blue", "red", "green")
typeof(char_vec)
class(char_vec)

# Factor
fac_vec <- factor(char_vec)
typeof(fac_vec)
class(fac_vec)

# Memory difference (with many repetitions)
x_char <- rep(c("Category A", "Category B"), 10000)
x_fac <- factor(x_char)

object.size(x_char)
object.size(x_fac)  # Much smaller!

# Statistical modeling difference
df <- data.frame(
  group = factor(c("A", "B", "A", "B")),
  value = c(10, 20, 15, 25)
)

# R knows 'group' is categorical
lm(value ~ group, data = df)
```

**When to use each:**
- **Character:** Text data, unique values, will manipulate as strings
- **Factor:** Categories, repeated values, for modeling/plotting
</div>

## Error #1: `invalid factor level, NA generated` {#invalid-factor-level}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r}
sizes <- factor(c("small", "medium", "large"))
sizes[1] <- "extra-large"  # Not in levels!
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In `[<-.factor`(`*tmp*`, 1, value = "extra-large") :
  invalid factor level, NA generated
```
</div>

```{r}
sizes  # Became NA!
```

### What It Means

You're trying to assign a value that's not in the factor's levels. R converts it to NA instead.

### Why This Happens

```{r}
sizes <- factor(c("small", "medium", "large"))

# Only these levels exist
levels(sizes)

# Can only assign existing levels
sizes[1] <- "medium"  # OK
sizes

# New levels not allowed
sizes[2] <- "tiny"    # Warning, becomes NA
sizes
```

### Common Causes

#### Cause 1: Typo in Assignment

```{r}
colors <- factor(c("red", "blue", "green"))
levels(colors)

# Typo: "blu" instead of "blue"
colors[2] <- "blu"
colors  # NA!
```

#### Cause 2: Case Mismatch

```{r}
sizes <- factor(c("small", "medium", "large"))

# Wrong case
sizes[1] <- "Small"  # "Small" != "small"
sizes
```

#### Cause 3: Adding New Categories

```{r}
responses <- factor(c("yes", "no", "yes"))

# Try to add new response
responses[4] <- "maybe"  # "maybe" not in original levels
responses
```

#### Cause 4: Data Merge Issues

```{r}
# Original data
df1 <- data.frame(
  group = factor(c("A", "B", "C"))
)

# New data with different level
df2 <- data.frame(
  group = factor(c("D", "E"))
)

# Combine
combined <- rbind(df1, df2)
combined$group  # D and E became NA!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Add New Level First**

```{r}
sizes <- factor(c("small", "medium", "large"))

# Add new level
levels(sizes) <- c(levels(sizes), "extra-large")
levels(sizes)

# Now assignment works
sizes[1] <- "extra-large"
sizes
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert to Character, Modify, Convert Back**

```{r}
sizes <- factor(c("small", "medium", "large"))

# Convert to character
sizes_char <- as.character(sizes)

# Modify freely
sizes_char[1] <- "extra-large"
sizes_char[4] <- "tiny"

# Convert back to factor
sizes_new <- factor(sizes_char)
sizes_new
levels(sizes_new)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Specify All Levels Upfront**

```{r}
# Specify all possible levels when creating
sizes <- factor(
  c("small", "medium", "large"),
  levels = c("tiny", "small", "medium", "large", "extra-large")
)

levels(sizes)

# Now any level can be assigned
sizes[1] <- "extra-large"
sizes[4] <- "tiny"
sizes
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 4: Use forcats Package (Tidyverse)**

```{r}
library(forcats)

sizes <- factor(c("small", "medium", "large"))

# Add level dynamically
sizes <- fct_expand(sizes, "extra-large", "tiny")
levels(sizes)

sizes[1] <- "extra-large"
sizes
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Silent NA Creation**

```{r}
# Create factor
status <- factor(c("active", "inactive", "active"))

# Update many values
new_values <- c("active", "paused", "inactive")
status <- new_values  # Coerces to character!

class(status)  # Not a factor anymore!

# Or if forcing to stay factor:
status <- factor(c("active", "inactive", "active"))
status[] <- new_values  # "paused" becomes NA silently!
status
```

**Always check for NAs after factor assignment:**
```{r}
if (any(is.na(status))) {
  warning("Some values became NA - check factor levels")
}
```
</div>

## Error #2: `number of levels differs` {#number-levels-differs}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
f1 <- factor(c("a", "b", "c"))
f2 <- factor(c("a", "b"))

c(f1, f2)  # Try to combine
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In c.factor(f1, f2) : number of levels differs
```
</div>

```{r}
# Result loses factor structure
result <- c(f1, f2)
class(result)  # "integer" not "factor"!
```

### What It Means

Combining factors with different levels produces unexpected results.

### The Problem

```{r}
f1 <- factor(c("red", "blue"))
f2 <- factor(c("green", "yellow"))

levels(f1)
levels(f2)

# Combine - loses factor structure!
combined <- c(f1, f2)
combined  # Just integers!
class(combined)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert to Character First**

```{r}
f1 <- factor(c("red", "blue"))
f2 <- factor(c("green", "yellow"))

# Convert both to character
combined <- c(as.character(f1), as.character(f2))
combined

# Convert back to factor
combined <- factor(combined)
combined
levels(combined)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Same Levels for Both**

```{r}
# Define all levels upfront
all_levels <- c("red", "blue", "green", "yellow")

f1 <- factor(c("red", "blue"), levels = all_levels)
f2 <- factor(c("green", "yellow"), levels = all_levels)

# Now same levels
identical(levels(f1), levels(f2))

# Combine works better
combined <- c(f1, f2)
combined <- factor(combined, levels = all_levels)
combined
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use forcats::fct_c()**

```{r}
library(forcats)

f1 <- factor(c("red", "blue"))
f2 <- factor(c("green", "yellow"))

# Smart concatenation
combined <- fct_c(f1, f2)
combined
levels(combined)
```
</div>

## Error #3: `contrasts can be applied only to factors with 2 or more levels` {#contrasts-levels}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-math">üßÆ MATH</span>

### The Error

```{r error=TRUE}
# Factor with only one level
single_level <- factor(c("A", "A", "A", "A"))
levels(single_level)

# Try to use in model
df <- data.frame(
  group = single_level,
  value = c(10, 20, 15, 25)
)

lm(value ~ group, data = df)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `contrasts<-`(`*tmp*`, value = contr.treatment(2)) : 
  contrasts can be applied only to factors with 2 or more levels
```
</div>

### What It Means

Statistical models need at least 2 levels to compare. A single-level factor can't be used as a predictor.

### Common Causes

#### Cause 1: Accidental Filtering

```{r error=TRUE}
df <- data.frame(
  treatment = factor(c("A", "B", "A", "B", "C")),
  outcome = rnorm(5)
)

# Filter to subset
df_filtered <- df[df$treatment == "A", ]
df_filtered$treatment  # Still a factor, but only one level used

# Try to model
lm(outcome ~ treatment, data = df_filtered)
```

#### Cause 2: Data Preparation Gone Wrong

```{r error=TRUE}
# Read data
responses <- factor(c("yes", "no", "maybe", "yes"))

# Remove certain responses
clean_responses <- responses[responses != "no" & responses != "maybe"]
clean_responses  # Only "yes" left

df <- data.frame(
  response = clean_responses,
  score = c(80, 90)
)

lm(score ~ response, data = df)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Drop Unused Levels**

```{r}
df <- data.frame(
  treatment = factor(c("A", "B", "A", "B", "C")),
  outcome = rnorm(5)
)

# Filter
df_filtered <- df[df$treatment == "A", ]

# Drop unused levels
df_filtered$treatment <- droplevels(df_filtered$treatment)
levels(df_filtered$treatment)  # Only "A" now

# Model will error (only 1 level)
# But at least levels match reality
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Before Modeling**

```{r}
check_factor_for_modeling <- function(f) {
  # Check if factor
  if (!is.factor(f)) {
    stop("Input is not a factor")
  }
  
  # Count levels with data
  level_counts <- table(f)
  levels_with_data <- sum(level_counts > 0)
  
  if (levels_with_data < 2) {
    stop("Factor has only ", levels_with_data, 
         " level(s) with data. Need at least 2 for modeling.")
  }
  
  # Check for unused levels
  if (nlevels(f) > levels_with_data) {
    message("Factor has ", nlevels(f) - levels_with_data, 
            " unused level(s). Consider droplevels().")
  }
  
  return(TRUE)
}

# Test
single <- factor(c("A", "A"))
```

```{r error=TRUE}
check_factor_for_modeling(single)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Convert to Character If Needed**

```{r}
df <- data.frame(
  treatment = factor(c("A", "B", "A", "B", "C")),
  outcome = rnorm(5)
)

df_filtered <- df[df$treatment == "A", ]

# If you don't need it as a factor, convert
df_filtered$treatment <- as.character(df_filtered$treatment)

# Or remove from model
lm(outcome ~ 1, data = df_filtered)  # Intercept-only model
```
</div>

## Creating Factors Correctly

<div class="bestpractice-box">
üéØ **Best Practice: Factor Creation**

```{r}
# Method 1: Basic factor
sizes <- factor(c("S", "M", "L", "M", "S"))
sizes

# Method 2: Specify levels explicitly
sizes <- factor(
  c("S", "M", "L"),
  levels = c("XS", "S", "M", "L", "XL")
)
sizes
levels(sizes)  # All levels present

# Method 3: With labels (different from levels)
sizes <- factor(
  c(1, 2, 3, 2, 1),
  levels = 1:5,
  labels = c("XS", "S", "M", "L", "XL")
)
sizes

# Method 4: Ordered factor
sizes <- factor(
  c("S", "M", "L", "M", "S"),
  levels = c("XS", "S", "M", "L", "XL"),
  ordered = TRUE
)
sizes
class(sizes)  # "ordered" "factor"

# Can now compare
sizes[1] < sizes[3]  # TRUE (S < L)

# Method 5: From numeric
ages_binned <- cut(
  c(15, 25, 35, 45, 55),
  breaks = c(0, 18, 30, 50, 100),
  labels = c("Youth", "Young Adult", "Middle Age", "Senior")
)
ages_binned
```
</div>

## Levels vs Labels

<div class="insight-box">
üí° **Key Insight: Levels vs Labels**

```{r}
# Levels: What you have in the data
# Labels: What you want to display

# Example: Survey responses coded as numbers
responses <- c(1, 2, 3, 2, 1, 3)

# Wrong: Just convert to factor
bad <- factor(responses)
bad  # Shows 1, 2, 3

# Right: Provide labels
good <- factor(
  responses,
  levels = 1:3,
  labels = c("Disagree", "Neutral", "Agree")
)
good  # Shows actual meanings

# The underlying data is still integers
as.integer(good)

# But displays with labels
print(good)
levels(good)
```

**Key difference:**
- **levels**: Values in your data (what it IS)
- **labels**: Display names (what you WANT TO SHOW)
</div>

## Ordered Factors

<div class="insight-box">
üí° **Ordered vs Unordered Factors**

```{r}
# Unordered (nominal)
colors <- factor(c("red", "blue", "green"))
colors
class(colors)

# Can't compare
colors[1] < colors[2]  # Not meaningful

# Ordered (ordinal)
sizes <- ordered(c("S", "M", "L", "M", "S"),
                levels = c("S", "M", "L"))
sizes
class(sizes)

# Can compare
sizes[1] < sizes[3]  # TRUE

# Or use factor with ordered = TRUE
grades <- factor(
  c("B", "A", "C", "A"),
  levels = c("F", "D", "C", "B", "A"),
  ordered = TRUE
)
grades
grades[1] < grades[2]  # TRUE (B < A)
```

**When to use ordered:**
- Size (S < M < L)
- Grade (F < D < C < B < A)
- Likert scales (Strongly Disagree < ... < Strongly Agree)
- Any natural ordering

**When NOT to use ordered:**
- Colors (no natural order)
- Categories (no natural order)
- Nominal data
</div>

## Checking and Modifying Levels

<div class="bestpractice-box">
üéØ **Best Practice: Working with Levels**

```{r}
sizes <- factor(c("S", "M", "L", "M", "S"))

# Check levels
levels(sizes)
nlevels(sizes)

# Check for specific level
"XL" %in% levels(sizes)

# Add levels
levels(sizes) <- c(levels(sizes), "XS", "XL")
levels(sizes)

# Rename levels
sizes <- factor(c("S", "M", "L"))
levels(sizes) <- c("Small", "Medium", "Large")
sizes

# Reorder levels
sizes <- factor(c("L", "S", "M"))
sizes <- factor(sizes, levels = c("S", "M", "L"))
sizes

# Drop unused levels
sizes <- factor(c("S", "M", "L"), levels = c("XS", "S", "M", "L", "XL"))
levels(sizes)  # All 5 levels

sizes <- sizes[sizes != "L"]  # Remove L observations
levels(sizes)  # Still shows L!

sizes <- droplevels(sizes)
levels(sizes)  # Now only S and M

# Collapse levels
sizes <- factor(c("XS", "S", "M", "L", "XL"))
sizes_collapsed <- fct_collapse(sizes,
  Small = c("XS", "S"),
  Medium = "M",
  Large = c("L", "XL")
)
sizes_collapsed
```
</div>

## Common Factor Mistakes

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall 1: Converting Factor to Numeric**

```{r}
# Factor with numeric-looking levels
scores <- factor(c("90", "85", "95", "88"))
scores

# WRONG: Direct conversion
as.numeric(scores)  # Gives 4 2 5 3 (factor codes!)

# RIGHT: Convert through character
as.numeric(as.character(scores))  # 90 85 95 88

# Or use levels
as.numeric(levels(scores))[scores]  # 90 85 95 88
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall 2: Unexpected Coercion**

```{r}
# Combining factor and character
fac <- factor(c("a", "b"))
char <- c("c", "d")

combined <- c(fac, char)
class(combined)  # "character" (lost factor)
combined

# Arithmetic with factors
fac <- factor(c("1", "2", "3"))
```

```{r error=TRUE}
fac + 10  # Error!
```

```{r}
# Convert first
as.numeric(as.character(fac)) + 10
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall 3: Factor Subsetting Keeps All Levels**

```{r}
sizes <- factor(c("S", "M", "L", "XL"))
levels(sizes)

# Subset to only S and M
sizes_small <- sizes[sizes %in% c("S", "M")]
sizes_small

# But levels still show L and XL!
levels(sizes_small)

# Drop unused levels
sizes_small <- droplevels(sizes_small)
levels(sizes_small)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Factors are integers with labels** - Understanding this prevents confusion
2. **Can only assign existing levels** - Add level first or convert to character
3. **Combining factors is tricky** - Use forcats or convert to character
4. **Drop unused levels** after subsetting with `droplevels()`
5. **Specify levels explicitly** when creating factors
6. **Ordered factors** for data with natural ordering
7. **Convert through character** when converting factor to numeric

**Quick Reference:**

| Error/Warning | Cause | Fix |
|---------------|-------|-----|
| invalid factor level, NA | Assigning non-existent level | Add level first or use character |
| number of levels differs | Combining different factors | Use fct_c() or same levels |
| contrasts need 2+ levels | Single-level factor in model | Check levels before modeling |
| Wrong numeric conversion | as.numeric(factor) | as.numeric(as.character(factor)) |

**Factor Operations:**

```{r eval=FALSE}
# Creation
factor(x)
factor(x, levels = ...)
factor(x, levels = ..., labels = ...)
ordered(x, levels = ...)

# Inspection
levels(f)
nlevels(f)
is.factor(f)
is.ordered(f)

# Modification
levels(f) <- new_levels
f <- droplevels(f)
f <- factor(f, levels = new_order)

# Conversion
as.character(f)
as.numeric(as.character(f))  # If numeric-like
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
factor(x, levels = all_possible_levels)  # Explicit levels
as.character(f) %>% modify() %>% factor() # Modify as character
droplevels(f)                             # After subsetting
fct_c(f1, f2)                            # Combine factors

# ‚ùå Avoid
as.numeric(factor_with_numbers)          # Wrong conversion
c(factor1, factor2)                      # Loses factor structure
factor(x)                                # Without explicit levels
f[f %in% subset] without droplevels()    # Unused levels remain
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Factor Conversion**

You have:
```{r eval=FALSE}
scores <- factor(c("85", "90", "95", "88", "92"))
```

1. Convert to proper numeric values
2. Bin into letter grades (A: 90-100, B: 80-89, etc.)
3. Create ordered factor of letter grades
</div>

<div class="exercise-box">
üìù **Exercise 2: Combining Factors**

You have survey data from two sources:
```{r eval=FALSE}
survey1 <- factor(c("Agree", "Disagree", "Neutral"))
survey2 <- factor(c("Strongly Agree", "Agree", "Disagree"))
```

Combine them into one factor with all response levels.
</div>

<div class="exercise-box">
üìù **Exercise 3: Factor Validation**

Write `validate_factor(f)` that checks:
1. If input is a factor
2. If it has at least 2 levels
3. If it has unused levels
4. Returns report of issues found
</div>

<div class="exercise-box">
üìù **Exercise 4: Safe Factor Assignment**

Write `safe_assign_level(f, index, value)` that:
1. Checks if value is in levels
2. Adds level if not present
3. Assigns the value
4. Returns modified factor
5. Warns about any changes made
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
scores <- factor(c("85", "90", "95", "88", "92"))

# 1. Convert to numeric
scores_num <- as.numeric(as.character(scores))
scores_num

# 2. Bin into letter grades
letter_grades <- cut(
  scores_num,
  breaks = c(0, 60, 70, 80, 90, 100),
  labels = c("F", "D", "C", "B", "A"),
  include.lowest = TRUE
)
letter_grades

# 3. Create ordered factor
letter_grades_ordered <- ordered(
  letter_grades,
  levels = c("F", "D", "C", "B", "A")
)
letter_grades_ordered

# Can now compare
letter_grades_ordered[1] < letter_grades_ordered[3]
```

**Exercise 2:**

```{r}
library(forcats)

survey1 <- factor(c("Agree", "Disagree", "Neutral"))
survey2 <- factor(c("Strongly Agree", "Agree", "Disagree"))

# Define all possible levels
all_levels <- c("Strongly Disagree", "Disagree", "Neutral", 
                "Agree", "Strongly Agree")

# Recreate with same levels
survey1 <- factor(survey1, levels = all_levels)
survey2 <- factor(survey2, levels = all_levels)

# Combine
combined <- fct_c(survey1, survey2)
combined
levels(combined)

# Alternative: convert to character first
survey1 <- factor(c("Agree", "Disagree", "Neutral"))
survey2 <- factor(c("Strongly Agree", "Agree", "Disagree"))

combined <- c(as.character(survey1), as.character(survey2))
combined <- factor(combined, levels = all_levels)
combined
```

**Exercise 3:**

```{r}
validate_factor <- function(f) {
  issues <- list()
  
  # Check if factor
  if (!is.factor(f)) {
    issues$not_factor <- paste("Input is", class(f)[1], "not factor")
    return(issues)
  }
  
  # Check number of levels
  n_levels <- nlevels(f)
  if (n_levels < 2) {
    issues$too_few_levels <- paste("Only", n_levels, "level(s). Need at least 2 for most analyses.")
  }
  
  # Check for unused levels
  used_levels <- unique(as.character(f))
  all_levels <- levels(f)
  unused <- setdiff(all_levels, used_levels)
  
  if (length(unused) > 0) {
    issues$unused_levels <- paste("Unused levels:", 
                                  paste(unused, collapse = ", "))
  }
  
  # Report
  if (length(issues) == 0) {
    message("‚úì Factor validation passed")
    return(invisible(NULL))
  } else {
    message("Factor validation issues found:")
    for (name in names(issues)) {
      message("  - ", issues[[name]])
    }
    return(invisible(issues))
  }
}

# Test
good <- factor(c("A", "B", "A", "B"))
validate_factor(good)

bad <- factor(c("A", "A", "A"), levels = c("A", "B", "C"))
validate_factor(bad)
```

**Exercise 4:**

```{r}
safe_assign_level <- function(f, index, value) {
  # Validate input
  if (!is.factor(f)) {
    stop("Input must be a factor")
  }
  
  if (index < 1 || index > length(f)) {
    stop("Index out of bounds")
  }
  
  # Check if value is in levels
  if (!value %in% levels(f)) {
    message("Adding new level: '", value, "'")
    levels(f) <- c(levels(f), value)
  }
  
  # Assign
  old_value <- as.character(f[index])
  f[index] <- value
  
  if (old_value != value) {
    message("Changed position ", index, " from '", old_value, 
            "' to '", value, "'")
  }
  
  return(f)
}

# Test
sizes <- factor(c("S", "M", "L"))

# Existing level
sizes <- safe_assign_level(sizes, 1, "M")
sizes

# New level
sizes <- safe_assign_level(sizes, 2, "XL")
sizes
levels(sizes)
```
</details>

<!--chapter:end:12-factor-creation-levels.Rmd-->

# Factor Operations {#factor-operations}

<div class="chapter-summary">
**What You'll Learn:**

- Recoding and relabeling factors
- Grouping and collapsing levels
- Reordering factors
- Factor arithmetic issues
- Common factor operation errors

**Key Errors Covered:** 10+ factor operation errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Working with existing factors requires care:

```{r error=TRUE}
grades <- factor(c("A", "B", "C", "B", "A"))
grades > "B"  # Try to compare
```

<div class="error-box">
üî¥ **ERROR**

```
Error in Ops.factor(grades, "B") : 
  level sets of factors are different
```
</div>

Let's master factor operations to avoid these errors.

## Recoding Factors

<div class="insight-box">
üí° **Key Insight: Recoding Strategies**

```{r}
# Original factor
responses <- factor(c("Y", "N", "Y", "N", "M"))
responses

# Method 1: Relabel levels directly
responses_v1 <- responses
levels(responses_v1) <- c("Maybe", "No", "Yes")  # Alphabetical order!
responses_v1

# Method 2: Create mapping
library(forcats)
responses_v2 <- fct_recode(responses,
  "Yes" = "Y",
  "No" = "N",
  "Maybe" = "M"
)
responses_v2

# Method 3: Convert to character, recode, factor
responses_v3 <- as.character(responses)
responses_v3[responses_v3 == "Y"] <- "Yes"
responses_v3[responses_v3 == "N"] <- "No"
responses_v3[responses_v3 == "M"] <- "Maybe"
responses_v3 <- factor(responses_v3)
responses_v3

# Method 4: Use named vector mapping
recode_map <- c(Y = "Yes", N = "No", M = "Maybe")
responses_v4 <- factor(recode_map[as.character(responses)])
responses_v4
```
</div>

## Error #1: `level sets of factors are different` {#level-sets-different}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
sizes1 <- factor(c("S", "M", "L"))
sizes2 <- factor(c("M", "L", "XL"))

sizes1 == sizes2
```

<div class="error-box">
üî¥ **ERROR**

```
Error in Ops.factor(sizes1, sizes2) : 
  level sets of factors are different
```
</div>

### What It Means

You're comparing factors with different level sets. R doesn't know how to match them.

### Common Causes

#### Cause 1: Comparing Different Factors

```{r error=TRUE}
color1 <- factor(c("red", "blue"))
color2 <- factor(c("green", "yellow"))

color1 == color2  # Different levels!
```

#### Cause 2: After Subsetting

```{r error=TRUE}
all_sizes <- factor(c("S", "M", "L", "XL"))

# Different subsets
small_sizes <- all_sizes[1:2]
large_sizes <- all_sizes[3:4]

# Both still have all levels
levels(small_sizes)
levels(large_sizes)

# But after droplevels...
small_sizes <- droplevels(small_sizes)
large_sizes <- droplevels(large_sizes)

levels(small_sizes)  # S, M
levels(large_sizes)  # L, XL

# Now can't compare
small_sizes[1] == large_sizes[1]
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert to Character**

```{r}
sizes1 <- factor(c("S", "M", "L"))
sizes2 <- factor(c("M", "L", "XL"))

# Compare as characters
as.character(sizes1) == as.character(sizes2)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Unify Levels**

```{r}
sizes1 <- factor(c("S", "M", "L"))
sizes2 <- factor(c("M", "L", "XL"))

# Find all unique levels
all_levels <- union(levels(sizes1), levels(sizes2))
all_levels

# Recreate with same levels
sizes1 <- factor(sizes1, levels = all_levels)
sizes2 <- factor(sizes2, levels = all_levels)

# Now can compare
sizes1 == sizes2
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use %in% Instead**

```{r}
sizes1 <- factor(c("S", "M", "L"))
sizes2 <- factor(c("M", "L", "XL"))

# Check membership
as.character(sizes1) %in% as.character(sizes2)
```
</div>

## Error #2: `NAs produced` in factor operations {#factor-nas-produced}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Warning

```{r}
sizes <- factor(c("S", "M", "L"))
levels(sizes) <- c("Small", "Large")  # Only 2 new names for 3 levels!
```

<div class="warning-box">
üü° **WARNING**

```
Warning message:
In `levels<-.factor`(`*tmp*`, value = c("Small", "Large")) :
  longer object length is not a multiple of replacement length
```
</div>

```{r}
sizes  # What happened?
```

### What It Means

When recoding, if you don't provide the right number of new level names, unexpected things happen.

### The Problem

```{r}
# Original
sizes <- factor(c("S", "M", "L", "XL"))
levels(sizes)

# Try to simplify to 2 categories
levels(sizes) <- c("Small", "Large")
sizes  # Recycled! Not what we wanted
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Provide All New Names**

```{r}
sizes <- factor(c("S", "M", "L", "XL"))

# All four mappings
levels(sizes) <- c("Small", "Medium", "Large", "Extra Large")
sizes
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use fct_collapse() for Grouping**

```{r}
library(forcats)

sizes <- factor(c("S", "M", "L", "XL"))

# Collapse into groups
sizes_collapsed <- fct_collapse(sizes,
  Small = c("S", "M"),
  Large = c("L", "XL")
)
sizes_collapsed
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use fct_recode() for Precise Mapping**

```{r}
sizes <- factor(c("S", "M", "L", "XL"))

# Explicit recoding
sizes_recoded <- fct_recode(sizes,
  "Small" = "S",
  "Small" = "M",    # Map M to Small too
  "Large" = "L",
  "Large" = "XL"
)
sizes_recoded
```
</div>

## Collapsing Factor Levels

<div class="bestpractice-box">
üéØ **Best Practice: Grouping Levels**

```{r}
library(forcats)

# Original detailed categories
age_groups <- factor(c("0-10", "11-20", "21-30", "31-40", 
                      "41-50", "51-60", "61-70", "71+"))

# Method 1: fct_collapse (explicit groups)
age_collapsed <- fct_collapse(age_groups,
  Youth = c("0-10", "11-20"),
  Adult = c("21-30", "31-40", "41-50"),
  Senior = c("51-60", "61-70", "71+")
)
age_collapsed

# Method 2: fct_other (keep some, lump rest)
top_ages <- fct_other(age_groups,
  keep = c("21-30", "31-40", "41-50"),
  other_level = "Other"
)
top_ages

# Method 3: fct_lump (keep n most frequent)
responses <- factor(c("A", "A", "A", "B", "B", "C", "D", "E"))
lumped <- fct_lump(responses, n = 2)  # Keep top 2
lumped

# Method 4: fct_lump_min (minimum count)
lumped_min <- fct_lump_min(responses, min = 2)  # Keep if appears 2+ times
lumped_min
```
</div>

## Reordering Factors

<div class="insight-box">
üí° **Key Insight: Factor Ordering**

```{r}
library(forcats)

# Original (alphabetical by default)
grades <- factor(c("B", "A", "C", "A", "B"))
grades
levels(grades)

# Method 1: Specify order explicitly
grades <- factor(grades, levels = c("C", "B", "A"))
levels(grades)

# Method 2: By frequency
grades <- fct_infreq(grades)
levels(grades)  # Most common first

# Method 3: By another variable
df <- data.frame(
  name = c("Alice", "Bob", "Charlie"),
  score = c(95, 85, 90)
)
df$name <- factor(df$name)

# Order by score
df$name <- fct_reorder(df$name, df$score)
levels(df$name)  # Ordered by score

# Method 4: Reverse order
grades <- fct_rev(grades)
levels(grades)

# Method 5: Manual reordering
grades <- fct_relevel(grades, "A", "B", "C")
levels(grades)
```
</div>

## Error #3: `'ordered' must be a factor` {#ordered-must-be-factor}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
sizes <- c("S", "M", "L")  # Character vector
ordered(sizes)  # Try to make ordered
```

<div class="error-box">
üî¥ **ERROR**

```
Error in ordered(sizes) : argument is not a factor
```
</div>

### What It Means

The `ordered()` function requires a factor, not a character vector.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert to Factor First**

```{r}
sizes <- c("S", "M", "L")

# Option A: Two steps
sizes_fac <- factor(sizes)
sizes_ord <- ordered(sizes_fac, levels = c("S", "M", "L"))
sizes_ord

# Option B: Direct with levels
sizes_ord <- ordered(sizes, levels = c("S", "M", "L"))
sizes_ord
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use factor() with ordered = TRUE**

```{r}
sizes <- c("S", "M", "L")

# Directly to ordered factor
sizes_ord <- factor(sizes, levels = c("S", "M", "L"), ordered = TRUE)
sizes_ord
class(sizes_ord)
```
</div>

## Factor Arithmetic Errors

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall: You Can't Do Math on Factors**

```{r error=TRUE}
# Numeric-looking factor
numbers <- factor(c("1", "2", "3", "4", "5"))

# Try arithmetic
numbers + 10
numbers * 2
mean(numbers)
```

**Why:** Factors are categorical, not numeric, even if they look like numbers.

**Solution:**
```{r}
# Convert first
numbers_numeric <- as.numeric(as.character(numbers))
numbers_numeric + 10
mean(numbers_numeric)
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall: Factor Comparison Limitations**

```{r}
# Unordered factors can only check equality
colors <- factor(c("red", "blue", "green"))
colors[1] == colors[2]  # OK
```

```{r error=TRUE}
colors[1] < colors[2]   # Error!
```

```{r}
# Ordered factors can be compared
sizes <- ordered(c("S", "M", "L"), levels = c("S", "M", "L"))
sizes[1] < sizes[3]     # OK
```
</div>

## Useful forcats Functions

<div class="bestpractice-box">
üéØ **Best Practice: forcats Toolkit**

```{r}
library(forcats)

# Sample data
responses <- factor(c("Good", "Bad", "Good", "Excellent", "Bad", 
                     "Good", "Fair", "Excellent"))

# 1. Count levels
fct_count(responses)

# 2. Reorder by frequency
responses_freq <- fct_infreq(responses)
levels(responses_freq)

# 3. Reverse order
responses_rev <- fct_rev(responses_freq)
levels(responses_rev)

# 4. Recode specific levels
responses_clean <- fct_recode(responses,
  "Very Good" = "Excellent",
  "Not Good" = "Bad"
)
levels(responses_clean)

# 5. Lump rare levels
responses_lumped <- fct_lump(responses, n = 2, other_level = "Other")
table(responses_lumped)

# 6. Add new levels
responses_expanded <- fct_expand(responses, "Outstanding")
levels(responses_expanded)

# 7. Drop unused levels
sub <- responses[responses %in% c("Good", "Bad")]
levels(sub)  # Still has all levels
sub <- fct_drop(sub)
levels(sub)  # Only Good and Bad

# 8. Explicit ordering
responses_ordered <- fct_relevel(responses, 
  "Bad", "Fair", "Good", "Excellent")
levels(responses_ordered)
```
</div>

## Factor in Data Frames

<div class="insight-box">
üí° **Key Insight: Factors in Data Analysis**

```{r}
library(dplyr)

# Sample data
df <- data.frame(
  category = factor(c("A", "B", "A", "C", "B", "A")),
  value = c(10, 20, 15, 25, 22, 18)
)

# Factors work well with grouping
df %>%
  group_by(category) %>%
  summarise(mean_value = mean(value))

# But watch out for unused levels after filtering
df_filtered <- df %>%
  filter(category != "C")

levels(df_filtered$category)  # C still there!

# Drop unused
df_filtered <- df_filtered %>%
  mutate(category = droplevels(category))

levels(df_filtered$category)  # Now just A and B

# Or use forcats
df_filtered <- df %>%
  filter(category != "C") %>%
  mutate(category = fct_drop(category))
```
</div>

## Converting Between Types

<div class="bestpractice-box">
üéØ **Best Practice: Type Conversions**

```{r}
# Factor to character
f <- factor(c("a", "b", "c"))
as.character(f)

# Factor to numeric (for numeric-looking factors)
f_num <- factor(c("10", "20", "30"))
as.numeric(as.character(f_num))  # Correct
# NOT: as.numeric(f_num)  # Wrong! Gives 1, 2, 3

# Character to factor
ch <- c("x", "y", "z")
factor(ch)

# Numeric to factor (with labels)
nums <- c(1, 2, 3, 2, 1)
factor(nums, levels = 1:3, labels = c("Low", "Medium", "High"))

# Ordered to unordered
ord <- ordered(c("S", "M", "L"), levels = c("S", "M", "L"))
factor(ord, ordered = FALSE)

# Unordered to ordered
unord <- factor(c("S", "M", "L"))
ordered(unord, levels = c("S", "M", "L"))
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Can't compare factors with different levels** - Unify first or convert to character
2. **Recoding requires all levels** - Use fct_recode() or fct_collapse()
3. **Can't do arithmetic on factors** - Convert to numeric first
4. **Unordered factors can't use < >** - Use ordered() for ordinal data
5. **droplevels() after subsetting** - Remove unused levels
6. **forcats makes factor work easier** - Use it!
7. **Convert through character** when going to numeric

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| level sets are different | Comparing different factors | Unify levels or convert |
| NAs produced | Wrong number of level names | Use fct_recode() or provide all names |
| 'ordered' must be a factor | Using ordered() on character | Convert to factor first |
| Can't do arithmetic | Math on factor | Convert to numeric |
| Can't use < > | Unordered factor comparison | Make ordered or use character |

**forcats Essential Functions:**

```{r eval=FALSE}
# Reordering
fct_infreq()      # By frequency
fct_reorder()     # By another variable
fct_relevel()     # Manually
fct_rev()         # Reverse

# Recoding
fct_recode()      # Explicit mapping
fct_collapse()    # Group levels
fct_lump()        # Combine rare levels

# Utilities
fct_count()       # Count levels
fct_drop()        # Drop unused
fct_expand()      # Add levels
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
as.numeric(as.character(f))       # Factor to numeric
fct_recode(f, "new" = "old")     # Explicit recoding
fct_drop(f)                       # After subsetting
ordered(f, levels = c(...))       # For ordinal data

# ‚ùå Avoid
as.numeric(f)                     # Wrong conversion
levels(f) <- too_few_names        # Will recycle
f1 == f2                          # Without checking levels
factor(x) without levels          # Implicit ordering
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Factor Recoding**

You have:
```{r eval=FALSE}
grades <- factor(c("A+", "A", "A-", "B+", "B", "B-", "C+", "C"))
```

1. Collapse to simple letter grades (A, B, C)
2. Convert to ordered factor
3. Create numeric scale (A=4, B=3, C=2)
</div>

<div class="exercise-box">
üìù **Exercise 2: Survey Data Cleaning**

You have messy survey responses:
```{r eval=FALSE}
responses <- factor(c("yes", "Yes", "YES", "no", "No", "NO", 
                     "maybe", "Maybe"))
```

Standardize all to lowercase and create ordered factor:
Disagree < Maybe < Agree
</div>

<div class="exercise-box">
üìù **Exercise 3: Factor Comparison**

Write `safe_compare(f1, f2, op)` that:
1. Checks if factors can be compared
2. Unifies levels if needed
3. Performs comparison
4. Returns result with warnings
</div>

<div class="exercise-box">
üìù **Exercise 4: Factor Summary**

Write `factor_summary(f)` that reports:
1. Number of levels
2. Most/least common levels
3. Any unused levels
4. Whether it's ordered
5. Suggested recoding (if many levels)
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
library(forcats)

grades <- factor(c("A+", "A", "A-", "B+", "B", "B-", "C+", "C"))

# 1. Collapse to letter grades
grades_simple <- fct_collapse(grades,
  A = c("A+", "A", "A-"),
  B = c("B+", "B", "B-"),
  C = c("C+", "C")
)
grades_simple

# 2. Convert to ordered
grades_ordered <- ordered(grades_simple, levels = c("C", "B", "A"))
grades_ordered

# 3. Numeric scale
grade_to_numeric <- c(A = 4, B = 3, C = 2)
grades_numeric <- grade_to_numeric[as.character(grades_simple)]
grades_numeric
```

**Exercise 2:**

```{r}
responses <- factor(c("yes", "Yes", "YES", "no", "No", "NO", 
                     "maybe", "Maybe"))

# Standardize to lowercase
responses_clean <- tolower(as.character(responses))

# Map to agreement scale
responses_clean[responses_clean == "yes"] <- "Agree"
responses_clean[responses_clean == "no"] <- "Disagree"
responses_clean[responses_clean == "maybe"] <- "Maybe"

# Create ordered factor
responses_ordered <- ordered(
  responses_clean,
  levels = c("Disagree", "Maybe", "Agree")
)
responses_ordered
```

**Exercise 3:**

```{r}
safe_compare <- function(f1, f2, op = c("==", "!=", "<", ">", "<=", ">=")) {
  op <- match.arg(op)
  
  # Check if both are factors
  if (!is.factor(f1) || !is.factor(f2)) {
    stop("Both inputs must be factors")
  }
  
  # Check length
  if (length(f1) != length(f2)) {
    warning("Factors have different lengths: ", 
            length(f1), " vs ", length(f2))
  }
  
  # Check if levels match
  if (!identical(levels(f1), levels(f2))) {
    message("Factors have different levels. Unifying...")
    
    # Unify levels
    all_levels <- union(levels(f1), levels(f2))
    f1 <- factor(f1, levels = all_levels)
    f2 <- factor(f2, levels = all_levels)
  }
  
  # Check if ordered (for < > <= >=)
  if (op %in% c("<", ">", "<=", ">=")) {
    if (!is.ordered(f1) || !is.ordered(f2)) {
      warning("Using ordering operators on unordered factors. ",
              "Converting to ordered.")
      f1 <- ordered(f1, levels = levels(f1))
      f2 <- ordered(f2, levels = levels(f2))
    }
  }
  
  # Perform comparison
  result <- switch(op,
    "==" = f1 == f2,
    "!=" = f1 != f2,
    "<"  = f1 < f2,
    ">"  = f1 > f2,
    "<=" = f1 <= f2,
    ">=" = f1 >= f2
  )
  
  return(result)
}

# Test
f1 <- factor(c("A", "B", "C"))
f2 <- factor(c("B", "C", "D"))
safe_compare(f1, f2, "==")
```

**Exercise 4:**

```{r}
factor_summary <- function(f) {
  if (!is.factor(f)) {
    stop("Input must be a factor")
  }
  
  # Basic info
  cat("Factor Summary\n")
  cat("==============\n\n")
  
  cat("Type:", if(is.ordered(f)) "Ordered" else "Unordered", "\n")
  cat("Number of levels:", nlevels(f), "\n")
  cat("Number of observations:", length(f), "\n\n")
  
  # Level counts
  level_counts <- table(f)
  cat("Level frequencies:\n")
  print(sort(level_counts, decreasing = TRUE))
  cat("\n")
  
  # Most/least common
  cat("Most common:", names(which.max(level_counts)), 
      "(", max(level_counts), "times)\n")
  cat("Least common:", names(which.min(level_counts)), 
      "(", min(level_counts), "times)\n\n")
  
  # Unused levels
  used_levels <- levels(f)[levels(f) %in% as.character(f)]
  unused_levels <- setdiff(levels(f), used_levels)
  
  if (length(unused_levels) > 0) {
    cat("‚ö† Unused levels:", paste(unused_levels, collapse = ", "), "\n")
    cat("  Consider using droplevels()\n\n")
  }
  
  # Suggestions
  if (nlevels(f) > 10) {
    cat("üí° Suggestion: Factor has", nlevels(f), "levels.\n")
    cat("   Consider grouping rare levels with fct_lump()\n")
    
    # Find rare levels (< 5% of data)
    rare <- level_counts < (0.05 * length(f))
    if (any(rare)) {
      cat("   Rare levels:", paste(names(level_counts)[rare], collapse = ", "), "\n")
    }
  }
  
  invisible(list(
    n_levels = nlevels(f),
    counts = level_counts,
    unused = unused_levels
  ))
}

# Test
grades <- factor(c("A", "B", "A", "C", "B", "A"), 
                levels = c("A", "B", "C", "D", "F"))
factor_summary(grades)
```
</details>

<!--chapter:end:13-factor-operations.Rmd-->

# Part VI: Strings & Characters {-}

# String Basics & Common Errors {#string-basics}

<div class="chapter-summary">
**What You'll Learn:**

- Character vectors vs strings
- String creation and encoding
- Common string errors
- Quotes and escaping
- String conversion issues

**Key Errors Covered:** 15+ string errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Strings in R seem simple but have surprising complexity:

```{r error=TRUE}
text <- "He said "Hello""  # Try to include quotes
```

<div class="error-box">
üî¥ **ERROR**

```
Error: unexpected symbol in "text <- "He said "Hello"
```
</div>

Let's master string handling to avoid these pitfalls.

## String Basics

<div class="insight-box">
üí° **Key Insight: No String Type in R**

R doesn't have a separate "string" type:

```{r}
# What you think of as a "string"
text <- "hello"
typeof(text)      # "character"
class(text)       # "character"

# It's a character vector of length 1
length(text)      # 1 (one element)
nchar(text)       # 5 (five characters)

# Multiple strings
texts <- c("hello", "world")
typeof(texts)     # Still "character"
length(texts)     # 2 (two elements)
nchar(texts)      # 5 5 (characters in each)
```

**Key points:**
- R has "character vectors", not "strings"
- A "string" is a character vector of length 1
- `length()` = number of elements
- `nchar()` = number of characters in each element
</div>

## Error #1: `unexpected symbol` (quote issues) {#unexpected-symbol-quotes}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
text <- "She said "yes""
```

<div class="error-box">
üî¥ **ERROR**

```
Error: unexpected symbol in "text <- "She said "yes"
```
</div>

### What It Means

You're trying to include quotes inside a quoted string without escaping them.

### The Problem

```{r error=TRUE}
# Double quotes inside double quotes
message <- "He said "Hello""

# Single quotes inside single quotes
message <- 'It's nice'
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use Different Quotes**

```{r}
# Use single quotes outside, double inside
message <- 'He said "Hello"'
message

# Or vice versa
message <- "It's nice"
message
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Escape Quotes**

```{r}
# Escape with backslash
message <- "He said \"Hello\""
message

# When printed, quotes show
cat(message)

# Single quote escaping
message <- 'It\'s nice'
cat(message)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Raw Strings (R 4.0+)**

```{r}
# Raw strings (if available in your R version)
if (getRversion() >= "4.0.0") {
  message <- r"(He said "Hello" and she said 'Hi')"
  cat(message)
}
```
</div>

## Escape Sequences

<div class="insight-box">
üí° **Key Insight: Common Escape Sequences**

```{r}
# Newline
cat("Line 1\nLine 2")

# Tab
cat("Col1\tCol2\tCol3")

# Backslash itself
cat("Path: C:\\Users\\Documents")

# Quotes
cat("He said \"Hello\"")
cat('It\'s working')

# Carriage return
cat("Part 1\rPart 2")  # Overwrites

# Unicode
cat("\u03B1 \u03B2 \u03B3")  # Œ± Œ≤ Œ≥

# Hex
cat("\x48\x65\x6C\x6C\x6F")  # Hello

# All escape sequences
cat("Newline:\nTab:\tQuote:\"Backslash:\\")
```

**Common escapes:**
- `\n` - newline
- `\t` - tab
- `\\` - backslash
- `\"` - double quote
- `\'` - single quote
- `\r` - carriage return
- `\uXXXX` - Unicode character
- `\xXX` - Hex character
</div>

## Error #2: `argument is not of mode character` {#not-mode-character}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
numbers <- c(1, 2, 3, 4, 5)
nchar(numbers)
```

<div class="error-box">
üî¥ **ERROR** (in some contexts)

```
Error in nchar(numbers) : 'nchar()' requires a character vector
```
</div>

Actually, `nchar()` coerces, but other functions don't:

```{r error=TRUE}
substr(123, 1, 2)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in substr(123, 1, 2) : argument is not of mode character
```
</div>

### What It Means

You're passing a non-character vector to a function that requires characters.

### Common Causes

#### Cause 1: Using Numbers Directly

```{r error=TRUE}
# Try to substring a number
substr(12345, 1, 3)

# Try to split a number
strsplit(123, "")
```

#### Cause 2: After Calculation

```{r error=TRUE}
x <- 10
y <- 20
result <- x + y

# Try to manipulate as string
substr(result, 1, 1)
```

#### Cause 3: Column Type Issues

```{r error=TRUE}
df <- data.frame(id = 1:5)

# Try string operation on numeric column
substr(df$id, 1, 1)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Convert to Character First**

```{r}
numbers <- c(1, 2, 3, 4, 5)

# Convert
numbers_char <- as.character(numbers)
nchar(numbers_char)

# Or inline
substr(as.character(12345), 1, 3)

# Extract first digit
as.numeric(substr(as.character(12345), 1, 1))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Type Before Operation**

```{r}
safe_substr <- function(x, start, stop) {
  if (!is.character(x)) {
    message("Converting to character")
    x <- as.character(x)
  }
  substr(x, start, stop)
}

# Test
safe_substr(12345, 1, 3)
safe_substr("hello", 1, 3)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use stringr (Auto-converts)**

```{r}
library(stringr)

# stringr functions auto-convert
str_sub(12345, 1, 3)
str_length(12345)
```
</div>

## Error #3: `invalid multibyte string` {#invalid-multibyte-string}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-encoding">üåê ENCODING</span>

### The Error

```{r error=TRUE}
# Try to read file with wrong encoding
text <- readLines("file_with_utf8.txt", encoding = "latin1")
nchar(text)  # May error
```

<div class="error-box">
üî¥ **ERROR**

```
Error in nchar(text) : invalid multibyte string
```
</div>

### What It Means

The string contains bytes that aren't valid in the expected encoding.

### Common Causes

#### Cause 1: Reading with Wrong Encoding

```{r eval=FALSE}
# File is UTF-8 but reading as different encoding
text <- readLines("utf8_file.txt", encoding = "latin1")

# Or vice versa
text <- readLines("latin1_file.txt", encoding = "UTF-8")
```

#### Cause 2: Locale Issues

```{r}
# Check current locale
Sys.getlocale("LC_CTYPE")

# May differ across systems
```

#### Cause 3: Pasting Invalid Bytes

```{r error=TRUE}
# Create invalid UTF-8
invalid <- rawToChar(as.raw(c(0xFF, 0xFE)))
nchar(invalid)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Specify Correct Encoding**

```{r eval=FALSE}
# Read with correct encoding
text <- readLines("file.txt", encoding = "UTF-8")

# Or detect encoding
library(readr)
guess_encoding("file.txt")

# Then read with detected encoding
text <- readLines("file.txt", encoding = "detected_encoding")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert Encoding**

```{r}
# Sample text (may need real multibyte text)
text <- "caf√©"

# Check encoding
Encoding(text)

# Convert if needed
text_utf8 <- iconv(text, from = "latin1", to = "UTF-8")

# Or ensure UTF-8
enc2utf8(text)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Clean Invalid Characters**

```{r}
clean_string <- function(x) {
  # Try to convert to UTF-8, replacing invalid
  iconv(x, to = "UTF-8", sub = "?")
}

# Or remove invalid
clean_string_remove <- function(x) {
  iconv(x, to = "UTF-8", sub = "")
}
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Platform Differences**

Encoding issues often vary by platform:

```{r eval=FALSE}
# Windows default: may be Windows-1252 or local encoding
Sys.getlocale()

# Mac/Linux default: usually UTF-8
Sys.getlocale()

# Always specify encoding when reading files:
readr::read_csv("file.csv", locale = locale(encoding = "UTF-8"))
readLines("file.txt", encoding = "UTF-8")
```
</div>

## String Creation and Manipulation

<div class="bestpractice-box">
üéØ **Best Practice: Creating and Combining Strings**

```{r}
# Creating strings
single <- "hello"
multiple <- c("hello", "world", "!")

# Combining strings
paste("hello", "world")                    # Space by default
paste("hello", "world", sep = "")          # No space
paste0("hello", "world")                   # paste with sep=""

# Collapse vector into one string
paste(c("a", "b", "c"), collapse = ", ")

# Vector operations (recycling)
paste("File", 1:5, ".txt", sep = "")

# stringr alternatives
library(stringr)
str_c("hello", "world", sep = " ")
str_c(c("a", "b", "c"), collapse = ", ")

# glue for interpolation
library(glue)
name <- "Alice"
age <- 30
glue("My name is {name} and I am {age} years old")
```
</div>

## Length vs Number of Characters

<div class="pitfall-box">
‚ö†Ô∏è **Common Confusion: length() vs nchar()**

```{r}
# Single string
text <- "hello"
length(text)      # 1 (one element in vector)
nchar(text)       # 5 (five characters)

# Multiple strings
texts <- c("hi", "hello", "hey")
length(texts)     # 3 (three elements)
nchar(texts)      # 2 5 3 (characters in each)

# Empty string vs NULL
empty <- ""
length(empty)     # 1 (one element)
nchar(empty)      # 0 (no characters)

nothing <- character(0)
length(nothing)   # 0 (no elements)
nchar(nothing)    # integer(0)

# Common mistake
text <- "hello world"
length(text)      # 1 (NOT 11!)
nchar(text)       # 11 (including space)

# To split into characters
strsplit(text, "")[[1]]
length(strsplit(text, "")[[1]])  # 11
```
</div>

## Empty Strings and NA

<div class="insight-box">
üí° **Key Insight: Empty vs NA vs NULL**

```{r}
# Empty string (exists but empty)
empty <- ""
length(empty)         # 1
nchar(empty)          # 0
is.na(empty)          # FALSE
empty == ""           # TRUE

# NA (missing value)
missing <- NA_character_
length(missing)       # 1
nchar(missing)        # NA (can't count characters of NA)
is.na(missing)        # TRUE

# NULL (doesn't exist)
nothing <- NULL
length(nothing)       # 0
is.null(nothing)      # TRUE

# In a vector
vec <- c("hello", "", NA, "world")
length(vec)           # 4
nchar(vec)            # 5 0 NA 5
is.na(vec)            # FALSE FALSE TRUE FALSE
vec == ""             # FALSE TRUE NA FALSE (NA propagates!)

# Testing for empty strings safely
is_empty <- function(x) {
  !is.na(x) & x == ""
}

is_empty(vec)         # FALSE TRUE FALSE FALSE
```
</div>

## Case Conversion

<div class="bestpractice-box">
üéØ **Best Practice: Case Operations**

```{r}
text <- "Hello World"

# Base R
toupper(text)
tolower(text)

# First letter (no built-in function)
capitalize <- function(x) {
  paste0(toupper(substr(x, 1, 1)), substr(x, 2, nchar(x)))
}
capitalize("hello")

# stringr alternatives
library(stringr)
str_to_upper(text)
str_to_lower(text)
str_to_title(text)    # Title Case

# Handle NAs better
text_with_na <- c("hello", NA, "world")
toupper(text_with_na)        # Preserves NA
str_to_upper(text_with_na)   # Also preserves NA
```
</div>

## Whitespace Issues

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: Invisible Whitespace**

```{r}
# Strings that look the same
text1 <- "hello"
text2 <- " hello"
text3 <- "hello "
text4 <- "hello\n"

# But aren't equal
text1 == text2  # FALSE (leading space)
text1 == text3  # FALSE (trailing space)
text1 == text4  # FALSE (newline)

# Hard to see!
print(text2)
print(text3)

# Better visualization
cat("[", text1, "]\n", sep = "")
cat("[", text2, "]\n", sep = "")
cat("[", text3, "]\n", sep = "")

# Trim whitespace
trimws(text2)  # Remove leading/trailing
trimws(text3)

# stringr
library(stringr)
str_trim(text2)
str_squish("hello    world")  # Remove extra internal spaces too
```
</div>

## String Comparison

<div class="insight-box">
üí° **Key Insight: String Comparison**

```{r}
# Equality
"hello" == "hello"   # TRUE
"hello" == "Hello"   # FALSE (case-sensitive)

# Lexicographic ordering
"a" < "b"           # TRUE
"apple" < "banana"  # TRUE
"10" < "2"          # TRUE (lexicographic, not numeric!)

# Vector comparison
c("a", "b") == c("a", "c")  # TRUE FALSE

# %in% for membership
"apple" %in% c("apple", "banana", "cherry")  # TRUE

# Case-insensitive comparison
tolower("Hello") == tolower("hello")  # TRUE

# Partial matching (base R)
grep("app", c("apple", "banana", "application"))  # 1 3
grepl("app", c("apple", "banana", "application")) # TRUE FALSE TRUE

# stringr
library(stringr)
str_detect(c("apple", "banana"), "app")  # TRUE FALSE
str_which(c("apple", "banana", "app"), "app")  # 1 3
```
</div>

## Type Coercion with Strings

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall: Implicit String Coercion**

```{r}
# Combining strings and numbers
c("a", 1, "b", 2)  # All become character

# In data frames (old R)
df_old <- data.frame(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie"),
  stringsAsFactors = TRUE  # Old default
)
class(df_old$name)  # "factor" (was default in R < 4.0)

# Modern R
df_new <- data.frame(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie")
)
class(df_new$name)  # "character"

# Operations can coerce
x <- c(1, 2, 3)
y <- paste(x, "items")
y                   # "1 items" "2 items" "3 items"
class(y)            # "character"
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **No string type** - R has character vectors
2. **length() vs nchar()** - Elements vs characters
3. **Escape quotes** with `\` or use different quotes
4. **Encoding matters** - Specify UTF-8 when reading files
5. **Empty vs NA vs NULL** - Three different concepts
6. **Convert to character** before string operations
7. **Whitespace is invisible** - Use trimws() or str_trim()

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| unexpected symbol | Quotes not escaped | Use `\"` or different quotes |
| not of mode character | Non-character input | as.character() first |
| invalid multibyte string | Encoding mismatch | Specify correct encoding |
| Wrong comparison | Case or whitespace | tolower() and trimws() |

**Essential Functions:**

```{r eval=FALSE}
# Creation
c(), paste(), paste0(), sprintf()

# Inspection
length(), nchar(), Encoding()

# Manipulation
substr(), substring(), strsplit()
toupper(), tolower(), trimws()

# Comparison
==, %in%, grep(), grepl()

# Conversion
as.character(), toString()

# stringr equivalents (better)
str_c(), str_length(), str_sub()
str_to_upper(), str_to_lower()
str_trim(), str_squish()
str_detect(), str_which()
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
text <- 'He said "Hello"'           # Different quotes
readLines("file.txt", encoding = "UTF-8")  # Explicit encoding
trimws(text)                        # Clean whitespace
as.character(x) before string ops   # Convert first

# ‚ùå Avoid
text <- "He said "Hello""           # Unescaped quotes
readLines("file.txt")               # Platform-dependent encoding
Assuming no whitespace              # Invisible characters
String operations on numbers        # Type mismatch
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Quote Handling**

Create strings containing:
1. Double quotes inside single quotes
2. Single quotes inside double quotes
3. Both quote types in one string
4. A file path with backslashes
</div>

<div class="exercise-box">
üìù **Exercise 2: Length vs Characters**

You have: `texts <- c("hi", "hello", "hey")`

1. Find number of elements
2. Find characters in each
3. Find total characters
4. Find longest string
</div>

<div class="exercise-box">
üìù **Exercise 3: Clean Text**

Write `clean_text(x)` that:
1. Trims whitespace
2. Converts to consistent case
3. Removes or replaces NAs
4. Reports what was changed
</div>

<div class="exercise-box">
üìù **Exercise 4: Safe String Operations**

Write `safe_substr(x, start, stop)` that:
1. Converts to character if needed
2. Handles NAs appropriately
3. Handles out-of-bounds indices
4. Returns character vector
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# 1. Double quotes inside single quotes
text1 <- 'She said "Hello"'
cat(text1)

# 2. Single quotes inside double quotes
text2 <- "It's a nice day"
cat(text2)

# 3. Both quote types
text3 <- "She said \"It's nice\""  # Escape double quotes
cat(text3)

# Alternative with single outside
text3_alt <- 'She said "It\'s nice"'  # Escape single quote
cat(text3_alt)

# 4. File path with backslashes
path <- "C:\\Users\\Documents\\file.txt"
cat(path)

# Or use forward slashes (works on all platforms)
path_alt <- "C:/Users/Documents/file.txt"
```

**Exercise 2:**

```{r}
texts <- c("hi", "hello", "hey")

# 1. Number of elements
num_elements <- length(texts)
num_elements

# 2. Characters in each
chars_each <- nchar(texts)
chars_each

# 3. Total characters
total_chars <- sum(nchar(texts))
total_chars

# 4. Longest string
longest <- texts[which.max(nchar(texts))]
longest

# Or get length of longest
max_length <- max(nchar(texts))
max_length

# Complete analysis
analyze_strings <- function(x) {
  list(
    n_elements = length(x),
    chars_each = nchar(x),
    total_chars = sum(nchar(x)),
    avg_chars = mean(nchar(x)),
    longest = x[which.max(nchar(x))],
    shortest = x[which.min(nchar(x))]
  )
}

analyze_strings(texts)
```

**Exercise 3:**

```{r}
clean_text <- function(x, 
                       trim = TRUE,
                       case = c("lower", "upper", "none"),
                       na_action = c("keep", "remove", "replace"),
                       na_replacement = "",
                       report = TRUE) {
  
  case <- match.arg(case)
  na_action <- match.arg(na_action)
  
  original <- x
  changes <- list()
  
  # Handle NAs
  n_na <- sum(is.na(x))
  if (n_na > 0) {
    if (na_action == "remove") {
      x <- x[!is.na(x)]
      changes$na <- paste("Removed", n_na, "NAs")
    } else if (na_action == "replace") {
      x[is.na(x)] <- na_replacement
      changes$na <- paste("Replaced", n_na, "NAs with", 
                         shQuote(na_replacement))
    } else {
      changes$na <- paste("Kept", n_na, "NAs")
    }
  }
  
  # Trim whitespace
  if (trim) {
    had_whitespace <- x != trimws(x) & !is.na(x)
    if (any(had_whitespace)) {
      x <- trimws(x)
      changes$whitespace <- paste("Trimmed whitespace from",
                                 sum(had_whitespace), "strings")
    }
  }
  
  # Case conversion
  if (case == "lower") {
    x <- tolower(x)
    changes$case <- "Converted to lowercase"
  } else if (case == "upper") {
    x <- toupper(x)
    changes$case <- "Converted to uppercase"
  }
  
  # Report
  if (report && length(changes) > 0) {
    message("Text cleaning applied:")
    for (change in changes) {
      message("  - ", change)
    }
  }
  
  return(x)
}

# Test
messy <- c("  Hello ", "WORLD", NA, " Test  ")
clean_text(messy, case = "lower", na_action = "replace", 
          na_replacement = "[missing]")
```

**Exercise 4:**

```{r}
safe_substr <- function(x, start, stop) {
  # Convert to character if needed
  if (!is.character(x)) {
    message("Converting input to character")
    x <- as.character(x)
  }
  
  # Validate indices
  if (start < 1) {
    warning("start < 1, setting to 1")
    start <- 1
  }
  
  if (stop < start) {
    warning("stop < start, returning empty strings")
    return(rep("", length(x)))
  }
  
  # Handle each element
  result <- character(length(x))
  
  for (i in seq_along(x)) {
    if (is.na(x[i])) {
      result[i] <- NA_character_
      next
    }
    
    # Get length
    len <- nchar(x[i])
    
    # Adjust stop if beyond length
    actual_stop <- min(stop, len)
    
    if (start > len) {
      result[i] <- ""
    } else {
      result[i] <- substr(x[i], start, actual_stop)
    }
  }
  
  return(result)
}

# Test
safe_substr(c("hello", "world", NA, "R"), 1, 3)
safe_substr(12345, 1, 3)  # Auto-converts
safe_substr("short", 1, 100)  # Beyond length
safe_substr("test", 10, 20)  # Start beyond length
```
</details>

<!--chapter:end:14-string-basics.Rmd-->

# String Pattern Matching {#string-pattern-matching}

<div class="chapter-summary">
**What You'll Learn:**

- Regular expressions basics
- grep family functions
- Pattern matching errors
- Replacement operations
- Common regex pitfalls

**Key Errors Covered:** 12+ pattern matching errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Pattern matching in strings is powerful but error-prone:

```{r error=TRUE}
# Try to match a pattern
text <- c("file1.txt", "file2.csv", "file3.txt")
grep(".", text)  # Expect to find the dots
```

```{r}
# But . in regex means "any character"!
grep(".", text)  # Matches everything!
```

Let's master pattern matching and avoid regex pitfalls.

## Pattern Matching Basics

<div class="insight-box">
üí° **Key Insight: grep Family Functions**

```{r}
texts <- c("apple", "banana", "apricot", "cherry")

# grep: return indices of matches
grep("ap", texts)
texts[grep("ap", texts)]

# grepl: return logical vector
grepl("ap", texts)

# sub: replace first match
sub("a", "X", texts)

# gsub: replace all matches
gsub("a", "X", texts)

# regexpr: position of first match
regexpr("a", texts)

# gregexpr: positions of all matches
gregexpr("a", texts)
```

**Key differences:**
- `grep()` ‚Üí indices
- `grepl()` ‚Üí TRUE/FALSE
- `sub()` ‚Üí replace first
- `gsub()` ‚Üí replace all
- `*expr()` ‚Üí positions
</div>

## Error #1: `invalid regular expression` {#invalid-regex}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
# Unmatched bracket
grep("[abc", c("a", "b", "c"))
```

<div class="error-box">
üî¥ **ERROR**

```
Error in grep("[abc", c("a", "b", "c")) : 
  invalid regular expression '[abc', reason 'Missing ']''
```
</div>

### What It Means

Your regular expression has invalid syntax.

### Common Invalid Patterns

```{r error=TRUE}
# Unmatched brackets
grep("[abc", "test")
grep("abc]", "test")

# Unmatched parentheses
grep("(abc", "test")
grep("abc)", "test")

# Invalid repetition
grep("a{2,1}", "test")  # max < min

# Trailing backslash
grep("test\\", "test")

# Invalid escape
grep("\\k", "test")  # \k not valid
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Escape Special Characters**

```{r}
# To match literal special characters, escape them
special_chars <- c(".", "*", "+", "?", "[", "]", "(", ")", 
                   "{", "}", "^", "$", "|", "\\")

# Match literal dot
grep("\\.", c("file.txt", "file_txt"))

# Match literal bracket
grep("\\[", c("[test]", "test"))

# Match literal backslash
grep("\\\\", c("C:\\path", "C:/path"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use fixed = TRUE for Literals**

```{r}
# When you want literal matching, not regex
grep(".", c("file.txt", "file_txt"), fixed = TRUE)

# Works with all special characters
grep("[abc]", c("[abc]", "abc"), fixed = TRUE)

# Much simpler for file extensions
grep(".txt", c("file.txt", "file.csv"), fixed = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Validate Pattern First**

```{r}
is_valid_regex <- function(pattern) {
  tryCatch({
    grep(pattern, "test")
    TRUE
  }, error = function(e) {
    message("Invalid regex: ", e$message)
    FALSE
  })
}

# Test
is_valid_regex("[abc")    # FALSE
is_valid_regex("[abc]")   # TRUE
```
</div>

## Regular Expression Special Characters

<div class="insight-box">
üí° **Key Insight: Regex Special Characters**

```{r}
texts <- c("abc", "a.c", "a*c", "aXc", "ac", "abbc")

# . = any single character
grep("a.c", texts, value = TRUE)

# * = zero or more of previous
grep("ab*c", texts, value = TRUE)

# + = one or more of previous
grep("ab+c", texts, value = TRUE)

# ? = zero or one of previous
grep("ab?c", texts, value = TRUE)

# ^ = start of string
grep("^a", texts, value = TRUE)

# $ = end of string
grep("c$", texts, value = TRUE)

# [abc] = any of a, b, or c
grep("a[bX]c", texts, value = TRUE)

# [^abc] = anything except a, b, or c
grep("a[^b]c", texts, value = TRUE)

# | = or
grep("a|c", texts, value = TRUE)

# {n} = exactly n
grep("b{2}", texts, value = TRUE)

# {n,} = n or more
grep("b{1,}", texts, value = TRUE)

# {n,m} = between n and m
grep("b{1,2}", texts, value = TRUE)
```

**To match literal special characters, escape with `\\`:**

```{r}
# Match literal dot
grep("\\.", c("a.b", "aXb"), value = TRUE)

# Match literal asterisk
grep("\\*", c("a*b", "aXb"), value = TRUE)
```
</div>

## Error #2: Pattern Matches Everything/Nothing

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r}
# Want to find files with dots
files <- c("file1.txt", "file2.csv", "README")

# But . matches any character!
grep(".", files)  # Matches all 3!

# Want to find emails
emails <- c("test@email.com", "notanemail", "another@test.org")

# But simple pattern matches too much
grep("@", emails, value = TRUE)  # OK so far...
grep(".*@.*", emails, value = TRUE)  # Also matches all!
```

### Common Pattern Mistakes

```{r}
texts <- c("abc", "def", "xyz")

# .* matches everything (zero or more any character)
grep(".*", texts)  # All match!

# Wrong escaping
grep(".", texts)   # All match (. is any character)
grep("\\.", texts) # None match (no literal dots)

# Too greedy
text <- "value=123&other=456"
sub("=.*", "", text)  # Removes too much! "value"
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Be Specific**

```{r}
files <- c("file1.txt", "file2.csv", "README")

# Match literal dot
grep("\\.", files, value = TRUE)

# Match specific extension
grep("\\.txt$", files, value = TRUE)

# Match email pattern
emails <- c("test@email.com", "notanemail", "another@test.org")
grep("[A-Za-z0-9.]+@[A-Za-z0-9.]+\\.[A-Za-z]{2,}", emails, value = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Anchors**

```{r}
texts <- c("apple", "pineapple", "application")

# Without anchor: matches all
grep("app", texts, value = TRUE)

# With ^: only at start
grep("^app", texts, value = TRUE)

# With $: only at end
grep("app$", texts, value = TRUE)

# Exact match
grep("^apple$", texts, value = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Non-greedy Matching**

```{r}
text <- "value=123&other=456"

# Greedy: takes everything
sub("=.*&", "=X&", text)  # "value=X&other=456"

# Non-greedy (in Perl regex): *? or +?
sub("=.*?&", "=X&", text, perl = TRUE)  # "value=X&other=456"

# Alternative: use negated character class
sub("=[^&]*&", "=X&", text)  # "value=X&other=456"
```
</div>

## stringr: Modern String Operations

<div class="bestpractice-box">
üéØ **Best Practice: Use stringr**

```{r}
library(stringr)

texts <- c("apple", "banana", "apricot")

# Detect pattern (like grepl)
str_detect(texts, "ap")

# Which match (like grep)
str_which(texts, "ap")

# Extract matches
str_subset(texts, "ap")

# Count matches
str_count(texts, "a")

# Extract pattern
str_extract(texts, "ap")
str_extract_all(texts, "a")

# Replace
str_replace(texts, "a", "X")      # First match
str_replace_all(texts, "a", "X")  # All matches

# Remove pattern
str_remove(texts, "ap")           # First match
str_remove_all(texts, "a")        # All matches

# Split
str_split("a-b-c", "-")
str_split("a-b-c", "-", simplify = TRUE)

# Better error messages
str_detect(texts, "[invalid")  # Clearer error
```
</div>

## Common Regex Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Useful Patterns**

```{r}
library(stringr)

# Digits
texts <- c("abc123", "def456", "xyz")
str_extract_all(texts, "\\d+")  # One or more digits

# Non-digits
str_extract_all(texts, "\\D+")  # One or more non-digits

# Word characters (letters, digits, underscore)
str_extract_all("hello_world123", "\\w+")

# Whitespace
str_detect("hello world", "\\s")

# Email (simple)
email_pattern <- "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}"
str_detect("test@email.com", email_pattern)

# Phone (US)
phone_pattern <- "\\d{3}-\\d{3}-\\d{4}"
str_detect("123-456-7890", phone_pattern)

# URL (simple)
url_pattern <- "https?://[A-Za-z0-9.-]+"
str_extract("Visit http://example.com", url_pattern)

# Extract numbers
text <- "Price: $19.99"
str_extract(text, "\\d+\\.?\\d*")

# Extract words
text <- "hello world, how are you?"
str_extract_all(text, "\\w+")
```
</div>

## Replacement Operations

<div class="insight-box">
üí° **Key Insight: Replacement Strategies**

```{r}
library(stringr)

texts <- c("apple", "banana", "apricot")

# Simple replacement
str_replace(texts, "a", "X")      # First 'a'
str_replace_all(texts, "a", "X")  # All 'a's

# Using captured groups
str_replace("John Smith", "(\\w+) (\\w+)", "\\2, \\1")

# Multiple replacements
text <- "I have 3 cats and 2 dogs"
str_replace_all(text, c("cats" = "birds", "dogs" = "fish"))

# Conditional replacement
str_replace_all("hello", "l+", "L")  # Multiple l's to one L

# Remove pattern
str_remove("Price: $19.99", "\\$")
str_remove_all("a-b-c-d", "-")

# Case-insensitive
str_replace("Hello", regex("hello", ignore_case = TRUE), "Hi")
```
</div>

## Splitting Strings

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: strsplit() Returns List**

```{r}
text <- "a,b,c"

# Returns a LIST
result <- strsplit(text, ",")
class(result)  # "list"
result         # List of 1 element

# To get vector, extract first element
result[[1]]

# With multiple strings
texts <- c("a,b,c", "d,e,f")
result <- strsplit(texts, ",")
result         # List of 2 elements

# To get all values as vector
unlist(result)

# stringr alternative (also returns list)
str_split(text, ",")

# But can simplify
str_split(text, ",", simplify = TRUE)  # Matrix

# Or use specific extraction
str_split_fixed(text, ",", n = 3)  # Fixed number of pieces
```
</div>

## Error #3: `'replacement' is not a character vector` {#replacement-not-character}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
texts <- c("price: 10", "price: 20")
sub("price: ", 100, texts)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in sub("price: ", 100, texts) : 
  invalid 'replacement' argument
```
</div>

### What It Means

The replacement value must be a character string, not numeric.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Convert Replacement to Character**

```{r}
texts <- c("price: 10", "price: 20")

# Convert to character
sub("price: ", as.character(100), texts)

# Or use paste
sub("price: ", paste0("$", 100), texts)

# With stringr (auto-converts)
library(stringr)
str_replace(texts, "price: ", 100)  # Auto-converts
```
</div>

## Case-Insensitive Matching

<div class="bestpractice-box">
üéØ **Best Practice: Ignore Case**

```{r}
texts <- c("Apple", "banana", "CHERRY")

# Base R: use ignore.case
grep("apple", texts, ignore.case = TRUE, value = TRUE)

# Or convert to same case first
grep("apple", tolower(texts), value = TRUE)

# stringr: use regex() with ignore_case
library(stringr)
str_subset(texts, regex("apple", ignore_case = TRUE))

# In replacement
str_replace(texts, regex("apple", ignore_case = TRUE), "Orange")
```
</div>

## Unicode and Locales

<div class="pitfall-box">
‚ö†Ô∏è **Platform Issue: Locale-Dependent Matching**

```{r}
# Character classes depend on locale
texts <- c("caf√©", "na√Øve", "r√©sum√©")

# May behave differently on different systems
grep("[[:alpha:]]+", texts, value = TRUE)

# Safer: specify UTF-8
Sys.setlocale("LC_CTYPE", "en_US.UTF-8")

# Or use Unicode escapes
grep("caf\\u00e9", texts, value = TRUE)

# stringr handles Unicode better
library(stringr)
str_detect(texts, "√©")  # More consistent across platforms
```
</div>

## Extracting Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Pattern Extraction**

```{r}
library(stringr)

# Extract all numbers
text <- "I have 3 cats, 2 dogs, and 15 fish"
str_extract_all(text, "\\d+")

# Extract email addresses
text <- "Contact: john@example.com or jane@test.org"
str_extract_all(text, "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}")

# Extract with groups
text <- "John Smith, Age: 30"
str_match(text, "(\\w+) (\\w+), Age: (\\d+)")

# Named groups (requires stringr)
str_match(text, "(?<first>\\w+) (?<last>\\w+), Age: (?<age>\\d+)")

# Extract between delimiters
text <- "The value is [123] and the code is [ABC]"
str_extract_all(text, "\\[([^\\]]+)\\]")
str_match_all(text, "\\[([^\\]]+)\\]")
```
</div>

## Debugging Regex

<div class="bestpractice-box">
üéØ **Best Practice: Test and Debug Patterns**

```{r}
# Test patterns incrementally
text <- "test@email.com"

# Build up pattern piece by piece
str_detect(text, "\\w+")           # Any word chars
str_detect(text, "\\w+@")          # Word chars + @
str_detect(text, "\\w+@\\w+")      # Add domain start
str_detect(text, "\\w+@\\w+\\.")   # Add dot
str_detect(text, "\\w+@\\w+\\.\\w+")  # Add extension

# Use str_view() to visualize (if available)
# str_view(text, "\\w+@\\w+\\.\\w+")

# Test on multiple examples
test_cases <- c(
  "valid@email.com",
  "invalid",
  "no@domain",
  "missing.at.sign.com"
)

pattern <- "\\w+@\\w+\\.\\w+"
data.frame(
  text = test_cases,
  matches = str_detect(test_cases, pattern)
)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Escape special characters** - Use `\\` or `fixed = TRUE`
2. **. matches any character** - Use `\\.` for literal dot
3. **Use anchors** - `^` for start, `$` for end
4. **stringr is easier** - Better errors and consistency
5. **Test patterns incrementally** - Build complex patterns step by step
6. **strsplit() returns list** - Extract with `[[1]]` or use `simplify = TRUE`
7. **Replacement must be character** - Convert numbers with `as.character()`

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| invalid regular expression | Syntax error in pattern | Check brackets, escape specials |
| Matches everything/nothing | Wrong pattern | Test incrementally, use anchors |
| replacement not character | Numeric replacement | as.character() first |
| Different results by platform | Locale/encoding | Use stringr, specify UTF-8 |

**Essential Patterns:**

```{r eval=FALSE}
# Special characters
.     # Any character
*     # Zero or more
+     # One or more
?     # Zero or one
^     # Start of string
$     # End of string
|     # Or
[]    # Character class
()    # Group

# Character classes
\\d   # Digit
\\D   # Non-digit
\\w   # Word character
\\W   # Non-word
\\s   # Whitespace
\\S   # Non-whitespace

# Quantifiers
{n}   # Exactly n
{n,}  # n or more
{n,m} # Between n and m
```

**grep Family:**

```{r eval=FALSE}
grep(pattern, x)        # Indices
grepl(pattern, x)       # Logical
sub(pattern, repl, x)   # Replace first
gsub(pattern, repl, x)  # Replace all

# stringr alternatives (recommended)
str_detect(x, pattern)
str_which(x, pattern)
str_subset(x, pattern)
str_replace(x, pattern, replacement)
str_replace_all(x, pattern, replacement)
str_extract(x, pattern)
str_extract_all(x, pattern)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
grep("\\.", files)                    # Escape special chars
str_detect(text, "^pattern$")         # Use anchors
str_replace_all(text, "a", "X")      # Use stringr
fixed = TRUE                          # For literal matching

# ‚ùå Avoid
grep(".", files)                      # Matches everything
grep(unvalidated_pattern, text)       # No error checking
sub() with unescaped specials         # Unexpected matches
Platform-dependent locale assumptions # Inconsistent results
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Pattern Building**

Build patterns to match:
1. Valid email addresses
2. Phone numbers (format: XXX-XXX-XXXX)
3. Dates (format: YYYY-MM-DD)
4. URLs starting with http:// or https://
</div>

<div class="exercise-box">
üìù **Exercise 2: Text Extraction**

From: `"Price: $19.99, Quantity: 5 units"`

Extract:
1. The price (numeric only)
2. The quantity (number only)
3. Both in a named vector
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Pattern Matching**

Write `safe_grep(pattern, x)` that:
1. Validates pattern first
2. Provides helpful errors
3. Returns indices with option for values
4. Handles empty inputs
</div>

<div class="exercise-box">
üìù **Exercise 4: Text Cleaning**

Write `clean_identifiers(x)` that:
1. Removes special characters
2. Converts spaces to underscores
3. Converts to lowercase
4. Ensures valid R variable names
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
library(stringr)

# 1. Email pattern
email_pattern <- "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}"

test_emails <- c(
  "valid@email.com",
  "also.valid@test.co.uk",
  "invalid",
  "missing@domain"
)
str_subset(test_emails, email_pattern)

# 2. Phone pattern (XXX-XXX-XXXX)
phone_pattern <- "\\d{3}-\\d{3}-\\d{4}"

test_phones <- c(
  "123-456-7890",
  "555-1234",
  "not a phone",
  "123-456-789"
)
str_subset(test_phones, phone_pattern)

# 3. Date pattern (YYYY-MM-DD)
date_pattern <- "\\d{4}-\\d{2}-\\d{2}"

test_dates <- c(
  "2024-01-15",
  "2024-1-5",
  "not a date",
  "2024/01/15"
)
str_subset(test_dates, date_pattern)

# 4. URL pattern
url_pattern <- "https?://[A-Za-z0-9.-]+(/[A-Za-z0-9._~:/?#\\[\\]@!$&'()*+,;=-]*)?"

test_urls <- c(
  "http://example.com",
  "https://test.org/path",
  "not a url",
  "ftp://wrong.com"
)
str_subset(test_urls, url_pattern)
```

**Exercise 2:**

```{r}
text <- "Price: $19.99, Quantity: 5 units"

# 1. Extract price
price <- str_extract(text, "\\d+\\.\\d+")
as.numeric(price)

# 2. Extract quantity
quantity <- str_extract(text, "Quantity: (\\d+)")
quantity <- str_extract(quantity, "\\d+")
as.numeric(quantity)

# 3. Both in named vector
extract_both <- function(text) {
  price <- as.numeric(str_extract(text, "(?<=\\$)\\d+\\.\\d+"))
  quantity <- as.numeric(str_extract(text, "(?<=Quantity: )\\d+"))
  
  c(price = price, quantity = quantity)
}

extract_both(text)

# Alternative: using str_match with groups
pattern <- "Price: \\$(\\d+\\.\\d+), Quantity: (\\d+)"
matches <- str_match(text, pattern)
c(
  price = as.numeric(matches[, 2]),
  quantity = as.numeric(matches[, 3])
)
```

**Exercise 3:**

```{r}
safe_grep <- function(pattern, x, value = FALSE, ignore.case = FALSE) {
  # Validate inputs
  if (length(x) == 0) {
    message("Input vector is empty")
    return(if (value) character(0) else integer(0))
  }
  
  if (!is.character(x)) {
    message("Converting input to character")
    x <- as.character(x)
  }
  
  # Validate pattern
  pattern_valid <- tryCatch({
    grep(pattern, "test")
    TRUE
  }, error = function(e) {
    FALSE
  })
  
  if (!pattern_valid) {
    stop("Invalid regular expression pattern: '", pattern, "'\n",
         "Check for:\n",
         "  - Unmatched brackets: [ ] ( )\n",
         "  - Invalid escapes\n",
         "  - Unescaped special characters: . * + ? ^ $")
  }
  
  # Perform grep
  result <- grep(pattern, x, value = value, ignore.case = ignore.case)
  
  # Report
  n_matches <- if (value) length(result) else length(result)
  message("Found ", n_matches, " match(es) out of ", length(x), " elements")
  
  return(result)
}

# Test
safe_grep("ap", c("apple", "banana", "apricot"))
safe_grep("ap", c("apple", "banana", "apricot"), value = TRUE)
safe_grep("[invalid", c("test"))  # Clear error
```

**Exercise 4:**

```{r}
clean_identifiers <- function(x) {
  library(stringr)
  
  # Convert to character if needed
  if (!is.character(x)) {
    x <- as.character(x)
  }
  
  # Remove leading/trailing whitespace
  x <- str_trim(x)
  
  # Convert to lowercase
  x <- str_to_lower(x)
  
  # Replace spaces with underscores
  x <- str_replace_all(x, "\\s+", "_")
  
  # Remove non-alphanumeric except underscore
  x <- str_replace_all(x, "[^a-z0-9_]", "")
  
  # Ensure doesn't start with number
  x <- str_replace(x, "^(\\d)", "x\\1")
  
  # Ensure not empty
  x[x == ""] <- "var"
  
  # Ensure unique
  x <- make.names(x, unique = TRUE)
  
  return(x)
}

# Test
messy <- c("My Variable!", "123 Start", "test@#$", "  spaces  ", "")
clean_identifiers(messy)
```
</details>

<!--chapter:end:15-string-pattern-matching.Rmd-->

# Part VII: Functions & Programming {-}

# Function Creation & Errors {#function-creation}

<div class="chapter-summary">
**What You'll Learn:**

- Creating functions in R
- Function arguments and defaults
- Return values
- Common function creation errors
- Function documentation

**Key Errors Covered:** 18+ function errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Functions are fundamental to R programming, but creating them has pitfalls:

```{r error=TRUE}
# Try to create a function
my_function <- function(x) {
  result <- x * 2
  # Forget to return!
}

my_function(5)  # Returns NULL!
```

Let's master function creation to avoid these issues.

## Function Basics

<div class="insight-box">
üí° **Key Insight: Functions Are Objects**

```{r}
# Functions are first-class objects
my_func <- function(x) {
  x * 2
}

# It's an object
class(my_func)
typeof(my_func)

# Can be passed around
apply_func <- function(f, value) {
  f(value)
}

apply_func(my_func, 5)

# Can be stored in lists
func_list <- list(
  double = function(x) x * 2,
  triple = function(x) x * 3
)

func_list$double(5)

# Can be returned from functions
make_multiplier <- function(n) {
  function(x) x * n
}

times_4 <- make_multiplier(4)
times_4(5)
```

**Key points:**
- Functions are objects like any other
- Can be assigned to variables
- Can be passed as arguments
- Can be returned from functions
- Can be anonymous (unnamed)
</div>

## Error #1: `could not find function` {#could-not-find-function}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
# Typo in function name
maen(c(1, 2, 3))
```

<div class="error-box">
üî¥ **ERROR**

```
Error in maen(c(1, 2, 3)) : could not find function "maen"
```
</div>

### What It Means

R can't find a function with that name in the current environment or loaded packages.

### Common Causes

#### Cause 1: Typo

```{r error=TRUE}
# Spelling mistakes
summry(mtcars)
lenght(1:10)
subsett(mtcars, mpg > 20)
```

#### Cause 2: Package Not Loaded

```{r error=TRUE}
# Function from package not loaded
ggplot(mtcars, aes(x = mpg, y = hp))  # ggplot2 not loaded
```

#### Cause 3: Function Not Created Yet

```{r error=TRUE}
# Calling before definition
result <- calculate_total(10, 20)

calculate_total <- function(a, b) {
  a + b
}
```

#### Cause 4: Wrong Scope

```{r error=TRUE}
# Function created in different environment
{
  local_func <- function(x) x * 2
}

local_func(5)  # No longer accessible
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Spelling**

```{r}
# Use tab completion in RStudio
# Type first few letters and press Tab

# Check available functions
apropos("mean")  # Find functions with "mean" in name

# Search help
??mean
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Load Required Package**

```{r}
# Check if function is in a package
help.search("ggplot")

# Load package
library(ggplot2)

# Or use package::function syntax
ggplot2::ggplot(mtcars, aes(x = mpg, y = hp))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check Function Exists**

```{r}
safe_call <- function(func_name, ...) {
  if (!exists(func_name, mode = "function")) {
    stop("Function '", func_name, "' not found. ",
         "Did you mean: ", paste(apropos(func_name), collapse = ", "))
  }
  
  do.call(func_name, list(...))
}

# Test
safe_call("mean", c(1, 2, 3))
```

```{r error=TRUE}
safe_call("maen", c(1, 2, 3))  # Helpful error
```
</div>

## Error #2: `argument "x" is missing, with no default` {#argument-missing}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
my_func <- function(x, y) {
  x + y
}

my_func(5)  # Missing y!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_func(5) : argument "y" is missing, with no default
```
</div>

### What It Means

You're calling a function without providing all required arguments.

### Understanding Arguments

```{r}
# Required arguments (no default)
func1 <- function(x, y) {
  x + y
}

func1(5, 10)  # Must provide both
```

```{r error=TRUE}
func1(5)      # Error!
```

```{r}
# Optional arguments (with default)
func2 <- function(x, y = 10) {
  x + y
}

func2(5, 20)  # Can override default
func2(5)      # Uses default y = 10

# All optional
func3 <- function(x = 5, y = 10) {
  x + y
}

func3()       # Uses all defaults
func3(8)      # Override x, use default y
func3(8, 12)  # Override both
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Provide All Required Arguments**

```{r}
my_func <- function(x, y) {
  x + y
}

# Call with all arguments
my_func(5, 10)

# Named arguments (order doesn't matter)
my_func(y = 10, x = 5)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Add Default Values**

```{r}
# Make some/all arguments optional
my_func <- function(x, y = 0) {
  x + y
}

my_func(5)     # Works, y defaults to 0
my_func(5, 10) # Can still override

# Can use NULL as default
my_func2 <- function(x, y = NULL) {
  if (is.null(y)) {
    y <- x  # Default to same as x
  }
  x + y
}

my_func2(5)
my_func2(5, 3)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check Arguments**

```{r}
my_func <- function(x, y) {
  # Check if arguments provided
  if (missing(x)) {
    stop("Argument 'x' is required")
  }
  if (missing(y)) {
    message("Argument 'y' not provided, using default of 0")
    y <- 0
  }
  
  x + y
}

my_func(5)    # Warning but works
my_func(5, 3)
```

```{r error=TRUE}
my_func()     # Clear error about x
```
</div>

## Error #3: `unused argument` {#unused-argument}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
my_func <- function(x, y) {
  x + y
}

my_func(5, 10, 15)  # Too many arguments!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_func(5, 10, 15) : unused argument (15)
```
</div>

### What It Means

You're passing more arguments than the function accepts.

### Common Causes

#### Cause 1: Extra Arguments

```{r error=TRUE}
mean(c(1, 2, NA), na.rm = TRUE, extra = "oops")
```

#### Cause 2: Wrong Argument Name

```{r error=TRUE}
mean(c(1, 2, NA), remove_na = TRUE)  # It's na.rm not remove_na
```

#### Cause 3: Positional Confusion

```{r error=TRUE}
# substr expects (x, start, stop)
substr("hello", 1, 3, "extra")
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Remove Extra Arguments**

```{r}
# Check function signature
args(mean)

# Provide correct arguments only
mean(c(1, 2, NA), na.rm = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use ... to Accept Extra Arguments**

```{r}
# Allow any number of additional arguments
my_func <- function(x, y, ...) {
  result <- x + y
  
  # Can pass ... to other functions
  extra_args <- list(...)
  if (length(extra_args) > 0) {
    message("Ignoring extra arguments: ", 
            paste(names(extra_args), collapse = ", "))
  }
  
  result
}

my_func(5, 10)              # Works
my_func(5, 10, z = 15)      # Works, ignores z
my_func(5, 10, 15, 20)      # Works, ignores unnamed extras
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Validate Arguments**

```{r}
my_func <- function(x, y) {
  # Capture call
  call <- match.call()
  
  # Check for unexpected arguments
  valid_args <- c("x", "y")
  provided_args <- names(call)[-1]  # Remove function name
  
  invalid <- setdiff(provided_args, valid_args)
  if (length(invalid) > 0) {
    stop("Unexpected arguments: ", paste(invalid, collapse = ", "),
         "\nValid arguments are: ", paste(valid_args, collapse = ", "))
  }
  
  x + y
}

my_func(5, 10)
```

```{r error=TRUE}
my_func(5, 10, z = 15)  # Helpful error
```
</div>

## Return Values

<div class="insight-box">
üí° **Key Insight: Return Values**

```{r}
# Implicit return (last expression)
func1 <- function(x) {
  x * 2
}
func1(5)  # Returns 10

# Explicit return
func2 <- function(x) {
  return(x * 2)
}
func2(5)  # Returns 10

# Early return
func3 <- function(x) {
  if (x < 0) {
    return(0)  # Exit early
  }
  x * 2
}
func3(-5)  # Returns 0
func3(5)   # Returns 10

# No return (returns NULL)
func4 <- function(x) {
  result <- x * 2
  # Forgot to return or print result
}
func4(5)  # Returns NULL invisibly

# Multiple values (use list)
func5 <- function(x) {
  list(
    original = x,
    doubled = x * 2,
    squared = x^2
  )
}
func5(5)

# Return NULL explicitly
func6 <- function(x) {
  if (x < 0) {
    return(NULL)
  }
  x * 2
}
func6(-5)  # NULL
func6(5)   # 10
```

**Best practices:**
- Last expression is returned automatically
- Use `return()` for early exits
- Use `invisible()` for functions with side effects
- Return lists for multiple values
</div>

## Error #4: `object of type 'closure' is not subsettable` {#closure-not-subsettable}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
my_func <- function(x) x * 2

# Try to subset a function
my_func[1]
```

<div class="error-box">
üî¥ **ERROR**

```
Error in my_func[1] : object of type 'closure' is not subsettable
```
</div>

### What It Means

You're trying to subset a function as if it were a vector or list. "Closure" is R's internal name for functions.

### Common Causes

#### Cause 1: Name Collision

```{r error=TRUE}
# Accidentally named data same as function
mean <- function(x) sum(x) / length(x)

# Later, try to use mean as data
mean[1]  # Error! mean is now a function
```

#### Cause 2: Forgot to Call Function

```{r error=TRUE}
data <- c(1, 2, 3, 4, 5)

# Forgot parentheses
result <- mean  # Assigns the function, not result
result[1]       # Error!
```

#### Cause 3: Wrong Object

```{r error=TRUE}
my_list <- list(a = 1, b = 2)
my_func <- function(x) x * 2

# Accidentally use function instead of list
my_func$a
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Object Type**

```{r}
my_func <- function(x) x * 2

# Check what it is
is.function(my_func)
class(my_func)

# If you need to subset, make sure you're using the right object
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Call Function Properly**

```{r}
# Call the function
result <- mean(c(1, 2, 3, 4, 5))
result

# Now can use result
result
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Avoid Name Collisions**

```{r}
# Don't overwrite common function names
# Bad
# mean <- my_data

# Good
my_mean_value <- mean(my_data)

# If you accidentally overwrote
mean <- function(x) sum(x) / length(x)

# Restore
rm(mean)  # Remove your version
mean(c(1, 2, 3))  # Uses base::mean again
```
</div>

## Function Arguments: ... (Dots)

<div class="insight-box">
üí° **Key Insight: The ... Argument**

```{r}
# ... captures any additional arguments
my_plot <- function(x, y, ...) {
  plot(x, y, ...)  # Pass ... to another function
}

# Can pass any plot arguments
my_plot(1:10, 1:10, col = "red", pch = 16, main = "Test")

# Access ... contents
my_func <- function(...) {
  args <- list(...)
  cat("Received", length(args), "arguments\n")
  args
}

my_func(a = 1, b = 2, c = 3)

# Extract specific arguments from ...
my_func2 <- function(x, ...) {
  dots <- list(...)
  
  # Get specific argument
  if ("multiplier" %in% names(dots)) {
    mult <- dots$multiplier
  } else {
    mult <- 1
  }
  
  x * mult
}

my_func2(5)
my_func2(5, multiplier = 3)

# Common use: wrapper functions
my_mean <- function(..., na.rm = FALSE) {
  # Add custom behavior
  message("Calculating mean...")
  
  # Pass to base function
  mean(..., na.rm = na.rm)
}

my_mean(c(1, 2, NA, 4), na.rm = TRUE)
```

**When to use ...:**
- Wrapper functions (pass args to another function)
- Flexible functions (accept varying arguments)
- Methods (S3/S4 generics often use ...)

**Caution:**
- Arguments after ... must be named explicitly
- Easy to make typos that go unnoticed
</div>

## Argument Matching

<div class="insight-box">
üí° **Key Insight: How R Matches Arguments**

```{r}
my_func <- function(first, second, third) {
  cat("first:", first, "\n")
  cat("second:", second, "\n")
  cat("third:", third, "\n")
}

# 1. Exact name match
my_func(first = 1, second = 2, third = 3)

# 2. Partial name match (not recommended!)
my_func(f = 1, s = 2, t = 3)

# 3. Positional match
my_func(1, 2, 3)

# 4. Mixed (named don't need to be in order)
my_func(third = 3, first = 1, second = 2)
my_func(1, third = 3, second = 2)

# Order of matching:
# 1. Exact name matches
# 2. Partial name matches  
# 3. Positional matches
```

**Best practices:**
- Use exact names for clarity
- Avoid partial matching (can cause confusion)
- Use names for all arguments after the first few
- Named arguments can be in any order
</div>

## Common Function Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Function Patterns**

```{r}
# 1. Validate inputs
safe_divide <- function(x, y) {
  # Check types
  if (!is.numeric(x) || !is.numeric(y)) {
    stop("Both x and y must be numeric")
  }
  
  # Check values
  if (any(y == 0)) {
    stop("Cannot divide by zero")
  }
  
  x / y
}

safe_divide(10, 2)
```

```{r error=TRUE}
safe_divide(10, 0)
```

```{r}
# 2. Provide informative messages
verbose_mean <- function(x, na.rm = FALSE, verbose = TRUE) {
  if (verbose) {
    message("Calculating mean of ", length(x), " values")
    if (na.rm) {
      message("Removing NA values")
    }
  }
  
  mean(x, na.rm = na.rm)
}

verbose_mean(c(1, 2, NA, 4), na.rm = TRUE)

# 3. Handle edge cases
robust_max <- function(x) {
  if (length(x) == 0) {
    return(NULL)
  }
  
  if (all(is.na(x))) {
    return(NA)
  }
  
  max(x, na.rm = TRUE)
}

robust_max(numeric(0))
robust_max(c(NA, NA))
robust_max(c(1, 2, NA, 3))

# 4. Return useful objects
detailed_summary <- function(x) {
  result <- list(
    mean = mean(x, na.rm = TRUE),
    median = median(x, na.rm = TRUE),
    sd = sd(x, na.rm = TRUE),
    n = length(x),
    n_missing = sum(is.na(x))
  )
  
  class(result) <- "detailed_summary"
  result
}

summary_obj <- detailed_summary(c(1, 2, NA, 4, 5))
summary_obj

# 5. Use ... appropriately
flexible_plot <- function(x, y, type = "p", ...) {
  # Set defaults
  defaults <- list(
    pch = 16,
    col = "blue"
  )
  
  # Override with ...
  args <- modifyList(defaults, list(...))
  
  # Call plot
  do.call(plot, c(list(x = x, y = y, type = type), args))
}

flexible_plot(1:10, 1:10, col = "red", main = "Test")
```
</div>

## Documentation

<div class="bestpractice-box">
üéØ **Best Practice: Document Your Functions**

```{r}
#' Calculate the area of a circle
#'
#' @param radius Numeric. The radius of the circle.
#' @param units Character. The units of measurement (default: "cm").
#' @return Numeric. The area of the circle.
#' @examples
#' circle_area(5)
#' circle_area(10, units = "inches")
#' @export
circle_area <- function(radius, units = "cm") {
  if (!is.numeric(radius) || radius < 0) {
    stop("radius must be a non-negative number")
  }
  
  area <- pi * radius^2
  
  structure(
    area,
    units = units,
    class = c("circle_area", "numeric")
  )
}

# In-function comments
calculate_price <- function(base_price, tax_rate = 0.1, discount = 0) {
  # Validate inputs
  if (base_price < 0) stop("base_price cannot be negative")
  if (tax_rate < 0 || tax_rate > 1) stop("tax_rate must be between 0 and 1")
  if (discount < 0 || discount > 1) stop("discount must be between 0 and 1")
  
  # Apply discount
  discounted_price <- base_price * (1 - discount)
  
  # Add tax
  final_price <- discounted_price * (1 + tax_rate)
  
  # Return itemized result
  list(
    base_price = base_price,
    discount = discount,
    discounted_price = discounted_price,
    tax = discounted_price * tax_rate,
    final_price = final_price
  )
}
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Functions are objects** - Can be assigned, passed, returned
2. **could not find function** - Check spelling, loading, scope
3. **Provide required arguments** - Or add defaults
4. **Don't pass extra arguments** - Unless function uses ...
5. **Last expression is returned** - Or use return() explicitly
6. **closure not subsettable** - You're trying to subset a function
7. **Use ... for flexibility** - Pass extra args to other functions
8. **Validate inputs** - Check types and values

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| could not find function | Typo, not loaded, not defined | Check spelling, load package |
| argument missing | Required arg not provided | Provide arg or add default |
| unused argument | Too many args | Remove extra or use ... |
| closure not subsettable | Subsetting a function | Call function or use right object |

**Function Creation:**

```{r eval=FALSE}
# Basic function
my_func <- function(x, y) {
  x + y
}

# With defaults
my_func <- function(x, y = 0) {
  x + y
}

# With ...
my_func <- function(x, ...) {
  # Do something
  other_func(x, ...)
}

# With validation
my_func <- function(x) {
  if (!is.numeric(x)) stop("x must be numeric")
  x * 2
}

# Return values
my_func <- function(x) {
  list(result = x * 2, original = x)
}
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
function(x, y = 0)              # Sensible defaults
if (!is.numeric(x)) stop()      # Validate inputs
return(list(a = 1, b = 2))      # Multiple values in list
Use descriptive names            # clear_cache() not cc()

# ‚ùå Avoid
function(x)                     # No defaults when optional
No input validation             # Causes cryptic errors later
mean <- my_data                 # Overwriting function names
function(x, y, z, a, b, c)      # Too many arguments
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Safe Division Function**

Write `safe_divide(x, y)` that:
1. Checks both are numeric
2. Handles division by zero
3. Works with vectors
4. Returns informative errors
</div>

<div class="exercise-box">
üìù **Exercise 2: Flexible Summary**

Write `my_summary(x, ...)` that:
1. Calculates mean, median, sd
2. Accepts ... for additional stats
3. Handles NA values
4. Returns named list
</div>

<div class="exercise-box">
üìù **Exercise 3: Argument Validator**

Write `validate_args(func, ...)` that:
1. Checks if function exists
2. Validates argument types
3. Checks required args provided
4. Returns TRUE/FALSE with messages
</div>

<div class="exercise-box">
üìù **Exercise 4: Function Factory**

Write `make_adder(n)` that returns a function that adds n to its argument.

Example:
```{r eval=FALSE}
add_5 <- make_adder(5)
add_5(10)  # Should return 15
```
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
safe_divide <- function(x, y) {
  # Check types
  if (!is.numeric(x)) {
    stop("x must be numeric, got ", class(x)[1])
  }
  if (!is.numeric(y)) {
    stop("y must be numeric, got ", class(y)[1])
  }
  
  # Check for zero
  if (any(y == 0)) {
    warning("Division by zero detected, returning Inf/-Inf")
    # R handles this naturally, but we warn
  }
  
  # Check lengths match or can recycle
  if (length(x) != length(y) && length(x) != 1 && length(y) != 1) {
    if (max(length(x), length(y)) %% min(length(x), length(y)) != 0) {
      warning("Lengths not compatible for recycling: ",
              length(x), " and ", length(y))
    }
  }
  
  result <- x / y
  result
}

# Test
safe_divide(10, 2)
safe_divide(c(10, 20, 30), c(2, 4, 5))
safe_divide(10, 0)  # Warning
```

```{r error=TRUE}
safe_divide("10", 2)  # Error
```

**Exercise 2:**

```{r}
my_summary <- function(x, ..., na.rm = TRUE) {
  # Base statistics
  result <- list(
    n = length(x),
    n_missing = sum(is.na(x)),
    mean = mean(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm),
    sd = sd(x, na.rm = na.rm),
    min = min(x, na.rm = na.rm),
    max = max(x, na.rm = na.rm)
  )
  
  # Additional statistics from ...
  extra_stats <- list(...)
  
  for (stat_name in names(extra_stats)) {
    stat_func <- extra_stats[[stat_name]]
    if (is.function(stat_func)) {
      result[[stat_name]] <- stat_func(x, na.rm = na.rm)
    }
  }
  
  class(result) <- "my_summary"
  result
}

# Print method
print.my_summary <- function(x, ...) {
  cat("Summary Statistics\n")
  cat("==================\n")
  for (name in names(x)) {
    cat(sprintf("%-12s: %s\n", name, 
                format(x[[name]], digits = 3)))
  }
  invisible(x)
}

# Test
data <- c(1, 2, NA, 4, 5, 6, 7, 8, 9, 10)
my_summary(data)

# With extra stats
my_summary(data, 
          IQR = IQR,
          mad = mad)
```

**Exercise 3:**

```{r}
validate_args <- function(func_name, ...) {
  # Check function exists
  if (!exists(func_name, mode = "function")) {
    message("‚úó Function '", func_name, "' not found")
    return(FALSE)
  }
  
  func <- get(func_name, mode = "function")
  func_args <- formals(func)
  
  # Get provided arguments
  provided <- list(...)
  
  # Check required arguments (those without defaults)
  required_args <- names(func_args)[sapply(func_args, 
                                           function(x) class(x) == "name")]
  
  missing_required <- setdiff(required_args, names(provided))
  
  if (length(missing_required) > 0) {
    message("‚úó Missing required arguments: ", 
            paste(missing_required, collapse = ", "))
    return(FALSE)
  }
  
  # Check for unexpected arguments
  if (!"..." %in% names(func_args)) {
    unexpected <- setdiff(names(provided), names(func_args))
    if (length(unexpected) > 0) {
      message("‚úó Unexpected arguments: ", 
              paste(unexpected, collapse = ", "))
      return(FALSE)
    }
  }
  
  # Check argument types (basic)
  for (arg_name in names(provided)) {
    arg_value <- provided[[arg_name]]
    # Could add more sophisticated type checking here
  }
  
  message("‚úì All validations passed for '", func_name, "'")
  return(TRUE)
}

# Test
validate_args("mean", x = c(1, 2, 3), na.rm = TRUE)
validate_args("mean", na.rm = TRUE)  # Missing x
validate_args("mean", x = c(1, 2, 3), invalid = TRUE)  # Extra arg
```

**Exercise 4:**

```{r}
make_adder <- function(n) {
  # Return a function that adds n
  function(x) {
    x + n
  }
}

# Test
add_5 <- make_adder(5)
add_5(10)

add_100 <- make_adder(100)
add_100(50)

# Multiple uses
add_5(1:10)

# Each function retains its own n
add_5(5)
add_100(5)

# More advanced: with validation
make_adder_safe <- function(n) {
  if (!is.numeric(n) || length(n) != 1) {
    stop("n must be a single numeric value")
  }
  
  function(x) {
    if (!is.numeric(x)) {
      stop("x must be numeric")
    }
    x + n
  }
}

add_3 <- make_adder_safe(3)
add_3(10)
```
</details>

<!--chapter:end:16-function-creation.Rmd-->

# Scoping & Environments {#scoping-environments}

<div class="chapter-summary">
**What You'll Learn:**

- How R finds objects
- Lexical scoping rules
- Environment hierarchy
- Common scoping errors
- Global vs local variables

**Key Errors Covered:** 12+ scoping errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Scoping determines how R finds objects, and it's often surprising:

```{r}
x <- 10

my_func <- function() {
  x  # Where does this x come from?
}

my_func()  # Returns 10!
```

Let's understand scoping to avoid confusion.

## Environment Basics

<div class="insight-box">
üí° **Key Insight: Environments Are Like Named Lists**

```{r}
# Create an environment
my_env <- new.env()

# Add objects
my_env$x <- 10
my_env$y <- 20

# Access objects
my_env$x

# List contents
ls(my_env)

# Every function has an environment
f <- function() {
  x <- 5
  environment()
}

f_env <- f()
ls(f_env)

# Current environment
environment()  # Usually global environment

# Parent environment
parent.env(my_env)
```

**Key points:**
- Environments contain named objects
- Every function creates a new environment
- Environments have parents
- R searches up the chain
</div>

## Error #1: `object not found` (scoping) {#object-not-found-scope}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
my_func <- function() {
  y <- 20
}

my_func()

y  # Where is y?
```

<div class="error-box">
üî¥ **ERROR**

```
Error in eval(expr, envir, enclos) : object 'y' not found
```
</div>

### What It Means

The object was created in a function's environment and isn't accessible outside.

### Understanding Scope

```{r}
# Global scope
x <- 10

func1 <- function() {
  # Function scope
  y <- 20
  
  # Can see global x
  cat("x:", x, "\n")
  
  # Can see local y
  cat("y:", y, "\n")
}

func1()

# x exists globally
x

# y doesn't (was in function scope)
exists("y")  # FALSE

# Example 2: Nested functions
outer_func <- function() {
  z <- 30
  
  inner_func <- function() {
    # Can see z from parent environment
    z
  }
  
  inner_func()
}

outer_func()

# z doesn't exist here
exists("z")  # FALSE
```

### Common Causes

#### Cause 1: Expecting Function to Modify Global

```{r}
x <- 10

# This doesn't modify global x!
add_ten <- function() {
  x <- x + 10
  x  # Returns 20
}

add_ten()  # Returns 20
x          # Still 10!
```

#### Cause 2: Variables Only Exist in Loop Scope

```{r error=TRUE}
for (i in 1:5) {
  temp <- i * 2
}

# temp still exists (for loop doesn't create new scope in R)
temp

# But function scope is different
func <- function() {
  for (i in 1:5) {
    temp2 <- i * 2
  }
}
func()

temp2  # Doesn't exist
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Return Values**

```{r}
x <- 10

# Return the new value
add_ten <- function(val) {
  val + 10
}

# Assign result
x <- add_ten(x)
x  # Now 20
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use <<- for Global Assignment (Caution!)**

```{r}
x <- 10

# Modifies global x
add_ten_global <- function() {
  x <<- x + 10
}

add_ten_global()
x  # Now 20

# ‚ö†Ô∏è Use sparingly! Can cause confusion
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Pass and Return Explicitly**

```{r}
# Best practice: explicit in and out
process_data <- function(data, operation) {
  # Do something
  result <- data * operation
  
  # Return explicitly
  return(result)
}

my_data <- 100
my_data <- process_data(my_data, 2)
my_data
```
</div>

## Lexical Scoping

<div class="insight-box">
üí° **Key Insight: Lexical Scoping**

R uses lexical (static) scoping: where a function was **defined** matters, not where it's **called**.

```{r}
x <- 10

func1 <- function() {
  x  # Uses x from where function was defined
}

func2 <- function() {
  x <- 20  # Different x
  func1()  # What does this return?
}

func2()  # Returns 10 (not 20!)

# Why? func1 looks for x where it was defined (global env)
# Not where it was called (inside func2)

# Example 2: Function factories
make_multiplier <- function(n) {
  function(x) {
    x * n  # n from make_multiplier's environment
  }
}

times_3 <- make_multiplier(3)
times_5 <- make_multiplier(5)

times_3(10)  # 30
times_5(10)  # 50

# Each function remembers its own n!
```

**Key rule:** R looks for variables in:
1. Current environment
2. Parent environment (where function was defined)
3. Parent's parent, etc.
4. Eventually global environment
5. Loaded packages
</div>

## Error #2: Unexpected Value from Outer Scope

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Problem

```{r}
x <- 999  # Global x

calculate <- function(a, b) {
  # Forgot to define x, uses global!
  a + b + x
}

calculate(1, 2)  # Returns 1002 (not 3!)
```

### What Happened

The function used a global variable unintentionally.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Explicit Parameters**

```{r}
# Make all inputs explicit
calculate <- function(a, b, x = 0) {
  a + b + x
}

calculate(1, 2)      # Uses default x = 0
calculate(1, 2, 10)  # Uses provided x
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check for Undefined Variables**

```{r}
# Development tool
check_function_variables <- function(func) {
  # Get function body
  body_expr <- body(func)
  
  # Get all variable names (simplified)
  all_vars <- all.names(body_expr)
  
  # Get formal arguments
  args <- names(formals(func))
  
  # Find variables not in arguments
  external <- setdiff(all_vars, c(args, "function", "{", "+", "-", "*", "/"))
  
  if (length(external) > 0) {
    message("Potentially external variables: ", 
            paste(external, collapse = ", "))
  }
}

x <- 999
calculate <- function(a, b) {
  a + b + x
}

check_function_variables(calculate)  # Warns about x
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Local Functions**

```{r}
# Keep related functions together
calculator <- local({
  # Private variable
  default_offset <- 0
  
  # Public functions
  list(
    add = function(a, b) a + b + default_offset,
    set_offset = function(value) default_offset <<- value
  )
})

calculator$add(5, 10)
calculator$set_offset(100)
calculator$add(5, 10)
```
</div>

## Global Assignment: <<-

<div class="pitfall-box">
‚ö†Ô∏è **Pitfall: Global Assignment**

```{r}
counter <- 0

# Bad: modifies global
increment_bad <- function() {
  counter <<- counter + 1
}

increment_bad()
counter  # 1

increment_bad()
counter  # 2

# Problem: Hard to track where changes happen
# Can cause bugs in large programs

# Better: Use closures
make_counter <- function() {
  count <- 0
  
  list(
    increment = function() {
      count <<- count + 1  # OK here (modifying enclosing env)
      count
    },
    get = function() count,
    reset = function() count <<- 0
  )
}

counter_obj <- make_counter()
counter_obj$increment()
counter_obj$increment()
counter_obj$get()
counter_obj$reset()
counter_obj$get()
```

**When to use <<-:**
- Inside closures/function factories
- For memoization
- When you truly need state

**When NOT to use <<-:**
- In regular functions (use return values instead)
- When you can pass arguments
- In package functions (very rarely appropriate)
</div>

## Environments in Functions

<div class="insight-box">
üí° **Key Insight: Function Environments**

```{r}
# Each function call creates new environment
create_accumulator <- function() {
  sum <- 0
  
  function(x) {
    sum <<- sum + x
    sum
  }
}

# Create two independent accumulators
acc1 <- create_accumulator()
acc2 <- create_accumulator()

# Each has its own sum!
acc1(5)   # 5
acc1(10)  # 15
acc2(3)   # 3
acc2(7)   # 10

acc1(0)   # 15 (independent)
acc2(0)   # 10 (independent)

# Inspect environments
environment(acc1)
environment(acc2)
# Different!

# Get value from environment
get("sum", environment(acc1))
get("sum", environment(acc2))
```
</div>

## Common Scoping Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Scoping Patterns**

```{r}
# 1. Function factories
make_power <- function(n) {
  function(x) {
    x ^ n
  }
}

square <- make_power(2)
cube <- make_power(3)

square(5)
cube(5)

# 2. Memoization (caching results)
fib_memo <- local({
  cache <- list()
  
  function(n) {
    if (n <= 1) return(n)
    
    # Check cache
    key <- as.character(n)
    if (!is.null(cache[[key]])) {
      return(cache[[key]])
    }
    
    # Calculate and cache
    result <- fib_memo(n - 1) + fib_memo(n - 2)
    cache[[key]] <<- result
    result
  }
})

system.time(fib_memo(30))
system.time(fib_memo(30))  # Much faster (cached)

# 3. Private variables
create_account <- function(initial_balance = 0) {
  balance <- initial_balance  # Private
  
  list(
    deposit = function(amount) {
      if (amount <= 0) stop("Amount must be positive")
      balance <<- balance + amount
      invisible(balance)
    },
    
    withdraw = function(amount) {
      if (amount > balance) stop("Insufficient funds")
      balance <<- balance - amount
      invisible(balance)
    },
    
    get_balance = function() {
      balance
    }
  )
}

account <- create_account(100)
account$deposit(50)
account$withdraw(30)
account$get_balance()

# Can't access balance directly
# account$balance  # NULL (not accessible)

# 4. Package-like namespacing
my_package <- local({
  # Private function
  helper <- function(x) {
    x * 2
  }
  
  # Public functions
  list(
    public_func1 = function(x) {
      helper(x) + 1
    },
    
    public_func2 = function(x) {
      helper(x) - 1
    }
  )
})

my_package$public_func1(5)  # Works
# my_package$helper(5)       # NULL (private)
```
</div>

## Search Path

<div class="insight-box">
üí° **Key Insight: Search Path**

```{r}
# Where R looks for objects
search()

# Order matters!
# 1. Global environment
# 2. Loaded packages (in order)
# 3. Base packages

# Example: name conflicts
library(dplyr)

# Both have filter()
# Which one gets used?
filter  # Shows dplyr::filter

# Use package::function to be explicit
stats::filter  # Base R version
dplyr::filter  # dplyr version

# Check where function comes from
find("filter")
```
</div>

## Debugging Scope Issues

<div class="bestpractice-box">
üéØ **Best Practice: Debug Scoping**

```{r}
# 1. Check where you are
debug_env <- function() {
  cat("Current environment:\n")
  print(environment())
  
  cat("\nParent environment:\n")
  print(parent.env(environment()))
  
  cat("\nObjects in current env:\n")
  print(ls())
}

my_func <- function(x) {
  y <- 10
  debug_env()
}

my_func(5)

# 2. Trace variable lookups
where_is <- function(name) {
  env <- parent.frame()
  
  while (!identical(env, emptyenv())) {
    if (exists(name, envir = env, inherits = FALSE)) {
      return(environmentName(env))
    }
    env <- parent.env(env)
  }
  
  "Not found"
}

x <- 10

test_func <- function() {
  where_is("x")
}

test_func()

# 3. List all variables in scope
ls.all <- function() {
  # Get all environments in search path
  envs <- search()
  
  for (env_name in envs) {
    env <- as.environment(env_name)
    objs <- ls(env)
    if (length(objs) > 0) {
      cat("\n", env_name, ":\n", sep = "")
      cat("  ", paste(head(objs, 10), collapse = ", "), "\n")
      if (length(objs) > 10) {
        cat("  ... and", length(objs) - 10, "more\n")
      }
    }
  }
}

# ls.all()  # Lists everything
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Lexical scoping** - Functions use variables from where they're defined
2. **Function environments** - Each call creates new environment
3. **Search path** - R looks up through parent environments
4. **Local before global** - Local variables shadow global ones
5. **<<- for parent environment** - Use cautiously
6. **Return values preferred** - Better than global modification
7. **Closures retain environment** - Function factories work because of this

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| object not found | Variable in wrong scope | Return from function or use <<- |
| Unexpected value | Using unintended global | Make parameters explicit |
| Function modifies global | Using <<- unintentionally | Use return values |
| Name conflicts | Same name in multiple packages | Use package::function |

**Scoping Rules:**

```{r eval=FALSE}
# R looks for variables in order:
1. Current environment
2. Parent environment (where defined, not called)
3. Parent's parent
4. ... up to global environment
5. Loaded packages
6. Base package

# Assignment
x <- value    # Creates in current environment
x <<- value   # Creates in first parent with x, or global

# Accessing
x             # Searches up environments
get("x")      # Same as above
exists("x")   # Check if exists
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
function(x, y) { x + y }         # Explicit parameters
result <- my_func(data)          # Return and assign
make_counter <- function() { }   # Closures for state

# ‚ùå Avoid
function() { global_var + 5 }    # Implicit global use
my_func <- function() { x <<- 5 } # Modifying global
Assuming variable exists          # Check with exists()
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Scope Exploration**

Predict the output:
```{r eval=FALSE}
x <- 10

func1 <- function() {
  x <- 20
  func2()
}

func2 <- function() {
  x
}

func1()  # What does this return?
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Counter Implementation**

Create a counter using closures:
1. `increment()` - adds 1
2. `decrement()` - subtracts 1
3. `get()` - returns current value
4. `reset()` - sets to 0
</div>

<div class="exercise-box">
üìù **Exercise 3: Function Factory**

Write `make_scaler(center, scale)` that returns a function that:
1. Subtracts center from input
2. Divides by scale
3. Use with built-in datasets
</div>

<div class="exercise-box">
üìù **Exercise 4: Environment Inspector**

Write `inspect_scope()` that:
1. Shows current environment
2. Lists parent environments
3. Shows variables at each level
4. Identifies potential conflicts
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
x <- 10

func1 <- function() {
  x <- 20  # Local x in func1
  func2()
}

func2 <- function() {
  x  # Looks for x where func2 was defined (global)
}

func1()  # Returns 10 (not 20!)

# Why? Lexical scoping:
# func2 was defined in global environment
# So it looks for x in global environment (x = 10)
# NOT where it was called (inside func1 with x = 20)
```

**Exercise 2:**

```{r}
make_counter <- function(initial = 0) {
  count <- initial
  
  list(
    increment = function() {
      count <<- count + 1
      invisible(count)
    },
    
    decrement = function() {
      count <<- count - 1
      invisible(count)
    },
    
    get = function() {
      count
    },
    
    reset = function() {
      count <<- initial
      invisible(count)
    }
  )
}

# Test
counter <- make_counter(10)
counter$increment()
counter$increment()
counter$get()          # 12

counter$decrement()
counter$get()          # 11

counter$reset()
counter$get()          # 10

# Create multiple independent counters
counter1 <- make_counter(0)
counter2 <- make_counter(100)

counter1$increment()
counter2$decrement()

counter1$get()  # 1
counter2$get()  # 99
```

**Exercise 3:**

```{r}
make_scaler <- function(center = 0, scale = 1) {
  # Validate inputs
  if (!is.numeric(center) || length(center) != 1) {
    stop("center must be a single numeric value")
  }
  if (!is.numeric(scale) || length(scale) != 1 || scale == 0) {
    stop("scale must be a single non-zero numeric value")
  }
  
  # Return scaling function
  function(x) {
    if (!is.numeric(x)) {
      stop("x must be numeric")
    }
    (x - center) / scale
  }
}

# Test with mtcars
mpg_mean <- mean(mtcars$mpg)
mpg_sd <- sd(mtcars$mpg)

standardize_mpg <- make_scaler(mpg_mean, mpg_sd)

# Standardize mpg
mpg_scaled <- standardize_mpg(mtcars$mpg)

# Check: should have mean ‚âà 0, sd ‚âà 1
mean(mpg_scaled)
sd(mpg_scaled)

# Create different scalers
scale_0_1 <- make_scaler(
  center = min(mtcars$hp),
  scale = max(mtcars$hp) - min(mtcars$hp)
)

hp_scaled <- scale_0_1(mtcars$hp)
range(hp_scaled)  # Should be 0 to 1
```

**Exercise 4:**

```{r}
inspect_scope <- function() {
  # Get calling environment
  env <- parent.frame()
  
  cat("=== Environment Inspection ===\n\n")
  
  level <- 0
  while (!identical(env, emptyenv())) {
    # Environment name
    env_name <- environmentName(env)
    if (env_name == "") {
      env_name <- paste0("<anonymous ", level, ">")
    }
    
    cat("Level", level, ":", env_name, "\n")
    
    # List objects
    objs <- ls(env, all.names = FALSE)
    if (length(objs) > 0) {
      cat("  Objects:", paste(head(objs, 5), collapse = ", "))
      if (length(objs) > 5) {
        cat(" ... +", length(objs) - 5, "more")
      }
      cat("\n")
      
      # Check for conflicts with parent
      parent_env <- parent.env(env)
      if (!identical(parent_env, emptyenv())) {
        parent_objs <- ls(parent_env, all.names = FALSE)
        conflicts <- intersect(objs, parent_objs)
        if (length(conflicts) > 0) {
          cat("  ‚ö† Shadows parent objects:", 
              paste(conflicts, collapse = ", "), "\n")
        }
      }
    } else {
      cat("  (empty)\n")
    }
    
    cat("\n")
    
    # Move to parent
    env <- parent.env(env)
    level <- level + 1
    
    # Stop at global or after reasonable depth
    if (level > 10) {
      cat("... (stopping after 10 levels)\n")
      break
    }
  }
}

# Test
test_function <- function() {
  local_var <- 123
  x <- "local x"  # Shadows global x if it exists
  
  inspect_scope()
}

x <- "global x"
test_function()
```
</details>

<!--chapter:end:17-scoping-environments.Rmd-->

# Control Flow {#control-flow}

<div class="chapter-summary">
**What You'll Learn:**

- if/else statements
- for, while, repeat loops
- break and next
- switch statements
- Common control flow errors

**Key Errors Covered:** 15+ control flow errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Control flow directs code execution, but has pitfalls:

```{r error=TRUE}
x <- 5

# Looks okay...
if (x > 3 & x < 10) {
  print("In range")
}
```

```{r}
# Works, but what about this?
x <- c(5, 15)

if (x > 3 & x < 10) {  # Warning!
  print("In range")
}
```

Let's master control flow to avoid these issues.

## if/else Basics

<div class="insight-box">
üí° **Key Insight: if Requires Single Logical**

```{r}
# Correct: single TRUE/FALSE
if (TRUE) {
  print("Yes")
}

if (5 > 3) {
  print("Five is greater")
}

# With else
x <- 10
if (x > 5) {
  print("Large")
} else {
  print("Small")
}

# else if
x <- 5
if (x > 10) {
  print("Large")
} else if (x > 5) {
  print("Medium")
} else {
  print("Small")
}

# ifelse for vectors (different!)
x <- c(3, 7, 12)
ifelse(x > 5, "Large", "Small")
```

**Key points:**
- `if` needs single logical value
- `ifelse()` is vectorized (for vectors)
- `if` can have `else` and `else if`
- Braces `{}` recommended even for single lines
</div>

## Error #1: `the condition has length > 1` {#condition-length-gt-1}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Error

```{r error=TRUE}
x <- c(5, 15)

if (x > 10) {
  print("Greater than 10")
}
```

<div class="error-box">
üî¥ **ERROR** (R >= 4.2)

```
Error in if (x > 10) { : the condition has length > 1
```
</div>

In older R versions, this gives a warning and uses only the first element.

### What It Means

You're using a vector in `if` when it expects a single TRUE/FALSE.

### Common Causes

#### Cause 1: Testing Vector

```{r error=TRUE}
ages <- c(15, 25, 35)

if (ages >= 18) {
  print("All adults")
}
```

#### Cause 2: Multiple Conditions

```{r error=TRUE}
x <- 5
y <- 10

# Wrong: creates vector of length 2
if (c(x > 3, y > 8)) {
  print("Both true")
}
```

#### Cause 3: Using | instead of ||

```{r}
x <- c(5, 15)

# & and | are vectorized
x > 3 & x < 10  # Vector of 2 elements

# && and || use only first element
x > 3 && x < 10  # Single logical (from first element)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use && or || for Scalar Conditions**

```{r}
x <- 5
y <- 10

# Logical AND
if (x > 3 && y > 8) {
  print("Both conditions true")
}

# Logical OR  
if (x < 3 || y > 8) {
  print("At least one true")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use all() or any() for Vectors**

```{r}
ages <- c(15, 25, 35)

# Check if all are adults
if (all(ages >= 18)) {
  print("All adults")
} else {
  print("Some minors")
}

# Check if any are adults
if (any(ages >= 18)) {
  print("At least one adult")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use ifelse() for Vectorized Operations**

```{r}
ages <- c(15, 25, 35)

# Vectorized: returns vector
status <- ifelse(ages >= 18, "Adult", "Minor")
status

# Or with dplyr::case_when (cleaner for multiple conditions)
library(dplyr)
case_when(
  ages < 13 ~ "Child",
  ages < 18 ~ "Teen",
  ages < 65 ~ "Adult",
  TRUE ~ "Senior"
)
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Pitfall: & vs && and | vs ||**

```{r}
# For if statements (scalar)
x <- 5
y <- 10

# Use && and || (short-circuit evaluation)
if (x > 3 && y > 8) {
  print("Both true")
}

# For vectors
v1 <- c(TRUE, FALSE, TRUE)
v2 <- c(TRUE, TRUE, FALSE)

# Use & and | (element-wise)
v1 & v2
v1 | v2

# Never use && or || on vectors in if!
```

**Key difference:**
- `&` and `|`: Vectorized, return vector
- `&&` and `||`: Scalar, return single value, short-circuit
</div>

## Error #2: `argument is of length zero` {#argument-length-zero}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Error

```{r error=TRUE}
x <- numeric(0)  # Empty vector

if (x > 5) {
  print("Greater")
}
```

<div class="error-box">
üî¥ **ERROR**

```
Error in if (x > 5) { : argument is of length zero
```
</div>

### What It Means

You're testing an empty vector in `if`.

### Common Causes

#### Cause 1: Empty Result from Operation

```{r error=TRUE}
data <- c(1, 2, 3, 4)
filtered <- data[data > 10]  # Empty!

if (filtered > 0) {
  print("Has values")
}
```

#### Cause 2: Missing Data

```{r error=TRUE}
value <- NA
result <- value[!is.na(value)]  # Empty if all NA

if (length(result) > 0) {  # Good
  # ...
}

if (result > 0) {  # Bad! Error if empty
  # ...
}
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Length First**

```{r}
x <- numeric(0)

if (length(x) > 0 && x[1] > 5) {
  print("First element greater than 5")
}

# Or more robustly
safe_check <- function(x, threshold) {
  if (length(x) == 0) {
    return(FALSE)
  }
  x[1] > threshold
}

if (safe_check(x, 5)) {
  print("Greater")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Provide Default**

```{r}
x <- numeric(0)

# Use default if empty
value <- if (length(x) > 0) x[1] else 0

if (value > 5) {
  print("Greater")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use any() or all()**

```{r}
x <- numeric(0)

# any() and all() handle empty vectors
any(x > 5)  # FALSE (no elements satisfy condition)
all(x > 5)  # TRUE (all zero elements satisfy condition!)

if (any(x > 5)) {
  print("At least one greater")
}
```
</div>

## for Loops

<div class="insight-box">
üí° **Key Insight: for Loop Patterns**

```{r}
# 1. Loop over vector
for (i in 1:5) {
  print(i)
}

# 2. Loop over elements
fruits <- c("apple", "banana", "cherry")
for (fruit in fruits) {
  print(fruit)
}

# 3. Loop with indices
for (i in seq_along(fruits)) {
  cat(i, ":", fruits[i], "\n")
}

# 4. Nested loops
for (i in 1:3) {
  for (j in 1:2) {
    cat("(", i, ",", j, ") ")
  }
  cat("\n")
}

# 5. Pre-allocate results (important for performance!)
n <- 1000
result <- numeric(n)  # Pre-allocate

for (i in 1:n) {
  result[i] <- i^2
}
```

**Best practices:**
- Use `seq_along()` instead of `1:length()`
- Pre-allocate result vectors
- Consider vectorization instead
- Use `for` for side effects (plots, files)
</div>

## Error #3: `object not found` in loops {#loop-object-not-found}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
# Empty vector
values <- numeric(0)

for (i in 1:length(values)) {
  print(values[i])
}
```

<div class="error-box">
üî¥ **ERROR**

```
Error in 1:length(values) : argument of length 0
```
</div>

Wait, that's different. Let me show the real issue:

```{r error=TRUE}
# This actually works (badly)
values <- numeric(0)
for (i in 1:length(values)) {  # 1:0 creates c(1, 0)
  print(i)
}
```

### The Real Problem

```{r}
# 1:length() is dangerous with empty vectors
values <- numeric(0)
1:length(values)  # c(1, 0) - not what you want!

# Safer: seq_along()
seq_along(values)  # integer(0) - correct!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use seq_along()**

```{r}
values <- numeric(0)

# Safe with empty vectors
for (i in seq_along(values)) {
  print(values[i])
}
# Doesn't iterate (correct behavior)

# Works with non-empty too
values <- c(10, 20, 30)
for (i in seq_along(values)) {
  print(values[i])
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Length First**

```{r}
values <- numeric(0)

if (length(values) > 0) {
  for (i in 1:length(values)) {
    print(values[i])
  }
} else {
  message("No values to process")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use seq_len()**

```{r}
n <- 0

# seq_len() handles zero correctly
for (i in seq_len(n)) {
  print(i)
}
# Doesn't iterate

n <- 5
for (i in seq_len(n)) {
  print(i)
}
# Iterates 1 to 5
```
</div>

## while Loops

<div class="insight-box">
üí° **Key Insight: while vs for**

```{r}
# for: known number of iterations
for (i in 1:5) {
  print(i)
}

# while: iterate until condition false
count <- 1
while (count <= 5) {
  print(count)
  count <- count + 1
}

# while with break
count <- 1
while (TRUE) {
  print(count)
  count <- count + 1
  if (count > 5) break
}

# Infinite loop danger!
# while (TRUE) {
#   # Never breaks!
# }
```

**When to use while:**
- Unknown number of iterations
- Convergence checking
- Reading until end
- Waiting for condition
</div>

## break and next

<div class="insight-box">
üí° **Key Insight: Loop Control**

```{r}
# break: exit loop immediately
for (i in 1:10) {
  if (i > 5) break
  print(i)
}
# Prints 1-5, then stops

# next: skip to next iteration
for (i in 1:10) {
  if (i %% 2 == 0) next  # Skip even numbers
  print(i)
}
# Prints only odd numbers

# Combined
for (i in 1:20) {
  if (i > 15) break       # Stop at 15
  if (i %% 2 == 0) next   # Skip evens
  print(i)
}
# Prints odd numbers up to 15

# In nested loops
for (i in 1:3) {
  for (j in 1:3) {
    if (i == j) next  # Skip diagonal
    cat("(", i, ",", j, ") ")
  }
  cat("\n")
}
```
</div>

## repeat Loops

<div class="insight-box">
üí° **Key Insight: repeat Loop**

```{r}
# repeat: infinite loop with break
count <- 0
repeat {
  count <- count + 1
  print(count)
  if (count >= 5) break
}

# Common pattern: read until done
# repeat {
#   line <- readLines(connection, n = 1)
#   if (length(line) == 0) break
#   process(line)
# }

# Convergence checking
tolerance <- 0.001
value <- 10
repeat {
  old_value <- value
  value <- value / 2 + 1
  
  if (abs(value - old_value) < tolerance) {
    break
  }
}
cat("Converged to:", value, "\n")
```
</div>

## switch Statement

<div class="bestpractice-box">
üéØ **Best Practice: switch()**

```{r}
# Cleaner than multiple if/else
operation <- "add"

result <- switch(operation,
  add = 10 + 5,
  subtract = 10 - 5,
  multiply = 10 * 5,
  divide = 10 / 5,
  "Unknown operation"  # Default
)
result

# With functions
calculate <- function(op, x, y) {
  switch(op,
    "+" = x + y,
    "-" = x - y,
    "*" = x * y,
    "/" = x / y,
    stop("Unknown operation: ", op)
  )
}

calculate("+", 10, 5)
calculate("*", 10, 5)

# Numeric switch (uses position)
type <- 2
switch(type,
  "First",    # 1
  "Second",   # 2
  "Third"     # 3
)

# Multiple cases to same result
grade <- "B"
message <- switch(grade,
  "A" = ,
  "B" = "Good job!",
  "C" = ,
  "D" = "Need improvement",
  "F" = "Failed",
  "Invalid grade"
)
message
```
</div>

## Common Loop Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Loop Patterns**

```{r}
# 1. Accumulation
total <- 0
for (i in 1:10) {
  total <- total + i
}
total

# Better: use sum()
sum(1:10)

# 2. Building a result vector
n <- 5
squares <- numeric(n)  # Pre-allocate!
for (i in 1:n) {
  squares[i] <- i^2
}
squares

# Better: vectorize
(1:5)^2

# 3. Processing with indices
data <- c(10, 20, 30, 40)
for (i in seq_along(data)) {
  cat("Element", i, "is", data[i], "\n")
}

# 4. Conditional accumulation
values <- c(1, 5, 3, 8, 2, 9, 4)
count <- 0
for (val in values) {
  if (val > 5) {
    count <- count + 1
  }
}
count

# Better: use sum()
sum(values > 5)

# 5. Early exit
find_first <- function(x, threshold) {
  for (i in seq_along(x)) {
    if (x[i] > threshold) {
      return(i)
    }
  }
  return(NA)
}

find_first(c(1, 3, 7, 2, 9), 5)

# 6. Nested iteration
matrix_data <- matrix(1:9, nrow = 3)
for (i in 1:nrow(matrix_data)) {
  for (j in 1:ncol(matrix_data)) {
    cat(matrix_data[i, j], " ")
  }
  cat("\n")
}

# Better: often use apply family or vectorization
```
</div>

## Vectorization vs Loops

<div class="pitfall-box">
‚ö†Ô∏è **Performance: Vectorization Usually Better**

```{r}
n <- 10000

# Loop (slow)
system.time({
  result <- numeric(n)
  for (i in 1:n) {
    result[i] <- sqrt(i)
  }
})

# Vectorized (fast)
system.time({
  result <- sqrt(1:n)
})

# When to use loops:
# 1. Sequential dependencies
fibonacci <- function(n) {
  fib <- numeric(n)
  fib[1] <- 1
  fib[2] <- 1
  for (i in 3:n) {
    fib[i] <- fib[i-1] + fib[i-2]  # Depends on previous
  }
  fib
}

# 2. Side effects (printing, plotting, file I/O)
for (i in 1:3) {
  plot(1:10, main = paste("Plot", i))
  Sys.sleep(0.1)
}

# 3. Complex logic that can't be vectorized
# 4. Early termination conditions
```
</div>

## ifelse() Details

<div class="insight-box">
üí° **Key Insight: ifelse() Behavior**

```{r}
# Basic ifelse
x <- c(1, 5, 3, 8, 2)
ifelse(x > 4, "High", "Low")

# Nested ifelse
ifelse(x < 3, "Low",
       ifelse(x < 7, "Medium", "High"))

# With NAs
x_na <- c(1, 5, NA, 8, 2)
ifelse(x_na > 4, "High", "Low")  # NA stays NA

# Type coercion in ifelse
ifelse(c(TRUE, FALSE, TRUE), 1, "No")  # Coerces to character!

# More control with dplyr::case_when
library(dplyr)
case_when(
  x < 3 ~ "Low",
  x < 7 ~ "Medium",
  TRUE ~ "High"  # Default
)

# Maintains types better
case_when(
  c(TRUE, FALSE, TRUE) ~ 1L,
  TRUE ~ NA_integer_
)
```

**Prefer case_when() for:**
- Multiple conditions
- Type preservation
- Clearer code
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **if needs single logical** - Use `&&`/`||` not `&`/`|`
2. **Check length first** - Avoid length-zero errors
3. **Use seq_along()** - Not `1:length()` in loops
4. **Pre-allocate vectors** - Important for performance
5. **break exits loop** - `next` skips iteration
6. **Vectorize when possible** - Usually faster than loops
7. **ifelse() is vectorized** - Different from `if`
8. **Use case_when()** - Cleaner than nested ifelse

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| condition has length > 1 | Vector in if | Use `all()`, `any()`, or `&&`/`||` |
| argument is of length zero | Empty vector in if | Check `length()` first |
| Infinite loop | No break condition | Add break or fix condition |
| Wrong 1:length() | Empty vector | Use `seq_along()` |

**Control Flow:**

```{r eval=FALSE}
# if/else
if (condition) {
  # code
} else if (other_condition) {
  # code  
} else {
  # code
}

# ifelse (vectorized)
ifelse(test, yes, no)

# for loop
for (i in seq_along(x)) {
  # code
}

# while loop
while (condition) {
  # code
}

# repeat loop
repeat {
  # code
  if (condition) break
}

# switch
switch(value,
  case1 = result1,
  case2 = result2,
  default
)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
if (length(x) > 0 && x[1] > 5)     # Check length
for (i in seq_along(x))             # Safe indexing
result <- numeric(n); for...       # Pre-allocate
result <- sqrt(x)                   # Vectorize when possible

# ‚ùå Avoid
if (x > 5)                          # Vector in if
for (i in 1:length(x))              # Fails on empty
for... result <- c(result, new)     # Growing vector (slow)
for (i in 1:n) result[i] <- x[i]^2  # Loop when vectorization works
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Safe Condition Checker**

Write `safe_if(condition, true_val, false_val)` that:
1. Checks if condition is single logical
2. Handles NA in condition
3. Returns appropriate value
4. Gives helpful errors
</div>

<div class="exercise-box">
üìù **Exercise 2: Loop Converter**

Convert this loop to vectorized code:
```{r eval=FALSE}
x <- 1:1000
result <- numeric(length(x))
for (i in seq_along(x)) {
  if (x[i] %% 2 == 0) {
    result[i] <- x[i]^2
  } else {
    result[i] <- x[i]^3
  }
}
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Find First**

Write `find_first(x, condition)` that:
1. Finds first element satisfying condition
2. Returns index and value
3. Handles case where none match
4. Uses early exit for efficiency
</div>

<div class="exercise-box">
üìù **Exercise 4: Grade Classifier**

Write `classify_grade(score)` using switch() that:
1. Converts numeric score to letter grade
2. Handles vectorized input
3. Validates input range (0-100)
4. Returns appropriate grade
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
safe_if <- function(condition, true_val, false_val) {
  # Check if condition is logical
  if (!is.logical(condition)) {
    stop("Condition must be logical, got ", class(condition)[1])
  }
  
  # Check length
  if (length(condition) == 0) {
    stop("Condition has length zero")
  }
  
  if (length(condition) > 1) {
    warning("Condition has length ", length(condition), 
            ", using first element only")
    condition <- condition[1]
  }
  
  # Handle NA
  if (is.na(condition)) {
    warning("Condition is NA, returning NA")
    return(NA)
  }
  
  # Return appropriate value
  if (condition) {
    true_val
  } else {
    false_val
  }
}

# Test
safe_if(TRUE, "yes", "no")
safe_if(5 > 3, "greater", "less")
safe_if(NA, "yes", "no")  # Warning
safe_if(c(TRUE, FALSE), "yes", "no")  # Warning
```

```{r error=TRUE}
safe_if("not logical", "yes", "no")  # Error
```

**Exercise 2:**

```{r}
# Original loop
x <- 1:1000
result_loop <- numeric(length(x))
for (i in seq_along(x)) {
  if (x[i] %% 2 == 0) {
    result_loop[i] <- x[i]^2
  } else {
    result_loop[i] <- x[i]^3
  }
}

# Vectorized version 1: ifelse
result_vec1 <- ifelse(x %% 2 == 0, x^2, x^3)

# Vectorized version 2: case_when
library(dplyr)
result_vec2 <- case_when(
  x %% 2 == 0 ~ x^2,
  TRUE ~ x^3
)

# Vectorized version 3: logical indexing
result_vec3 <- numeric(length(x))
even <- x %% 2 == 0
result_vec3[even] <- x[even]^2
result_vec3[!even] <- x[!even]^3

# Verify all give same result
all.equal(result_loop, result_vec1)
all.equal(result_loop, result_vec2)
all.equal(result_loop, result_vec3)

# Compare performance
library(microbenchmark)
microbenchmark(
  loop = {
    result <- numeric(length(x))
    for (i in seq_along(x)) {
      if (x[i] %% 2 == 0) result[i] <- x[i]^2
      else result[i] <- x[i]^3
    }
  },
  ifelse = ifelse(x %% 2 == 0, x^2, x^3),
  case_when = case_when(x %% 2 == 0 ~ x^2, TRUE ~ x^3),
  logical_index = {
    result <- numeric(length(x))
    even <- x %% 2 == 0
    result[even] <- x[even]^2
    result[!even] <- x[!even]^3
  },
  times = 100
)
```

**Exercise 3:**

```{r}
find_first <- function(x, condition) {
  # Validate inputs
  if (!is.function(condition)) {
    stop("condition must be a function")
  }
  
  if (length(x) == 0) {
    return(list(index = NA, value = NA, found = FALSE))
  }
  
  # Search with early exit
  for (i in seq_along(x)) {
    if (condition(x[i])) {
      return(list(
        index = i,
        value = x[i],
        found = TRUE
      ))
    }
  }
  
  # None found
  list(index = NA, value = NA, found = FALSE)
}

# Test
data <- c(1, 3, 5, 8, 2, 9, 4)

# Find first > 5
find_first(data, function(x) x > 5)

# Find first even
find_first(data, function(x) x %% 2 == 0)

# Find first > 100 (none)
find_first(data, function(x) x > 100)

# Empty vector
find_first(numeric(0), function(x) x > 5)

# More complex condition
find_first(c("apple", "banana", "cherry"), 
          function(x) nchar(x) > 5)
```

**Exercise 4:**

```{r}
classify_grade <- function(score) {
  # Validate input
  if (!is.numeric(score)) {
    stop("Score must be numeric")
  }
  
  # Vectorized function
  sapply(score, function(s) {
    # Check range
    if (is.na(s)) {
      return(NA_character_)
    }
    
    if (s < 0 || s > 100) {
      warning("Score ", s, " is out of range (0-100)")
      return("Invalid")
    }
    
    # Classify using switch on integer ranges
    grade_num <- cut(s, 
                    breaks = c(-Inf, 60, 70, 80, 90, Inf),
                    labels = FALSE)
    
    switch(grade_num,
      "F",  # 1: 0-59
      "D",  # 2: 60-69
      "C",  # 3: 70-79
      "B",  # 4: 80-89
      "A"   # 5: 90-100
    )
  })
}

# Test
classify_grade(85)
classify_grade(c(45, 65, 75, 85, 95))
classify_grade(c(95, NA, 105, 65))

# More detailed version with +/-
classify_grade_detailed <- function(score) {
  sapply(score, function(s) {
    if (is.na(s)) return(NA_character_)
    if (s < 0 || s > 100) return("Invalid")
    
    if (s >= 97) return("A+")
    if (s >= 93) return("A")
    if (s >= 90) return("A-")
    if (s >= 87) return("B+")
    if (s >= 83) return("B")
    if (s >= 80) return("B-")
    if (s >= 77) return("C+")
    if (s >= 73) return("C")
    if (s >= 70) return("C-")
    if (s >= 67) return("D+")
    if (s >= 63) return("D")
    if (s >= 60) return("D-")
    return("F")
  })
}

classify_grade_detailed(c(98, 88, 78, 68, 58))
```
</details>

<!--chapter:end:18-control-flow.Rmd-->

# Error Handling {#error-handling}

<div class="chapter-summary">
**What You'll Learn:**

- try() and tryCatch()
- Creating custom errors
- Warning and message handling
- Defensive programming
- Debugging strategies

**Key Errors Covered:** 12+ error handling patterns

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Error handling lets you gracefully handle problems:

```{r error=TRUE}
# Without error handling
result <- log("not a number")
```

```{r}
# With error handling
result <- try(log("not a number"), silent = TRUE)

if (inherits(result, "try-error")) {
  cat("Error occurred, using default value\n")
  result <- NA
}
result
```

Let's master error handling for robust code.

## Error Basics

<div class="insight-box">
üí° **Key Insight: Errors, Warnings, Messages**

```{r error=TRUE}
# Error: stops execution
stop("This is an error")
```

```{r}
# Warning: continues execution
warning("This is a warning")
cat("Execution continues\n")

# Message: informational
message("This is a message")
cat("Execution continues\n")

# Creating conditions
# Error
error_func <- function(x) {
  if (x < 0) {
    stop("x must be non-negative")
  }
  sqrt(x)
}
```

```{r error=TRUE}
error_func(-5)
```

```{r}
# Warning
warn_func <- function(x) {
  if (x < 0) {
    warning("x is negative, taking absolute value")
    x <- abs(x)
  }
  sqrt(x)
}

warn_func(-5)

# Message
message_func <- function(x) {
  message("Calculating square root of ", x)
  sqrt(x)
}

message_func(25)
```
</div>

## try()

<div class="insight-box">
üí° **Key Insight: try() Basics**

```{r}
# Without try: error stops everything
safe_log <- function(x) {
  result <- try(log(x), silent = TRUE)
  
  if (inherits(result, "try-error")) {
    return(NA)
  }
  
  result
}

# Test
safe_log(10)      # Works
safe_log("text")  # Returns NA instead of error

# Process multiple values
values <- list(10, "text", 100, "more text", 50)

results <- lapply(values, safe_log)
results

# Or with verbose errors
results_verbose <- lapply(values, function(x) {
  try(log(x), silent = FALSE)
})
```

**When to use try():**
- Simple error catching
- Don't need to distinguish error types
- Want to return special value on error
- Processing multiple items
</div>

## tryCatch()

<div class="insight-box">
üí° **Key Insight: tryCatch() for Full Control**

```{r}
# Full control over errors, warnings, messages
safe_divide <- function(x, y) {
  tryCatch(
    {
      # Try this code
      if (y == 0) stop("Division by zero")
      x / y
    },
    error = function(e) {
      # Handle error
      message("Error: ", e$message)
      return(Inf)
    },
    warning = function(w) {
      # Handle warning
      message("Warning: ", w$message)
    },
    finally = {
      # Always runs (cleanup)
      message("Division attempted")
    }
  )
}

safe_divide(10, 2)
safe_divide(10, 0)

# More complex example
read_data_safe <- function(file) {
  tryCatch(
    {
      data <- read.csv(file)
      message("Successfully read ", nrow(data), " rows")
      data
    },
    error = function(e) {
      if (grepl("cannot open", e$message)) {
        stop("File not found: ", file)
      } else if (grepl("more columns", e$message)) {
        stop("File format error in: ", file)
      } else {
        stop("Unknown error reading: ", file, "\n", e$message)
      }
    }
  )
}

# Example with warnings
sqrt_checked <- function(x) {
  tryCatch(
    {
      if (!is.numeric(x)) {
        stop("Input must be numeric")
      }
      if (any(x < 0)) {
        warning("Negative values detected, taking absolute value")
        x <- abs(x)
      }
      sqrt(x)
    },
    error = function(e) {
      message("Error: ", e$message)
      return(rep(NA, length(x)))
    },
    warning = function(w) {
      message("Warning caught: ", w$message)
      # Re-signal the warning
      warning(w)
    }
  )
}

sqrt_checked(c(4, -9, 16))
```

**tryCatch() handlers:**
- `error`: catches errors
- `warning`: catches warnings
- `message`: catches messages
- `finally`: always runs (cleanup)
</div>

## Custom Errors

<div class="bestpractice-box">
üéØ **Best Practice: Custom Error Classes**

```{r}
# Create custom error class
validation_error <- function(message, field = NULL) {
  structure(
    list(message = message, field = field),
    class = c("validation_error", "error", "condition")
  )
}

# Function using custom errors
validate_age <- function(age) {
  if (!is.numeric(age)) {
    stop(validation_error(
      "Age must be numeric",
      field = "age"
    ))
  }
  
  if (age < 0) {
    stop(validation_error(
      "Age cannot be negative",
      field = "age"
    ))
  }
  
  if (age > 150) {
    stop(validation_error(
      "Age seems unrealistic",
      field = "age"
    ))
  }
  
  TRUE
}

# Catch and handle custom errors
process_age <- function(age) {
  tryCatch(
    {
      validate_age(age)
      message("Valid age: ", age)
    },
    validation_error = function(e) {
      message("Validation failed for field '", e$field, "': ", e$message)
    },
    error = function(e) {
      message("Other error: ", e$message)
    }
  )
}

process_age(25)
process_age(-5)
process_age("invalid")

# Multiple custom error types
value_error <- function(message, value = NULL) {
  structure(
    list(message = message, value = value),
    class = c("value_error", "error", "condition")
  )
}

type_error <- function(message, expected = NULL, got = NULL) {
  structure(
    list(message = message, expected = expected, got = got),
    class = c("type_error", "error", "condition")
  )
}

# Function with multiple error types
safe_calculate <- function(x, y, op) {
  # Type checking
  if (!is.numeric(x) || !is.numeric(y)) {
    stop(type_error(
      "Inputs must be numeric",
      expected = "numeric",
      got = c(class(x)[1], class(y)[1])
    ))
  }
  
  # Value checking
  if (op == "/" && y == 0) {
    stop(value_error(
      "Cannot divide by zero",
      value = y
    ))
  }
  
  # Calculate
  switch(op,
    "+" = x + y,
    "-" = x - y,
    "*" = x * y,
    "/" = x / y,
    stop("Unknown operation: ", op)
  )
}

# Handle different error types
calculate_safe <- function(x, y, op) {
  tryCatch(
    safe_calculate(x, y, op),
    type_error = function(e) {
      message("Type error: expected ", e$expected, 
              ", got ", paste(e$got, collapse = ", "))
      NA
    },
    value_error = function(e) {
      message("Value error: ", e$message)
      Inf
    },
    error = function(e) {
      message("Other error: ", e$message)
      NA
    }
  )
}

calculate_safe(10, 5, "+")
calculate_safe("10", 5, "+")
calculate_safe(10, 0, "/")
```
</div>

## Defensive Programming

<div class="bestpractice-box">
üéØ **Best Practice: Input Validation**

```{r}
# Comprehensive validation
calculate_mean <- function(x, na.rm = FALSE, trim = 0) {
  # Check x exists and is not NULL
  if (missing(x)) {
    stop("Argument 'x' is missing with no default")
  }
  
  if (is.null(x)) {
    stop("Argument 'x' cannot be NULL")
  }
  
  # Check x type
  if (!is.numeric(x)) {
    stop("Argument 'x' must be numeric, got ", class(x)[1])
  }
  
  # Check x length
  if (length(x) == 0) {
    warning("x has length 0, returning NA")
    return(NA_real_)
  }
  
  # Check na.rm type
  if (!is.logical(na.rm) || length(na.rm) != 1) {
    stop("Argument 'na.rm' must be a single logical value")
  }
  
  # Check trim
  if (!is.numeric(trim) || length(trim) != 1) {
    stop("Argument 'trim' must be a single numeric value")
  }
  
  if (trim < 0 || trim >= 0.5) {
    stop("Argument 'trim' must be in [0, 0.5)")
  }
  
  # All validated, proceed
  mean(x, na.rm = na.rm, trim = trim)
}

# Test
calculate_mean(1:10)
calculate_mean(c(1, 2, NA, 4), na.rm = TRUE)
```

```{r error=TRUE}
calculate_mean("not numeric")
calculate_mean(1:10, na.rm = "yes")
calculate_mean(1:10, trim = 0.6)
```

```{r}
# Reusable validators
is_single_numeric <- function(x, name = "argument") {
  if (!is.numeric(x) || length(x) != 1) {
    stop(name, " must be a single numeric value")
  }
  TRUE
}

is_single_logical <- function(x, name = "argument") {
  if (!is.logical(x) || length(x) != 1) {
    stop(name, " must be a single logical value")
  }
  TRUE
}

is_probability <- function(x, name = "argument") {
  is_single_numeric(x, name)
  if (x < 0 || x > 1) {
    stop(name, " must be between 0 and 1")
  }
  TRUE
}

# Using validators
sample_with_prob <- function(x, size, prob) {
  is_probability(prob, "prob")
  is_single_numeric(size, "size")
  
  # ... rest of function
}
```
</div>

## Assertions

<div class="bestpractice-box">
üéØ **Best Practice: Assertions**

```{r}
# Simple assertions
assert_that <- function(condition, message = "Assertion failed") {
  if (!condition) {
    stop(message, call. = FALSE)
  }
  invisible(TRUE)
}

# Usage
calculate_discount <- function(price, discount_pct) {
  assert_that(is.numeric(price), "price must be numeric")
  assert_that(price > 0, "price must be positive")
  assert_that(is.numeric(discount_pct), "discount_pct must be numeric")
  assert_that(discount_pct >= 0 && discount_pct <= 100, 
              "discount_pct must be between 0 and 100")
  
  price * (1 - discount_pct / 100)
}

calculate_discount(100, 20)
```

```{r error=TRUE}
calculate_discount(-100, 20)
calculate_discount(100, 150)
```

```{r}
# Using assertthat package (if available)
if (requireNamespace("assertthat", quietly = TRUE)) {
  library(assertthat)
  
  validate_input <- function(x) {
    assert_that(is.numeric(x))
    assert_that(length(x) > 0)
    assert_that(all(!is.na(x)))
  }
}

# Stopifnot (base R)
calculate_ratio <- function(x, y) {
  stopifnot(
    "x must be numeric" = is.numeric(x),
    "y must be numeric" = is.numeric(y),
    "y cannot be zero" = all(y != 0)
  )
  
  x / y
}

calculate_ratio(10, 5)
```

```{r error=TRUE}
calculate_ratio(10, 0)
```
</div>

## Warnings and Suppression

<div class="insight-box">
üí° **Key Insight: Warning Control**

```{r}
# Generate warning
careful_sqrt <- function(x) {
  if (any(x < 0)) {
    warning("Negative values found, returning NaN for those")
  }
  sqrt(x)
}

careful_sqrt(c(4, -9, 16))

# Suppress warnings
suppressWarnings({
  result <- careful_sqrt(c(4, -9, 16))
})
result

# Capture warnings
result <- withCallingHandlers(
  careful_sqrt(c(4, -9, 16)),
  warning = function(w) {
    message("Caught warning: ", w$message)
  }
)

# Turn warnings into errors
options(warn = 2)  # Warnings become errors
```

```{r error=TRUE}
careful_sqrt(c(4, -9, 16))  # Now errors!
```

```{r}
options(warn = 0)  # Reset to default

# Suppress specific warnings
suppressWarnings(
  log(-1),  # Would warn: NaNs produced
  classes = "warning"
)

# Count warnings
warn_count <- 0
withCallingHandlers(
  {
    for (i in -5:5) {
      log(i)
    }
  },
  warning = function(w) {
    warn_count <<- warn_count + 1
    invokeRestart("muffleWarning")
  }
)
cat("Warnings generated:", warn_count, "\n")
```
</div>

## Error Recovery

<div class="bestpractice-box">
üéØ **Best Practice: Graceful Failure**

```{r}
# Provide defaults on error
read_config <- function(file, default = list()) {
  tryCatch(
    {
      config <- read.csv(file)
      message("Loaded configuration from ", file)
      config
    },
    error = function(e) {
      warning("Could not read config file, using defaults: ", e$message)
      default
    }
  )
}

# Retry logic
retry <- function(expr, max_attempts = 3, wait = 1) {
  for (attempt in 1:max_attempts) {
    result <- try(expr, silent = TRUE)
    
    if (!inherits(result, "try-error")) {
      return(result)
    }
    
    if (attempt < max_attempts) {
      message("Attempt ", attempt, " failed, retrying...")
      Sys.sleep(wait)
    }
  }
  
  stop("All ", max_attempts, " attempts failed")
}

# Simulate flaky function
flaky_function <- function() {
  if (runif(1) < 0.7) {  # 70% failure rate
    stop("Random failure")
  }
  "Success!"
}

# Use with retry
# result <- retry(flaky_function(), max_attempts = 5)

# Fallback chain
with_fallbacks <- function(...) {
  funcs <- list(...)
  
  for (i in seq_along(funcs)) {
    result <- try(funcs[[i]](), silent = TRUE)
    
    if (!inherits(result, "try-error")) {
      if (i > 1) {
        message("Used fallback #", i)
      }
      return(result)
    }
  }
  
  stop("All fallback options failed")
}

# Example
get_data <- function() {
  with_fallbacks(
    function() {
      # Primary: read from file
      read.csv("data.csv")
    },
    function() {
      # Fallback 1: read from backup
      read.csv("data_backup.csv")
    },
    function() {
      # Fallback 2: use default
      data.frame(x = 1:10, y = 11:20)
    }
  )
}
```
</div>

## on.exit()

<div class="insight-box">
üí° **Key Insight: Cleanup with on.exit()**

```{r}
# Ensure cleanup happens
write_temp_file <- function(data) {
  temp_file <- tempfile()
  
  # Ensure file is deleted even if error occurs
  on.exit(unlink(temp_file))
  
  # Write data
  writeLines(data, temp_file)
  
  # Process (might error)
  processed <- toupper(readLines(temp_file))
  
  processed
  # temp_file automatically deleted here
}

write_temp_file(c("hello", "world"))

# Multiple cleanups
complex_function <- function() {
  conn <- file("temp.txt", "w")
  on.exit(close(conn), add = TRUE)
  
  old_wd <- getwd()
  on.exit(setwd(old_wd), add = TRUE)
  
  old_par <- par(mfrow = c(1, 1))
  on.exit(par(old_par), add = TRUE)
  
  # Do work...
  # All cleanup happens automatically
}

# Conditional cleanup
read_with_progress <- function(file, show_progress = TRUE) {
  if (show_progress) {
    pb <- txtProgressBar(max = 100, style = 3)
    on.exit(close(pb))
  }
  
  # Read file...
  # Progress bar closed automatically if created
}
```
</div>

## Debugging Strategies

<div class="bestpractice-box">
üéØ **Best Practice: Debugging Techniques**

```{r eval=FALSE}
# 1. Print debugging
my_func <- function(x, y) {
  cat("x =", x, "\n")
  cat("y =", y, "\n")
  
  result <- x + y
  cat("result =", result, "\n")
  
  result
}

# 2. Browser debugging
my_func_debug <- function(x, y) {
  browser()  # Pauses execution here
  result <- x + y
  result
}

# 3. Conditional browser
my_func_conditional <- function(x, y) {
  result <- x + y
  
  if (result < 0) {
    browser()  # Only pause if negative
  }
  
  result
}

# 4. Debug function
debug(my_func)  # Next call will enter debugger
my_func(5, 10)
undebug(my_func)

# 5. Recover on error
options(error = recover)  # Enter debugger on error
# ... run code ...
options(error = NULL)  # Reset

# 6. Traceback
tryCatch(
  {
    # Code that errors
  },
  error = function(e) {
    cat("Error occurred:\n")
    print(e)
    cat("\nTraceback:\n")
    print(sys.calls())
  }
)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **try() for simple cases** - Returns special object on error
2. **tryCatch() for full control** - Handle errors, warnings, messages
3. **Custom error classes** - Better error handling
4. **Validate inputs early** - Defensive programming
5. **Use assertions** - Make assumptions explicit
6. **on.exit() for cleanup** - Ensures cleanup happens
7. **Debug systematically** - browser(), debug(), traceback()

**Quick Reference:**

| Function | Purpose | When to Use |
|----------|---------|-------------|
| try() | Simple error catching | Don't need error details |
| tryCatch() | Full error handling | Need to handle differently |
| stop() | Raise error | Invalid input/state |
| warning() | Non-fatal issue | Questionable but proceeding |
| message() | Information | Status updates |
| on.exit() | Cleanup | Files, connections, state |

**Error Handling:**

```{r eval=FALSE}
# try()
result <- try(risky_operation(), silent = TRUE)
if (inherits(result, "try-error")) {
  # Handle error
}

# tryCatch()
tryCatch(
  {
    # Code that might error
  },
  error = function(e) {
    # Handle error
  },
  warning = function(w) {
    # Handle warning
  },
  finally = {
    # Cleanup (always runs)
  }
)

# Custom errors
my_error <- function(msg) {
  structure(
    list(message = msg),
    class = c("my_error", "error", "condition")
  )
}

# Validation
stopifnot(
  "x must be positive" = x > 0,
  "y must be numeric" = is.numeric(y)
)

# Cleanup
on.exit(cleanup(), add = TRUE)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
tryCatch(expr, error = function(e) ...)  # Explicit handling
stopifnot("msg" = condition)             # Named conditions
on.exit(cleanup(), add = TRUE)           # Always cleanup
Validate inputs early                    # Fail fast

# ‚ùå Avoid
try(expr, silent = TRUE) without check   # Ignoring errors
stop() without informative message       # Unclear errors
No input validation                      # Unclear failures
Cleanup without on.exit()                # May not run
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Safe File Reader**

Write `read_file_safe(file, default)` that:
1. Tries to read the file
2. Returns default on error
3. Logs what happened
4. Handles missing file vs corrupt file differently
</div>

<div class="exercise-box">
üìù **Exercise 2: Retry with Backoff**

Write `retry_with_backoff(expr, max_attempts, initial_wait)` that:
1. Retries failed operations
2. Doubles wait time after each failure
3. Returns result or final error
4. Logs attempts
</div>

<div class="exercise-box">
üìù **Exercise 3: Input Validator**

Write `validate_data_frame(df, required_cols, col_types)` that:
1. Checks df is data frame
2. Verifies required columns present
3. Validates column types
4. Returns informative errors
</div>

<div class="exercise-box">
üìù **Exercise 4: Transaction Pattern**

Write `with_transaction(expr)` that:
1. Sets up state before expr
2. Runs expr
3. Commits if successful
4. Rolls back if error
5. Always cleans up
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
read_file_safe <- function(file, default = NULL, verbose = TRUE) {
  tryCatch(
    {
      # Check file exists
      if (!file.exists(file)) {
        stop("File not found: ", file, call. = FALSE)
      }
      
      # Try to read
      data <- readLines(file)
      
      if (verbose) {
        message("Successfully read ", length(data), " lines from ", file)
      }
      
      data
    },
    error = function(e) {
      # Classify error
      if (grepl("File not found", e$message)) {
        if (verbose) {
          warning("File does not exist: ", file, ", using default")
        }
      } else if (grepl("cannot open", e$message)) {
        if (verbose) {
          warning("Cannot open file: ", file, ", using default")
        }
      } else {
        if (verbose) {
          warning("Error reading file: ", e$message, ", using default")
        }
      }
      
      default
    }
  )
}

# Test
read_file_safe("nonexistent.txt", default = c("default", "content"))

# Create test file
writeLines(c("line 1", "line 2"), "test.txt")
read_file_safe("test.txt")
unlink("test.txt")
```

**Exercise 2:**

```{r}
retry_with_backoff <- function(expr, max_attempts = 3, 
                               initial_wait = 1, verbose = TRUE) {
  wait_time <- initial_wait
  
  for (attempt in 1:max_attempts) {
    result <- try(expr, silent = TRUE)
    
    if (!inherits(result, "try-error")) {
      if (verbose && attempt > 1) {
        message("Succeeded on attempt ", attempt)
      }
      return(result)
    }
    
    # Failed
    error_msg <- attr(result, "condition")$message
    
    if (attempt < max_attempts) {
      if (verbose) {
        message("Attempt ", attempt, "/", max_attempts, 
                " failed: ", error_msg)
        message("Waiting ", wait_time, " seconds before retry...")
      }
      
      Sys.sleep(wait_time)
      wait_time <- wait_time * 2  # Exponential backoff
    } else {
      stop("All ", max_attempts, " attempts failed. Last error: ", 
           error_msg)
    }
  }
}

# Test with flaky function
attempt_counter <- 0
flaky_operation <- function() {
  attempt_counter <<- attempt_counter + 1
  if (attempt_counter < 3) {
    stop("Temporary failure")
  }
  "Success!"
}

attempt_counter <- 0
result <- retry_with_backoff(
  flaky_operation(),
  max_attempts = 5,
  initial_wait = 0.1
)
result
```

**Exercise 3:**

```{r}
validate_data_frame <- function(df, required_cols = NULL, col_types = NULL) {
  errors <- character()
  
  # Check is data frame
  if (!is.data.frame(df)) {
    stop("Input must be a data frame, got ", class(df)[1])
  }
  
  # Check required columns
  if (!is.null(required_cols)) {
    missing_cols <- setdiff(required_cols, names(df))
    if (length(missing_cols) > 0) {
      errors <- c(errors, 
        paste("Missing required columns:", 
              paste(missing_cols, collapse = ", "))
      )
    }
  }
  
  # Check column types
  if (!is.null(col_types)) {
    for (col_name in names(col_types)) {
      expected_type <- col_types[[col_name]]
      
      if (!col_name %in% names(df)) {
        errors <- c(errors,
          paste("Column", col_name, "not found for type checking")
        )
        next
      }
      
      actual_type <- class(df[[col_name]])[1]
      
      if (actual_type != expected_type) {
        errors <- c(errors,
          paste("Column", col_name, "has type", actual_type, 
                "but expected", expected_type)
        )
      }
    }
  }
  
  # Report errors
  if (length(errors) > 0) {
    stop("Data frame validation failed:\n  ",
         paste(errors, collapse = "\n  "),
         call. = FALSE)
  }
  
  invisible(TRUE)
}

# Test
df_good <- data.frame(
  id = 1:5,
  name = letters[1:5],
  value = rnorm(5)
)

validate_data_frame(
  df_good,
  required_cols = c("id", "name"),
  col_types = list(id = "integer", name = "character")
)

df_bad <- data.frame(
  id = letters[1:5],  # Wrong type
  value = rnorm(5)
)
```

```{r error=TRUE}
validate_data_frame(
  df_bad,
  required_cols = c("id", "name"),  # Missing name
  col_types = list(id = "integer")  # Wrong type
)
```

**Exercise 4:**

```{r}
with_transaction <- function(expr, setup = NULL, commit = NULL, 
                            rollback = NULL, cleanup = NULL) {
  # Setup
  state <- NULL
  if (!is.null(setup)) {
    message("Setting up transaction...")
    state <- setup()
  }
  
  # Ensure cleanup happens
  on.exit({
    if (!is.null(cleanup)) {
      message("Cleaning up...")
      cleanup(state)
    }
  })
  
  # Try operation
  result <- tryCatch(
    {
      message("Executing transaction...")
      result <- expr
      
      # Commit on success
      if (!is.null(commit)) {
        message("Committing transaction...")
        commit(state, result)
      }
      
      result
    },
    error = function(e) {
      # Rollback on error
      if (!is.null(rollback)) {
        message("Error occurred, rolling back...")
        rollback(state)
      }
      
      stop("Transaction failed: ", e$message, call. = FALSE)
    }
  )
  
  result
}

# Example: Simulated database transaction
db_transaction_example <- function() {
  with_transaction(
    expr = {
      # Simulate operations
      message("  Writing records...")
      Sys.sleep(0.1)
      
      # Simulate error
      if (runif(1) < 0.3) {
        stop("Simulated database error")
      }
      
      message("  Updates complete")
      list(rows_affected = 10)
    },
    setup = function() {
      message("  Opening connection")
      list(conn = "connection_object")
    },
    commit = function(state, result) {
      message("  Committing changes")
    },
    rollback = function(state) {
      message("  Rolling back changes")
    },
    cleanup = function(state) {
      message("  Closing connection")
    }
  )
}

# Try running (may succeed or fail)
# db_transaction_example()
```
</details>

<!--chapter:end:19-error-handling.Rmd-->

# Part VIII: Data Manipulation (dplyr & tidyr) {-}

# Introduction to dplyr {#dplyr-intro}

<div class="chapter-summary">
**What You'll Learn:**

- dplyr basics and philosophy
- The pipe operator (%>% and |>)
- Core dplyr verbs
- Common dplyr errors
- Tidy evaluation basics

**Key Errors Covered:** 20+ dplyr errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

dplyr revolutionized R data manipulation:

```{r error=TRUE}
library(dplyr)

# Try to filter
mtcars %>% filter(mpg > 20)
```

```{r}
# Works! But errors are common...
mtcars %>% filter(mpg > 20 & cyl = 4)  # Oops!
```

Let's master dplyr to avoid these pitfalls.

## dplyr Basics

<div class="insight-box">
üí° **Key Insight: The dplyr Philosophy**

```{r message=FALSE}
library(dplyr)

# Core verbs (functions)
# 1. filter() - keep rows
# 2. select() - keep columns
# 3. mutate() - create/modify columns
# 4. arrange() - sort rows
# 5. summarize() - aggregate data
# 6. group_by() - group for operations

# Each returns a data frame
# Easy to chain with pipe

# Example data
head(mtcars)
```

**Key principles:**
- Each function does one thing well
- First argument is always data
- Returns a data frame
- Works with pipes
- NSE (non-standard evaluation) for column names
</div>

## The Pipe Operator

<div class="insight-box">
üí° **Key Insight: Pipe Operators**

```{r}
# Traditional nesting (hard to read)
result <- arrange(
  filter(
    select(mtcars, mpg, cyl, hp),
    mpg > 20
  ),
  desc(hp)
)

# With magrittr pipe %>%
result <- mtcars %>%
  select(mpg, cyl, hp) %>%
  filter(mpg > 20) %>%
  arrange(desc(hp))

# Native pipe |> (R >= 4.1)
result <- mtcars |>
  select(mpg, cyl, hp) |>
  filter(mpg > 20) |>
  arrange(desc(hp))

result

# How pipe works
# x %>% f(y) becomes f(x, y)
# x %>% f(y) %>% g(z) becomes g(f(x, y), z)

# Pipe sends left side as first argument to right side
mtcars %>% head(3)
# Same as:
head(mtcars, 3)
```

**Differences between %>% and |>:**
- `%>%` from magrittr (more flexible)
- `|>` native R (R >= 4.1, faster)
- `%>%` has more features (., shortcuts)
- `|>` simpler, no package needed
</div>

## Error #1: `object not found` with pipes {#pipe-object-not-found}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
library(dplyr)

mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp) %>%
  arrange(horsepower)  # Wrong column name!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in arrange():
! Can't subset columns that don't exist.
‚úñ Column `horsepower` doesn't exist.
```
</div>

### What It Means

You're referencing a column that doesn't exist in the data.

### Common Causes

#### Cause 1: Typo in Column Name

```{r error=TRUE}
mtcars %>%
  select(mpgg, cyl)  # Typo: mpgg instead of mpg
```

#### Cause 2: Column Already Removed

```{r error=TRUE}
mtcars %>%
  select(mpg, cyl) %>%
  filter(hp > 100)  # hp not in selected columns!
```

#### Cause 3: Wrong Dataset

```{r error=TRUE}
# Expecting different columns
iris %>%
  select(mpg, cyl)  # iris doesn't have these columns
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Column Names**

```{r}
# Before piping, check what you have
names(mtcars)

# Or with glimpse
glimpse(mtcars)

# In pipe chain
mtcars %>%
  names()
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Order Operations Correctly**

```{r}
# Filter before selecting
mtcars %>%
  filter(hp > 100) %>%  # Use hp while it exists
  select(mpg, cyl)      # Then select subset

# Or keep needed columns
mtcars %>%
  select(mpg, cyl, hp) %>%  # Keep hp
  filter(hp > 100)          # Now can use it
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Column Existence Check**

```{r}
safe_filter <- function(data, ...) {
  # Check if columns exist
  expr <- rlang::enexpr(...)
  cols_used <- all.vars(expr)
  
  missing_cols <- setdiff(cols_used, names(data))
  
  if (length(missing_cols) > 0) {
    stop("Columns not found: ", paste(missing_cols, collapse = ", "))
  }
  
  filter(data, ...)
}

# Will give helpful error
# mtcars %>% safe_filter(horsepower > 100)
```
</div>

## filter() Basics

<div class="insight-box">
üí° **Key Insight: filter() Patterns**

```{r}
# Keep rows where condition is TRUE
mtcars %>%
  filter(mpg > 20)

# Multiple conditions (AND)
mtcars %>%
  filter(mpg > 20, cyl == 4)

# Same as
mtcars %>%
  filter(mpg > 20 & cyl == 4)

# OR condition
mtcars %>%
  filter(mpg > 25 | hp > 200)

# Complex conditions
mtcars %>%
  filter(mpg > 20 & (cyl == 4 | cyl == 6))

# Using %in%
mtcars %>%
  filter(cyl %in% c(4, 6))

# Negation
mtcars %>%
  filter(!(cyl %in% c(4, 6)))

# Or
mtcars %>%
  filter(!cyl %in% c(4, 6))

# Filter with string operations
mtcars %>%
  rownames_to_column("car") %>%
  filter(grepl("Merc", car))

# Remove NAs
data_with_na <- tibble(x = c(1, 2, NA, 4))
data_with_na %>%
  filter(!is.na(x))
```
</div>

## Error #2: Using `=` instead of `==` {#filter-equals}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
mtcars %>%
  filter(cyl = 4)  # Wrong: = is assignment
```

<div class="error-box">
üî¥ **ERROR**

```
Error in filter():
! We detected a named input.
‚Ñπ This usually means that you've used `=` instead of `==`.
‚Ñπ Did you mean `cyl == 4`?
```
</div>

### What It Means

You used assignment (`=`) instead of comparison (`==`).

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Use == for Comparison**

```{r}
# Correct: use ==
mtcars %>%
  filter(cyl == 4)

# Other comparison operators
mtcars %>%
  filter(mpg > 20)      # Greater than

mtcars %>%
  filter(mpg >= 20)     # Greater or equal

mtcars %>%
  filter(mpg < 20)      # Less than

mtcars %>%
  filter(mpg <= 20)     # Less or equal

mtcars %>%
  filter(mpg != 4)      # Not equal

# For NA, use is.na()
data_with_na <- tibble(x = c(1, NA, 3))
data_with_na %>%
  filter(is.na(x))      # Keep NAs

data_with_na %>%
  filter(!is.na(x))     # Remove NAs
```
</div>

## select() Basics

<div class="insight-box">
üí° **Key Insight: select() Patterns**

```{r}
# Select specific columns
mtcars %>%
  select(mpg, cyl, hp)

# Select range
mtcars %>%
  select(mpg:hp)

# Select by position
mtcars %>%
  select(1:3)

# Exclude columns
mtcars %>%
  select(-mpg, -cyl)

# Exclude range
mtcars %>%
  select(-(mpg:disp))

# Helper functions
# starts_with()
iris %>%
  select(starts_with("Sepal"))

# ends_with()
iris %>%
  select(ends_with("Width"))

# contains()
iris %>%
  select(contains("etal"))

# matches() - regex
mtcars %>%
  select(matches("^d"))  # Starts with 'd'

# everything() - all remaining
mtcars %>%
  select(mpg, cyl, everything())

# where() - by condition
mtcars %>%
  select(where(is.numeric))

# Rename while selecting
mtcars %>%
  select(miles_per_gallon = mpg, cylinders = cyl)

# Just rename (keep all)
mtcars %>%
  rename(miles_per_gallon = mpg)
```
</div>

## Error #3: `unused argument` in select {#select-unused-argument}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
mtcars %>%
  select(mpg, cyl, cyl == 4)  # Can't filter in select!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in select():
! Can't subset columns with `cyl == 4`.
‚úñ `cyl == 4` must be numeric or character, not `logical`.
```
</div>

### What It Means

You're trying to use filter logic in select, or using wrong syntax.

### Common Causes

```{r error=TRUE}
# Trying to filter in select
mtcars %>%
  select(mpg, cyl > 4)

# Wrong helper syntax
mtcars %>%
  select(starts_with(Sepal))  # Missing quotes
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Separate select and filter**

```{r}
# Correct: separate operations
mtcars %>%
  select(mpg, cyl, hp) %>%
  filter(cyl == 4)

# Or filter first
mtcars %>%
  filter(cyl == 4) %>%
  select(mpg, cyl, hp)

# Use quotes with helpers
iris %>%
  select(starts_with("Sepal"))
```
</div>

## mutate() Basics

<div class="insight-box">
üí° **Key Insight: mutate() Patterns**

```{r}
# Create new column
mtcars %>%
  mutate(mpg_per_cyl = mpg / cyl) %>%
  select(mpg, cyl, mpg_per_cyl)

# Multiple new columns
mtcars %>%
  mutate(
    kpl = mpg * 0.425,
    wt_kg = wt * 453.592
  ) %>%
  select(mpg, kpl, wt, wt_kg)

# Modify existing column
mtcars %>%
  mutate(hp = hp * 0.746) %>%  # Convert to kW
  select(hp)

# Use newly created columns
mtcars %>%
  mutate(
    hp_per_cyl = hp / cyl,
    hp_ratio = hp_per_cyl / mean(hp_per_cyl)
  ) %>%
  select(hp, cyl, hp_per_cyl, hp_ratio)

# Conditional creation
mtcars %>%
  mutate(
    efficiency = case_when(
      mpg > 25 ~ "High",
      mpg > 20 ~ "Medium",
      TRUE ~ "Low"
    )
  ) %>%
  select(mpg, efficiency)

# With ifelse
mtcars %>%
  mutate(
    heavy = ifelse(wt > 3.5, "Heavy", "Light")
  ) %>%
  select(wt, heavy)

# Keep only new columns with transmute()
mtcars %>%
  transmute(
    car = rownames(mtcars),
    kpl = mpg * 0.425
  )
```
</div>

## Error #4: `object not found` in mutate {#mutate-object-not-found}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
mpg_threshold <- 20

mtcars %>%
  mutate(efficient = mpg > mpg_treshold)  # Typo!
```

<div class="error-box">
üî¥ **ERROR**

```
Error in mutate():
! object 'mpg_treshold' not found
```
</div>

### What It Means

Referenced an object or column that doesn't exist.

### Common Causes

```{r error=TRUE}
# Typo in external variable
threshold <- 20
mtcars %>%
  mutate(high = mpg > threshhold)

# Typo in column name
mtcars %>%
  mutate(power_ratio = horsepower / wt)

# Using column before creating it
mtcars %>%
  mutate(
    mpg_ratio = mpg_scaled / mean(mpg_scaled),
    mpg_scaled = mpg / mean(mpg)
  )
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Names Carefully**

```{r}
# Check column names
names(mtcars)

# Check variable exists
threshold <- 20
exists("threshold")

# Correct usage
mtcars %>%
  mutate(efficient = mpg > threshold) %>%
  select(mpg, efficient)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Order Operations**

```{r}
# Create columns in right order
mtcars %>%
  mutate(
    mpg_scaled = mpg / mean(mpg),
    mpg_ratio = mpg_scaled / mean(mpg_scaled)
  ) %>%
  select(mpg, mpg_scaled, mpg_ratio)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use .data pronoun**

```{r}
# Explicit about column reference
mtcars %>%
  mutate(power_ratio = .data$hp / .data$wt) %>%
  select(hp, wt, power_ratio)

# Useful in functions
calculate_ratio <- function(data, num_col, denom_col) {
  data %>%
    mutate(ratio = .data[[num_col]] / .data[[denom_col]])
}

calculate_ratio(mtcars, "hp", "wt") %>%
  select(hp, wt, ratio)
```
</div>

## arrange() Basics

<div class="insight-box">
üí° **Key Insight: arrange() Patterns**

```{r}
# Sort ascending (default)
mtcars %>%
  arrange(mpg) %>%
  select(mpg, cyl, hp)

# Sort descending
mtcars %>%
  arrange(desc(mpg)) %>%
  select(mpg, cyl, hp)

# Multiple columns
mtcars %>%
  arrange(cyl, desc(mpg)) %>%
  select(cyl, mpg, hp)

# With NA handling
data_with_na <- tibble(
  x = c(3, 1, NA, 2),
  y = c("a", "b", "c", "d")
)

data_with_na %>%
  arrange(x)  # NAs last by default

# NAs first
data_with_na %>%
  arrange(desc(is.na(x)), x)
```
</div>

## summarize() Basics

<div class="insight-box">
üí° **Key Insight: summarize() Patterns**

```{r}
# Single summary
mtcars %>%
  summarize(avg_mpg = mean(mpg))

# Multiple summaries
mtcars %>%
  summarize(
    avg_mpg = mean(mpg),
    sd_mpg = sd(mpg),
    min_mpg = min(mpg),
    max_mpg = max(mpg),
    n = n()
  )

# With grouping (next chapter covers in detail)
mtcars %>%
  group_by(cyl) %>%
  summarize(
    avg_mpg = mean(mpg),
    count = n()
  )

# Useful summary functions
mtcars %>%
  summarize(
    mean = mean(mpg),
    median = median(mpg),
    sd = sd(mpg),
    min = min(mpg),
    max = max(mpg),
    q25 = quantile(mpg, 0.25),
    q75 = quantile(mpg, 0.75),
    n = n(),
    n_distinct = n_distinct(cyl)
  )
```
</div>

## Common Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Common dplyr Workflows**

```{r}
# 1. Filter ‚Üí Select ‚Üí Arrange
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp) %>%
  arrange(desc(mpg))

# 2. Create variables ‚Üí Summarize
mtcars %>%
  mutate(hp_per_cyl = hp / cyl) %>%
  summarize(
    avg_hp_per_cyl = mean(hp_per_cyl),
    max_hp_per_cyl = max(hp_per_cyl)
  )

# 3. Group ‚Üí Summarize ‚Üí Arrange
mtcars %>%
  group_by(cyl) %>%
  summarize(
    avg_mpg = mean(mpg),
    count = n()
  ) %>%
  arrange(desc(avg_mpg))

# 4. Top N
mtcars %>%
  arrange(desc(mpg)) %>%
  slice_head(n = 5)

# 5. Distinct values
mtcars %>%
  distinct(cyl, gear)

# 6. Count
mtcars %>%
  count(cyl, sort = TRUE)

# 7. Add row numbers
mtcars %>%
  mutate(row_id = row_number()) %>%
  select(row_id, everything())
```
</div>

## Error #5: Forgetting to assign or print {#forget-assign}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-usage">üí° USAGE</span>

### The Problem

```{r}
# Doesn't save result!
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl)

# Original unchanged
head(mtcars, 2)
```

### What It Means

dplyr doesn't modify in place - must assign result.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Assign Result**

```{r}
# Save to new variable
high_mpg <- mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl)

head(high_mpg, 3)

# Or overwrite (careful!)
mtcars_filtered <- mtcars %>%
  filter(mpg > 20)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Just Print (for exploration)**

```{r}
# Print automatically (no assignment)
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl)

# Explicit print
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl) %>%
  print()
```
</div>

## Debugging dplyr Chains

<div class="bestpractice-box">
üéØ **Best Practice: Debug Pipe Chains**

```{r}
# 1. Run step by step
# Start here
mtcars %>%
  filter(mpg > 20)

# Add next step
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp)

# Continue...
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp) %>%
  arrange(desc(hp))

# 2. Check intermediate results
mtcars %>%
  filter(mpg > 20) %>%
  {cat("After filter:", nrow(.), "rows\n"); .} %>%
  select(mpg, cyl, hp) %>%
  {cat("After select:", ncol(.), "cols\n"); .} %>%
  arrange(desc(hp))

# 3. Use View() in RStudio
# mtcars %>%
#   filter(mpg > 20) %>%
#   View()

# 4. Print at each step
debug_pipe <- function(data, label = NULL) {
  if (!is.null(label)) {
    cat("\n===", label, "===\n")
  }
  print(head(data, 3))
  data
}

mtcars %>%
  filter(mpg > 20) %>%
  debug_pipe("After filter") %>%
  select(mpg, cyl, hp) %>%
  debug_pipe("After select")
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **dplyr philosophy** - Simple verbs, chainable with pipes
2. **Pipe operator** - `%>%` or `|>` makes code readable
3. **filter() uses ==** - Not `=` for comparison
4. **Check column names** - Use `names()` or `glimpse()`
5. **Order matters** - Can't use columns after removing them
6. **Assign results** - dplyr doesn't modify in place
7. **Debug step-by-step** - Run pipes incrementally

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| object not found | Column doesn't exist | Check names, order operations |
| Using = not == | Assignment in filter | Use == for comparison |
| unused argument | Wrong function usage | Check function signature |
| Result not saved | No assignment | Assign with <- |

**Core Verbs:**

```{r eval=FALSE}
# filter() - keep rows
data %>% filter(condition)

# select() - keep columns
data %>% select(col1, col2)

# mutate() - create columns
data %>% mutate(new_col = expression)

# arrange() - sort rows
data %>% arrange(col)
data %>% arrange(desc(col))

# summarize() - aggregate
data %>% summarize(stat = function(col))

# Common helpers
starts_with("prefix")
ends_with("suffix")
contains("text")
where(is.numeric)
everything()
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
data %>% filter(col == value)      # Use ==
data %>% select(col1, col2)        # Select then filter if needed
names(data)                         # Check before selecting
result <- data %>% ...              # Assign result

# ‚ùå Avoid
data %>% filter(col = value)       # Using =
data %>% select(col) %>%           # Then try to use removed col
  filter(other_col > 5)
data %>% filter(...) # no assign    # Result lost
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Basic Pipeline**

Use `mtcars` to:
1. Filter cars with mpg > 20
2. Select mpg, cyl, hp, wt
3. Create hp_per_ton = hp / wt
4. Arrange by hp_per_ton descending
5. Show top 5
</div>

<div class="exercise-box">
üìù **Exercise 2: Error Fixing**

Fix these errors:
```{r eval=FALSE}
# Error 1
mtcars %>%
  filter(cyl = 6)

# Error 2
mtcars %>%
  select(mpg, cyl) %>%
  filter(hp > 100)

# Error 3
mtcars %>%
  mutate(ratio = mpg_per_cyl / wt) %>%
  mutate(mpg_per_cyl = mpg / cyl)
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Select**

Write `safe_select(data, ...)` that:
1. Checks columns exist before selecting
2. Gives helpful error if not found
3. Suggests similar names
4. Works with select helpers
</div>

<div class="exercise-box">
üìù **Exercise 4: Summary Report**

Create function `summarize_by_group(data, group_col, value_col)` that:
1. Groups by specified column
2. Summarizes mean, median, sd, min, max
3. Counts observations
4. Returns sorted by mean descending
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
result <- mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp, wt) %>%
  mutate(hp_per_ton = hp / wt) %>%
  arrange(desc(hp_per_ton)) %>%
  slice_head(n = 5)

result

# Alternative: use top_n (deprecated but still works)
mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp, wt) %>%
  mutate(hp_per_ton = hp / wt) %>%
  slice_max(hp_per_ton, n = 5)
```

**Exercise 2:**

```{r}
# Error 1: Use == not =
mtcars %>%
  filter(cyl == 6)

# Error 2: Keep hp column or filter before select
# Option A: Select hp too
mtcars %>%
  select(mpg, cyl, hp) %>%
  filter(hp > 100)

# Option B: Filter first
mtcars %>%
  filter(hp > 100) %>%
  select(mpg, cyl)

# Error 3: Create mpg_per_cyl before using it
mtcars %>%
  mutate(mpg_per_cyl = mpg / cyl) %>%
  mutate(ratio = mpg_per_cyl / wt)

# Or in one mutate
mtcars %>%
  mutate(
    mpg_per_cyl = mpg / cyl,
    ratio = mpg_per_cyl / wt
  )
```

**Exercise 3:**

```{r}
safe_select <- function(data, ...) {
  # Capture expressions
  cols <- rlang::enquos(...)
  
  # Get all column names in data
  data_cols <- names(data)
  
  # Evaluate each selection
  for (col_expr in cols) {
    col_name <- rlang::as_name(col_expr)
    
    # Skip if it's a helper function call
    if (grepl("^(starts_with|ends_with|contains|matches|everything|where)", 
              col_name)) {
      next
    }
    
    # Check if column exists
    if (!col_name %in% data_cols) {
      # Find similar names
      similar <- agrep(col_name, data_cols, max.distance = 0.3, value = TRUE)
      
      error_msg <- paste0("Column '", col_name, "' not found in data.")
      
      if (length(similar) > 0) {
        error_msg <- paste0(error_msg, "\nDid you mean: ",
                           paste(similar, collapse = ", "), "?")
      }
      
      error_msg <- paste0(error_msg, "\nAvailable columns: ",
                         paste(data_cols, collapse = ", "))
      
      stop(error_msg, call. = FALSE)
    }
  }
  
  # If all checks pass, do the select
  select(data, !!!cols)
}

# Test
safe_select(mtcars, mpg, cyl, hp)
```

```{r error=TRUE}
safe_select(mtcars, mpg, horsepower)  # Helpful error
```

**Exercise 4:**

```{r}
summarize_by_group <- function(data, group_col, value_col) {
  # Use across for flexible column selection
  data %>%
    group_by(across({{ group_col }})) %>%
    summarize(
      n = n(),
      mean = mean({{ value_col }}, na.rm = TRUE),
      median = median({{ value_col }}, na.rm = TRUE),
      sd = sd({{ value_col }}, na.rm = TRUE),
      min = min({{ value_col }}, na.rm = TRUE),
      max = max({{ value_col }}, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(desc(mean))
}

# Test
summarize_by_group(mtcars, cyl, mpg)
summarize_by_group(mtcars, gear, hp)

# With iris
summarize_by_group(iris, Species, Sepal.Length)
```
</details>

<!--chapter:end:20-dplyr-intro.Rmd-->

# Grouping & Summarizing {#dplyr-grouping}

<div class="chapter-summary">
**What You'll Learn:**

- group_by() mechanics
- Grouped operations
- summarize() with groups
- Common grouping errors
- Multiple grouping variables
- Ungrouping data

**Key Errors Covered:** 18+ grouping errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Grouping is one of dplyr's most powerful features:

```{r message=FALSE}
library(dplyr)

# Without grouping
mtcars %>%
  summarize(avg_mpg = mean(mpg))

# With grouping
mtcars %>%
  group_by(cyl) %>%
  summarize(avg_mpg = mean(mpg))
```

But grouping has surprising behaviors. Let's master it!

## group_by() Basics

<div class="insight-box">
üí° **Key Insight: group_by() Creates Invisible Groups**

```{r}
# Create grouped data
grouped_data <- mtcars %>%
  group_by(cyl)

# Looks the same when printed
head(grouped_data, 3)

# But it's grouped!
class(grouped_data)
groups(grouped_data)

# Check if grouped
is_grouped_df(grouped_data)

# See grouping variables
group_vars(grouped_data)

# Count groups
n_groups(grouped_data)

# Subsequent operations work within groups
grouped_data %>%
  summarize(avg_mpg = mean(mpg))
```

**Key insight:** Grouping doesn't change data, just how operations apply!
</div>

## Error #1: Forgetting Data is Grouped {#forgot-grouped}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r}
# Group the data
cars_grouped <- mtcars %>%
  group_by(cyl)

# Later in code... expecting ungrouped behavior
cars_grouped %>%
  mutate(rank = row_number())  # Ranks within groups!
```

### What Happened

`row_number()` operated within each group, not across all data.

### Common Causes

```{r}
# Expecting overall statistics
mtcars %>%
  group_by(cyl) %>%
  mutate(
    overall_mean = mean(mpg)  # Actually group means!
  ) %>%
  select(cyl, mpg, overall_mean)

# Expecting all rows
mtcars %>%
  group_by(cyl) %>%
  slice(1)  # Gets first row of EACH group, not overall first

# Filtering
mtcars %>%
  group_by(cyl) %>%
  filter(mpg == max(mpg))  # Max within each group
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Ungroup When Done**

```{r}
# Ungroup explicitly
result <- mtcars %>%
  group_by(cyl) %>%
  summarize(avg_mpg = mean(mpg)) %>%
  ungroup()  # Remove grouping

# Now operations are ungrouped
result %>%
  mutate(rank = row_number())  # Ranks across all rows
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check Grouping Status**

```{r}
# Always check if data is grouped
check_grouping <- function(data) {
  if (is_grouped_df(data)) {
    message("Data is grouped by: ", paste(group_vars(data), collapse = ", "))
  } else {
    message("Data is not grouped")
  }
  invisible(data)
}

mtcars %>%
  group_by(cyl) %>%
  check_grouping() %>%
  summarize(avg_mpg = mean(mpg)) %>%
  check_grouping()
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use .groups Argument**

```{r}
# Control grouping in summarize
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    avg_mpg = mean(mpg),
    .groups = "drop"  # Ungroup completely
  )

# Keep some grouping
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    avg_mpg = mean(mpg),
    .groups = "drop_last"  # Keep cyl grouping
  ) %>%
  group_vars()

# Keep all groups
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    avg_mpg = mean(mpg),
    .groups = "keep"
  ) %>%
  group_vars()
```
</div>

## summarize() with Groups

<div class="insight-box">
üí° **Key Insight: summarize() Reduces Groups**

```{r}
# Single grouping variable
mtcars %>%
  group_by(cyl) %>%
  summarize(
    n = n(),
    avg_mpg = mean(mpg),
    sd_mpg = sd(mpg)
  )

# Multiple grouping variables
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    n = n(),
    avg_mpg = mean(mpg),
    .groups = "drop"
  )

# Useful summary functions
mtcars %>%
  group_by(cyl) %>%
  summarize(
    count = n(),                    # Number of observations
    n_distinct = n_distinct(gear),  # Unique values
    mean = mean(mpg),
    median = median(mpg),
    sd = sd(mpg),
    min = min(mpg),
    max = max(mpg),
    first = first(mpg),             # First value
    last = last(mpg),               # Last value
    nth = nth(mpg, 2)               # Nth value
  )

# Multiple values from same column
mtcars %>%
  group_by(cyl) %>%
  summarize(
    mpg_stats = list(summary(mpg))  # List column
  )
```
</div>

## Error #2: `must be length 1, not ...` {#summarize-length}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
mtcars %>%
  group_by(cyl) %>%
  summarize(
    top_mpg = head(mpg, 3)  # Returns multiple values!
  )
```

<div class="error-box">
üî¥ **ERROR**

```
Error in summarize():
! `top_mpg` must be size 1, not 3.
```
</div>

### What It Means

`summarize()` expects functions that return a single value per group, not vectors.

### Common Causes

```{r error=TRUE}
# Functions returning multiple values
mtcars %>%
  group_by(cyl) %>%
  summarize(all_mpg = mpg)  # All values, not one

mtcars %>%
  group_by(cyl) %>%
  summarize(quantiles = quantile(mpg))  # Returns 5 values

mtcars %>%
  group_by(cyl) %>%
  summarize(range = range(mpg))  # Returns 2 values
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use Single-Value Functions**

```{r}
# Functions that return one value
mtcars %>%
  group_by(cyl) %>%
  summarize(
    mean_mpg = mean(mpg),
    max_mpg = max(mpg),
    min_mpg = min(mpg),
    n_obs = n()
  )

# For ranges, get separately
mtcars %>%
  group_by(cyl) %>%
  summarize(
    min_mpg = min(mpg),
    max_mpg = max(mpg)
  )
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use reframe() for Multiple Rows**

```{r}
# reframe() allows multiple rows per group (dplyr >= 1.1.0)
if (packageVersion("dplyr") >= "1.1.0") {
  mtcars %>%
    group_by(cyl) %>%
    reframe(
      top_3_mpg = head(sort(mpg, decreasing = TRUE), 3)
    )
}

# For older dplyr, use summarize with list
mtcars %>%
  group_by(cyl) %>%
  summarize(
    top_3_mpg = list(head(sort(mpg, decreasing = TRUE), 3))
  ) %>%
  tidyr::unnest(top_3_mpg)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use slice() Instead**

```{r}
# Get top N rows per group with slice
mtcars %>%
  group_by(cyl) %>%
  slice_max(mpg, n = 3) %>%
  select(cyl, mpg)

# Or with arrange and slice
mtcars %>%
  group_by(cyl) %>%
  arrange(desc(mpg)) %>%
  slice(1:3) %>%
  select(cyl, mpg)
```
</div>

## mutate() with Groups

<div class="insight-box">
üí° **Key Insight: mutate() Keeps All Rows**

```{r}
# mutate() operates within groups but keeps all rows
mtcars %>%
  group_by(cyl) %>%
  mutate(
    group_mean = mean(mpg),
    deviation = mpg - group_mean
  ) %>%
  select(cyl, mpg, group_mean, deviation) %>%
  arrange(cyl, mpg)

# Ranking within groups
mtcars %>%
  group_by(cyl) %>%
  mutate(
    mpg_rank = rank(desc(mpg)),
    mpg_dense_rank = dense_rank(desc(mpg)),
    mpg_row_number = row_number(desc(mpg))
  ) %>%
  select(cyl, mpg, mpg_rank, mpg_dense_rank, mpg_row_number) %>%
  arrange(cyl, desc(mpg))

# Cumulative operations within groups
mtcars %>%
  group_by(cyl) %>%
  arrange(mpg) %>%
  mutate(
    cumsum_mpg = cumsum(mpg),
    cummax_mpg = cummax(mpg)
  ) %>%
  select(cyl, mpg, cumsum_mpg, cummax_mpg)

# Lead and lag within groups
mtcars %>%
  group_by(cyl) %>%
  arrange(mpg) %>%
  mutate(
    prev_mpg = lag(mpg),
    next_mpg = lead(mpg),
    diff_from_prev = mpg - lag(mpg)
  ) %>%
  select(cyl, mpg, prev_mpg, next_mpg, diff_from_prev)
```
</div>

## filter() with Groups

<div class="insight-box">
üí° **Key Insight: filter() with Groups**

```{r}
# Filter based on group statistics
mtcars %>%
  group_by(cyl) %>%
  filter(mpg > mean(mpg)) %>%
  select(cyl, mpg) %>%
  arrange(cyl, mpg)

# Keep only groups meeting criteria
mtcars %>%
  group_by(cyl) %>%
  filter(n() >= 10) %>%  # Only groups with 10+ observations
  select(cyl) %>%
  distinct()

# Top N per group
mtcars %>%
  group_by(cyl) %>%
  filter(rank(desc(mpg)) <= 2) %>%
  select(cyl, mpg) %>%
  arrange(cyl, desc(mpg))

# Filter by group condition
mtcars %>%
  group_by(cyl) %>%
  filter(mean(mpg) > 20) %>%  # Only groups with avg mpg > 20
  select(cyl, mpg)
```
</div>

## Multiple Grouping Variables

<div class="insight-box">
üí° **Key Insight: Multiple Groups**

```{r}
# Group by multiple variables
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    n = n(),
    avg_mpg = mean(mpg),
    .groups = "drop"
  )

# Order matters for operations
mtcars %>%
  group_by(cyl, gear) %>%
  mutate(
    rank_in_cyl_gear = row_number(desc(mpg))
  ) %>%
  select(cyl, gear, mpg, rank_in_cyl_gear) %>%
  arrange(cyl, gear, desc(mpg))

# Count combinations
mtcars %>%
  count(cyl, gear)

# Or with group_by + summarize
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(n = n(), .groups = "drop")
```
</div>

## Error #3: Unexpected Grouping After summarize() {#unexpected-grouping}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r}
# Summarize with multiple groups
result <- mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg))  # Message about grouping

# Still grouped!
is_grouped_df(result)
group_vars(result)

# Next operation uses this grouping
result %>%
  mutate(rank = row_number())  # Within cyl groups!
```

### What Happened

By default, `summarize()` drops the last grouping variable but keeps others.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use .groups = "drop"**

```{r}
# Ungroup completely
result <- mtcars %>%
  group_by(cyl, gear) %>%
  summarize(
    avg_mpg = mean(mpg),
    .groups = "drop"
  )

is_grouped_df(result)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Explicit ungroup()**

```{r}
result <- mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg)) %>%
  ungroup()

is_grouped_df(result)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Understand .groups Options**

```{r}
# .groups = "drop_last" (default)
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg), .groups = "drop_last") %>%
  group_vars()  # Still has cyl

# .groups = "keep"
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg), .groups = "keep") %>%
  group_vars()  # Has both cyl and gear

# .groups = "drop"
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg), .groups = "drop") %>%
  group_vars()  # No groups

# .groups = "rowwise"
mtcars %>%
  group_by(cyl, gear) %>%
  summarize(avg_mpg = mean(mpg), .groups = "rowwise") %>%
  class()
```
</div>

## Window Functions

<div class="bestpractice-box">
üéØ **Best Practice: Window Functions with Groups**

```{r}
# Ranking functions
mtcars %>%
  group_by(cyl) %>%
  mutate(
    rank = rank(desc(mpg)),           # Ties get average rank
    dense_rank = dense_rank(desc(mpg)), # Ties get same rank, no gaps
    row_number = row_number(desc(mpg)), # Ties broken arbitrarily
    percent_rank = percent_rank(desc(mpg)), # Percentile
    cume_dist = cume_dist(desc(mpg))   # Cumulative distribution
  ) %>%
  select(cyl, mpg, rank, dense_rank, row_number, percent_rank, cume_dist) %>%
  arrange(cyl, desc(mpg))

# Lead and lag
mtcars %>%
  group_by(cyl) %>%
  arrange(mpg) %>%
  mutate(
    prev_value = lag(mpg, 1),      # Previous value
    next_value = lead(mpg, 1),     # Next value
    prev_2 = lag(mpg, 2),          # 2 rows back
    change = mpg - lag(mpg, 1)     # Change from previous
  ) %>%
  select(cyl, mpg, prev_value, next_value, change)

# Cumulative functions
mtcars %>%
  group_by(cyl) %>%
  arrange(mpg) %>%
  mutate(
    cumsum = cumsum(mpg),
    cummean = cummean(mpg),
    cummin = cummin(mpg),
    cummax = cummax(mpg)
  ) %>%
  select(cyl, mpg, cumsum, cummean, cummin, cummax)

# Offset functions
mtcars %>%
  group_by(cyl) %>%
  arrange(mpg) %>%
  mutate(
    first_val = first(mpg),
    last_val = last(mpg),
    nth_val = nth(mpg, 3)
  ) %>%
  select(cyl, mpg, first_val, last_val, nth_val)
```
</div>

## count() and add_count()

<div class="insight-box">
üí° **Key Insight: Counting Shortcuts**

```{r}
# count() is shortcut for group_by + summarize + ungroup
mtcars %>%
  count(cyl)

# Equivalent to:
mtcars %>%
  group_by(cyl) %>%
  summarize(n = n()) %>%
  ungroup()

# Multiple variables
mtcars %>%
  count(cyl, gear)

# With sorting
mtcars %>%
  count(cyl, sort = TRUE)

# With weights
mtcars %>%
  count(cyl, wt = mpg)  # Sum of mpg instead of count

# add_count() keeps all rows
mtcars %>%
  add_count(cyl) %>%
  select(cyl, n, everything())

# Name the count column
mtcars %>%
  add_count(cyl, name = "n_per_cyl") %>%
  select(cyl, n_per_cyl, mpg)
```
</div>

## across() for Multiple Columns

<div class="bestpractice-box">
üéØ **Best Practice: across() for Multiple Columns**

```{r}
# Summarize multiple columns
mtcars %>%
  group_by(cyl) %>%
  summarize(
    across(c(mpg, hp, wt), mean),
    .groups = "drop"
  )

# With named functions
mtcars %>%
  group_by(cyl) %>%
  summarize(
    across(c(mpg, hp, wt), 
           list(mean = mean, sd = sd),
           .names = "{.col}_{.fn}"),
    .groups = "drop"
  )

# Using selection helpers
mtcars %>%
  group_by(cyl) %>%
  summarize(
    across(where(is.numeric), mean),
    .groups = "drop"
  )

# In mutate
mtcars %>%
  group_by(cyl) %>%
  mutate(
    across(c(mpg, hp), 
           ~ . - mean(.),
           .names = "{.col}_centered")
  ) %>%
  select(cyl, mpg, mpg_centered, hp, hp_centered)

# Multiple functions
mtcars %>%
  group_by(cyl) %>%
  summarize(
    across(c(mpg, hp), 
           list(min = min, max = max, mean = mean)),
    .groups = "drop"
  )
```
</div>

## Common Pitfalls

<div class="pitfall-box">
‚ö†Ô∏è **Common Grouping Pitfalls**

```{r}
# Pitfall 1: Forgetting to ungroup
bad <- mtcars %>%
  group_by(cyl) %>%
  mutate(mpg_scaled = mpg / mean(mpg))
# Still grouped!

good <- mtcars %>%
  group_by(cyl) %>%
  mutate(mpg_scaled = mpg / mean(mpg)) %>%
  ungroup()

# Pitfall 2: Summarizing already summarized data
mtcars %>%
  group_by(cyl) %>%
  summarize(avg_mpg = mean(mpg)) %>%
  summarize(overall_avg = mean(avg_mpg))  # Wrong! Treats groups equally

# Correct: weight by group size
mtcars %>%
  group_by(cyl) %>%
  summarize(
    avg_mpg = mean(mpg),
    n = n(),
    .groups = "drop"
  ) %>%
  summarize(overall_avg = sum(avg_mpg * n) / sum(n))

# Pitfall 3: Group order affecting row_number
set.seed(123)
df <- tibble(
  group = rep(c("A", "B"), each = 3),
  value = sample(1:6)
)

# Different results!
df %>% group_by(group) %>% mutate(rn = row_number())
df %>% arrange(value) %>% group_by(group) %>% mutate(rn = row_number())

# Pitfall 4: Comparing grouped vs ungrouped
mtcars %>%
  group_by(cyl) %>%
  filter(mpg == max(mpg)) %>%  # Max within each cyl
  nrow()

mtcars %>%
  filter(mpg == max(mpg)) %>%  # Overall max
  nrow()
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **group_by() is invisible** - Data looks same but behaves differently
2. **Always ungroup** - Use `ungroup()` or `.groups = "drop"`
3. **summarize() reduces groups** - Drops last group by default
4. **mutate() keeps all rows** - Operations within groups
5. **Window functions** - Work great with groups
6. **Check grouping status** - Use `group_vars()` or `is_grouped_df()`
7. **across() for multiple columns** - Apply same operation to many columns

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| Unexpected grouped behavior | Forgot data is grouped | Check with `group_vars()`, use `ungroup()` |
| must be size 1 | summarize() with vector | Use single-value function or `reframe()` |
| Wrong statistics | Operating on groups | Ungroup or use different operation |

**Grouping Operations:**

```{r eval=FALSE}
# Basic grouping
data %>% group_by(col)

# Multiple groups
data %>% group_by(col1, col2)

# Ungroup
data %>% ungroup()

# Check grouping
group_vars(data)
is_grouped_df(data)
n_groups(data)

# Summarize with groups
data %>%
  group_by(col) %>%
  summarize(stat = mean(value), .groups = "drop")

# Mutate with groups (keeps all rows)
data %>%
  group_by(col) %>%
  mutate(group_mean = mean(value))

# Filter with groups
data %>%
  group_by(col) %>%
  filter(value > mean(value))

# Count
data %>% count(col)
data %>% add_count(col)

# across for multiple columns
data %>%
  group_by(col) %>%
  summarize(across(where(is.numeric), mean))
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
data %>% group_by(col) %>% 
  summarize(stat = mean(x), .groups = "drop")  # Explicit ungrouping
data %>% group_by(col) %>% ... %>% ungroup()   # Ungroup at end
Always check: group_vars(data)                  # Verify grouping

# ‚ùå Avoid
data %>% group_by(col) %>% summarize(...)      # No .groups argument
Leave data grouped                               # Causes confusion later
Assume data is/isn't grouped                     # Always check
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Group Statistics**

Using `mtcars`:
1. Group by cyl
2. Calculate mean, median, sd of mpg per group
3. Add count and min/max mpg
4. Sort by mean mpg descending
5. Ensure result is ungrouped
</div>

<div class="exercise-box">
üìù **Exercise 2: Window Functions**

Using `mtcars`:
1. Group by cyl
2. Add rank of mpg within each cyl
3. Add difference from group mean
4. Add percentile within group
5. Keep only top 2 per group
</div>

<div class="exercise-box">
üìù **Exercise 3: Group Detector**

Write `check_grouped_operations(data)` that:
1. Checks if data is grouped
2. Shows what grouping variables exist
3. Warns about potential issues
4. Suggests when to ungroup
</div>

<div class="exercise-box">
üìù **Exercise 4: Grouped Summary Report**

Write `grouped_summary(data, group_vars, summary_vars)` that:
1. Groups by specified columns
2. Summarizes multiple statistics for each summary variable
3. Includes count and percentage of total
4. Returns ungrouped, sorted result
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
result <- mtcars %>%
  group_by(cyl) %>%
  summarize(
    count = n(),
    mean_mpg = mean(mpg),
    median_mpg = median(mpg),
    sd_mpg = sd(mpg),
    min_mpg = min(mpg),
    max_mpg = max(mpg),
    .groups = "drop"
  ) %>%
  arrange(desc(mean_mpg))

result

# Verify it's ungrouped
is_grouped_df(result)
```

**Exercise 2:**

```{r}
result <- mtcars %>%
  group_by(cyl) %>%
  mutate(
    mpg_rank = rank(desc(mpg)),
    deviation_from_mean = mpg - mean(mpg),
    percentile = percent_rank(mpg)
  ) %>%
  filter(mpg_rank <= 2) %>%
  select(cyl, mpg, mpg_rank, deviation_from_mean, percentile) %>%
  arrange(cyl, mpg_rank) %>%
  ungroup()

result
```

**Exercise 3:**

```{r}
check_grouped_operations <- function(data, warn_threshold = 3) {
  cat("=== Grouping Analysis ===\n\n")
  
  # Check if grouped
  if (!is_grouped_df(data)) {
    cat("‚úì Data is NOT grouped\n")
    return(invisible(data))
  }
  
  # Get grouping info
  grp_vars <- group_vars(data)
  n_grps <- n_groups(data)
  
  cat("‚ö† Data IS grouped\n")
  cat("Grouping variables:", paste(grp_vars, collapse = ", "), "\n")
  cat("Number of groups:", n_grps, "\n\n")
  
  # Group sizes
  grp_sizes <- data %>%
    summarize(n = n(), .groups = "drop") %>%
    pull(n)
  
  cat("Group size summary:\n")
  cat("  Min:", min(grp_sizes), "\n")
  cat("  Max:", max(grp_sizes), "\n")
  cat("  Mean:", round(mean(grp_sizes), 1), "\n\n")
  
  # Warnings
  if (length(grp_vars) > warn_threshold) {
    warning("Many grouping variables (", length(grp_vars), 
            ") may lead to many small groups")
  }
  
  if (any(grp_sizes == 1)) {
    warning("Some groups have only 1 observation")
  }
  
  # Suggestions
  cat("Suggestions:\n")
  cat("  - Use ungroup() when done with grouped operations\n")
  cat("  - Or use .groups = 'drop' in summarize()\n")
  cat("  - Check grouping with group_vars() before operations\n")
  
  invisible(data)
}

# Test
mtcars %>%
  group_by(cyl) %>%
  check_grouped_operations()

mtcars %>%
  group_by(cyl, gear, carb) %>%
  check_grouped_operations()
```

**Exercise 4:**

```{r}
grouped_summary <- function(data, group_vars, summary_vars) {
  # Get total count for percentages
  total_n <- nrow(data)
  
  # Create summary
  result <- data %>%
    group_by(across(all_of(group_vars))) %>%
    summarize(
      count = n(),
      pct_of_total = n() / total_n * 100,
      across(
        all_of(summary_vars),
        list(
          mean = ~mean(., na.rm = TRUE),
          median = ~median(., na.rm = TRUE),
          sd = ~sd(., na.rm = TRUE),
          min = ~min(., na.rm = TRUE),
          max = ~max(., na.rm = TRUE)
        ),
        .names = "{.col}_{.fn}"
      ),
      .groups = "drop"
    ) %>%
    arrange(desc(count))
  
  result
}

# Test
grouped_summary(
  mtcars,
  group_vars = c("cyl"),
  summary_vars = c("mpg", "hp")
)

grouped_summary(
  mtcars,
  group_vars = c("cyl", "gear"),
  summary_vars = c("mpg", "hp", "wt")
)

# With iris
grouped_summary(
  iris,
  group_vars = "Species",
  summary_vars = c("Sepal.Length", "Sepal.Width", "Petal.Length")
)
```
</details>

<!--chapter:end:21-dplyr-grouping.Rmd-->

# Joins & Merging {#dplyr-joins}

<div class="chapter-summary">
**What You'll Learn:**

- Types of joins (inner, left, right, full)
- Join keys and matching
- Common join errors
- Multiple key joins
- Handling duplicates
- Anti and semi joins

**Key Errors Covered:** 20+ join errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Joining combines data from multiple sources:

```{r message=FALSE}
library(dplyr)

# Two related datasets
customers <- tibble(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie")
)

orders <- tibble(
  order_id = 1:4,
  customer_id = c(1, 1, 2, 4),
  amount = c(100, 150, 200, 75)
)

# Join them
customers %>%
  left_join(orders, by = c("id" = "customer_id"))
```

But joins have many pitfalls. Let's master them!

## Join Types

<div class="insight-box">
üí° **Key Insight: Four Main Join Types**

```{r}
# Sample data
band_members
band_instruments

# inner_join: Only matching rows
band_members %>%
  inner_join(band_instruments, by = "name")

# left_join: All from left, matching from right
band_members %>%
  left_join(band_instruments, by = "name")

# right_join: All from right, matching from left
band_members %>%
  right_join(band_instruments, by = "name")

# full_join: All rows from both
band_members %>%
  full_join(band_instruments, by = "name")
```

**Visual representation:**
- `inner_join`: ‚à© (intersection)
- `left_join`: ‚Üê (left + intersection)
- `right_join`: ‚Üí (right + intersection)
- `full_join`: ‚à™ (union, all rows)
</div>

## Error #1: `by must be supplied` {#join-by-missing}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
df1 <- tibble(id = 1:3, x = c("a", "b", "c"))
df2 <- tibble(identifier = 1:3, y = c("d", "e", "f"))

df1 %>%
  left_join(df2)
```

<div class="error-box">
üî¥ **ERROR** (dplyr >= 1.1.0)

```
Error in left_join():
! `by` must be supplied when `x` and `y` have no common variables.
```
</div>

### What It Means

The two datasets have no columns with the same name, so dplyr doesn't know how to join them.

### Common Causes

```{r error=TRUE}
# Different column names for same concept
customers <- tibble(customer_id = 1:3, name = c("A", "B", "C"))
orders <- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200))

customers %>%
  left_join(orders)  # No common columns!

# Typo in column name
df1 <- tibble(id = 1:3, x = "a")
df2 <- tibble(ID = 1:3, y = "b")  # Different case!

df1 %>%
  left_join(df2)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Specify Join Keys**

```{r}
# Use by argument with named vector
customers <- tibble(customer_id = 1:3, name = c("A", "B", "C"))
orders <- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200))

customers %>%
  left_join(orders, by = c("customer_id" = "cust_id"))

# Multiple keys
df1 <- tibble(id = 1:3, type = "A", x = 1:3)
df2 <- tibble(id = 1:3, type = "A", y = 4:6)

df1 %>%
  left_join(df2, by = c("id", "type"))

# Or with different names
df1 <- tibble(id1 = 1:3, type1 = "A", x = 1:3)
df2 <- tibble(id2 = 1:3, type2 = "A", y = 4:6)

df1 %>%
  left_join(df2, by = c("id1" = "id2", "type1" = "type2"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Rename Columns First**

```{r}
customers <- tibble(customer_id = 1:3, name = c("A", "B", "C"))
orders <- tibble(cust_id = c(1, 1, 2), amount = c(100, 150, 200))

# Rename to match
orders_renamed <- orders %>%
  rename(customer_id = cust_id)

customers %>%
  left_join(orders_renamed, by = "customer_id")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use join_by() (dplyr >= 1.1.0)**

```{r}
# Modern syntax (if available)
if (packageVersion("dplyr") >= "1.1.0") {
  customers %>%
    left_join(orders, join_by(customer_id == cust_id))
}
```
</div>

## Error #2: Duplicate keys creating many rows {#join-duplicates}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r}
# Data with duplicates
customers <- tibble(
  id = c(1, 1, 2),  # Duplicate id 1!
  name = c("Alice", "Alice", "Bob")
)

orders <- tibble(
  customer_id = c(1, 1, 2),  # Duplicate id 1!
  amount = c(100, 150, 200)
)

# Join creates cartesian product
result <- customers %>%
  left_join(orders, by = c("id" = "customer_id"))

result
nrow(result)  # 5 rows from 3 + 3!
```

### What Happened

When both tables have duplicate keys, you get all combinations (cartesian product).

### Common Causes

```{r}
# Many-to-many relationship
students <- tibble(
  student_id = c(1, 1, 2, 2),
  course = c("Math", "English", "Math", "Science")
)

grades <- tibble(
  student_id = c(1, 1, 2, 2),
  grade = c("A", "B", "A", "B")
)

# Which grade goes with which course?
students %>%
  left_join(grades, by = "student_id")  # Ambiguous!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Remove Duplicates Before Join**

```{r}
customers <- tibble(
  id = c(1, 1, 2),
  name = c("Alice", "Alice", "Bob")
)

# Keep unique customers
customers_unique <- customers %>%
  distinct(id, .keep_all = TRUE)

customers_unique %>%
  left_join(orders, by = c("id" = "customer_id"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Check for Duplicates**

```{r}
check_join_keys <- function(data, key_cols) {
  dups <- data %>%
    group_by(across(all_of(key_cols))) %>%
    filter(n() > 1) %>%
    ungroup()
  
  if (nrow(dups) > 0) {
    warning("Duplicate keys found:\n")
    print(dups)
    return(FALSE)
  }
  
  message("No duplicate keys")
  return(TRUE)
}

check_join_keys(customers, "id")
check_join_keys(customers_unique, "id")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Aggregate Before Join**

```{r}
# If duplicates make sense (e.g., multiple orders)
orders_summary <- orders %>%
  group_by(customer_id) %>%
  summarize(
    total_orders = n(),
    total_amount = sum(amount),
    .groups = "drop"
  )

customers_unique %>%
  left_join(orders_summary, by = c("id" = "customer_id"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 4: Use relationship argument (dplyr >= 1.1.0)**

```{r}
# Specify expected relationship
if (packageVersion("dplyr") >= "1.1.0") {
  # This will error if relationship is wrong
  # customers %>%
  #   left_join(orders, 
  #            by = c("id" = "customer_id"),
  #            relationship = "one-to-one")
  
  # Specify many-to-one
  customers %>%
    left_join(orders, 
             by = c("id" = "customer_id"),
             relationship = "many-to-one")
}
```
</div>

## Multiple Key Joins

<div class="insight-box">
üí° **Key Insight: Joining on Multiple Columns**

```{r}
# Data with composite keys
sales <- tibble(
  store = c("A", "A", "B", "B"),
  product = c("X", "Y", "X", "Y"),
  quantity = c(10, 20, 15, 25)
)

prices <- tibble(
  store = c("A", "A", "B", "B"),
  product = c("X", "Y", "X", "Y"),
  price = c(5.00, 7.50, 4.50, 8.00)
)

# Join on both store and product
sales %>%
  left_join(prices, by = c("store", "product")) %>%
  mutate(revenue = quantity * price)

# With different names
prices2 <- tibble(
  location = c("A", "A", "B", "B"),
  item = c("X", "Y", "X", "Y"),
  price = c(5.00, 7.50, 4.50, 8.00)
)

sales %>%
  left_join(prices2, by = c("store" = "location", "product" = "item"))
```
</div>

## Error #3: Unexpected NA values after join {#join-unexpected-na}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r}
customers <- tibble(
  id = 1:4,
  name = c("Alice", "Bob", "Charlie", "David")
)

orders <- tibble(
  customer_id = c(1, 1, 2, 5),  # Customer 5 doesn't exist!
  amount = c(100, 150, 200, 75)
)

# Left join
result <- customers %>%
  left_join(orders, by = c("id" = "customer_id"))

result
# Charlie and David have no orders (NA in amount)
```

### What Happened

Left join keeps all rows from left table. Unmatched rows get NA in right table columns.

### Understanding NA Sources

```{r}
# Right join - unmatched from right get NA in left columns
result_right <- customers %>%
  right_join(orders, by = c("id" = "customer_id"))

result_right
# Customer 5 order has NA in name

# Inner join - no NAs (only matching rows)
result_inner <- customers %>%
  inner_join(orders, by = c("id" = "customer_id"))

result_inner
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Choose Right Join Type**

```{r}
# If you want only matching rows
customers %>%
  inner_join(orders, by = c("id" = "customer_id"))

# If you want all customers (even without orders)
customers %>%
  left_join(orders, by = c("id" = "customer_id"))

# If you want all orders (even with unknown customers)
customers %>%
  right_join(orders, by = c("id" = "customer_id"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Fill NAs After Join**

```{r}
customers %>%
  left_join(orders, by = c("id" = "customer_id")) %>%
  mutate(
    amount = replace_na(amount, 0),
    order_count = if_else(is.na(amount), 0L, 1L)
  )

# Or with tidyr
library(tidyr)
customers %>%
  left_join(orders, by = c("id" = "customer_id")) %>%
  replace_na(list(amount = 0))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Check for Unmatched Rows**

```{r}
# Find unmatched customers
customers %>%
  anti_join(orders, by = c("id" = "customer_id"))

# Find unmatched orders
orders %>%
  anti_join(customers, by = c("customer_id" = "id"))
```
</div>

## Filtering Joins

<div class="insight-box">
üí° **Key Insight: semi_join() and anti_join()**

```{r}
# semi_join: Keep rows in x that have match in y
# Like inner_join but doesn't add columns from y
band_members %>%
  semi_join(band_instruments, by = "name")

# anti_join: Keep rows in x that DON'T have match in y
band_members %>%
  anti_join(band_instruments, by = "name")

# Practical use: find missing data
customers <- tibble(id = 1:5, name = letters[1:5])
orders <- tibble(customer_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75))

# Customers with no orders
customers %>%
  anti_join(orders, by = c("id" = "customer_id"))

# Customers with orders
customers %>%
  semi_join(orders, by = c("id" = "customer_id"))
```
</div>

## Error #4: Column name conflicts {#join-name-conflicts}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-naming">üè∑Ô∏è NAMING</span>

### The Problem

```{r}
df1 <- tibble(
  id = 1:3,
  value = c(10, 20, 30)
)

df2 <- tibble(
  id = 1:3,
  value = c(100, 200, 300)
)

# Both have 'value' column
result <- df1 %>%
  left_join(df2, by = "id")

result
# Creates value.x and value.y
```

### What Happened

Columns with same name (not in join key) get suffixes.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use suffix argument**

```{r}
df1 %>%
  left_join(df2, by = "id", suffix = c("_left", "_right"))

# Or more descriptive
df1 %>%
  left_join(df2, by = "id", suffix = c("_original", "_new"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Rename Before Join**

```{r}
df1 %>%
  rename(value1 = value) %>%
  left_join(
    df2 %>% rename(value2 = value),
    by = "id"
  )
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Select Columns First**

```{r}
# Only keep needed columns from each
df1 %>%
  left_join(
    df2 %>% select(id, value2 = value),
    by = "id"
  )
```
</div>

## Common Join Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Common Join Patterns**

```{r}
# 1. Lookup table (add descriptions)
products <- tibble(
  product_id = 1:3,
  quantity = c(10, 20, 15)
)

product_info <- tibble(
  product_id = 1:3,
  name = c("Widget", "Gadget", "Doohickey"),
  price = c(9.99, 19.99, 14.99)
)

products %>%
  left_join(product_info, by = "product_id")

# 2. Aggregate then join
orders <- tibble(
  customer_id = c(1, 1, 2, 2, 3),
  amount = c(100, 150, 200, 75, 300)
)

customers <- tibble(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie")
)

order_summary <- orders %>%
  group_by(customer_id) %>%
  summarize(
    total_orders = n(),
    total_spent = sum(amount),
    avg_order = mean(amount),
    .groups = "drop"
  )

customers %>%
  left_join(order_summary, by = c("id" = "customer_id"))

# 3. Multiple joins
students <- tibble(id = 1:3, name = c("A", "B", "C"))
math_grades <- tibble(student_id = 1:3, math = c(85, 90, 78))
english_grades <- tibble(student_id = 1:3, english = c(88, 92, 85))

students %>%
  left_join(math_grades, by = c("id" = "student_id")) %>%
  left_join(english_grades, by = c("id" = "student_id"))

# 4. Self join
employees <- tibble(
  id = 1:4,
  name = c("Alice", "Bob", "Charlie", "David"),
  manager_id = c(NA, 1, 1, 2)
)

employees %>%
  left_join(
    employees %>% select(id, manager_name = name),
    by = c("manager_id" = "id")
  )

# 5. Rolling join (closest match)
events <- tibble(
  time = c(1, 3, 5, 7),
  event = c("A", "B", "C", "D")
)

measurements <- tibble(
  time = c(0, 2, 4, 6, 8),
  value = c(10, 20, 30, 40, 50)
)

# Nearest match (simplified example)
events %>%
  left_join(measurements, by = "time")  # Only exact matches
```
</div>

## Checking Join Results

<div class="bestpractice-box">
üéØ **Best Practice: Validate Joins**

```{r}
validate_join <- function(original, joined, join_type = "left") {
  cat("=== Join Validation ===\n\n")
  
  # Row count check
  cat("Original rows:", nrow(original), "\n")
  cat("Joined rows:", nrow(joined), "\n")
  
  if (join_type == "inner") {
    if (nrow(joined) > nrow(original)) {
      warning("Inner join resulted in MORE rows - duplicates in join key?")
    }
  } else if (join_type == "left") {
    if (nrow(joined) < nrow(original)) {
      warning("Left join resulted in FEWER rows - this shouldn't happen!")
    } else if (nrow(joined) > nrow(original)) {
      warning("Left join resulted in MORE rows - duplicates in right table?")
    }
  }
  
  # NA check
  na_cols <- names(joined)[colSums(is.na(joined)) > 0]
  if (length(na_cols) > 0) {
    cat("\nColumns with NAs:\n")
    for (col in na_cols) {
      n_na <- sum(is.na(joined[[col]]))
      cat("  ", col, ":", n_na, "NAs\n")
    }
  }
  
  # Duplicate check in key columns
  cat("\n")
}

# Test
customers <- tibble(id = 1:3, name = c("A", "B", "C"))
orders <- tibble(customer_id = c(1, 1, 2, 4), amount = c(100, 150, 200, 75))

result <- customers %>%
  left_join(orders, by = c("id" = "customer_id"))

validate_join(customers, result, "left")
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Four main joins** - inner, left, right, full
2. **Specify by argument** - When column names differ
3. **Watch for duplicates** - Can create many rows
4. **Left join creates NAs** - For unmatched rows
5. **Use filtering joins** - semi_join(), anti_join()
6. **Check join results** - Validate row counts and NAs
7. **Name conflicts** - Use suffix or rename

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| by must be supplied | No common columns | Use `by = c("x" = "y")` |
| Too many rows | Duplicate keys | Check for duplicates, aggregate |
| Unexpected NAs | Unmatched rows | Use right join type, fill NAs |
| Column conflicts | Same name, not in key | Use suffix argument |

**Join Types:**

```{r eval=FALSE}
# Mutating joins (add columns)
inner_join(x, y, by = "key")  # Only matching
left_join(x, y, by = "key")   # All x, matching y
right_join(x, y, by = "key")  # Matching x, all y
full_join(x, y, by = "key")   # All rows

# Filtering joins (filter rows)
semi_join(x, y, by = "key")   # x rows that match y
anti_join(x, y, by = "key")   # x rows that don't match y

# Different column names
left_join(x, y, by = c("x_id" = "y_id"))

# Multiple keys
left_join(x, y, by = c("id", "type"))

# Handle name conflicts
left_join(x, y, by = "id", suffix = c("_x", "_y"))
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
left_join(x, y, by = "key")              # Explicit by
Check for duplicates before join          # Avoid cartesian
Validate row counts after join            # Catch issues
Use appropriate join type                 # inner vs left vs full

# ‚ùå Avoid
left_join(x, y)  # No by (relies on names)
Join without checking duplicates          # Surprise row explosion
Ignore NAs after join                     # May indicate issues
Always use left_join                      # Sometimes inner is right
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Basic Joins**

Given:
```{r eval=FALSE}
products <- tibble(id = 1:5, name = c("A", "B", "C", "D", "E"))
sales <- tibble(product_id = c(1, 2, 2, 3, 6), amount = c(100, 150, 200, 75, 50))
```

1. Inner join - only products with sales
2. Left join - all products, add sales
3. Find products with no sales
4. Find sales for unknown products
</div>

<div class="exercise-box">
üìù **Exercise 2: Duplicate Handling**

Given data with duplicates:
```{r eval=FALSE}
customers <- tibble(id = c(1, 1, 2, 3), name = c("A", "A", "B", "C"))
orders <- tibble(cust_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75))
```

1. Identify the duplicates
2. Remove them appropriately
3. Perform safe join
4. Validate result
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Join Function**

Write `safe_join(x, y, by, type)` that:
1. Checks for duplicate keys
2. Validates join will work
3. Performs join
4. Checks result makes sense
5. Returns result with metadata
</div>

<div class="exercise-box">
üìù **Exercise 4: Multiple Table Join**

Join three tables efficiently:
```{r eval=FALSE}
students <- tibble(id = 1:3, name = c("A", "B", "C"))
courses <- tibble(student_id = c(1, 1, 2, 3), course = c("Math", "Eng", "Math", "Sci"))
grades <- tibble(student_id = c(1, 1, 2, 3), course = c("Math", "Eng", "Math", "Sci"), 
                grade = c(85, 90, 78, 92))
```
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
products <- tibble(id = 1:5, name = c("A", "B", "C", "D", "E"))
sales <- tibble(product_id = c(1, 2, 2, 3, 6), amount = c(100, 150, 200, 75, 50))

# 1. Inner join - only products with sales
products_with_sales <- products %>%
  inner_join(sales, by = c("id" = "product_id"))
products_with_sales

# 2. Left join - all products, add sales
all_products <- products %>%
  left_join(sales, by = c("id" = "product_id"))
all_products

# 3. Find products with no sales
no_sales <- products %>%
  anti_join(sales, by = c("id" = "product_id"))
no_sales

# 4. Find sales for unknown products
unknown_products <- sales %>%
  anti_join(products, by = c("product_id" = "id"))
unknown_products
```

**Exercise 2:**

```{r}
customers <- tibble(id = c(1, 1, 2, 3), name = c("A", "A", "B", "C"))
orders <- tibble(cust_id = c(1, 2, 2, 3), amount = c(100, 150, 200, 75))

# 1. Identify duplicates
cat("Duplicate customers:\n")
customers %>%
  group_by(id) %>%
  filter(n() > 1)

cat("\nDuplicate orders:\n")
orders %>%
  group_by(cust_id) %>%
  filter(n() > 1)

# 2. Remove duplicates
customers_unique <- customers %>%
  distinct(id, .keep_all = TRUE)

# Orders: multiple per customer is expected, so aggregate
orders_summary <- orders %>%
  group_by(cust_id) %>%
  summarize(
    n_orders = n(),
    total_amount = sum(amount),
    avg_amount = mean(amount),
    .groups = "drop"
  )

# 3. Perform safe join
result <- customers_unique %>%
  left_join(orders_summary, by = c("id" = "cust_id"))

# 4. Validate
cat("\nValidation:\n")
cat("Original customers:", nrow(customers_unique), "\n")
cat("Result rows:", nrow(result), "\n")
cat("Should be equal:", nrow(customers_unique) == nrow(result), "\n")

result
```

**Exercise 3:**

```{r}
safe_join <- function(x, y, by, type = "left") {
  # Validate inputs
  if (!type %in% c("inner", "left", "right", "full")) {
    stop("type must be inner, left, right, or full")
  }
  
  # Extract key columns
  if (is.character(by)) {
    x_keys <- if (is.null(names(by))) by else names(by)
    y_keys <- if (is.null(names(by))) by else unname(by)
  } else {
    stop("by must be a character vector")
  }
  
  # Check keys exist
  if (!all(x_keys %in% names(x))) {
    stop("Some keys not found in x: ", 
         paste(setdiff(x_keys, names(x)), collapse = ", "))
  }
  if (!all(y_keys %in% names(y))) {
    stop("Some keys not found in y: ", 
         paste(setdiff(y_keys, names(y)), collapse = ", "))
  }
  
  # Check for duplicates
  x_dups <- x %>%
    group_by(across(all_of(x_keys))) %>%
    filter(n() > 1) %>%
    nrow()
  
  y_dups <- y %>%
    group_by(across(all_of(y_keys))) %>%
    filter(n() > 1) %>%
    nrow()
  
  if (x_dups > 0) {
    warning("x has ", x_dups, " duplicate key rows")
  }
  if (y_dups > 0) {
    warning("y has ", y_dups, " duplicate key rows")
  }
  
  # Perform join
  result <- switch(type,
    inner = inner_join(x, y, by = by),
    left = left_join(x, y, by = by),
    right = right_join(x, y, by = by),
    full = full_join(x, y, by = by)
  )
  
  # Validate result
  metadata <- list(
    type = type,
    x_rows = nrow(x),
    y_rows = nrow(y),
    result_rows = nrow(result),
    x_duplicates = x_dups,
    y_duplicates = y_dups,
    na_columns = names(result)[colSums(is.na(result)) > 0]
  )
  
  # Check expectations
  if (type == "left" && nrow(result) < nrow(x)) {
    warning("Left join resulted in fewer rows than x!")
  }
  
  if (type == "inner" && nrow(result) > min(nrow(x), nrow(y))) {
    warning("Inner join resulted in more rows than either input - check for duplicates")
  }
  
  # Return with metadata
  attr(result, "join_metadata") <- metadata
  result
}

# Test
customers <- tibble(id = 1:3, name = c("A", "B", "C"))
orders <- tibble(customer_id = c(1, 1, 2, 4), amount = c(100, 150, 200, 75))

result <- safe_join(customers, orders, by = c("id" = "customer_id"), type = "left")
result
attr(result, "join_metadata")
```

**Exercise 4:**

```{r}
students <- tibble(id = 1:3, name = c("A", "B", "C"))
courses <- tibble(
  student_id = c(1, 1, 2, 3), 
  course = c("Math", "Eng", "Math", "Sci")
)
grades <- tibble(
  student_id = c(1, 1, 2, 3), 
  course = c("Math", "Eng", "Math", "Sci"), 
  grade = c(85, 90, 78, 92)
)

# Method 1: Chain joins
result1 <- students %>%
  left_join(courses, by = c("id" = "student_id")) %>%
  left_join(grades, by = c("id" = "student_id", "course" = "course"))
result1

# Method 2: Join courses and grades first
result2 <- students %>%
  left_join(
    courses %>%
      left_join(grades, by = c("student_id", "course")),
    by = c("id" = "student_id")
  )
result2

# Method 3: Using reduce (for many tables)
library(purrr)

tables <- list(
  students,
  courses,
  grades
)

keys <- list(
  c("id" = "student_id"),
  c("id" = "student_id", "course" = "course")
)

# This is complex - usually method 1 or 2 is better
# Showing for completeness

# Summary by student
summary_result <- students %>%
  left_join(
    courses %>%
      left_join(grades, by = c("student_id", "course")) %>%
      group_by(student_id) %>%
      summarize(
        n_courses = n(),
        avg_grade = mean(grade, na.rm = TRUE),
        courses = paste(course, collapse = ", "),
        .groups = "drop"
      ),
    by = c("id" = "student_id")
  )

summary_result
```
</details>

<!--chapter:end:22-dplyr-joins.Rmd-->

# Introduction to tidyr {#tidyr-intro}

<div class="chapter-summary">
**What You'll Learn:**

- Tidy data principles
- Wide vs long format
- pivot_longer() and pivot_wider()
- Common reshaping errors
- When to reshape data

**Key Errors Covered:** 15+ tidyr errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

tidyr helps reshape data between wide and long formats:

```{r message=FALSE}
library(tidyr)
library(dplyr)

# Wide format
wide_data <- tibble(
  id = 1:3,
  time_1 = c(10, 20, 30),
  time_2 = c(15, 25, 35),
  time_3 = c(20, 30, 40)
)

# Convert to long format
long_data <- wide_data %>%
  pivot_longer(
    cols = starts_with("time"),
    names_to = "time",
    values_to = "value"
  )

long_data
```

Let's master reshaping!

## Tidy Data Principles

<div class="insight-box">
üí° **Key Insight: What is Tidy Data?**

```{r}
# Tidy data rules:
# 1. Each variable is a column
# 2. Each observation is a row
# 3. Each type of observational unit is a table

# Example: UNTIDY (wide format)
untidy <- tibble(
  person = c("Alice", "Bob"),
  age = c(25, 30),
  income_2020 = c(50000, 60000),
  income_2021 = c(52000, 62000),
  income_2022 = c(54000, 64000)
)

untidy

# TIDY (long format)
tidy <- untidy %>%
  pivot_longer(
    cols = starts_with("income"),
    names_to = "year",
    names_prefix = "income_",
    values_to = "income"
  )

tidy

# Now year is a variable, each row is person-year observation
```

**Why tidy data?**
- Works naturally with dplyr and ggplot2
- Easy to filter, group, and summarize
- Consistent structure for analysis
</div>

## pivot_longer() Basics

<div class="insight-box">
üí° **Key Insight: Wide to Long with pivot_longer()**

```{r}
# Basic pivot_longer
wide <- tibble(
  id = 1:3,
  q1 = c(5, 3, 4),
  q2 = c(4, 5, 3),
  q3 = c(3, 4, 5)
)

wide %>%
  pivot_longer(
    cols = q1:q3,           # Columns to pivot
    names_to = "quarter",   # New column for names
    values_to = "score"     # New column for values
  )

# Using selection helpers
wide %>%
  pivot_longer(
    cols = starts_with("q"),
    names_to = "quarter",
    values_to = "score"
  )

# Keep some columns
wide %>%
  pivot_longer(
    cols = -id,             # All except id
    names_to = "quarter",
    values_to = "score"
  )

# Multiple value types
data <- tibble(
  id = 1:2,
  x_value = c(10, 20),
  x_error = c(1, 2),
  y_value = c(30, 40),
  y_error = c(3, 4)
)

data %>%
  pivot_longer(
    cols = -id,
    names_to = c("variable", ".value"),
    names_sep = "_"
  )
```
</div>

## Error #1: `cols must select at least one column` {#pivot-no-cols}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
data <- tibble(
  id = 1:3,
  value = c(10, 20, 30)
)

data %>%
  pivot_longer(
    cols = starts_with("time"),  # No columns match!
    names_to = "time",
    values_to = "measurement"
  )
```

<div class="error-box">
üî¥ **ERROR**

```
Error in pivot_longer():
! `cols` must select at least one column.
```
</div>

### What It Means

The column selection didn't match any columns.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Column Names**

```{r}
# Verify columns exist
names(data)

# Use correct selection
data_wide <- tibble(
  id = 1:3,
  time_1 = c(10, 20, 30),
  time_2 = c(15, 25, 35)
)

data_wide %>%
  pivot_longer(
    cols = starts_with("time"),
    names_to = "time",
    values_to = "value"
  )
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Flexible Selection**

```{r}
# Select all numeric columns
data_wide %>%
  pivot_longer(
    cols = where(is.numeric),
    names_to = "variable",
    values_to = "value"
  )

# Or exclude specific columns
data_wide %>%
  pivot_longer(
    cols = -id,
    names_to = "variable",
    values_to = "value"
  )
```
</div>

## pivot_wider() Basics

<div class="insight-box">
üí° **Key Insight: Long to Wide with pivot_wider()**

```{r}
# Basic pivot_wider
long <- tibble(
  id = rep(1:3, each = 2),
  time = rep(c("before", "after"), 3),
  value = c(10, 15, 20, 25, 30, 35)
)

long %>%
  pivot_wider(
    names_from = time,      # Column to get names from
    values_from = value     # Column to get values from
  )

# Multiple value columns
long_multi <- tibble(
  id = rep(1:2, each = 2),
  time = rep(c("t1", "t2"), 2),
  score = c(10, 15, 20, 25),
  error = c(1, 2, 3, 4)
)

long_multi %>%
  pivot_wider(
    names_from = time,
    values_from = c(score, error)
  )

# With name formatting
long %>%
  pivot_wider(
    names_from = time,
    values_from = value,
    names_prefix = "time_"
  )
```
</div>

## Error #2: `Values are not uniquely identified` {#pivot-not-unique}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Error

```{r error=TRUE}
# Data with duplicates
data <- tibble(
  id = c(1, 1, 2, 2),
  time = c("before", "before", "before", "after"),
  value = c(10, 15, 20, 25)
)

data %>%
  pivot_wider(
    names_from = time,
    values_from = value
  )
```

<div class="error-box">
üî¥ **WARNING/ERROR**

```
Warning: Values from `value` are not uniquely identified; output will contain list-cols.
```
</div>

### What It Means

Multiple values exist for same id-time combination. Can't decide which to use.

### Common Causes

```{r}
# Multiple measurements per combination
measurements <- tibble(
  person = c("Alice", "Alice", "Bob", "Bob"),
  test = c("test1", "test1", "test2", "test2"),
  score = c(85, 87, 90, 92)  # Two scores for Alice-test1
)

measurements %>%
  pivot_wider(
    names_from = test,
    values_from = score
  )
# Creates list columns!
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Aggregate First**

```{r}
measurements %>%
  group_by(person, test) %>%
  summarize(score = mean(score), .groups = "drop") %>%
  pivot_wider(
    names_from = test,
    values_from = score
  )
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Add Identifier**

```{r}
# Add row number to make unique
measurements %>%
  group_by(person, test) %>%
  mutate(attempt = row_number()) %>%
  pivot_wider(
    names_from = c(test, attempt),
    values_from = score
  )
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use values_fn**

```{r}
# Specify how to aggregate
measurements %>%
  pivot_wider(
    names_from = test,
    values_from = score,
    values_fn = list(score = mean)
  )

# Or use list for multiple aggregations
measurements %>%
  pivot_wider(
    names_from = test,
    values_from = score,
    values_fn = list(score = list)
  )
```
</div>

## separate() and unite()

<div class="insight-box">
üí° **Key Insight: Splitting and Combining Columns**

```{r}
# separate: split one column into multiple
data <- tibble(
  id = 1:3,
  name = c("Alice_Smith", "Bob_Jones", "Charlie_Brown")
)

data %>%
  separate(name, into = c("first", "last"), sep = "_")

# With different separator
data2 <- tibble(
  id = 1:3,
  date = c("2024-01-15", "2024-02-20", "2024-03-25")
)

data2 %>%
  separate(date, into = c("year", "month", "day"), sep = "-")

# Convert types
data2 %>%
  separate(date, into = c("year", "month", "day"), 
           sep = "-", convert = TRUE)

# unite: combine multiple columns
data_split <- tibble(
  id = 1:3,
  first = c("Alice", "Bob", "Charlie"),
  last = c("Smith", "Jones", "Brown")
)

data_split %>%
  unite(name, first, last, sep = " ")

# Keep original columns
data_split %>%
  unite(name, first, last, sep = " ", remove = FALSE)
```
</div>

## fill() for Missing Values

<div class="insight-box">
üí° **Key Insight: Fill Missing Values**

```{r}
# Data with implicit missing values
data <- tibble(
  group = c("A", NA, NA, "B", NA, "C"),
  value = 1:6
)

# Fill down
data %>%
  fill(group)

# Fill up
data %>%
  fill(group, .direction = "up")

# Fill both directions
data %>%
  fill(group, .direction = "downup")
```
</div>

## complete() for Implicit Missing Values

<div class="insight-box">
üí° **Key Insight: Make Implicit NAs Explicit**

```{r}
# Incomplete data
sales <- tibble(
  product = c("A", "A", "B"),
  quarter = c(1, 2, 1),
  sales = c(100, 150, 200)
)

# Missing: product B quarter 2
# Make it explicit
sales %>%
  complete(product, quarter)

# Fill with specific value
sales %>%
  complete(product, quarter, fill = list(sales = 0))

# With sequences
dates <- tibble(
  date = as.Date(c("2024-01-01", "2024-01-03", "2024-01-05")),
  value = c(10, 20, 30)
)

dates %>%
  complete(date = seq(min(date), max(date), by = "day"))
```
</div>

## Common Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Reshaping Workflows**

```{r}
# 1. Survey data wide to long
survey_wide <- tibble(
  id = 1:3,
  q1_satisfaction = c(5, 4, 3),
  q1_importance = c(5, 5, 4),
  q2_satisfaction = c(4, 3, 5),
  q2_importance = c(4, 4, 5)
)

survey_long <- survey_wide %>%
  pivot_longer(
    cols = -id,
    names_to = c("question", "measure"),
    names_sep = "_",
    values_to = "rating"
  )

survey_long

# 2. Time series wide to long
stocks <- tibble(
  date = as.Date("2024-01-01") + 0:2,
  AAPL = c(150, 152, 149),
  GOOGL = c(140, 142, 138),
  MSFT = c(380, 385, 378)
)

stocks %>%
  pivot_longer(
    cols = -date,
    names_to = "stock",
    values_to = "price"
  )

# 3. Pivot wider for comparison
comparisons <- tibble(
  id = rep(1:3, each = 2),
  condition = rep(c("control", "treatment"), 3),
  outcome = c(10, 12, 15, 18, 20, 22)
)

comparisons %>%
  pivot_wider(
    names_from = condition,
    values_from = outcome
  ) %>%
  mutate(difference = treatment - control)

# 4. Complex reshape
data <- tibble(
  id = 1:2,
  treatment_1_pre = c(10, 15),
  treatment_1_post = c(12, 17),
  treatment_2_pre = c(20, 25),
  treatment_2_post = c(22, 27)
)

data %>%
  pivot_longer(
    cols = -id,
    names_to = c("treatment", "time"),
    names_pattern = "treatment_(.*)_(.*)",
    values_to = "score"
  )
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Tidy data principles** - Variables in columns, observations in rows
2. **pivot_longer()** - Wide to long format
3. **pivot_wider()** - Long to wide format
4. **Check for duplicates** - Before pivot_wider()
5. **separate() and unite()** - Split/combine columns
6. **fill()** - Handle missing values
7. **complete()** - Make implicit NAs explicit

**Quick Reference:**

| Function | Purpose | Common Use |
|----------|---------|------------|
| pivot_longer() | Wide ‚Üí Long | Convert multiple columns to rows |
| pivot_wider() | Long ‚Üí Wide | Spread values across columns |
| separate() | Split column | Parse combined data |
| unite() | Combine columns | Create composite keys |
| fill() | Fill NAs | Propagate values |
| complete() | Add missing combos | Explicit NAs |

**Reshaping:**

```{r eval=FALSE}
# Wide to long
data %>%
  pivot_longer(
    cols = col1:col3,
    names_to = "variable",
    values_to = "value"
  )

# Long to wide
data %>%
  pivot_wider(
    names_from = variable,
    values_from = value
  )

# Split column
data %>%
  separate(col, into = c("part1", "part2"), sep = "_")

# Combine columns
data %>%
  unite(new_col, col1, col2, sep = "_")

# Fill missing
data %>%
  fill(col, .direction = "down")

# Complete combinations
data %>%
  complete(var1, var2, fill = list(value = 0))
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Check data structure first                # Know what you have
Aggregate before pivot_wider              # Avoid list columns
Use descriptive names_to/values_to        # Clear column names
Test on small sample first                # Verify logic

# ‚ùå Avoid
Pivot_wider with duplicates               # Creates list columns
Complex reshapes in one step              # Hard to debug
Forgetting to specify cols                # Error or unexpected
Not checking result structure             # May not be what you want
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Wide to Long**

Given:
```{r eval=FALSE}
grades <- tibble(
  student = c("Alice", "Bob", "Charlie"),
  math_q1 = c(85, 78, 92),
  math_q2 = c(88, 82, 95),
  english_q1 = c(90, 85, 88),
  english_q2 = c(92, 87, 90)
)
```

Convert to long format with columns: student, subject, quarter, grade
</div>

<div class="exercise-box">
üìù **Exercise 2: Long to Wide**

Given:
```{r eval=FALSE}
measurements <- tibble(
  id = rep(1:3, each = 3),
  time = rep(c("t1", "t2", "t3"), 3),
  value = c(10, 12, 14, 20, 22, 24, 30, 32, 34)
)
```

Convert to wide format with time as columns
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe Pivot**

Write `safe_pivot_wider(data, names_from, values_from)` that:
1. Checks for duplicate combinations
2. Aggregates if needed
3. Performs pivot
4. Validates result
</div>

<div class="exercise-box">
üìù **Exercise 4: Complex Reshape**

Given survey data:
```{r eval=FALSE}
survey <- tibble(
  id = 1:3,
  age = c(25, 30, 35),
  q1_pre = c(3, 4, 2),
  q1_post = c(4, 5, 3),
  q2_pre = c(2, 3, 4),
  q2_post = c(3, 4, 5)
)
```

Reshape to: id, age, question, time, response
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
grades <- tibble(
  student = c("Alice", "Bob", "Charlie"),
  math_q1 = c(85, 78, 92),
  math_q2 = c(88, 82, 95),
  english_q1 = c(90, 85, 88),
  english_q2 = c(92, 87, 90)
)

# Method 1: Two-step pivot
result <- grades %>%
  pivot_longer(
    cols = -student,
    names_to = "subject_quarter",
    values_to = "grade"
  ) %>%
  separate(subject_quarter, into = c("subject", "quarter"), sep = "_")

result

# Method 2: Use names_pattern
result2 <- grades %>%
  pivot_longer(
    cols = -student,
    names_to = c("subject", "quarter"),
    names_pattern = "(.*)_(.*)",
    values_to = "grade"
  )

result2
```

**Exercise 2:**

```{r}
measurements <- tibble(
  id = rep(1:3, each = 3),
  time = rep(c("t1", "t2", "t3"), 3),
  value = c(10, 12, 14, 20, 22, 24, 30, 32, 34)
)

result <- measurements %>%
  pivot_wider(
    names_from = time,
    values_from = value
  )

result

# Verify dimensions
cat("Original: ", nrow(measurements), "rows\n")
cat("Wide: ", nrow(result), "rows,", ncol(result) - 1, "time columns\n")
```

**Exercise 3:**

```{r}
safe_pivot_wider <- function(data, names_from, values_from, 
                             aggregate_fn = mean, warn = TRUE) {
  
  names_col <- rlang::ensym(names_from)
  values_col <- rlang::ensym(values_from)
  
  # Get ID columns (everything except names_from and values_from)
  id_cols <- setdiff(names(data), c(as.character(names_col), 
                                     as.character(values_col)))
  
  # Check for duplicates
  dup_check <- data %>%
    group_by(across(all_of(c(id_cols, as.character(names_col))))) %>%
    filter(n() > 1) %>%
    ungroup()
  
  if (nrow(dup_check) > 0) {
    if (warn) {
      warning("Found ", nrow(dup_check), " duplicate rows. ",
              "Aggregating with ", deparse(substitute(aggregate_fn)))
      print(head(dup_check))
    }
    
    # Aggregate
    data <- data %>%
      group_by(across(all_of(c(id_cols, as.character(names_col))))) %>%
      summarize(
        !!values_col := aggregate_fn(!!values_col),
        .groups = "drop"
      )
  }
  
  # Perform pivot
  result <- data %>%
    pivot_wider(
      names_from = !!names_col,
      values_from = !!values_col
    )
  
  # Validate
  expected_rows <- length(unique(interaction(data[id_cols])))
  actual_rows <- nrow(result)
  
  if (expected_rows != actual_rows) {
    warning("Row count mismatch! Expected: ", expected_rows, 
            ", Got: ", actual_rows)
  }
  
  result
}

# Test with clean data
measurements <- tibble(
  id = rep(1:3, each = 2),
  time = rep(c("t1", "t2"), 3),
  value = c(10, 15, 20, 25, 30, 35)
)

safe_pivot_wider(measurements, time, value)

# Test with duplicates
measurements_dup <- tibble(
  id = c(1, 1, 2, 2, 2),
  time = c("t1", "t1", "t1", "t2", "t2"),
  value = c(10, 12, 20, 25, 27)
)

safe_pivot_wider(measurements_dup, time, value)
```

**Exercise 4:**

```{r}
survey <- tibble(
  id = 1:3,
  age = c(25, 30, 35),
  q1_pre = c(3, 4, 2),
  q1_post = c(4, 5, 3),
  q2_pre = c(2, 3, 4),
  q2_post = c(3, 4, 5)
)

# Method 1: Step by step
result <- survey %>%
  pivot_longer(
    cols = starts_with("q"),
    names_to = "question_time",
    values_to = "response"
  ) %>%
  separate(question_time, into = c("question", "time"), sep = "_")

result

# Method 2: Using names_pattern
result2 <- survey %>%
  pivot_longer(
    cols = starts_with("q"),
    names_to = c("question", "time"),
    names_pattern = "(q\\d+)_(.*)",
    values_to = "response"
  )

result2

# Verify
cat("Original questions:", (ncol(survey) - 2), "\n")
cat("Long format rows:", nrow(result), "\n")
cat("Should be:", nrow(survey) * (ncol(survey) - 2), "\n")
```
</details>

<!--chapter:end:23-tidyr-intro.Rmd-->

# Advanced dplyr Patterns {#dplyr-advanced}

<div class="chapter-summary">
**What You'll Learn:**

- Programming with dplyr
- Tidy evaluation
- Dynamic column selection
- Row-wise operations
- Complex aggregations

**Key Errors Covered:** 12+ advanced dplyr errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Advanced dplyr enables programmatic data manipulation:

```{r message=FALSE}
library(dplyr)
library(rlang)

# Function with column name as string
summarize_col <- function(data, col_name) {
  data %>%
    summarize(
      mean = mean(.data[[col_name]], na.rm = TRUE),
      sd = sd(.data[[col_name]], na.rm = TRUE)
    )
}

summarize_col(mtcars, "mpg")
```

Let's master advanced patterns!

## Tidy Evaluation Basics

<div class="insight-box">
üí° **Key Insight: .data and .env Pronouns**

```{r}
# .data pronoun for data frame columns
mtcars %>%
  summarize(avg = mean(.data$mpg))

# .env pronoun for environment variables
threshold <- 20
mtcars %>%
  filter(.data$mpg > .env$threshold)

# In functions
filter_by_value <- function(data, col, value) {
  data %>%
    filter(.data[[col]] > value)
}

filter_by_value(mtcars, "mpg", 20)

# Dynamic column creation
create_column <- function(data, new_col, value) {
  data %>%
    mutate("{new_col}" := value)
}

create_column(mtcars, "test", 42) %>%
  select(mpg, test)
```
</div>

## Error #1: Cannot use object of type 'symbol' {#symbol-error}

<span class="difficulty-advanced">‚≠ê‚≠ê‚≠ê ADVANCED</span> <span class="category-badge cat-tidy-eval">üîÆ TIDY-EVAL</span>

### The Error

```{r error=TRUE}
my_function <- function(data, col) {
  data %>%
    summarize(mean = mean(col))
}

my_function(mtcars, mpg)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in mean(col) : object 'mpg' not found
```
</div>

### What It Means

Need to use tidy evaluation to pass column names.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use {{ }} (Embrace)**

```{r}
my_function <- function(data, col) {
  data %>%
    summarize(mean = mean({{ col }}))
}

my_function(mtcars, mpg)

# Works with multiple operations
my_filter_summarize <- function(data, filter_col, summary_col) {
  data %>%
    filter({{ filter_col }} > 4) %>%
    summarize(
      mean = mean({{ summary_col }}),
      n = n()
    )
}

my_filter_summarize(mtcars, cyl, mpg)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use .data[[]] for Strings**

```{r}
my_function2 <- function(data, col_name) {
  data %>%
    summarize(mean = mean(.data[[col_name]]))
}

my_function2(mtcars, "mpg")

# Dynamic column names
summarize_multiple <- function(data, cols) {
  data %>%
    summarize(
      across(all_of(cols), mean, .names = "mean_{.col}")
    )
}

summarize_multiple(mtcars, c("mpg", "hp", "wt"))
```
</div>

## rowwise() Operations

<div class="insight-box">
üí° **Key Insight: Row-wise Operations**

```{r}
# Calculate row means
data <- tibble(
  id = 1:3,
  x = c(1, 2, 3),
  y = c(4, 5, 6),
  z = c(7, 8, 9)
)

# Wrong: column mean
data %>%
  mutate(mean = mean(c(x, y, z)))

# Right: use rowwise()
data %>%
  rowwise() %>%
  mutate(mean = mean(c(x, y, z))) %>%
  ungroup()

# Or use c_across()
data %>%
  rowwise() %>%
  mutate(mean = mean(c_across(x:z))) %>%
  ungroup()

# Complex row operations
data %>%
  rowwise() %>%
  mutate(
    total = sum(c_across(x:z)),
    min_val = min(c_across(x:z)),
    max_val = max(c_across(x:z))
  ) %>%
  ungroup()
```
</div>

## across() Advanced Usage

<div class="bestpractice-box">
üéØ **Best Practice: across() Patterns**

```{r}
# Multiple functions
mtcars %>%
  summarize(
    across(c(mpg, hp, wt),
           list(mean = mean, sd = sd, min = min, max = max),
           .names = "{.col}_{.fn}")
  )

# With where()
mtcars %>%
  summarize(
    across(where(is.numeric) & !c(vs, am), 
           mean,
           .names = "avg_{.col}")
  )

# In mutate with formula
mtcars %>%
  mutate(
    across(c(mpg, hp), 
           ~ . / mean(.),
           .names = "{.col}_scaled")
  ) %>%
  select(mpg, mpg_scaled, hp, hp_scaled)

# Conditional transformation
mtcars %>%
  mutate(
    across(where(is.numeric), 
           ~ if_else(. < median(.), "Low", "High"),
           .names = "{.col}_cat")
  ) %>%
  select(mpg, mpg_cat, hp, hp_cat)
```
</div>

## if_any() and if_all()

<div class="insight-box">
üí° **Key Insight: Filter with Multiple Conditions**

```{r}
# if_any: TRUE if ANY condition met
mtcars %>%
  filter(if_any(c(mpg, hp), ~ . > 100)) %>%
  select(mpg, hp) %>%
  head()

# if_all: TRUE if ALL conditions met
mtcars %>%
  filter(if_all(c(mpg, hp), ~ . > 100)) %>%
  select(mpg, hp)

# With where()
mtcars %>%
  filter(if_any(where(is.numeric), ~ . > 200)) %>%
  select(where(function(x) any(x > 200)))
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Use {{ }}** - For passing column names to functions
2. **Use .data[[]]** - For string column names
3. **rowwise()** - For row-by-row operations
4. **across()** - Apply functions to multiple columns
5. **if_any() / if_all()** - Filter with multiple conditions
6. **Always ungroup()** - After rowwise()

**Quick Reference:**

```{r eval=FALSE}
# Tidy evaluation
function(data, col) {
  data %>% mutate(new = {{ col }} * 2)
}

# String column names
function(data, col_name) {
  data %>% mutate(new = .data[[col_name]] * 2)
}

# Rowwise
data %>%
  rowwise() %>%
  mutate(mean = mean(c_across(x:z))) %>%
  ungroup()

# across
data %>%
  summarize(across(where(is.numeric), mean))

# if_any/if_all
data %>%
  filter(if_any(c(x, y), ~ . > 10))
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise: Create Flexible Function**

Write `summarize_by_group(data, group_col, summary_cols)` using tidy evaluation that groups by one column and summarizes multiple columns.
</div>

## Exercise Answer

<details>
<summary>Click to see answer</summary>

```{r}
summarize_by_group <- function(data, group_col, summary_cols) {
  data %>%
    group_by({{ group_col }}) %>%
    summarize(
      across({{ summary_cols }},
             list(mean = mean, sd = sd, n = ~n()),
             .names = "{.col}_{.fn}"),
      .groups = "drop"
    )
}

summarize_by_group(mtcars, cyl, c(mpg, hp, wt))
```
</details>

<!--chapter:end:24-dplyr-advanced.Rmd-->

# Data Manipulation Best Practices {#dplyr-best-practices}

<div class="chapter-summary">
**What You'll Learn:**

- Efficient dplyr workflows
- Performance optimization
- Code organization
- Common anti-patterns
- Debugging strategies

**Key Errors Covered:** 10+ workflow errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Best practices make code faster, clearer, and more maintainable:

```{r message=FALSE}
library(dplyr)
library(tidyr)

# Good: Clear pipeline
result <- mtcars %>%
  filter(mpg > 20) %>%
  select(mpg, cyl, hp) %>%
  mutate(hp_per_cyl = hp / cyl) %>%
  arrange(desc(hp_per_cyl))

head(result, 3)
```

## Performance Optimization

<div class="bestpractice-box">
üéØ **Best Practice: Optimize for Speed**

```{r}
# 1. Filter early
# Bad: filter after heavy operations
mtcars %>%
  mutate(complex = mpg * hp / wt) %>%
  left_join(mtcars, by = c("cyl")) %>%
  filter(mpg > 20)

# Good: filter first
mtcars %>%
  filter(mpg > 20) %>%
  mutate(complex = mpg * hp / wt) %>%
  left_join(mtcars, by = c("cyl"))

# 2. Select early
# Bad: keep all columns
mtcars %>%
  mutate(new = mpg * 2) %>%
  filter(cyl == 4) %>%
  select(mpg, cyl, new)

# Good: select needed columns early
mtcars %>%
  select(mpg, cyl, hp, wt) %>%
  filter(cyl == 4) %>%
  mutate(new = mpg * 2)

# 3. Use data.table for large data
# library(dtplyr)
# lazy_dt(large_data) %>%
#   filter(...) %>%
#   as_tibble()
```
</div>

## Code Organization

<div class="bestpractice-box">
üéØ **Best Practice: Readable Pipelines**

```{r}
# Good: One operation per line
result <- mtcars %>%
  filter(mpg > 20) %>%
  mutate(
    hp_per_ton = hp / wt,
    efficiency = mpg / hp
  ) %>%
  group_by(cyl) %>%
  summarize(
    avg_efficiency = mean(efficiency),
    n = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(avg_efficiency))

# Good: Use intermediate variables for clarity
filtered_cars <- mtcars %>%
  filter(mpg > 20, cyl %in% c(4, 6))

efficiency_metrics <- filtered_cars %>%
  mutate(
    hp_per_ton = hp / wt,
    efficiency = mpg / hp
  )

final_summary <- efficiency_metrics %>%
  group_by(cyl) %>%
  summarize(
    avg_efficiency = mean(efficiency),
    n = n(),
    .groups = "drop"
  )

# Bad: Everything in one long pipe
# result <- mtcars %>% filter(mpg > 20) %>% mutate(hp_per_ton = hp / wt, efficiency = mpg / hp) %>% group_by(cyl) %>% summarize(avg_efficiency = mean(efficiency), n = n(), .groups = "drop") %>% arrange(desc(avg_efficiency))
```
</div>

## Common Anti-Patterns

<div class="pitfall-box">
‚ö†Ô∏è **Avoid These Patterns**

```{r}
# Anti-pattern 1: Growing data frame in loop
# Bad
result <- tibble()
for (i in 1:100) {
  result <- bind_rows(result, tibble(x = i, y = i^2))
}

# Good
result <- tibble(
  x = 1:100,
  y = x^2
)

# Anti-pattern 2: Unnecessary grouping
# Bad
mtcars %>%
  group_by(cyl) %>%
  select(mpg, cyl, hp)  # select doesn't need groups

# Good
mtcars %>%
  select(mpg, cyl, hp) %>%
  group_by(cyl)  # Group only when needed

# Anti-pattern 3: Repeated similar code
# Bad
mtcars %>%
  summarize(
    mean_mpg = mean(mpg),
    mean_hp = mean(hp),
    mean_wt = mean(wt),
    mean_disp = mean(disp)
  )

# Good
mtcars %>%
  summarize(across(c(mpg, hp, wt, disp), mean, .names = "mean_{.col}"))

# Anti-pattern 4: Ignoring NAs
# Bad
data_with_na <- tibble(x = c(1, 2, NA, 4))
data_with_na %>%
  summarize(mean_x = mean(x))  # Returns NA!

# Good
data_with_na %>%
  summarize(mean_x = mean(x, na.rm = TRUE))
```
</div>

## Debugging Strategies

<div class="bestpractice-box">
üéØ **Best Practice: Debug Effectively**

```{r}
# 1. Check intermediate steps
mtcars %>%
  filter(mpg > 20) %>%
  {cat("After filter:", nrow(.), "rows\n"); .} %>%
  select(mpg, cyl, hp) %>%
  {cat("After select:", ncol(.), "cols\n"); .} %>%
  head(3)

# 2. Use View() in RStudio
# mtcars %>%
#   filter(mpg > 20) %>%
#   View()

# 3. Print summary statistics
debug_data <- function(data, label = "") {
  cat("\n=== Debug:", label, "===\n")
  cat("Rows:", nrow(data), "\n")
  cat("Cols:", ncol(data), "\n")
  cat("Columns:", paste(names(data), collapse = ", "), "\n")
  data
}

mtcars %>%
  debug_data("original") %>%
  filter(mpg > 20) %>%
  debug_data("after filter")

# 4. Check for common issues
check_pipeline <- function(data) {
  cat("=== Pipeline Check ===\n")
  cat("Rows:", nrow(data), "\n")
  cat("NA counts:\n")
  print(colSums(is.na(data)))
  cat("\nGrouping:", paste(group_vars(data), collapse = ", "), "\n")
  cat("Grouped:", is_grouped_df(data), "\n")
  data
}
```
</div>

## Documentation

<div class="bestpractice-box">
üéØ **Best Practice: Document Complex Operations**

```{r}
# Good: Comments explain WHY, not WHAT
clean_sales_data <- function(data) {
  data %>%
    # Remove test transactions (internal use only)
    filter(customer_id >= 1000) %>%
    # Standardize date format for downstream systems
    mutate(date = as.Date(date)) %>%
    # Calculate revenue (excluding tax per accounting rules)
    mutate(revenue = quantity * price) %>%
    # Remove cancelled orders (status code 99)
    filter(status != 99)
}

# Good: Function documentation
#' Calculate customer lifetime value
#'
#' @param orders Data frame with customer_id, date, amount
#' @param window_days Number of days to consider (default: 365)
#' @return Data frame with customer_id and lifetime_value
calculate_ltv <- function(orders, window_days = 365) {
  cutoff_date <- Sys.Date() - window_days
  
  orders %>%
    filter(date >= cutoff_date) %>%
    group_by(customer_id) %>%
    summarize(
      lifetime_value = sum(amount),
      n_orders = n(),
      .groups = "drop"
    )
}
```
</div>

## Error Handling

<div class="bestpractice-box">
üéØ **Best Practice: Handle Errors Gracefully**

```{r}
# Validate inputs
safe_summarize <- function(data, col) {
  # Check data frame
  if (!is.data.frame(data)) {
    stop("data must be a data frame")
  }
  
  # Check column exists
  if (!col %in% names(data)) {
    stop("Column '", col, "' not found. ",
         "Available: ", paste(names(data), collapse = ", "))
  }
  
  # Check numeric
  if (!is.numeric(data[[col]])) {
    stop("Column '", col, "' must be numeric")
  }
  
  # Perform operation
  data %>%
    summarize(
      mean = mean(.data[[col]], na.rm = TRUE),
      sd = sd(.data[[col]], na.rm = TRUE),
      n = sum(!is.na(.data[[col]]))
    )
}

# Test
safe_summarize(mtcars, "mpg")
```

```{r error=TRUE}
safe_summarize(mtcars, "missing_col")
```
</div>

## Testing Pipelines

<div class="bestpractice-box">
üéØ **Best Practice: Test Your Code**

```{r}
# Create test function
test_clean_data <- function() {
  # Setup test data
  test_data <- tibble(
    id = 1:5,
    value = c(10, NA, 30, 40, 50),
    group = c("A", "A", "B", "B", "C")
  )
  
  # Run pipeline
  result <- test_data %>%
    filter(!is.na(value)) %>%
    group_by(group) %>%
    summarize(mean_value = mean(value), .groups = "drop")
  
  # Check results
  stopifnot(nrow(result) == 3)  # 3 groups
  stopifnot(all(!is.na(result$mean_value)))  # No NAs
  stopifnot("group" %in% names(result))  # Has group column
  
  message("‚úì All tests passed")
  TRUE
}

test_clean_data()
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Filter early** - Reduce data size first
2. **Select needed columns** - Don't carry extra data
3. **One operation per line** - Readable pipelines
4. **Use across()** - Avoid repetition
5. **Handle NAs** - Always specify na.rm
6. **Ungroup** - Clean up after group operations
7. **Document WHY** - Not what code does
8. **Test code** - Catch errors early

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Excellent pipeline
result <- data %>%
  # Filter first (reduce data)
  filter(important_condition) %>%
  # Select needed columns
  select(needed_cols) %>%
  # Transform
  mutate(new_col = calculation) %>%
  # Aggregate
  group_by(category) %>%
  summarize(
    metric = mean(value, na.rm = TRUE),
    n = n(),
    .groups = "drop"  # Always ungroup
  ) %>%
  # Sort
  arrange(desc(metric))

# ‚úÖ Use functions for repeated logic
calculate_stats <- function(data, group_var, value_var) {
  data %>%
    group_by({{ group_var }}) %>%
    summarize(
      across({{ value_var }},
             list(mean = ~mean(., na.rm = TRUE),
                  sd = ~sd(., na.rm = TRUE)),
             .names = "{.col}_{.fn}"),
      .groups = "drop"
    )
}

# ‚úÖ Document complex operations
# Remove outliers using IQR method (1.5 * IQR)
clean_data <- data %>%
  group_by(category) %>%
  filter(
    value >= quantile(value, 0.25) - 1.5 * IQR(value),
    value <= quantile(value, 0.75) + 1.5 * IQR(value)
  ) %>%
  ungroup()
```

**Anti-Patterns to Avoid:**

```{r eval=FALSE}
# ‚ùå Bad
Growing data in loops
Unnecessary grouping
Repeated similar code
Ignoring NAs
No error checking
Complex one-liners
No comments on complex logic

# ‚úÖ Good
Vectorized operations
Group only when needed
Use across() for repetition
Always handle NAs
Validate inputs
Break into readable steps
Document WHY not WHAT
```
</div>

## Exercise

<div class="exercise-box">
üìù **Exercise: Refactor Pipeline**

Improve this code:

```{r eval=FALSE}
result <- data %>%
  mutate(x = a + b, y = c + d, z = e + f) %>%
  filter(category == "A" | category == "B" | category == "C") %>%
  group_by(category) %>%
  summarize(mean_x = mean(x), mean_y = mean(y), mean_z = mean(z)) %>%
  filter(mean_x > 0)
```
</div>

## Exercise Answer

<details>
<summary>Click to see answer</summary>

```{r eval=FALSE}
# Refactored version
result <- data %>%
  # Filter early for better performance
  filter(category %in% c("A", "B", "C")) %>%
  # Use across() to avoid repetition
  mutate(
    across(c(a, b), .names = "sum_{.col}",
           .fns = ~ . + .)
  ) %>%
  # Group for aggregation
  group_by(category) %>%
  # Use across() in summarize
  summarize(
    across(starts_with("sum_"),
           mean,
           na.rm = TRUE,
           .names = "mean_{.col}"),
    .groups = "drop"
  ) %>%
  # Filter on summarized values
  filter(mean_sum_a > 0)
```
</details>

## Completion

<div class="chapter-summary">
**Part VIII Complete!**

You've mastered:
- dplyr fundamentals (filter, select, mutate, etc.)
- Grouping and summarizing
- Joining data
- Reshaping with tidyr
- Advanced tidy evaluation
- Best practices and optimization

**Ready for:** Part IX (Graphics) or other advanced topics!
</div>

<!--chapter:end:25-dplyr-best-practices.Rmd-->

# Part IX: Graphics (ggplot2) {-}

# Introduction to ggplot2 {#ggplot2-intro}

<div class="chapter-summary">
**What You'll Learn:**

- Grammar of Graphics principles
- Basic ggplot2 structure
- Common plotting errors
- Aesthetics and geoms
- Layer system

**Key Errors Covered:** 20+ ggplot2 errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

ggplot2 revolutionized R graphics with the Grammar of Graphics:

```{r message=FALSE, warning=FALSE}
library(ggplot2)

# Basic plot
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()
```

But ggplot2 has unique error patterns. Let's master them!

## ggplot2 Structure

<div class="insight-box">
üí° **Key Insight: Grammar of Graphics**

```{r}
# Three essential components:
# 1. Data
# 2. Aesthetic mappings (aes)
# 3. Geometric objects (geom)

# Basic structure
ggplot(data = mtcars, mapping = aes(x = mpg, y = hp)) +
  geom_point()

# Shortened (common)
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()

# Can specify aes in geom instead
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp))

# Or mix (useful for multiple layers)
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  geom_smooth()
```

**Key principle:** Build plots in layers with `+`
</div>

## Error #1: `object not found` in aes() {#ggplot-object-not-found}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-scope">üîç SCOPE</span>

### The Error

```{r error=TRUE}
ggplot(mtcars, aes(x = mpg, y = horsepower)) +
  geom_point()
```

<div class="error-box">
üî¥ **ERROR**

```
Error in FUN(X[[i]], ...) : object 'horsepower' not found
```
</div>

### What It Means

The column name doesn't exist in the data.

### Common Causes

```{r error=TRUE}
# Typo in column name
ggplot(mtcars, aes(x = mpgg, y = hp)) +
  geom_point()

# Wrong dataset
ggplot(iris, aes(x = mpg, y = hp)) +
  geom_point()

# Forgot to create column
ggplot(mtcars, aes(x = mpg, y = efficiency)) +
  geom_point()
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Column Names**

```{r}
# Verify columns
names(mtcars)

# Use correct name
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Create Column First**

```{r}
library(dplyr)

mtcars %>%
  mutate(efficiency = mpg / hp) %>%
  ggplot(aes(x = hp, y = efficiency)) +
  geom_point()
```
</div>

## Error #2: Using `+` vs `%>%` {#ggplot-plus-vs-pipe}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-syntax">üî§ SYNTAX</span>

### The Error

```{r error=TRUE}
library(dplyr)

mtcars %>%
  filter(cyl == 4) %>%
  ggplot(aes(x = mpg, y = hp)) %>%  # Wrong operator!
  geom_point()
```

<div class="error-box">
üî¥ **ERROR**

```
Error in geom_point(.) : 
  Cannot use `+` with a ggplot object. Did you accidentally use `%>%` instead of `+`?
```
</div>

### What It Means

Must use `+` to add ggplot2 layers, not `%>%`.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Use + for ggplot layers**

```{r}
# Correct: + for ggplot
mtcars %>%
  filter(cyl == 4) %>%
  ggplot(aes(x = mpg, y = hp)) +  # Use +
  geom_point()

# Pipe data into ggplot, then use +
mtcars %>%
  filter(cyl == 4) %>%
  ggplot(aes(x = mpg, y = hp)) +
  geom_point() +
  theme_minimal()
```
</div>

## Aesthetics (aes)

<div class="insight-box">
üí° **Key Insight: Aesthetic Mappings**

```{r}
# Map variables to visual properties
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point()

# Common aesthetics:
# x, y - position
# color - point/line color
# fill - area fill color
# size - point/line size
# shape - point shape
# alpha - transparency
# linetype - line pattern

# Multiple aesthetics
ggplot(mtcars, aes(x = mpg, y = hp, 
                   color = factor(cyl),
                   size = wt)) +
  geom_point()

# Set vs map
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point(color = "blue")  # Set: all points blue

ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point()  # Map: color varies by cyl
```
</div>

## Error #3: Aesthetic outside aes() {#aesthetic-outside-aes}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Error

```{r error=TRUE}
# Trying to map cyl to color outside aes()
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp), color = cyl)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in layer(...) : object 'cyl' not found
```
</div>

### What It Means

Variable mappings must be inside `aes()`.

### Common Causes

```{r error=TRUE}
# Want color by variable
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp), color = factor(cyl))

# Want size by variable
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp), size = wt)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Put Variable Mappings in aes()**

```{r}
# Correct: color mapping inside aes
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp, color = factor(cyl)))

# Can be in ggplot() aes
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point()

# Fixed values go OUTSIDE aes
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point(color = "blue", size = 3)  # All points same
```
</div>

<div class="pitfall-box">
‚ö†Ô∏è **Common Confusion: Inside vs Outside aes()**

```{r}
# INSIDE aes(): varies by data
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point()  # Color varies by cyl

# OUTSIDE aes(): fixed for all
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point(color = "red")  # All points red

# Wrong: puts string in aes
ggplot(mtcars, aes(x = mpg, y = hp, color = "red")) +
  geom_point()  # Creates legend for "red"!
```
</div>

## Common geoms

<div class="insight-box">
üí° **Key Insight: Geometric Objects**

```{r}
# Points
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()

# Lines
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_line()

# Bars
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar()

# Histogram
ggplot(mtcars, aes(x = mpg)) +
  geom_histogram(bins = 10)

# Boxplot
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_boxplot()

# Smooth
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  geom_smooth(method = "lm")

# Text
ggplot(mtcars, aes(x = mpg, y = hp, label = rownames(mtcars))) +
  geom_text(size = 3)
```
</div>

## Error #4: `stat_count() requires x or y` {#stat-count-error}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-args">üìã ARGS</span>

### The Error

```{r error=TRUE}
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_bar()
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `geom_bar()`:
! Problem while computing stat.
‚Ñπ Error occurred in the 1st layer.
Caused by error:
! `stat_count()` must only have an `x` or `y` aesthetic.
```
</div>

### What It Means

`geom_bar()` is for counts. For pre-computed heights, use `geom_col()`.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use geom_col() for Heights**

```{r}
# Pre-computed values
data <- data.frame(
  category = c("A", "B", "C"),
  value = c(10, 15, 20)
)

ggplot(data, aes(x = category, y = value)) +
  geom_col()

# Or use stat = "identity" with geom_bar
ggplot(data, aes(x = category, y = value)) +
  geom_bar(stat = "identity")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use geom_bar() for Counts**

```{r}
# Count occurrences
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar()

# Equivalent to
mtcars %>%
  count(cyl) %>%
  ggplot(aes(x = factor(cyl), y = n)) +
  geom_col()
```
</div>

## Faceting

<div class="insight-box">
üí° **Key Insight: Small Multiples**

```{r}
# Facet by one variable
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  facet_wrap(~ cyl)

# Facet by two variables
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  facet_grid(cyl ~ gear)

# Free scales
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  facet_wrap(~ cyl, scales = "free")

# Number of columns
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  facet_wrap(~ cyl, ncol = 2)
```
</div>

## Themes and Customization

<div class="bestpractice-box">
üéØ **Best Practice: Customizing Plots**

```{r}
# Built-in themes
p <- ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()

p + theme_minimal()
p + theme_classic()
p + theme_bw()

# Custom labels
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  labs(
    title = "Fuel Efficiency vs Horsepower",
    subtitle = "Motor Trend Car Road Tests",
    x = "Miles per Gallon",
    y = "Horsepower",
    caption = "Source: mtcars dataset"
  )

# Customize theme elements
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )
```
</div>

## Error #5: Non-numeric variable for histogram {#histogram-non-numeric}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_histogram()
```

<div class="error-box">
üî¥ **ERROR**

```
Error in `geom_histogram()`:
! `stat_bin()` requires a numeric `x` variable
```
</div>

### What It Means

Histograms need continuous numeric data, not categorical.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Use Appropriate Geom**

```{r}
# For categorical: use geom_bar
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar()

# For continuous: histogram works
ggplot(mtcars, aes(x = mpg)) +
  geom_histogram(bins = 10)

# Density plot alternative
ggplot(mtcars, aes(x = mpg)) +
  geom_density()
```
</div>

## Saving Plots

<div class="bestpractice-box">
üéØ **Best Practice: Save Plots**

```{r eval=FALSE}
# Create plot
p <- ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  theme_minimal()

# Save with ggsave
ggsave("plot.png", p, width = 6, height = 4, dpi = 300)

# Or save last plot
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()

ggsave("last_plot.png", width = 6, height = 4)

# Different formats
ggsave("plot.pdf", p)
ggsave("plot.svg", p)
ggsave("plot.jpg", p)
```
</div>

## Common Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Common Plot Types**

```{r}
# Scatterplot with trend line
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point(aes(color = factor(cyl))) +
  geom_smooth(method = "lm", se = FALSE) +
  theme_minimal()

# Grouped bar chart
mtcars %>%
  count(cyl, gear) %>%
  ggplot(aes(x = factor(cyl), y = n, fill = factor(gear))) +
  geom_col(position = "dodge")

# Boxplot with points
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.3)

# Time series
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_line() +
  theme_minimal() +
  labs(title = "US Unemployment Over Time")
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Three components** - Data, aes(), geom
2. **Use + not %>%** - Add layers with +
3. **Variables in aes()** - Fixed values outside
4. **geom_bar() vs geom_col()** - Counts vs heights
5. **Check column names** - Before plotting
6. **Histograms need numeric** - Use geom_bar() for categorical
7. **Build in layers** - Add components step by step

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| object not found | Column doesn't exist | Check names(data) |
| Can't use + | Used %>% instead of + | Use + for ggplot layers |
| object 'var' not found | Variable outside aes | Put in aes() |
| stat_count requires x or y | geom_bar with y | Use geom_col() |
| requires numeric x | Non-numeric histogram | Use appropriate geom |

**Basic Structure:**

```{r eval=FALSE}
# Template
ggplot(data, aes(x = var1, y = var2)) +
  geom_point() +
  theme_minimal()

# With pipes
data %>%
  filter(condition) %>%
  ggplot(aes(x = var1, y = var2)) +  # Use +
  geom_point() +
  labs(title = "Plot Title")

# Common aesthetics
aes(
  x = var,           # x-axis
  y = var,           # y-axis
  color = var,       # point/line color
  fill = var,        # area fill
  size = var,        # size
  shape = var,       # point shape
  alpha = var,       # transparency
  linetype = var     # line pattern
)

# Common geoms
geom_point()         # scatter
geom_line()          # line
geom_bar()           # bar (counts)
geom_col()           # bar (heights)
geom_histogram()     # histogram
geom_boxplot()       # boxplot
geom_smooth()        # trend line
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
ggplot(data, aes(x = var1, y = var2, color = var3)) +
  geom_point() +
  theme_minimal()

data %>% filter(...) %>%
  ggplot(aes(x = var)) +  # + not %>%
  geom_histogram()

# ‚ùå Avoid
ggplot(data, aes(x = var1, y = var2)) %>%  # Wrong operator
  geom_point()

ggplot(data) +
  geom_point(aes(x = var), color = other_var)  # Should be in aes

geom_histogram(aes(x = factor_var))  # Need numeric
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Basic Plot**

Create a scatterplot of mtcars:
1. mpg vs hp
2. Color by cyl
3. Size by wt
4. Add title and labels
5. Use theme_minimal()
</div>

<div class="exercise-box">
üìù **Exercise 2: Error Fixing**

Fix these errors:
```{r eval=FALSE}
# Error 1
ggplot(mtcars, aes(x = mpg, y = hp)) %>%
  geom_point()

# Error 2
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp), color = cyl)

# Error 3
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_histogram()
```
</div>

<div class="exercise-box">
üìù **Exercise 3: Multiple Geoms**

Create a plot with:
1. Points for raw data
2. Smooth line for trend
3. Faceted by cyl
4. Custom colors
</div>

<div class="exercise-box">
üìù **Exercise 4: Bar Chart**

Using mtcars:
1. Count cars by cyl
2. Fill by gear
3. Dodge position
4. Add labels
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl), size = wt)) +
  geom_point(alpha = 0.7) +
  labs(
    title = "Fuel Efficiency vs Horsepower",
    subtitle = "Motor Trend Car Road Tests",
    x = "Miles per Gallon",
    y = "Horsepower",
    color = "Cylinders",
    size = "Weight (1000 lbs)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    legend.position = "right"
  )
```

**Exercise 2:**

```{r}
# Error 1: Use + not %>%
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point()

# Error 2: Put variable in aes()
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp, color = factor(cyl)))

# Error 3: Use geom_boxplot for this
ggplot(mtcars, aes(x = factor(cyl), y = mpg)) +
  geom_boxplot()

# Or if want histogram of mpg
ggplot(mtcars, aes(x = mpg)) +
  geom_histogram(bins = 10)
```

**Exercise 3:**

```{r}
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point(aes(color = factor(cyl)), size = 3, alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "black", linetype = "dashed") +
  facet_wrap(~ cyl, labeller = label_both) +
  scale_color_manual(values = c("4" = "#E41A1C", "6" = "#377EB8", "8" = "#4DAF4A")) +
  labs(
    title = "MPG vs HP by Number of Cylinders",
    x = "Miles per Gallon",
    y = "Horsepower",
    color = "Cylinders"
  ) +
  theme_bw()
```

**Exercise 4:**

```{r}
library(dplyr)

mtcars %>%
  count(cyl, gear) %>%
  ggplot(aes(x = factor(cyl), y = n, fill = factor(gear))) +
  geom_col(position = "dodge") +
  labs(
    title = "Car Count by Cylinders and Gears",
    x = "Number of Cylinders",
    y = "Count",
    fill = "Number of Gears"
  ) +
  theme_minimal() +
  scale_fill_brewer(palette = "Set2")
```
</details>

<!--chapter:end:26-ggplot2-intro.Rmd-->

# Advanced ggplot2 {#ggplot2-advanced}

<div class="chapter-summary">
**What You'll Learn:**

- Scales and coordinate systems
- Advanced themes
- Annotations and labels
- Multiple plots
- Statistical transformations

**Key Errors Covered:** 18+ advanced ggplot2 errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Advanced ggplot2 enables publication-quality graphics:

```{r message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)

# Advanced plot
ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) +
  geom_point(size = 3) +
  scale_color_gradient(low = "blue", high = "red") +
  scale_x_continuous(breaks = seq(10, 35, 5)) +
  coord_cartesian(ylim = c(50, 350)) +
  theme_minimal() +
  labs(title = "Horsepower vs MPG")
```

## Scales

<div class="insight-box">
üí° **Key Insight: Scale Functions**

```{r}
# Continuous scales
ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) +
  geom_point() +
  scale_color_gradient(low = "blue", high = "red")

# Discrete scales
ggplot(mtcars, aes(x = factor(cyl), y = mpg, fill = factor(cyl))) +
  geom_boxplot() +
  scale_fill_manual(values = c("4" = "green", "6" = "blue", "8" = "red"))

# Log scales
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  scale_y_log10()
```
</div>

## Error #1: `Discrete value supplied to continuous scale` {#discrete-continuous}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
ggplot(mtcars, aes(x = mpg, y = hp, color = cyl)) +
  geom_point() +
  scale_color_gradient(low = "blue", high = "red")
```

<div class="error-box">
üî¥ **ERROR**

```
Error: Discrete value supplied to continuous scale
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Match Scale to Data Type**

```{r}
# For discrete: use discrete scale
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point() +
  scale_color_manual(values = c("4" = "green", "6" = "blue", "8" = "red"))

# For continuous: ensure numeric
ggplot(mtcars, aes(x = mpg, y = hp, color = wt)) +
  geom_point() +
  scale_color_gradient(low = "blue", high = "red")
```
</div>

## Themes

<div class="bestpractice-box">
üéØ **Best Practice: Custom Themes**

```{r}
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title = element_text(size = 12, face = "bold"),
    legend.position = "right",
    panel.grid.minor = element_blank()
  )

ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point(size = 3) +
  custom_theme +
  labs(title = "Custom Themed Plot")
```
</div>

## Annotations

<div class="insight-box">
üí° **Key Insight: Adding Annotations**

```{r}
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  annotate("text", x = 30, y = 250, label = "High HP", color = "red") +
  geom_hline(yintercept = mean(mtcars$hp), linetype = "dashed")
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Match scales to data types**
2. **Customize with themes**
3. **Add annotations for context**
4. **Use appropriate coordinates**

**Quick Reference:**

```{r eval=FALSE}
# Scales
scale_x_continuous()
scale_color_manual()
scale_fill_brewer()

# Themes
theme_minimal()
theme()

# Annotations
annotate()
geom_hline/vline()
```
</div>

<!--chapter:end:27-ggplot2-advanced.Rmd-->

# ggplot2 Extensions {#ggplot2-extensions}

<div class="chapter-summary">
**What You'll Learn:**

- Extension packages
- Special plot types  
- Interactive plots
- Combining plots

**Key Errors Covered:** 15+ extension errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

ggplot2 extensions add specialized functionality:

```{r message=FALSE}
library(ggplot2)
library(dplyr)
```

## patchwork

<div class="insight-box">
üí° **Key Insight: Combining Plots**

```{r message=FALSE}
library(patchwork)

p1 <- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point()
p2 <- ggplot(mtcars, aes(x = mpg, y = wt)) + geom_point()

p1 + p2
p1 / p2
```
</div>

## ggrepel

<div class="insight-box">
üí° **Key Insight: Better Labels**

```{r message=FALSE}
library(ggrepel)

ggplot(mtcars, aes(x = mpg, y = hp, label = rownames(mtcars))) +
  geom_point() +
  geom_text_repel(max.overlaps = 10)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **patchwork** - Combine plots
2. **ggrepel** - Non-overlapping labels
3. **Many extensions available**

**Common Extensions:**

```{r eval=FALSE}
library(patchwork)  # Combine plots
library(ggrepel)    # Labels
library(ggthemes)   # Themes
library(plotly)     # Interactive
```
</div>

<!--chapter:end:28-ggplot2-extensions.Rmd-->

# ggplot2 Troubleshooting {#ggplot2-troubleshooting}

<div class="chapter-summary">
**What You'll Learn:**

- Common pitfalls
- Debugging strategies
- Performance tips
- Best practices
- Publication-ready plots

**Key Errors Covered:** 12+ workflow errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Mastering ggplot2 troubleshooting saves time:

```{r message=FALSE}
library(ggplot2)
library(dplyr)
```

## Common Pitfalls

<div class="pitfall-box">
‚ö†Ô∏è **Common ggplot2 Mistakes**

```{r error=TRUE}
# Pitfall 1: Using %>% instead of +
# mtcars %>%
#   ggplot(aes(x = mpg, y = hp)) %>%
#   geom_point()

# Pitfall 2: Variable outside aes
# ggplot(mtcars) +
#   geom_point(aes(x = mpg, y = hp), color = cyl)

# Pitfall 3: Wrong geom for data
# ggplot(mtcars, aes(x = factor(cyl))) +
#   geom_histogram()

# Pitfall 4: Modifying after ggsave
p <- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point()
ggsave("plot.png", p, width = 6, height = 4)
# p + theme_minimal()  # Won't affect saved plot
```
</div>

## Debugging Strategies

<div class="bestpractice-box">
üéØ **Best Practice: Debug Plots**

```{r}
# Build incrementally
p <- ggplot(mtcars, aes(x = mpg, y = hp))
p  # Check data and aesthetics

p <- p + geom_point()
p  # Check geom

p <- p + theme_minimal()
p  # Check theme

# Check data
ggplot(mtcars, aes(x = mpg, y = hp)) +
  geom_point() +
  labs(title = paste("N =", nrow(mtcars)))

# Verify aesthetics
p <- ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl)))
p$mapping  # See mappings
```
</div>

## Performance Tips

<div class="bestpractice-box">
üéØ **Best Practice: Optimize Performance**

```{r}
# For large data: sample first
# large_data %>%
#   sample_n(1000) %>%
#   ggplot(aes(x = x, y = y)) +
#   geom_point(alpha = 0.5)

# Use geom_hex for many points
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_hex() +
  scale_fill_viridis_c()

# Avoid unnecessary calculations
# Bad: calculate in aes
# ggplot(mtcars, aes(x = mpg, y = hp / wt)) + geom_point()

# Good: calculate first
mtcars %>%
  mutate(hp_per_wt = hp / wt) %>%
  ggplot(aes(x = mpg, y = hp_per_wt)) +
  geom_point()
```
</div>

## Publication-Ready Plots

<div class="bestpractice-box">
üéØ **Best Practice: Publication Quality**

```{r}
publication_plot <- function(data, x, y, color = NULL) {
  ggplot(data, aes(x = {{x}}, y = {{y}}, color = {{color}})) +
    geom_point(size = 3, alpha = 0.7) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 14),
      axis.title = element_text(size = 12, face = "bold"),
      axis.text = element_text(size = 10),
      legend.position = "right",
      legend.title = element_text(face = "bold"),
      panel.grid.minor = element_blank(),
      panel.border = element_rect(color = "black", fill = NA)
    ) +
    scale_color_viridis_d(option = "plasma")
}

publication_plot(mtcars, mpg, hp, factor(cyl)) +
  labs(
    title = "Fuel Efficiency vs Horsepower",
    subtitle = "Motor Trend Car Road Tests",
    x = "Miles per Gallon",
    y = "Horsepower",
    color = "Cylinders",
    caption = "Source: mtcars dataset"
  )
```
</div>

## Saving Plots

<div class="bestpractice-box">
üéØ **Best Practice: Save High-Quality Plots**

```{r eval=FALSE}
# High-resolution PNG
ggsave("plot.png", width = 8, height = 6, dpi = 300)

# Vector format
ggsave("plot.pdf", width = 8, height = 6)
ggsave("plot.svg", width = 8, height = 6)

# Specify plot object
p <- ggplot(mtcars, aes(x = mpg, y = hp)) + geom_point()
ggsave("my_plot.png", plot = p, width = 10, height = 8, dpi = 300)

# Different devices
ggsave("plot.jpg", device = "jpeg", quality = 95)
ggsave("plot.tiff", device = "tiff", compression = "lzw")
```
</div>

## Error Checklist

<div class="bestpractice-box">
üéØ **Debugging Checklist**

When a plot fails, check:

1. **Column names** - Do they exist in data?
```{r eval=FALSE}
names(data)
```

2. **Data types** - Numeric vs factor?
```{r eval=FALSE}
str(data)
```

3. **Missing values** - NAs present?
```{r eval=FALSE}
summary(data)
colSums(is.na(data))
```

4. **Operators** - Using + not %>%?

5. **Aesthetics** - Variables in aes()?

6. **Geom compatibility** - Right geom for data?

7. **Scale compatibility** - Match data type?
</div>

## Common Error Solutions

<div class="solution-box">
‚úÖ **Quick Fixes**

```{r}
# object not found ‚Üí Check column names
names(mtcars)

# + vs %>% ‚Üí Use + for ggplot layers
mtcars %>%
  filter(cyl == 4) %>%
  ggplot(aes(x = mpg, y = hp)) +  # Use +
  geom_point()

# Discrete/continuous mismatch ‚Üí Check data type
ggplot(mtcars, aes(x = mpg, y = hp, color = factor(cyl))) +
  geom_point() +
  scale_color_manual(values = c("4" = "red", "6" = "blue", "8" = "green"))

# stat_count requires x or y ‚Üí Use geom_col for heights
data.frame(x = c("A", "B", "C"), y = c(10, 20, 15)) %>%
  ggplot(aes(x = x, y = y)) +
  geom_col()

# Histogram needs numeric ‚Üí Use geom_bar for categorical
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar()
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Use + not %>%** - For ggplot layers
2. **Build incrementally** - Test each step
3. **Check data first** - Verify structure
4. **Variables in aes()** - Fixed values outside
5. **Match scales** - To data types
6. **Save properly** - High resolution for publication
7. **Follow checklist** - When debugging

**Quick Reference:**

```{r eval=FALSE}
# Basic structure
ggplot(data, aes(x = var1, y = var2)) +
  geom_point() +
  theme_minimal()

# With preprocessing
data %>%
  filter(condition) %>%
  ggplot(aes(x = var1, y = var2)) +  # + not %>%
  geom_point()

# Save plot
ggsave("plot.png", width = 8, height = 6, dpi = 300)

# Debug checklist
names(data)              # Column names
str(data)                # Data types
summary(data)            # Check NAs
p$mapping                # Check aesthetics
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Build plots incrementally
Check data structure first
Use appropriate geom for data type
Match scales to data
Save at high resolution
Document complex plots

# ‚ùå Avoid
Using %>% for ggplot layers
Variables outside aes()
Ignoring warnings
Low-resolution saves
Complex one-liners without testing
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Fix Errors**

Fix these common errors:
```{r eval=FALSE}
# Error 1
mtcars %>%
  ggplot(aes(x = mpg, y = hp)) %>%
  geom_point()

# Error 2  
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp), color = cyl)

# Error 3
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_histogram()
```
</div>

<div class="exercise-box">
üìù **Exercise 2: Publication Plot**

Create a publication-ready plot with:
- Custom theme
- Proper labels
- High-quality aesthetics
- Save at 300 DPI
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# Error 1: Use + not %>%
mtcars %>%
  ggplot(aes(x = mpg, y = hp)) +
  geom_point()

# Error 2: Put variable in aes()
ggplot(mtcars) +
  geom_point(aes(x = mpg, y = hp, color = factor(cyl)))

# Error 3: Use geom_bar() for categorical
ggplot(mtcars, aes(x = factor(cyl))) +
  geom_bar()
```

**Exercise 2:**

```{r eval=FALSE}
p <- mtcars %>%
  ggplot(aes(x = mpg, y = hp, color = factor(cyl), size = wt)) +
  geom_point(alpha = 0.7) +
  scale_color_manual(
    values = c("4" = "#1f77b4", "6" = "#ff7f0e", "8" = "#2ca02c"),
    name = "Cylinders"
  ) +
  scale_size_continuous(name = "Weight (1000 lbs)", range = c(2, 6)) +
  labs(
    title = "Fuel Efficiency vs Horsepower",
    subtitle = "Motor Trend Car Road Tests (1974)",
    x = "Miles per Gallon",
    y = "Horsepower",
    caption = "Source: Henderson and Velleman (1981), mtcars dataset"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, color = "gray40"),
    axis.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(size = 10),
    legend.position = "right",
    legend.title = element_text(face = "bold", size = 11),
    legend.text = element_text(size = 10),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5),
    plot.caption = element_text(hjust = 0, size = 8, color = "gray50")
  )

# Save high-resolution
ggsave("publication_plot.png", plot = p, 
       width = 10, height = 7, dpi = 300, bg = "white")

# Also save vector version
ggsave("publication_plot.pdf", plot = p,
       width = 10, height = 7)
```
</details>

## Completion

<div class="chapter-summary">
**Part IX Complete!**

You've mastered:
- ggplot2 basics and structure
- Advanced customization
- Extensions and special plots
- Troubleshooting and best practices

**Ready for:** Part X (Statistical Operations) or other topics!
</div>

<!--chapter:end:29-ggplot2-troubleshooting.Rmd-->

# Part X: Statistical Operations {-}

# Statistical Tests {#statistical-tests}

<div class="chapter-summary">
**What You'll Learn:**

- t-tests (one-sample, two-sample, paired)
- Common statistical test errors
- Assumptions and violations
- Interpreting results
- Effect sizes

**Key Errors Covered:** 22+ statistical errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

R excels at statistical testing, but errors are common:

```{r message=FALSE}
# Simple t-test
t.test(mtcars$mpg[mtcars$am == 0], 
       mtcars$mpg[mtcars$am == 1])
```

Let's master statistical testing errors!

## t-tests

<div class="insight-box">
üí° **Key Insight: Types of t-tests**

```{r}
# One-sample t-test (compare to population mean)
t.test(mtcars$mpg, mu = 20)

# Two-sample t-test (independent groups)
t.test(mpg ~ am, data = mtcars)

# Paired t-test (same subjects, two conditions)
before <- c(120, 135, 140, 125, 130)
after <- c(115, 130, 135, 120, 128)
t.test(before, after, paired = TRUE)

# One-sided test
t.test(mpg ~ am, data = mtcars, alternative = "greater")

# Unequal variances (Welch's t-test, default)
t.test(mpg ~ am, data = mtcars, var.equal = FALSE)

# Equal variances (Student's t-test)
t.test(mpg ~ am, data = mtcars, var.equal = TRUE)
```
</div>

## Error #1: `not enough 'x' observations` {#not-enough-obs}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
# Only one observation
t.test(c(5))
```

<div class="error-box">
üî¥ **ERROR**

```
Error in t.test.default(c(5)) : not enough 'x' observations
```
</div>

### What It Means

Need at least 2 observations for t-test.

### Common Causes

```{r error=TRUE}
# Empty vector after filtering
data <- mtcars$mpg[mtcars$cyl == 99]  # No cars with 99 cylinders
t.test(data)

# Single group
t.test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 99])
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Data First**

```{r}
# Check sample sizes
automatic <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

cat("Automatic:", length(automatic), "observations\n")
cat("Manual:", length(manual), "observations\n")

if (length(automatic) >= 2 && length(manual) >= 2) {
  t.test(automatic, manual)
} else {
  warning("Insufficient data for t-test")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Safe t-test Function**

```{r}
safe_t_test <- function(x, y = NULL, ...) {
  if (is.null(y)) {
    if (length(x) < 2) {
      stop("x must have at least 2 observations")
    }
  } else {
    if (length(x) < 2) {
      stop("x must have at least 2 observations")
    }
    if (length(y) < 2) {
      stop("y must have at least 2 observations")
    }
  }
  
  t.test(x, y, ...)
}

# Test
safe_t_test(mtcars$mpg[mtcars$am == 0], 
            mtcars$mpg[mtcars$am == 1])
```
</div>

## Error #2: `data are essentially constant` {#constant-data}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
# All values the same
t.test(c(5, 5, 5, 5, 5))
```

<div class="error-box">
üî¥ **ERROR**

```
Error in t.test.default(c(5, 5, 5, 5, 5)) : 
  data are essentially constant
```
</div>

### What It Means

No variation in data - standard deviation is zero or near-zero.

### Common Causes

```{r error=TRUE}
# Rounded data with no variation
t.test(c(10, 10, 10, 10, 10))

# Binary data coded as 0/1 with all same
t.test(c(1, 1, 1, 1))
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check for Variation**

```{r}
check_variation <- function(x) {
  if (sd(x) == 0 || length(unique(x)) == 1) {
    warning("No variation in data - t-test not appropriate")
    return(FALSE)
  }
  TRUE
}

# Check before test
data <- c(10, 10, 10, 10)
if (check_variation(data)) {
  t.test(data)
} else {
  cat("Data has no variation\n")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Appropriate Test**

```{r}
# For proportions, use prop.test
successes <- c(1, 1, 1, 1)  # All successes
prop.test(sum(successes), length(successes))

# Or check if variation exists
data <- mtcars$mpg
if (sd(data) > 0) {
  t.test(data, mu = 20)
} else {
  cat("Data is constant, mean =", mean(data), "\n")
}
```
</div>

## Formula Interface

<div class="insight-box">
üí° **Key Insight: Formula vs Vector Interface**

```{r}
# Vector interface
group1 <- mtcars$mpg[mtcars$am == 0]
group2 <- mtcars$mpg[mtcars$am == 1]
t.test(group1, group2)

# Formula interface (preferred)
t.test(mpg ~ am, data = mtcars)

# Formula with subset
t.test(mpg ~ am, data = mtcars, subset = cyl == 4)

# Advantages of formula:
# - Cleaner code
# - Automatic labeling
# - Works with model functions
# - Subset argument
```
</div>

## Error #3: `grouping factor must have 2 levels` {#two-levels}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
# Three levels in grouping variable
t.test(mpg ~ cyl, data = mtcars)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in t.test.formula(mpg ~ cyl, data = mtcars) : 
  grouping factor must have exactly 2 levels
```
</div>

### What It Means

t-test compares exactly 2 groups. Variable has more than 2 levels.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Filter to 2 Groups**

```{r}
# Compare only 4 vs 6 cylinders
mtcars_subset <- mtcars[mtcars$cyl %in% c(4, 6), ]
t.test(mpg ~ cyl, data = mtcars_subset)

# Or use subset argument
t.test(mpg ~ cyl, data = mtcars, subset = cyl %in% c(4, 6))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use ANOVA for >2 Groups**

```{r}
# For 3+ groups, use ANOVA
anova_result <- aov(mpg ~ factor(cyl), data = mtcars)
summary(anova_result)

# Post-hoc tests
TukeyHSD(anova_result)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Multiple Comparisons**

```{r}
# Compare all pairs
library(dplyr)

# Get unique cylinder values
cyl_levels <- unique(mtcars$cyl)
comparisons <- combn(cyl_levels, 2)

# Perform all pairwise tests
results <- apply(comparisons, 2, function(pair) {
  subset_data <- mtcars[mtcars$cyl %in% pair, ]
  test <- t.test(mpg ~ cyl, data = subset_data)
  
  data.frame(
    comparison = paste(pair[1], "vs", pair[2]),
    p_value = test$p.value,
    statistic = test$statistic
  )
})

do.call(rbind, results)
```
</div>

## Assumptions

<div class="insight-box">
üí° **Key Insight: t-test Assumptions**

```{r}
# Assumptions:
# 1. Independence
# 2. Normality (esp. for small samples)
# 3. Equal variances (for Student's t-test)

# Check normality
shapiro.test(mtcars$mpg)

# Visual check
qqnorm(mtcars$mpg)
qqline(mtcars$mpg)

# Check equal variances
var.test(mpg ~ am, data = mtcars)

# If assumptions violated:
# - Use Welch's t-test (var.equal = FALSE, default)
# - Use Mann-Whitney U test (non-parametric)
wilcox.test(mpg ~ am, data = mtcars)
```
</div>

## Interpreting Results

<div class="insight-box">
üí° **Key Insight: Understanding Output**

```{r}
result <- t.test(mpg ~ am, data = mtcars)
result

# Extract components
result$statistic    # t-statistic
result$parameter    # degrees of freedom
result$p.value      # p-value
result$conf.int     # confidence interval
result$estimate     # group means

# Interpretation
cat("t-statistic:", round(result$statistic, 3), "\n")
cat("p-value:", round(result$p.value, 4), "\n")
cat("95% CI:", round(result$conf.int, 2), "\n")
cat("Mean difference:", round(diff(result$estimate), 2), "\n")

if (result$p.value < 0.05) {
  cat("\nSignificant difference between groups (p < 0.05)\n")
} else {
  cat("\nNo significant difference between groups (p >= 0.05)\n")
}
```
</div>

## Effect Size

<div class="bestpractice-box">
üéØ **Best Practice: Report Effect Sizes**

```{r}
# Cohen's d for effect size
cohens_d <- function(x, y) {
  n1 <- length(x)
  n2 <- length(y)
  
  # Pooled standard deviation
  s_pooled <- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2))
  
  # Cohen's d
  d <- (mean(x) - mean(y)) / s_pooled
  
  # Interpretation
  interpretation <- if (abs(d) < 0.2) "negligible"
    else if (abs(d) < 0.5) "small"
    else if (abs(d) < 0.8) "medium"
    else "large"
  
  list(
    d = d,
    interpretation = interpretation
  )
}

# Calculate effect size
auto <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

effect <- cohens_d(auto, manual)
cat("Cohen's d:", round(effect$d, 2), "\n")
cat("Effect size:", effect$interpretation, "\n")
```
</div>

## Paired t-tests

<div class="insight-box">
üí° **Key Insight: Paired vs Independent**

```{r}
# Paired: same subjects, two conditions
before <- c(120, 135, 140, 125, 130, 145, 150)
after <- c(115, 130, 135, 120, 128, 140, 145)

# Paired t-test
t.test(before, after, paired = TRUE)

# Calculate differences
differences <- before - after
cat("Mean difference:", mean(differences), "\n")
cat("SD of differences:", sd(differences), "\n")

# One-sample test on differences (equivalent)
t.test(differences, mu = 0)

# Independent would be WRONG here
t.test(before, after, paired = FALSE)  # Ignores pairing
```
</div>

## Error #4: `'x' and 'y' must have the same length` {#length-mismatch-paired}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
before <- c(120, 135, 140, 125)
after <- c(115, 130, 135)  # Only 3 values

t.test(before, after, paired = TRUE)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in t.test.default(before, after, paired = TRUE) : 
  'x' and 'y' must have the same length
```
</div>

### What It Means

Paired t-test requires same number of observations in each group.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Lengths**

```{r}
before <- c(120, 135, 140, 125, 130)
after <- c(115, 130, 135, 120, 128)

if (length(before) != length(after)) {
  stop("before and after must have same length for paired test")
}

t.test(before, after, paired = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Handle Missing Data**

```{r}
# Data with NAs
before <- c(120, 135, NA, 125, 130)
after <- c(115, 130, 135, 120, NA)

# Remove pairs with any NA
complete_cases <- complete.cases(before, after)
before_clean <- before[complete_cases]
after_clean <- after[complete_cases]

cat("Complete pairs:", sum(complete_cases), "\n")

t.test(before_clean, after_clean, paired = TRUE)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Use Data Frame Approach**

```{r}
library(dplyr)
library(tidyr)

# Store in data frame
data <- data.frame(
  id = 1:5,
  before = c(120, 135, NA, 125, 130),
  after = c(115, 130, 135, 120, NA)
)

# Remove incomplete cases
data_complete <- data %>%
  filter(!is.na(before) & !is.na(after))

cat("Complete cases:", nrow(data_complete), "\n")

with(data_complete, t.test(before, after, paired = TRUE))
```
</div>

## Power and Sample Size

<div class="bestpractice-box">
üéØ **Best Practice: Power Analysis**

```{r}
# Calculate required sample size
power.t.test(
  delta = 5,        # Expected difference
  sd = 10,          # Standard deviation
  sig.level = 0.05, # Alpha
  power = 0.80      # Desired power
)

# Calculate power for given sample size
power.t.test(
  n = 20,
  delta = 5,
  sd = 10,
  sig.level = 0.05
)

# For existing study
auto <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

power.t.test(
  n = length(auto),
  delta = abs(mean(auto) - mean(manual)),
  sd = sd(c(auto, manual)),
  sig.level = 0.05
)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Check sample sizes** - Need at least 2 observations per group
2. **Check variation** - Data can't be constant
3. **Exactly 2 groups** - Use ANOVA for 3+
4. **Paired = same length** - Remove incomplete pairs
5. **Check assumptions** - Normality, equal variances
6. **Report effect sizes** - Not just p-values
7. **Formula interface preferred** - Cleaner code

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| not enough observations | n < 2 | Check sample sizes |
| data are constant | sd = 0 | Check for variation |
| must have 2 levels | 3+ groups | Filter or use ANOVA |
| must have same length | Paired mismatch | Remove incomplete pairs |

**t-test Variations:**

```{r eval=FALSE}
# One-sample
t.test(x, mu = 0)

# Two-sample (independent)
t.test(x, y)
t.test(y ~ x, data = df)

# Paired
t.test(x, y, paired = TRUE)

# One-sided
t.test(x, y, alternative = "greater")
t.test(x, y, alternative = "less")

# Equal variances
t.test(x, y, var.equal = TRUE)

# With subset
t.test(y ~ x, data = df, subset = condition)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Check sample sizes first
Check assumptions (normality, equal variance)
Use formula interface: t.test(y ~ x, data = df)
Report effect sizes (Cohen's d)
Use Welch's t-test (default) for unequal variances
Check for paired vs independent design

# ‚ùå Avoid
Assuming data meets assumptions
Using t-test for 3+ groups
Ignoring pairing in data
Only reporting p-values
Using with constant data
Not checking sample sizes
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Basic t-test**

Using mtcars:
1. Test if mean mpg differs by transmission (am)
2. Check assumptions
3. Calculate effect size
4. Interpret results
</div>

<div class="exercise-box">
üìù **Exercise 2: Paired t-test**

Create before/after data and:
1. Perform paired t-test
2. Check if order matters
3. Calculate mean difference
4. Visualize differences
</div>

<div class="exercise-box">
üìù **Exercise 3: Safe t-test Function**

Write `safe_t_test()` that:
1. Checks sample sizes
2. Checks for variation
3. Verifies assumptions
4. Performs test
5. Returns formatted results
</div>

<div class="exercise-box">
üìù **Exercise 4: Multiple Comparisons**

Using iris dataset:
1. Compare petal length across species
2. Perform all pairwise t-tests
3. Adjust for multiple testing
4. Report results in table
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# 1. Test mean mpg by transmission
result <- t.test(mpg ~ am, data = mtcars)
result

# 2. Check assumptions
# Normality
shapiro.test(mtcars$mpg[mtcars$am == 0])
shapiro.test(mtcars$mpg[mtcars$am == 1])

# Equal variances
var.test(mpg ~ am, data = mtcars)

# 3. Effect size
auto <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

cohens_d <- function(x, y) {
  n1 <- length(x)
  n2 <- length(y)
  s_pooled <- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2))
  (mean(x) - mean(y)) / s_pooled
}

d <- cohens_d(auto, manual)

# 4. Interpret
cat("\n=== Results ===\n")
cat("t-statistic:", round(result$statistic, 3), "\n")
cat("p-value:", format.pval(result$p.value, digits = 3), "\n")
cat("Mean difference:", round(diff(result$estimate), 2), "mpg\n")
cat("95% CI:", round(result$conf.int, 2), "\n")
cat("Cohen's d:", round(d, 2), "\n")

if (result$p.value < 0.05) {
  cat("\nConclusion: Significant difference in mpg between transmission types (p < 0.05)\n")
  cat("Manual transmission has", round(abs(diff(result$estimate)), 1), 
      "higher mpg on average.\n")
}
```

**Exercise 2:**

```{r}
# Create data
set.seed(123)
before <- c(120, 135, 140, 125, 130, 145, 150, 128, 138, 142)
after <- before - rnorm(10, mean = 8, sd = 3)

# 1. Paired t-test
result <- t.test(before, after, paired = TRUE)
result

# 2. Order doesn't matter for pairing
t.test(after, before, paired = TRUE)  # Same magnitude, opposite sign

# 3. Mean difference
differences <- before - after
cat("\nMean difference:", round(mean(differences), 2), "\n")
cat("SD of differences:", round(sd(differences), 2), "\n")

# 4. Visualize
library(ggplot2)

data_df <- data.frame(
  id = rep(1:10, 2),
  time = rep(c("Before", "After"), each = 10),
  value = c(before, after)
)

ggplot(data_df, aes(x = time, y = value, group = id)) +
  geom_line(alpha = 0.5) +
  geom_point(size = 3) +
  labs(title = "Before vs After Comparison",
       subtitle = paste("Mean difference:", round(mean(differences), 1)),
       y = "Value") +
  theme_minimal()

# Difference plot
diff_df <- data.frame(
  id = 1:10,
  difference = differences
)

ggplot(diff_df, aes(x = id, y = difference)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point(size = 3) +
  geom_segment(aes(xend = id, yend = 0)) +
  labs(title = "Individual Differences",
       y = "Before - After") +
  theme_minimal()
```

**Exercise 3:**

```{r}
safe_t_test <- function(x, y = NULL, paired = FALSE, ...) {
  
  # Check inputs
  if (is.null(y)) {
    # One-sample test
    if (length(x) < 2) {
      stop("Need at least 2 observations")
    }
    if (sd(x) == 0) {
      stop("Data has no variation")
    }
  } else {
    # Two-sample test
    if (length(x) < 2) stop("x needs at least 2 observations")
    if (length(y) < 2) stop("y needs at least 2 observations")
    if (sd(x) == 0) stop("x has no variation")
    if (sd(y) == 0) stop("y has no variation")
    
    # Check paired
    if (paired && length(x) != length(y)) {
      stop("For paired test, x and y must have same length")
    }
  }
  
  # Perform test
  result <- t.test(x, y, paired = paired, ...)
  
  # Format output
  output <- list(
    test = result,
    summary = data.frame(
      statistic = result$statistic,
      df = result$parameter,
      p_value = result$p.value,
      mean_diff = ifelse(is.null(y), 
                         result$estimate - result$null.value,
                         diff(result$estimate)),
      ci_lower = result$conf.int[1],
      ci_upper = result$conf.int[2]
    )
  )
  
  # Print summary
  cat("=== t-test Results ===\n")
  cat("t =", round(output$summary$statistic, 3), "\n")
  cat("df =", round(output$summary$df, 1), "\n")
  cat("p-value =", format.pval(output$summary$p_value, digits = 3), "\n")
  cat("Mean difference =", round(output$summary$mean_diff, 2), "\n")
  cat("95% CI: [", round(output$summary$ci_lower, 2), ",",
      round(output$summary$ci_upper, 2), "]\n")
  
  if (output$summary$p_value < 0.05) {
    cat("\nSignificant at Œ± = 0.05\n")
  } else {
    cat("\nNot significant at Œ± = 0.05\n")
  }
  
  invisible(output)
}

# Test it
safe_t_test(mtcars$mpg[mtcars$am == 0], mtcars$mpg[mtcars$am == 1])
```

**Exercise 4:**

```{r}
library(dplyr)

# 1 & 2. All pairwise comparisons
species <- levels(iris$Species)
results_list <- list()

for (i in 1:(length(species) - 1)) {
  for (j in (i + 1):length(species)) {
    sp1 <- species[i]
    sp2 <- species[j]
    
    data_subset <- iris %>%
      filter(Species %in% c(sp1, sp2))
    
    test <- t.test(Petal.Length ~ Species, data = data_subset)
    
    results_list[[paste(sp1, "vs", sp2)]] <- data.frame(
      comparison = paste(sp1, "vs", sp2),
      mean_1 = test$estimate[1],
      mean_2 = test$estimate[2],
      mean_diff = diff(test$estimate),
      t_stat = test$statistic,
      p_value = test$p.value,
      ci_lower = test$conf.int[1],
      ci_upper = test$conf.int[2]
    )
  }
}

results_df <- do.call(rbind, results_list)
rownames(results_df) <- NULL

# 3. Adjust for multiple testing
results_df$p_adjusted <- p.adjust(results_df$p_value, method = "bonferroni")

# 4. Display results
cat("=== Pairwise Comparisons of Petal Length ===\n\n")
print(results_df, digits = 3)

cat("\n=== Summary ===\n")
cat("Total comparisons:", nrow(results_df), "\n")
cat("Significant (unadjusted):", sum(results_df$p_value < 0.05), "\n")
cat("Significant (Bonferroni):", sum(results_df$p_adjusted < 0.05), "\n")
```
</details>

<!--chapter:end:30-statistical-tests.Rmd-->

# Regression & ANOVA {#regression-anova}

<div class="chapter-summary">
**What You'll Learn:**

- Linear regression
- ANOVA (one-way, two-way)
- Model diagnostics
- Common regression errors
- Interpreting results

**Key Errors Covered:** 20+ regression errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Regression and ANOVA are fundamental statistical tools:

```{r}
# Simple linear regression
model <- lm(mpg ~ hp, data = mtcars)
summary(model)
```

Let's master these analyses!

## Linear Regression

<div class="insight-box">
üí° **Key Insight: lm() Function**

```{r}
# Simple regression (one predictor)
model1 <- lm(mpg ~ hp, data = mtcars)
summary(model1)

# Multiple regression
model2 <- lm(mpg ~ hp + wt + cyl, data = mtcars)
summary(model2)

# With interaction
model3 <- lm(mpg ~ hp * wt, data = mtcars)
summary(model3)

# Polynomial
model4 <- lm(mpg ~ poly(hp, 2), data = mtcars)
summary(model4)

# Extract components
coef(model1)          # Coefficients
fitted(model1)        # Fitted values
residuals(model1)     # Residuals
predict(model1)       # Predictions
confint(model1)       # Confidence intervals
```
</div>

## Error #1: `NA/NaN/Inf in 'y'` {#na-in-y}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
# Data with NA
data_na <- mtcars
data_na$mpg[1:3] <- NA

lm(mpg ~ hp, data = data_na)
```

<div class="error-box">
üî¥ **ERROR/WARNING**

Model runs but removes NAs with warning. Can cause issues downstream.
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Handle NAs Explicitly**

```{r}
# Remove NAs before modeling
data_clean <- mtcars[complete.cases(mtcars[, c("mpg", "hp")]), ]
model <- lm(mpg ~ hp, data = data_clean)

# Or use na.omit
data_clean2 <- na.omit(mtcars[, c("mpg", "hp", "wt")])
model2 <- lm(mpg ~ hp + wt, data = data_clean2)

# Check for NAs
cat("Complete cases:", sum(complete.cases(mtcars)), "\n")
cat("NAs in mpg:", sum(is.na(mtcars$mpg)), "\n")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use na.action**

```{r}
# Different NA handling
model_fail <- lm(mpg ~ hp, data = data_na, na.action = na.fail)  # Fails if NA
# model_exclude <- lm(mpg ~ hp, data = data_na, na.action = na.exclude)  # Excludes
# model_omit <- lm(mpg ~ hp, data = data_na, na.action = na.omit)  # Omits (default)

cat("na.omit: removes NAs, shortens residuals\n")
cat("na.exclude: removes NAs, preserves length with NAs\n")
```
</div>

## Model Diagnostics

<div class="insight-box">
üí° **Key Insight: Checking Assumptions**

```{r}
model <- lm(mpg ~ hp + wt, data = mtcars)

# Diagnostic plots
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(1, 1))

# 1. Residuals vs Fitted - Check linearity
# 2. Q-Q plot - Check normality
# 3. Scale-Location - Check homoscedasticity
# 4. Residuals vs Leverage - Check influential points

# Individual checks
# Normality of residuals
shapiro.test(residuals(model))

# Homoscedasticity
library(lmtest)
bptest(model)

# Multicollinearity
library(car)
vif(model)
```
</div>

## ANOVA

<div class="insight-box">
üí° **Key Insight: Analysis of Variance**

```{r}
# One-way ANOVA
anova_model <- aov(mpg ~ factor(cyl), data = mtcars)
summary(anova_model)

# Two-way ANOVA
anova_model2 <- aov(mpg ~ factor(cyl) + factor(gear), data = mtcars)
summary(anova_model2)

# With interaction
anova_model3 <- aov(mpg ~ factor(cyl) * factor(gear), data = mtcars)
summary(anova_model3)

# Post-hoc tests
TukeyHSD(anova_model)
```
</div>

## Error #2: `contrasts can be applied only to factors` {#contrasts-factors}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Using numeric variable as factor
model <- lm(mpg ~ cyl, data = mtcars, contrasts = list(cyl = contr.treatment))
```

<div class="error-box">
üî¥ **ERROR**

```
Error in contrasts<-: contrasts can be applied only to factors with 2 or more levels
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Convert to Factor**

```{r}
# Convert numeric to factor
mtcars$cyl_factor <- factor(mtcars$cyl)
model <- lm(mpg ~ cyl_factor, data = mtcars)
summary(model)

# For ANOVA, must be factor
anova_model <- aov(mpg ~ factor(cyl), data = mtcars)
summary(anova_model)
```
</div>

## Predictions

<div class="bestpractice-box">
üéØ **Best Practice: Making Predictions**

```{r}
model <- lm(mpg ~ hp + wt, data = mtcars)

# Predict on original data
predictions <- predict(model)
head(predictions)

# Predict on new data
new_data <- data.frame(
  hp = c(100, 150, 200),
  wt = c(2.5, 3.0, 3.5)
)

predict(model, newdata = new_data)

# With confidence intervals
predict(model, newdata = new_data, interval = "confidence")

# With prediction intervals
predict(model, newdata = new_data, interval = "prediction")
```
</div>

## Error #3: `variable lengths differ` {#variable-lengths}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-data">üìä DATA</span>

### The Error

```{r error=TRUE}
# Mismatched lengths
x <- 1:10
y <- 1:5
lm(y ~ x)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in model.frame.default: variable lengths differ (found for 'x')
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Check Data Lengths**

```{r}
# Check before modeling
x <- 1:10
y <- 1:10  # Fixed

if (length(x) != length(y)) {
  stop("Variables must have same length")
}

model <- lm(y ~ x)
```
</div>

## Model Comparison

<div class="bestpractice-box">
üéØ **Best Practice: Compare Models**

```{r}
# Nested models
model1 <- lm(mpg ~ hp, data = mtcars)
model2 <- lm(mpg ~ hp + wt, data = mtcars)
model3 <- lm(mpg ~ hp + wt + cyl, data = mtcars)

# ANOVA comparison
anova(model1, model2, model3)

# AIC/BIC
AIC(model1, model2, model3)
BIC(model1, model2, model3)

# R-squared
summary(model1)$r.squared
summary(model2)$r.squared
summary(model3)$r.squared

# Adjusted R-squared (accounts for # predictors)
summary(model1)$adj.r.squared
summary(model2)$adj.r.squared
summary(model3)$adj.r.squared
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Handle NAs explicitly** - Check before modeling
2. **Factors for ANOVA** - Convert numeric to factor
3. **Check diagnostics** - Assumptions matter
4. **Compare models** - Use ANOVA, AIC, BIC
5. **Report properly** - Coefficients, p-values, R¬≤
6. **Predict carefully** - Match variable names

**Quick Reference:**

```{r eval=FALSE}
# Linear regression
model <- lm(y ~ x, data = df)
model <- lm(y ~ x1 + x2, data = df)
model <- lm(y ~ x1 * x2, data = df)  # Interaction

# ANOVA
model <- aov(y ~ factor(group), data = df)
TukeyHSD(model)

# Diagnostics
plot(model)
summary(model)

# Predictions
predict(model, newdata = new_df)
predict(model, interval = "confidence")
```
</div>

<!--chapter:end:31-regression-anova.Rmd-->

# Statistical Best Practices {#stats-best-practices}

<div class="chapter-summary">
**What You'll Learn:**

- P-value interpretation
- Multiple testing corrections
- Effect sizes and power
- Reproducible analyses
- Common pitfalls

**Key Errors Covered:** 15+ conceptual errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Statistical best practices prevent common mistakes:

```{r message=FALSE}
library(dplyr)
```

## P-values

<div class="insight-box">
üí° **Key Insight: Understanding P-values**

```{r}
# P-value is NOT:
# - Probability hypothesis is true
# - Probability of replication
# - Effect size

# P-value IS:
# - P(data | H0 is true)
# - Probability of seeing data this extreme if null is true

# Example
t_result <- t.test(mpg ~ am, data = mtcars)

cat("P-value:", round(t_result$p.value, 4), "\n")
cat("\nInterpretation:\n")
cat("If there were truly no difference in mpg between transmissions,\n")
cat("we would see a difference this large or larger in", 
    round(t_result$p.value * 100, 2), "% of studies.\n")

# Common thresholds
if (t_result$p.value < 0.001) cat("\nVery strong evidence against H0\n")
else if (t_result$p.value < 0.01) cat("\nStrong evidence against H0\n")
else if (t_result$p.value < 0.05) cat("\nModerate evidence against H0\n")
else cat("\nWeak evidence against H0\n")
```
</div>

## Multiple Testing

<div class="insight-box">
üí° **Key Insight: Adjusting for Multiple Tests**

```{r}
# Problem: More tests = more false positives
set.seed(123)
n_tests <- 20
p_values <- replicate(n_tests, {
  x <- rnorm(30)
  y <- rnorm(30)
  t.test(x, y)$p.value
})

cat("Significant at Œ± = 0.05:", sum(p_values < 0.05), "out of", n_tests, "\n")
cat("Expected false positives:", n_tests * 0.05, "\n")

# Solutions:
# 1. Bonferroni correction (conservative)
p_bonferroni <- p.adjust(p_values, method = "bonferroni")
cat("\nAfter Bonferroni:", sum(p_bonferroni < 0.05), "significant\n")

# 2. FDR control (less conservative)
p_fdr <- p.adjust(p_values, method = "fdr")
cat("After FDR:", sum(p_fdr < 0.05), "significant\n")

# 3. Holm method (sequential)
p_holm <- p.adjust(p_values, method = "holm")
cat("After Holm:", sum(p_holm < 0.05), "significant\n")
```
</div>

## Effect Sizes

<div class="bestpractice-box">
üéØ **Best Practice: Always Report Effect Sizes**

```{r}
# t-test with effect size
auto <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

t_result <- t.test(auto, manual)

# Cohen's d
cohens_d <- function(x, y) {
  n1 <- length(x)
  n2 <- length(y)
  s_pooled <- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2))
  (mean(x) - mean(y)) / s_pooled
}

d <- cohens_d(auto, manual)

# Complete reporting
cat("=== Complete Statistical Report ===\n\n")
cat("Descriptives:\n")
cat("  Automatic: M =", round(mean(auto), 2), ", SD =", round(sd(auto), 2), ", n =", length(auto), "\n")
cat("  Manual: M =", round(mean(manual), 2), ", SD =", round(sd(manual), 2), ", n =", length(manual), "\n\n")

cat("Inferential:\n")
cat("  t(", round(t_result$parameter, 1), ") = ", round(t_result$statistic, 2), "\n", sep = "")
cat("  p =", format.pval(t_result$p.value, digits = 3), "\n")
cat("  95% CI: [", round(t_result$conf.int[1], 2), ", ", round(t_result$conf.int[2], 2), "]\n", sep = "")
cat("  Cohen's d =", round(d, 2), "\n")
```
</div>

## Power Analysis

<div class="bestpractice-box">
üéØ **Best Practice: Consider Statistical Power**

```{r}
# A priori power analysis (before study)
power_result <- power.t.test(
  delta = 5,          # Expected difference
  sd = 6,             # Expected SD
  sig.level = 0.05,
  power = 0.80
)

cat("Required sample size per group:", ceiling(power_result$n), "\n")

# Post-hoc power analysis (after study)
power_observed <- power.t.test(
  n = length(auto),
  delta = abs(mean(auto) - mean(manual)),
  sd = sd(c(auto, manual)),
  sig.level = 0.05
)

cat("Observed power:", round(power_observed$power, 2), "\n")

# Sensitivity analysis
cat("\nDetectable effect sizes with 80% power:\n")
for (n in c(10, 20, 30, 50)) {
  result <- power.t.test(n = n, sd = 6, sig.level = 0.05, power = 0.80)
  cat("  n =", n, ": d =", round(result$delta / 6, 2), "\n")
}
```
</div>

## Reproducible Analysis

<div class="bestpractice-box">
üéØ **Best Practice: Make Analyses Reproducible**

```{r}
# Set seed for reproducibility
set.seed(42)

# Document R version and packages
cat("R version:", R.version.string, "\n")
cat("Packages:\n")
cat("  dplyr:", as.character(packageVersion("dplyr")), "\n")

# Save session info
# sessionInfo()

# Complete analysis function
reproducible_t_test <- function(data, formula, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  
  # Record context
  context <- list(
    date = Sys.time(),
    r_version = R.version.string,
    data_rows = nrow(data),
    seed = seed
  )
  
  # Perform test
  result <- t.test(formula, data = data)
  
  # Return everything
  list(
    result = result,
    context = context,
    data_summary = summary(data)
  )
}

# Use it
analysis <- reproducible_t_test(mtcars, mpg ~ am, seed = 123)
analysis$result
```
</div>

## Common Pitfalls

<div class="pitfall-box">
‚ö†Ô∏è **Avoid These Common Mistakes**

```{r}
# Pitfall 1: P-hacking (testing until significant)
# BAD: Keep testing different variables until p < 0.05
# GOOD: Pre-specify hypotheses

# Pitfall 2: HARKing (Hypothesizing After Results Known)
# BAD: Claim you predicted a finding you discovered
# GOOD: Be transparent about exploratory vs confirmatory

# Pitfall 3: Not checking assumptions
model <- lm(mpg ~ hp, data = mtcars)
# BAD: Trust results without checking
# GOOD: Check diagnostics
plot(model)

# Pitfall 4: Confusing significance with importance
# p < 0.05 doesn't mean effect is large or meaningful
# Always report effect sizes

# Pitfall 5: Ignoring multiple comparisons
# BAD: Do 20 t-tests, report any p < 0.05
# GOOD: Adjust for multiple testing

# Pitfall 6: Treating p = 0.051 differently than p = 0.049
# BAD: Arbitrary cutoffs
# GOOD: Report actual p-values and confidence intervals
```
</div>

## Reporting Results

<div class="bestpractice-box">
üéØ **Best Practice: Complete Reporting Template**

```{r}
report_t_test <- function(x, y, test_name = "t-test") {
  # Perform test
  result <- t.test(x, y)
  
  # Calculate effect size
  n1 <- length(x)
  n2 <- length(y)
  s_pooled <- sqrt(((n1 - 1) * var(x) + (n2 - 1) * var(y)) / (n1 + n2 - 2))
  d <- (mean(x) - mean(y)) / s_pooled
  
  # Format report
  cat("======================\n")
  cat(test_name, "\n")
  cat("======================\n\n")
  
  cat("Sample sizes:\n")
  cat("  Group 1: n =", n1, "\n")
  cat("  Group 2: n =", n2, "\n\n")
  
  cat("Descriptive statistics:\n")
  cat("  Group 1: M =", round(mean(x), 2), ", SD =", round(sd(x), 2), "\n")
  cat("  Group 2: M =", round(mean(y), 2), ", SD =", round(sd(y), 2), "\n")
  cat("  Difference: M =", round(mean(x) - mean(y), 2), "\n\n")
  
  cat("Inferential statistics:\n")
  cat("  t(", round(result$parameter, 1), ") = ", round(result$statistic, 2), "\n", sep = "")
  cat("  p-value:", format.pval(result$p.value, digits = 3), "\n")
  cat("  95% CI: [", round(result$conf.int[1], 2), ", ", 
      round(result$conf.int[2], 2), "]\n", sep = "")
  cat("  Cohen's d =", round(d, 2))
  
  if (abs(d) < 0.2) cat(" (negligible)")
  else if (abs(d) < 0.5) cat(" (small)")
  else if (abs(d) < 0.8) cat(" (medium)")
  else cat(" (large)")
  
  cat("\n\nInterpretation:\n")
  if (result$p.value < 0.05) {
    cat("  Statistically significant difference (p < 0.05)\n")
  } else {
    cat("  No statistically significant difference (p >= 0.05)\n")
  }
  
  cat("  Effect size is", ifelse(abs(d) < 0.5, "small", "moderate to large"), "\n")
  
  invisible(list(result = result, effect_size = d))
}

# Use it
auto <- mtcars$mpg[mtcars$am == 0]
manual <- mtcars$mpg[mtcars$am == 1]

report_t_test(auto, manual, "Transmission Type Comparison")
```
</div>

## Checklist

<div class="bestpractice-box">
üéØ **Pre-Analysis Checklist**

**Before running any statistical test:**

1. ‚òê Check sample sizes (adequate power?)
2. ‚òê Check for missing data
3. ‚òê Check assumptions
   - ‚òê Independence
   - ‚òê Normality (if required)
   - ‚òê Equal variances (if required)
4. ‚òê Pre-specify hypotheses
5. ‚òê Determine if multiple testing correction needed
6. ‚òê Set random seed for reproducibility

**After running test:**

1. ‚òê Check diagnostics
2. ‚òê Calculate effect sizes
3. ‚òê Create visualizations
4. ‚òê Report completely:
   - ‚òê Descriptive statistics
   - ‚òê Test statistic and df
   - ‚òê P-value
   - ‚òê Confidence interval
   - ‚òê Effect size
5. ‚òê Interpret in context
6. ‚òê Note limitations

```{r}
# Example checklist function
analysis_checklist <- function(data, dv, iv) {
  cat("=== Analysis Checklist ===\n\n")
  
  # Sample size
  n <- nrow(data)
  cat("‚úì Sample size:", n, "\n")
  if (n < 30) cat("  ‚ö† Small sample size\n")
  
  # Missing data
  n_missing <- sum(!complete.cases(data))
  cat("‚úì Missing data:", n_missing, "cases\n")
  if (n_missing > 0) cat("  ‚ö† Consider handling missing data\n")
  
  # Assumptions
  cat("‚úì Check assumptions:\n")
  cat("  - Independence: Consider study design\n")
  cat("  - Normality: Use shapiro.test() or Q-Q plot\n")
  cat("  - Equal variances: Use var.test()\n\n")
  
  cat("‚úì Analysis ready!\n")
}

analysis_checklist(mtcars, "mpg", "am")
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **P-values measure evidence** - Not truth or importance
2. **Adjust for multiple tests** - Use Bonferroni, FDR, or Holm
3. **Always report effect sizes** - Cohen's d, R¬≤, etc.
4. **Consider power** - Before and after study
5. **Be reproducible** - Set seeds, document versions
6. **Check assumptions** - Don't blindly trust results
7. **Report completely** - All statistics, not just p-values

**Reporting Template:**

```{r eval=FALSE}
# Complete report includes:
1. Sample sizes
2. Descriptive statistics (M, SD)
3. Test statistic and df
4. P-value (exact, not just p < 0.05)
5. Confidence interval
6. Effect size
7. Interpretation in context
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Pre-specify hypotheses
Check all assumptions
Report effect sizes
Adjust for multiple testing
Use confidence intervals
Be transparent about exploratory analyses
Set random seeds
Document everything

# ‚ùå Avoid
P-hacking
HARKing
Treating p = 0.05 as magic threshold
Only reporting significant results
Ignoring effect sizes
Not checking assumptions
Cherry-picking results
```
</div>

## Completion

<div class="chapter-summary">
**Part X Complete!**

You've mastered:
- t-tests and common errors
- Regression and ANOVA
- Statistical best practices
- P-values and effect sizes
- Multiple testing corrections
- Reproducible analysis

**Ready for:** Part XI (File I/O) or other topics!
</div>

<!--chapter:end:32-stats-best-practices.Rmd-->

# Part XI: File I/O {-}

# Reading Data {#reading-data}

<div class="chapter-summary">
**What You'll Learn:**

- Reading CSV and text files
- Excel files
- Common import errors
- Encoding issues
- File path problems
- Data type detection

**Key Errors Covered:** 25+ import errors

**Difficulty:** ‚≠ê‚≠ê Intermediate to ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Reading data is the first step in any analysis:

```{r message=FALSE}
library(readr)
library(dplyr)

# Reading CSV
# data <- read_csv("file.csv")
```

But file reading has many pitfalls. Let's master them!

## Reading CSV Files

<div class="insight-box">
üí° **Key Insight: Base R vs readr**

```{r eval=FALSE}
# Base R
data1 <- read.csv("file.csv")
# - Converts strings to factors by default
# - Uses row names
# - Slower for large files

# readr (tidyverse)
data2 <- read_csv("file.csv")
# - Keeps strings as character
# - No row names
# - Much faster
# - Better type guessing
# - Progress bar
```
</div>

## Error #1: `cannot open file` {#cannot-open-file}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-path">üìÅ PATH</span>

### The Error

```{r error=TRUE}
data <- read_csv("nonexistent_file.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error: 'nonexistent_file.csv' does not exist in current working directory
```
</div>

### What It Means

File not found - wrong path or filename.

### Common Causes

```{r error=TRUE}
# Wrong filename
# read_csv("daat.csv")  # Typo

# Wrong directory
# read_csv("data/file.csv")  # data/ doesn't exist

# Case sensitivity (Linux/Mac)
# read_csv("File.csv")  # file is actually "file.csv"
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Working Directory**

```{r}
# Check current directory
getwd()

# List files
list.files()
list.files(pattern = "\\.csv$")

# Check if file exists
file.exists("mtcars.csv")

# Create example file for demonstration
write_csv(mtcars, "mtcars.csv")

# Now read it
if (file.exists("mtcars.csv")) {
  data <- read_csv("mtcars.csv", show_col_types = FALSE)
  cat("Successfully read", nrow(data), "rows\n")
}
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Full Paths**

```{r eval=FALSE}
# Absolute path (Windows)
data <- read_csv("C:/Users/username/Documents/data.csv")

# Absolute path (Mac/Linux)
data <- read_csv("/home/username/data/file.csv")

# Relative from project root (best with RStudio projects)
data <- read_csv("data/file.csv")

# Use here package for project-relative paths
library(here)
data <- read_csv(here("data", "file.csv"))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 3: Interactive File Selection**

```{r eval=FALSE}
# Choose file interactively
file_path <- file.choose()
data <- read_csv(file_path)

# Or with safe checking
safe_read_csv <- function(path = NULL) {
  if (is.null(path)) {
    path <- file.choose()
  }
  
  if (!file.exists(path)) {
    stop("File does not exist: ", path)
  }
  
  read_csv(path)
}
```
</div>

## Error #2: Encoding Issues {#encoding-issues}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-encoding">üî§ ENCODING</span>

### The Problem

```{r eval=FALSE}
# File with special characters appears garbled
data <- read_csv("international_data.csv")
# Names show as: "M√ºller" ‚Üí "M√É¬ºller"
```

### What Happened

Wrong character encoding - file is in different encoding than assumed.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Specify Encoding**

```{r eval=FALSE}
# Common encodings
data <- read_csv("file.csv", locale = locale(encoding = "UTF-8"))
data <- read_csv("file.csv", locale = locale(encoding = "latin1"))
data <- read_csv("file.csv", locale = locale(encoding = "Windows-1252"))

# Guess encoding
library(readr)
guess_encoding("file.csv")

# Use guessed encoding
encoding <- guess_encoding("file.csv")$encoding[1]
data <- read_csv("file.csv", locale = locale(encoding = encoding))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Handle in readr**

```{r eval=FALSE}
# readr handles UTF-8 by default
data <- read_csv("file.csv")

# For other encodings
data <- read_csv("file.csv", 
                 locale = locale(encoding = "ISO-8859-1"))
```
</div>

## Column Type Problems

<div class="insight-box">
üí° **Key Insight: Type Detection**

```{r}
# Create sample data
sample_data <- tibble(
  id = 1:5,
  value = c("1.5", "2.3", "3.7", "NA", "5.2"),
  date = c("2024-01-01", "2024-01-02", "2024-01-03", 
           "2024-01-04", "2024-01-05")
)

write_csv(sample_data, "sample.csv")

# Read with automatic type detection
data1 <- read_csv("sample.csv", show_col_types = FALSE)
str(data1)

# Specify column types
data2 <- read_csv("sample.csv",
                  col_types = cols(
                    id = col_integer(),
                    value = col_double(),
                    date = col_date()
                  ))
str(data2)

# Shorthand
data3 <- read_csv("sample.csv",
                  col_types = "iDd")  # integer, double, date
```
</div>

## Error #3: `One or more parsing failures` {#parsing-failures}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-parse">üîß PARSE</span>

### The Warning

```{r warning=TRUE}
# Create problematic data
bad_data <- tibble(
  id = 1:5,
  value = c("1.5", "2.3", "not_a_number", "4.1", "5.2")
)

write_csv(bad_data, "bad_data.csv")

# Read with type specification
data <- read_csv("bad_data.csv", 
                 col_types = cols(value = col_double()),
                 show_col_types = FALSE)
```

<div class="warning-box">
‚ö†Ô∏è **WARNING**

```
Warning: One or more parsing failures
```
</div>

### What It Means

Data doesn't match expected type.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check Problems**

```{r}
# See what failed
problems(data)

# Read as character first
data_char <- read_csv("bad_data.csv", 
                      col_types = cols(value = col_character()))

# Manually handle conversion
data_clean <- data_char %>%
  mutate(value_num = as.numeric(value),
         value_clean = if_else(is.na(value_num), 0, value_num))

head(data_clean)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use col_guess()**

```{r}
# Let readr guess
data_guess <- read_csv("bad_data.csv", show_col_types = FALSE)

# Check what it guessed
spec(data_guess)
```
</div>

## Reading Excel Files

<div class="insight-box">
üí° **Key Insight: readxl Package**

```{r message=FALSE}
library(readxl)

# Create example Excel file
library(writexl)
write_xlsx(list(Sheet1 = mtcars), "example.xlsx")

# Read Excel
data <- read_excel("example.xlsx")
head(data)

# Specify sheet
data <- read_excel("example.xlsx", sheet = "Sheet1")
# Or by number
data <- read_excel("example.xlsx", sheet = 1)

# List sheets
excel_sheets("example.xlsx")

# Read specific range
data <- read_excel("example.xlsx", range = "A1:D10")

# Skip rows
data <- read_excel("example.xlsx", skip = 2)

# Specify column types
data <- read_excel("example.xlsx",
                   col_types = c("numeric", "text", "date"))
```
</div>

## Error #4: `Expecting numeric` {#expecting-numeric}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r eval=FALSE}
# Excel file with mixed types in column
data <- read_excel("mixed_types.xlsx",
                   col_types = "numeric")
```

<div class="error-box">
üî¥ **WARNING**

```
Warning: Expecting numeric in A2 / R2C1: got 'text'
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Read as Text First**

```{r eval=FALSE}
# Read everything as text
data <- read_excel("file.xlsx", col_types = "text")

# Then convert as needed
data_clean <- data %>%
  mutate(
    numeric_col = as.numeric(numeric_col),
    date_col = as.Date(date_col)
  )
```
</div>

## File Paths Best Practices

<div class="bestpractice-box">
üéØ **Best Practice: Portable File Paths**

```{r eval=FALSE}
# ‚ùå Bad: Absolute paths
read_csv("C:/Users/John/Documents/data.csv")

# ‚ùå Bad: Backslashes (Windows only)
read_csv("data\\file.csv")

# ‚úÖ Good: Forward slashes (cross-platform)
read_csv("data/file.csv")

# ‚úÖ Better: here package
library(here)
read_csv(here("data", "file.csv"))

# ‚úÖ Best: RStudio projects + here
# In project root:
read_csv(here("data", "raw", "file.csv"))

# Check paths
here()                           # Project root
here("data", "file.csv")        # Build path
file.exists(here("data"))       # Check if exists
```
</div>

## Reading Other Formats

<div class="insight-box">
üí° **Key Insight: Format-Specific Packages**

```{r eval=FALSE}
# SPSS, SAS, Stata
library(haven)
data <- read_spss("file.sav")
data <- read_sas("file.sas7bdat")
data <- read_stata("file.dta")

# JSON
library(jsonlite)
data <- fromJSON("file.json")

# XML
library(xml2)
doc <- read_xml("file.xml")

# Fixed-width files
data <- read_fwf("file.txt",
                 fwf_widths(c(10, 8, 5)))

# Delimited by other characters
data <- read_delim("file.txt", delim = "|")
data <- read_tsv("file.txt")  # Tab-separated
```
</div>

## Large Files

<div class="bestpractice-box">
üéØ **Best Practice: Handling Large Files**

```{r eval=FALSE}
# Read in chunks
library(readr)

# Specify rows to read
data_sample <- read_csv("large_file.csv", n_max = 1000)

# Read columns selectively
data <- read_csv("large_file.csv",
                 col_select = c(id, value, date))

# Use data.table for speed
library(data.table)
data <- fread("large_file.csv")

# Use vroom for very large files
library(vroom)
data <- vroom("large_file.csv")

# Read in chunks with callback
library(readr)
chunk_size <- 10000
read_csv_chunked("large_file.csv",
                 callback = DataFrameCallback$new(function(chunk, pos) {
                   # Process chunk
                   processed <- chunk %>% filter(value > 0)
                   # Return to accumulate
                   processed
                 }),
                 chunk_size = chunk_size)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Check file exists** - Use file.exists()
2. **Use readr, not base R** - Faster and better
3. **Specify encoding** - When dealing with international characters
4. **Check column types** - Use col_types or read problems()
5. **Use here package** - For portable paths
6. **Handle large files** - Read in chunks or use data.table
7. **Excel with readxl** - Specify sheets and ranges

**Quick Reference:**

| Error | Cause | Fix |
|-------|-------|-----|
| cannot open file | Wrong path | Check getwd(), use here() |
| Encoding garbled | Wrong encoding | Use locale(encoding = ...) |
| Parsing failures | Type mismatch | Check problems(), read as text |
| Sheet not found | Wrong sheet name | Use excel_sheets() |

**Reading Functions:**

```{r eval=FALSE}
# CSV/text
read_csv("file.csv")              # readr
read_csv2("file.csv")             # European format (;)
read_tsv("file.txt")              # Tab-separated
read_delim("file.txt", "|")       # Custom delimiter

# Excel
library(readxl)
read_excel("file.xlsx")
read_excel("file.xlsx", sheet = 2)
read_excel("file.xlsx", range = "A1:D10")

# Other formats
library(haven)
read_spss("file.sav")
read_sas("file.sas7bdat")
read_stata("file.dta")

# JSON
library(jsonlite)
fromJSON("file.json")
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Use here() for paths
Specify col_types for reliability
Check file.exists() before reading
Use read_csv() not read.csv()
Handle encoding explicitly
Read large files in chunks

# ‚ùå Avoid
Absolute paths
Assuming default encoding
Ignoring parsing warnings
Reading entire large files
Using read.csv() for new code
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Safe File Reader**

Write `safe_read_csv()` that:
1. Checks if file exists
2. Handles errors gracefully
3. Reports file info
4. Returns data or informative error
</div>

<div class="exercise-box">
üìù **Exercise 2: Excel Multi-Sheet Reader**

Write function to:
1. Read all sheets from Excel file
2. Return named list of data frames
3. Handle empty sheets
4. Report sheet names and dimensions
</div>

<div class="exercise-box">
üìù **Exercise 3: Data Inspector**

Create `inspect_file()` that:
1. Checks encoding
2. Detects delimiter
3. Previews first few rows
4. Reports column types
5. Identifies problems
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
safe_read_csv <- function(path, ...) {
  # Check file exists
  if (!file.exists(path)) {
    stop("File does not exist: ", path)
  }
  
  # Get file info
  info <- file.info(path)
  cat("File:", basename(path), "\n")
  cat("Size:", round(info$size / 1024, 2), "KB\n")
  cat("Modified:", format(info$mtime, "%Y-%m-%d %H:%M"), "\n\n")
  
  # Try to read
  tryCatch({
    data <- read_csv(path, ..., show_col_types = FALSE)
    
    cat("Successfully read:\n")
    cat("  Rows:", nrow(data), "\n")
    cat("  Columns:", ncol(data), "\n")
    cat("  Column names:", paste(names(data), collapse = ", "), "\n")
    
    # Check for problems
    probs <- problems(data)
    if (nrow(probs) > 0) {
      warning("Found ", nrow(probs), " parsing issues")
      print(probs)
    }
    
    return(data)
    
  }, error = function(e) {
    stop("Failed to read file: ", e$message)
  })
}

# Test
write_csv(mtcars, "test.csv")
data <- safe_read_csv("test.csv")
```

**Exercise 2:**

```{r message=FALSE}
library(readxl)

read_all_sheets <- function(path, ...) {
  # Check file exists
  if (!file.exists(path)) {
    stop("File does not exist: ", path)
  }
  
  # Get sheet names
  sheets <- excel_sheets(path)
  
  cat("Reading Excel file:", basename(path), "\n")
  cat("Sheets found:", length(sheets), "\n\n")
  
  # Read all sheets
  result <- list()
  
  for (sheet in sheets) {
    cat("Reading sheet:", sheet, "... ")
    
    tryCatch({
      data <- read_excel(path, sheet = sheet, ...)
      
      # Check if empty
      if (nrow(data) == 0) {
        cat("EMPTY\n")
        result[[sheet]] <- NULL
      } else {
        cat("OK (", nrow(data), " rows, ", ncol(data), " cols)\n", sep = "")
        result[[sheet]] <- data
      }
      
    }, error = function(e) {
      cat("ERROR:", e$message, "\n")
      result[[sheet]] <- NULL
    })
  }
  
  cat("\nSuccessfully read", length(result), "sheets\n")
  
  return(result)
}

# Test
library(writexl)
write_xlsx(list(
  Cars = mtcars[1:10, ],
  Iris = iris[1:10, ],
  Empty = data.frame()
), "multi_sheet.xlsx")

all_data <- read_all_sheets("multi_sheet.xlsx")
names(all_data)
```

**Exercise 3:**

```{r}
inspect_file <- function(path, n_preview = 5) {
  cat("=== File Inspection ===\n\n")
  
  # Check exists
  if (!file.exists(path)) {
    stop("File does not exist: ", path)
  }
  
  # File info
  info <- file.info(path)
  cat("File:", path, "\n")
  cat("Size:", round(info$size / 1024, 2), "KB\n")
  cat("Modified:", format(info$mtime, "%Y-%m-%d %H:%M"), "\n\n")
  
  # Guess encoding
  cat("Encoding:\n")
  enc <- guess_encoding(path, n_max = 1000)
  print(enc)
  cat("\n")
  
  # Try to detect structure
  cat("Structure Detection:\n")
  
  # Read first few lines
  lines <- readLines(path, n = 10)
  
  # Detect delimiter
  delims <- c(",", ";", "\t", "|")
  delim_counts <- sapply(delims, function(d) {
    sum(grepl(d, lines[1], fixed = TRUE))
  })
  
  likely_delim <- delims[which.max(delim_counts)]
  cat("Likely delimiter:", 
      switch(likely_delim,
             "," = "comma",
             ";" = "semicolon",
             "\t" = "tab",
             "|" = "pipe"), "\n\n")
  
  # Preview
  cat("Preview (first", n_preview, "lines):\n")
  cat(paste(head(lines, n_preview), collapse = "\n"), "\n\n")
  
  # Try to read
  cat("Reading data...\n")
  data <- read_csv(path, show_col_types = FALSE, n_max = 100)
  
  cat("Dimensions:", nrow(data), "rows (preview) x", ncol(data), "columns\n\n")
  
  cat("Column types:\n")
  print(spec(data))
  
  # Check for problems
  probs <- problems(data)
  if (nrow(probs) > 0) {
    cat("\nProblems found:\n")
    print(probs)
  } else {
    cat("\nNo parsing problems detected\n")
  }
  
  invisible(data)
}

# Test
write_csv(mtcars, "inspect_test.csv")
inspect_file("inspect_test.csv")
```
</details>

## Cleanup

```{r echo=FALSE}
# Clean up example files
unlink(c("mtcars.csv", "sample.csv", "bad_data.csv", "example.xlsx",
         "test.csv", "multi_sheet.xlsx", "inspect_test.csv"))
```

<!--chapter:end:33-reading-data.Rmd-->

# Writing Data {#writing-data}

<div class="chapter-summary">
**What You'll Learn:**

- Writing CSV and text files
- Excel export
- Common export errors
- File permissions
- Data serialization
- Format preservation

**Key Errors Covered:** 18+ export errors

**Difficulty:** ‚≠ê‚≠ê Intermediate
</div>

## Introduction

Writing data is just as important as reading:

```{r message=FALSE}
library(readr)
library(dplyr)

# Writing CSV
# write_csv(data, "output.csv")
```

## Writing CSV Files

<div class="insight-box">
üí° **Key Insight: Base R vs readr**

```{r}
# Create sample data
data <- mtcars[1:5, 1:5]

# Base R
write.csv(data, "base_output.csv")
# - Adds row names by default
# - Quotes strings
# - Slower

# readr
write_csv(data, "readr_output.csv")
# - No row names
# - Only quotes when needed
# - Faster
# - Better handling of special values

# Compare
cat("Base R file:\n")
cat(paste(head(readLines("base_output.csv"), 3), collapse = "\n"))

cat("\n\nreadr file:\n")
cat(paste(head(readLines("readr_output.csv"), 3), collapse = "\n"))
```
</div>

## Error #1: `cannot open the connection` {#cannot-open-connection-write}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-path">üìÅ PATH</span>

### The Error

```{r error=TRUE}
# Try to write to non-existent directory
write_csv(mtcars, "nonexistent_dir/file.csv")
```

<div class="error-box">
üî¥ **ERROR**

```
Error: Cannot open file for writing:
'nonexistent_dir/file.csv'
```
</div>

### What It Means

Directory doesn't exist or no write permission.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Create Directory First**

```{r}
# Check if directory exists
output_dir <- "output"

if (!dir.exists(output_dir)) {
  dir.create(output_dir, recursive = TRUE)
  cat("Created directory:", output_dir, "\n")
}

# Now write
write_csv(mtcars, file.path(output_dir, "data.csv"))
cat("File written successfully\n")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Safe Write Function**

```{r}
safe_write_csv <- function(data, path, ...) {
  # Get directory
  dir_path <- dirname(path)
  
  # Create if doesn't exist
  if (!dir.exists(dir_path)) {
    dir.create(dir_path, recursive = TRUE)
    message("Created directory: ", dir_path)
  }
  
  # Check write permission
  if (!file.access(dir_path, mode = 2) == 0) {
    stop("No write permission for directory: ", dir_path)
  }
  
  # Write file
  write_csv(data, path, ...)
  
  # Verify
  if (file.exists(path)) {
    message("Successfully wrote ", nrow(data), " rows to ", path)
  } else {
    stop("File was not created")
  }
  
  invisible(path)
}

# Test
safe_write_csv(mtcars, "test_output/cars.csv")
```
</div>

## Writing Options

<div class="insight-box">
üí° **Key Insight: Write Options**

```{r}
# Control output format
write_csv(mtcars, "formatted.csv",
          na = "MISSING",           # How to write NAs
          quote = "all")            # Quote all fields

# Append to existing file
write_csv(mtcars[1:5, ], "append_test.csv")
write_csv(mtcars[6:10, ], "append_test.csv", append = TRUE)

cat("Lines in file:", length(readLines("append_test.csv")), "\n")

# Write with semicolon delimiter (European)
write_csv2(mtcars, "european.csv")

# Custom delimiter
write_delim(mtcars, "pipe_delim.txt", delim = "|")

# Tab-separated
write_tsv(mtcars, "tab_separated.txt")
```
</div>

## Writing Excel Files

<div class="insight-box">
üí° **Key Insight: writexl Package**

```{r message=FALSE}
library(writexl)

# Single sheet
write_xlsx(mtcars, "cars.xlsx")

# Multiple sheets
write_xlsx(
  list(
    Cars = mtcars,
    Iris = iris,
    Summary = data.frame(
      Dataset = c("mtcars", "iris"),
      Rows = c(nrow(mtcars), nrow(iris))
    )
  ),
  "multi_sheet.xlsx"
)

# Verify
library(readxl)
excel_sheets("multi_sheet.xlsx")
```
</div>

## Error #2: File Permission Denied {#permission-denied}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-system">üíª SYSTEM</span>

### The Problem

```{r eval=FALSE}
# File is open in Excel or locked
write_csv(data, "open_file.csv")
# Error: Permission denied
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Check File Access**

```{r}
check_file_writable <- function(path) {
  # Check if file exists and is writable
  if (file.exists(path)) {
    if (file.access(path, mode = 2) == 0) {
      cat("File is writable\n")
      return(TRUE)
    } else {
      warning("File exists but is not writable (may be open)")
      return(FALSE)
    }
  } else {
    # Check if directory is writable
    dir_path <- dirname(path)
    if (file.access(dir_path, mode = 2) == 0) {
      cat("Directory is writable\n")
      return(TRUE)
    } else {
      warning("No write permission for directory")
      return(FALSE)
    }
  }
}

# Test
check_file_writable("test.csv")
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use Temporary File**

```{r}
# Write to temp file first
temp_file <- tempfile(fileext = ".csv")
write_csv(mtcars, temp_file)

# Then copy/move to destination
final_path <- "output/final.csv"
if (!dir.exists("output")) dir.create("output")

file.copy(temp_file, final_path, overwrite = TRUE)
cat("File written via temporary location\n")
```
</div>

## Preserving Data Types

<div class="bestpractice-box">
üéØ **Best Practice: Preserve Types**

```{r message=FALSE}
library(lubridate)

# Create data with various types
complex_data <- tibble(
  id = 1:3,
  name = c("Alice", "Bob", "Charlie"),
  value = c(1.5, 2.3, 3.7),
  date = ymd("2024-01-01") + days(0:2),
  logical = c(TRUE, FALSE, TRUE),
  factor_col = factor(c("A", "B", "C"))
)

# CSV loses some type info
write_csv(complex_data, "types_csv.csv")
from_csv <- read_csv("types_csv.csv", show_col_types = FALSE)
str(from_csv)

# RDS preserves everything
saveRDS(complex_data, "types_rds.rds")
from_rds <- readRDS("types_rds.rds")
str(from_rds)

# Excel preserves some types
write_xlsx(complex_data, "types_excel.xlsx")
from_excel <- read_excel("types_excel.xlsx")
str(from_excel)
```
</div>

## Large Data Export

<div class="bestpractice-box">
üéØ **Best Practice: Writing Large Files**

```{r eval=FALSE}
# For very large data
library(data.table)
fwrite(large_data, "large_file.csv")

# Write in chunks
write_csv_chunked <- function(data, path, chunk_size = 10000) {
  n_chunks <- ceiling(nrow(data) / chunk_size)
  
  for (i in 1:n_chunks) {
    start <- (i - 1) * chunk_size + 1
    end <- min(i * chunk_size, nrow(data))
    
    chunk <- data[start:end, ]
    
    write_csv(chunk, path, 
              append = i > 1,  # Append after first chunk
              col_names = i == 1)  # Only write headers first time
    
    cat("Wrote chunk", i, "of", n_chunks, "\n")
  }
}

# Compressed output
library(readr)
write_csv(data, gzfile("data.csv.gz"))
```
</div>

## R-Specific Formats

<div class="insight-box">
üí° **Key Insight: R Binary Formats**

```{r}
# RDS - single object
saveRDS(mtcars, "mtcars.rds")
cars_rds <- readRDS("mtcars.rds")

# RData/rda - multiple objects
x <- 1:10
y <- "text"
save(x, y, mtcars, file = "data.RData")
rm(x, y, mtcars)
load("data.RData")  # Restores objects with original names

# Feather - fast, interoperable
library(arrow)
write_feather(mtcars, "mtcars.feather")
cars_feather <- read_feather("mtcars.feather")

# Parquet - compressed, columnar
write_parquet(mtcars, "mtcars.parquet")
cars_parquet <- read_parquet("mtcars.parquet")
```
</div>

## Error #3: Overwriting Files {#overwriting-files}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-safety">‚ö†Ô∏è SAFETY</span>

### The Problem

```{r}
# Accidentally overwrite important file
# write_csv(new_data, "important_results.csv")
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Safe Write with Backup**

```{r}
safe_write_with_backup <- function(data, path, backup = TRUE, ...) {
  # If file exists and backup requested
  if (file.exists(path) && backup) {
    # Create backup
    backup_path <- paste0(path, ".backup.", 
                          format(Sys.time(), "%Y%m%d_%H%M%S"))
    file.copy(path, backup_path)
    message("Created backup: ", basename(backup_path))
  }
  
  # Write new file
  write_csv(data, path, ...)
  message("Wrote file: ", path)
  
  invisible(path)
}

# Create test file
write_csv(mtcars[1:5, ], "important.csv")

# Safely overwrite
safe_write_with_backup(mtcars[1:10, ], "important.csv")

# Check backups
list.files(pattern = "important")
```
</div>

## Format Comparison

<div class="bestpractice-box">
üéØ **Best Practice: Choose Right Format**

```{r}
# Compare formats
compare_formats <- function(data) {
  formats <- list(
    CSV = function() write_csv(data, "test.csv"),
    RDS = function() saveRDS(data, "test.rds"),
    Excel = function() write_xlsx(data, "test.xlsx"),
    Feather = function() write_feather(data, "test.feather"),
    Parquet = function() write_parquet(data, "test.parquet")
  )
  
  results <- data.frame(
    Format = names(formats),
    Size_KB = numeric(length(formats)),
    Time_ms = numeric(length(formats))
  )
  
  for (i in seq_along(formats)) {
    # Time it
    time <- system.time(formats[[i]]())["elapsed"] * 1000
    
    # Get size
    files <- list.files(pattern = "^test\\.")
    size <- sum(file.info(files)$size) / 1024
    
    results$Size_KB[i] <- round(size, 2)
    results$Time_ms[i] <- round(time, 2)
    
    # Cleanup
    unlink(files)
  }
  
  results
}

# Test with mtcars
compare_formats(mtcars)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Create directories first** - Check with dir.exists()
2. **Use readr functions** - write_csv(), not write.csv()
3. **Check permissions** - Verify file access
4. **Preserve types** - Use RDS for R objects
5. **Backup important files** - Before overwriting
6. **Choose right format** - CSV for sharing, RDS for R
7. **Handle large files** - Use data.table or chunks

**Quick Reference:**

| Format | Function | Best For |
|--------|----------|----------|
| CSV | write_csv() | Sharing, Excel |
| RDS | saveRDS() | R objects, types |
| Excel | write_xlsx() | Multiple sheets |
| Feather | write_feather() | Fast, interoperable |
| Parquet | write_parquet() | Big data, compressed |

**Writing Functions:**

```{r eval=FALSE}
# CSV
write_csv(data, "file.csv")
write_csv2(data, "european.csv")  # Semicolon
write_tsv(data, "file.txt")       # Tab
write_delim(data, "file.txt", "|")

# Excel
library(writexl)
write_xlsx(data, "file.xlsx")
write_xlsx(list(Sheet1 = data1, Sheet2 = data2), "file.xlsx")

# R formats
saveRDS(data, "file.rds")
save(obj1, obj2, file = "file.RData")

# Modern formats
library(arrow)
write_feather(data, "file.feather")
write_parquet(data, "file.parquet")
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Create directories before writing
Check file permissions
Use write_csv() not write.csv()
Backup before overwriting
Choose appropriate format
Compress large files
Test write with small sample first

# ‚ùå Avoid
Writing to non-existent directories
Overwriting without backup
Using write.csv() for new code
Writing very large files without chunks
Ignoring permission errors
```
</div>

## Cleanup

```{r echo=FALSE}
# Clean up example files
unlink(c("base_output.csv", "readr_output.csv", "output", "test_output",
         "formatted.csv", "append_test.csv", "european.csv", 
         "pipe_delim.txt", "tab_separated.txt", "cars.xlsx",
         "multi_sheet.xlsx", "test.csv", "types_csv.csv", "types_rds.rds",
         "types_excel.xlsx", "mtcars.rds", "data.RData", "mtcars.feather",
         "mtcars.parquet", "important.csv"), recursive = TRUE)
list.files(pattern = "important\\.csv\\.backup")
unlink(list.files(pattern = "important\\.csv\\.backup"))
```

<!--chapter:end:34-writing-data.Rmd-->

# Database Connections {#database-connections}

<div class="chapter-summary">
**What You'll Learn:**

- Connecting to databases
- SQL queries from R
- Common database errors
- Connection management
- Best practices

**Key Errors Covered:** 15+ database errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

R connects to databases via DBI and database-specific packages:

```{r message=FALSE, eval=FALSE}
library(DBI)

# Generic connection pattern
con <- dbConnect(
  RSQLite::SQLite(),
  dbname = "database.db"
)
```

## Database Basics

<div class="insight-box">
üí° **Key Insight: DBI Package**

```{r message=FALSE}
library(DBI)
library(RSQLite)

# Create in-memory SQLite database
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Write data to database
dbWriteTable(con, "mtcars", mtcars)
dbWriteTable(con, "iris", iris)

# List tables
dbListTables(con)

# Get table info
dbListFields(con, "mtcars")

# Read entire table
data <- dbReadTable(con, "mtcars")
head(data, 3)

# Always disconnect when done
dbDisconnect(con)
```
</div>

## SQL Queries

<div class="insight-box">
üí° **Key Insight: Running Queries**

```{r}
# Reconnect
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "mtcars", mtcars)

# Simple query
result <- dbGetQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
head(result, 3)

# Query with parameters (safe from SQL injection)
result <- dbGetQuery(
  con,
  "SELECT * FROM mtcars WHERE cyl = ? AND mpg > ?",
  params = list(4, 25)
)
head(result)

# Count rows
count <- dbGetQuery(con, "SELECT COUNT(*) as n FROM mtcars")
count$n

# Aggregation
summary <- dbGetQuery(con, 
  "SELECT cyl, AVG(mpg) as avg_mpg, COUNT(*) as count
   FROM mtcars 
   GROUP BY cyl")
summary

dbDisconnect(con)
```
</div>

## Error #1: `could not connect to server` {#connection-failed}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-connection">üîå CONNECTION</span>

### The Error

```{r error=TRUE}
# Try to connect to non-existent server
con <- dbConnect(
  RPostgreSQL::PostgreSQL(),
  host = "nonexistent.server.com",
  dbname = "mydb"
)
```

<div class="error-box">
üî¥ **ERROR**

```
Error: could not connect to server
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Safe Connection Function**

```{r}
safe_db_connect <- function(drv, ..., timeout = 5) {
  # Try to connect with timeout
  tryCatch({
    con <- dbConnect(drv, ...)
    
    # Test connection
    if (dbIsValid(con)) {
      message("Successfully connected to database")
      return(con)
    } else {
      stop("Connection established but not valid")
    }
    
  }, error = function(e) {
    stop("Failed to connect: ", e$message, 
         "\nCheck host, port, credentials, and network")
  })
}

# Use it
con <- safe_db_connect(
  RSQLite::SQLite(),
  dbname = ":memory:"
)

dbIsValid(con)
dbDisconnect(con)
```
</div>

## Error #2: `table ... does not exist` {#table-not-exist}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-sql">üìä SQL</span>

### The Error

```{r error=TRUE}
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Try to query non-existent table
dbGetQuery(con, "SELECT * FROM nonexistent_table")
```

<div class="error-box">
üî¥ **ERROR**

```
Error: no such table: nonexistent_table
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Check Table Exists**

```{r}
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "mtcars", mtcars)

# Check if table exists
table_exists <- function(con, table_name) {
  table_name %in% dbListTables(con)
}

# Safe query
safe_query <- function(con, sql, table_name = NULL) {
  # Extract table name from SQL if not provided
  if (is.null(table_name)) {
    # Simple extraction (works for basic queries)
    table_match <- regmatches(sql, regexpr("FROM\\s+(\\w+)", sql, ignore.case = TRUE))
    if (length(table_match) > 0) {
      table_name <- sub("FROM\\s+", "", table_match, ignore.case = TRUE)
    }
  }
  
  # Check table exists
  if (!is.null(table_name) && !table_exists(con, table_name)) {
    stop("Table '", table_name, "' does not exist. Available tables: ",
         paste(dbListTables(con), collapse = ", "))
  }
  
  # Run query
  dbGetQuery(con, sql)
}

# Test
head(safe_query(con, "SELECT * FROM mtcars"), 3)

dbDisconnect(con)
```
</div>

## dplyr with Databases

<div class="insight-box">
üí° **Key Insight: Using dplyr with Databases**

```{r message=FALSE}
library(dplyr)
library(dbplyr)

con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "mtcars", mtcars)

# Create dplyr table reference
cars_tbl <- tbl(con, "mtcars")

# Use dplyr verbs (lazy evaluation)
result <- cars_tbl %>%
  filter(cyl == 4) %>%
  select(mpg, hp, wt) %>%
  arrange(desc(mpg))

# See the SQL that will be generated
result %>% show_query()

# Execute and collect results
data <- result %>% collect()
head(data)

# Or compute and store in database
cars_tbl %>%
  filter(mpg > 20) %>%
  compute("efficient_cars")

dbListTables(con)

dbDisconnect(con)
```
</div>

## Connection Management

<div class="bestpractice-box">
üéØ **Best Practice: Manage Connections**

```{r}
# Pattern 1: Explicit disconnect
con <- dbConnect(RSQLite::SQLite(), ":memory:")
# ... do work ...
dbDisconnect(con)

# Pattern 2: Use on.exit (safer)
query_with_cleanup <- function() {
  con <- dbConnect(RSQLite::SQLite(), ":memory:")
  on.exit(dbDisconnect(con))  # Always disconnect
  
  dbWriteTable(con, "test", mtcars)
  return(dbGetQuery(con, "SELECT COUNT(*) FROM test"))
}

result <- query_with_cleanup()
result

# Pattern 3: Connection pooling (for web apps)
# library(pool)
# pool <- dbPool(RSQLite::SQLite(), dbname = ":memory:")
# con <- poolCheckout(pool)
# # ... use connection ...
# poolReturn(con)
# poolClose(pool)
```
</div>

## Writing to Databases

<div class="insight-box">
üí° **Key Insight: Writing Data**

```{r}
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Write entire data frame
dbWriteTable(con, "iris", iris)

# Append to existing table
dbWriteTable(con, "iris", iris[1:10, ], append = TRUE)

# Overwrite existing table
dbWriteTable(con, "iris", iris, overwrite = TRUE)

# Check row count
dbGetQuery(con, "SELECT COUNT(*) as count FROM iris")

# Insert single row
dbExecute(con,
  "INSERT INTO iris (Sepal.Length, Sepal.Width, Petal.Length, Petal.Width, Species)
   VALUES (?, ?, ?, ?, ?)",
  params = list(5.1, 3.5, 1.4, 0.2, "setosa")
)

dbDisconnect(con)
```
</div>

## Prepared Statements

<div class="bestpractice-box">
üéØ **Best Practice: Use Parameters**

```{r}
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "mtcars", mtcars)

# ‚ùå BAD: SQL injection vulnerable
user_input <- "4 OR 1=1"  # Malicious input
# query <- paste0("SELECT * FROM mtcars WHERE cyl = ", user_input)
# DON'T DO THIS!

# ‚úÖ GOOD: Parameterized query
safe_query_by_cyl <- function(con, cyl_value) {
  dbGetQuery(
    con,
    "SELECT * FROM mtcars WHERE cyl = ?",
    params = list(cyl_value)
  )
}

result <- safe_query_by_cyl(con, 4)
nrow(result)

dbDisconnect(con)
```
</div>

## Error #3: `columns ... have mismatching types` {#db-type-mismatch}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Problem

```{r error=TRUE}
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Create table with specific types
dbExecute(con, "CREATE TABLE test (id INTEGER, value REAL)")

# Try to insert wrong type
data <- data.frame(id = 1:3, value = c("a", "b", "c"))
dbWriteTable(con, "test", data, append = TRUE)
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Match Types**

```{r}
# Check table schema
dbGetQuery(con, "PRAGMA table_info(test)")

# Convert data to match
data_correct <- data.frame(
  id = as.integer(1:3),
  value = as.numeric(c(1.5, 2.3, 3.7))
)

dbWriteTable(con, "test", data_correct, append = TRUE)

# Verify
dbReadTable(con, "test")

dbDisconnect(con)
```
</div>

## Transactions

<div class="bestpractice-box">
üéØ **Best Practice: Use Transactions**

```{r}
con <- dbConnect(RSQLite::SQLite(), ":memory:")
dbWriteTable(con, "accounts", data.frame(id = 1:3, balance = c(100, 200, 150)))

# Transaction ensures all-or-nothing
safe_transfer <- function(con, from_id, to_id, amount) {
  # Start transaction
  dbBegin(con)
  
  tryCatch({
    # Deduct from sender
    dbExecute(con,
      "UPDATE accounts SET balance = balance - ? WHERE id = ?",
      params = list(amount, from_id))
    
    # Add to receiver
    dbExecute(con,
      "UPDATE accounts SET balance = balance + ? WHERE id = ?",
      params = list(amount, to_id))
    
    # Commit if both succeed
    dbCommit(con)
    message("Transfer successful")
    
  }, error = function(e) {
    # Rollback on error
    dbRollback(con)
    stop("Transfer failed: ", e$message)
  })
}

# Before
dbReadTable(con, "accounts")

# Transfer
safe_transfer(con, from_id = 1, to_id = 2, amount = 50)

# After
dbReadTable(con, "accounts")

dbDisconnect(con)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Use DBI package** - Standard interface for all databases
2. **Always disconnect** - Use on.exit() for safety
3. **Parameterize queries** - Prevent SQL injection
4. **Check table exists** - Before querying
5. **Use dplyr** - For familiar syntax
6. **Manage connections** - Pool for web apps
7. **Use transactions** - For multiple operations

**Quick Reference:**

| Function | Purpose |
|----------|---------|
| dbConnect() | Connect to database |
| dbDisconnect() | Close connection |
| dbListTables() | List tables |
| dbReadTable() | Read entire table |
| dbWriteTable() | Write data frame |
| dbGetQuery() | Run SELECT query |
| dbExecute() | Run INSERT/UPDATE/DELETE |
| dbBegin/Commit/Rollback() | Transactions |

**Database Operations:**

```{r eval=FALSE}
# Connect
library(DBI)
con <- dbConnect(RSQLite::SQLite(), "database.db")

# List and inspect
dbListTables(con)
dbListFields(con, "table_name")

# Read data
data <- dbReadTable(con, "table_name")
data <- dbGetQuery(con, "SELECT * FROM table WHERE col = ?", 
                   params = list(value))

# Write data
dbWriteTable(con, "table_name", data_frame)
dbExecute(con, "INSERT INTO table VALUES (?, ?)",
          params = list(val1, val2))

# dplyr interface
library(dplyr)
tbl(con, "table_name") %>%
  filter(col > 10) %>%
  collect()

# Always disconnect
dbDisconnect(con)
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Use parameterized queries
Always disconnect (use on.exit)
Check dbIsValid() before queries
Use dplyr for complex operations
Use transactions for multiple operations
Handle connection errors gracefully

# ‚ùå Avoid
Building SQL with paste() (SQL injection!)
Leaving connections open
Assuming table exists
Not handling connection errors
```
</div>

## Completion

<div class="chapter-summary">
**Part XI Complete!**

You've mastered:
- Reading data from various formats
- Writing data efficiently
- Database connections and queries
- SQL integration with R
- Best practices for data I/O

**Ready for:** Part XII (Dates and Times) or other topics!
</div>

<!--chapter:end:35-database-connections.Rmd-->

# Part XIII: Programming Patterns {-}

# apply Family & Iteration {#apply-family}

<div class="chapter-summary">
**What You'll Learn:**

- apply, lapply, sapply, mapply
- Common iteration errors
- When to use each function
- Performance considerations
- Alternative approaches

**Key Errors Covered:** 20+ iteration errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

R's apply family provides vectorized operations:

```{r}
# Instead of loops
result <- numeric(nrow(mtcars))
for (i in 1:nrow(mtcars)) {
  result[i] <- mean(as.numeric(mtcars[i, ]))
}

# Use apply
result <- apply(mtcars, 1, mean)
head(result)
```

Let's master the apply family!

## apply() - Arrays and Matrices

<div class="insight-box">
üí° **Key Insight: apply() for Matrices**

```{r}
# Create matrix
mat <- matrix(1:12, nrow = 3, ncol = 4)
mat

# Apply to rows (MARGIN = 1)
row_sums <- apply(mat, 1, sum)
row_sums

# Apply to columns (MARGIN = 2)
col_means <- apply(mat, 2, mean)
col_means

# Custom function
apply(mat, 1, function(x) max(x) - min(x))

# With additional arguments
apply(mat, 2, sum, na.rm = TRUE)

# Both dimensions
apply(mat, c(1, 2), sqrt)
```
</div>

## Error #1: `dim(X) must have positive length` {#dim-positive}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Try apply on vector
vec <- 1:10
apply(vec, 1, sum)
```

<div class="error-box">
üî¥ **ERROR**

```
Error in apply(vec, 1, sum) : dim(X) must have a positive length
```
</div>

### What It Means

`apply()` requires a matrix/array, not a vector.

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use lapply() or sapply()**

```{r}
# For vectors, use lapply/sapply
vec <- 1:10

# Wrong: apply(vec, 1, sqrt)

# Right: use sapply
sapply(vec, sqrt)

# Or vectorized operation
sqrt(vec)
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Convert to Matrix**

```{r}
# If you really need apply
vec <- 1:10
mat <- matrix(vec, ncol = 1)
apply(mat, 1, function(x) x * 2)

# But this is unnecessary - use vectorization
vec * 2
```
</div>

## lapply() - Lists

<div class="insight-box">
üí° **Key Insight: lapply() Always Returns List**

```{r}
# Create list
my_list <- list(a = 1:5, b = 6:10, c = 11:15)

# Apply function to each element
result <- lapply(my_list, mean)
result

# With custom function
lapply(my_list, function(x) sum(x^2))

# On data frame (df is a list of columns)
lapply(mtcars[, 1:3], mean)

# Extract elements
lapply(my_list, `[`, 1:2)

# With multiple arguments
lapply(my_list, sum, na.rm = TRUE)
```
</div>

## sapply() - Simplified

<div class="insight-box">
üí° **Key Insight: sapply() Simplifies Output**

```{r}
my_list <- list(a = 1:5, b = 6:10, c = 11:15)

# lapply returns list
lapply(my_list, mean)

# sapply returns vector
sapply(my_list, mean)

# sapply with matrix output
sapply(my_list, function(x) c(mean = mean(x), sd = sd(x)))

# When can't simplify, returns list
sapply(my_list, summary)  # Returns list
```
</div>

## Error #2: Unexpected Output Type {#unexpected-type}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Problem

```{r}
# sapply behavior depends on output
result1 <- sapply(1:3, function(x) x)
result1
class(result1)  # vector

result2 <- sapply(1:3, function(x) c(x, x^2))
result2
class(result2)  # matrix

result3 <- sapply(1:3, function(x) list(x, x^2))
result3
class(result3)  # list
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use vapply() for Type Safety**

```{r}
# Specify output type
result <- vapply(1:3, function(x) x * 2, FUN.VALUE = numeric(1))
result

# Will error if output doesn't match
# vapply(1:3, function(x) c(x, x^2), FUN.VALUE = numeric(1))

# For multiple values
result <- vapply(1:3, function(x) c(x, x^2), FUN.VALUE = numeric(2))
result
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Use lapply() and Post-Process**

```{r}
# Always get list, then convert
result <- lapply(1:3, function(x) x * 2)
unlist(result)

# Or use do.call
do.call(c, result)
```
</div>

## mapply() - Multiple Arguments

<div class="insight-box">
üí° **Key Insight: mapply() for Parallel Iteration**

```{r}
# Apply function to multiple vectors in parallel
mapply(function(x, y) x + y, 
       x = 1:5, 
       y = 6:10)

# Multiple arguments
mapply(rep, 
       x = 1:4, 
       times = 4:1)

# With data frames
df1 <- data.frame(a = 1:3, b = 4:6)
df2 <- data.frame(c = 7:9, d = 10:12)

mapply(function(x, y) x + y, df1$a, df2$c)

# MoreArgs for constant arguments
mapply(function(x, y, z) x + y + z,
       x = 1:3,
       y = 4:6,
       MoreArgs = list(z = 10))
```
</div>

## tapply() - Grouped Apply

<div class="insight-box">
üí° **Key Insight: tapply() for Split-Apply-Combine**

```{r}
# Apply function by groups
tapply(mtcars$mpg, mtcars$cyl, mean)

# Multiple grouping variables
tapply(mtcars$mpg, 
       list(Cyl = mtcars$cyl, Gear = mtcars$gear), 
       mean)

# With custom function
tapply(mtcars$mpg, mtcars$cyl, 
       function(x) c(mean = mean(x), sd = sd(x)))

# Like dplyr group_by + summarize
library(dplyr)
mtcars %>%
  group_by(cyl) %>%
  summarize(mean_mpg = mean(mpg))
```
</div>

## Common Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Choose Right Function**

```{r}
# Pattern 1: Apply to each column of data frame
lapply(mtcars[, 1:3], mean)
sapply(mtcars[, 1:3], mean)

# Pattern 2: Apply to each row
apply(mtcars[, 1:3], 1, sum)

# Pattern 3: Apply with multiple inputs
mapply(function(x, y) x / y,
       x = mtcars$hp,
       y = mtcars$wt)

# Pattern 4: Apply by groups
tapply(mtcars$mpg, mtcars$cyl, mean)

# Pattern 5: Nested lists
nested <- list(
  a = list(x = 1:3, y = 4:6),
  b = list(x = 7:9, y = 10:12)
)

# Get all 'x' elements
lapply(nested, `[[`, "x")

# Apply to nested structure
lapply(nested, function(sublist) {
  lapply(sublist, mean)
})
```
</div>

## Performance Considerations

<div class="bestpractice-box">
üéØ **Best Practice: Vectorize When Possible**

```{r}
# Compare performance
n <- 10000

# Loop (slow)
system.time({
  result <- numeric(n)
  for (i in 1:n) {
    result[i] <- sqrt(i)
  }
})

# sapply (better)
system.time({
  result <- sapply(1:n, sqrt)
})

# Vectorized (best)
system.time({
  result <- sqrt(1:n)
})

# When apply family is appropriate
df <- data.frame(matrix(rnorm(1000), ncol = 10))

# Row-wise operations (apply is good)
system.time({
  apply(df, 1, mean)
})

# Column-wise operations (vectorized is better)
system.time({
  colMeans(df)
})
```
</div>

## Error #3: Function Not Vectorized {#not-vectorized}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-logic">üß† LOGIC</span>

### The Problem

```{r error=TRUE}
# Custom function expecting single value
my_function <- function(x) {
  if (x > 0) {
    return("positive")
  } else {
    return("negative")
  }
}

# Doesn't work with vectors
my_function(c(-1, 2, -3, 4))
```

<div class="warning-box">
‚ö†Ô∏è **WARNING**

```
Warning: the condition has length > 1
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION 1: Use sapply/vapply**

```{r}
# Apply to each element
sapply(c(-1, 2, -3, 4), my_function)

# Type-safe version
vapply(c(-1, 2, -3, 4), my_function, FUN.VALUE = character(1))
```
</div>

<div class="solution-box">
‚úÖ **SOLUTION 2: Vectorize the Function**

```{r}
# Make function vectorized
my_function_vec <- Vectorize(my_function)
my_function_vec(c(-1, 2, -3, 4))

# Or rewrite using ifelse
my_function_better <- function(x) {
  ifelse(x > 0, "positive", "negative")
}

my_function_better(c(-1, 2, -3, 4))
```
</div>

## Alternative: purrr Package

<div class="insight-box">
üí° **Key Insight: purrr for Modern Iteration**

```{r message=FALSE}
library(purrr)

# map() family (like lapply/sapply)
map(1:3, ~ . * 2)           # Returns list
map_dbl(1:3, ~ . * 2)       # Returns numeric
map_chr(1:3, ~ as.character(.))  # Returns character

# map2() for two inputs (like mapply)
map2_dbl(1:3, 4:6, ~ .x + .y)

# pmap() for multiple inputs
pmap_dbl(list(x = 1:3, y = 4:6, z = 7:9), 
         function(x, y, z) x + y + z)

# Useful helpers
list(a = 1:3, b = 4:6, c = 7:9) %>%
  map_dbl(mean)

# Safe operations
map(c("1", "2", "not_a_number"), 
    possibly(as.numeric, otherwise = NA))
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **apply()** - For matrices/arrays
2. **lapply()** - Always returns list
3. **sapply()** - Simplifies output
4. **vapply()** - Type-safe sapply
5. **mapply()** - Multiple inputs
6. **tapply()** - Grouped operations
7. **Vectorize when possible** - Faster than apply

**Quick Reference:**

| Function | Input | Output | Use Case |
|----------|-------|--------|----------|
| apply() | Matrix/array | Vector/list | Row/column operations |
| lapply() | List/vector | List | Any operation |
| sapply() | List/vector | Vector/matrix | When simplified OK |
| vapply() | List/vector | Specified type | Type safety |
| mapply() | Multiple vectors | Vector/list | Parallel iteration |
| tapply() | Vector + groups | Array | Split-apply-combine |

**Usage Patterns:**

```{r eval=FALSE}
# Matrices
apply(matrix, 1, function)    # By row
apply(matrix, 2, function)    # By column

# Lists
lapply(list, function)        # Returns list
sapply(list, function)        # Simplified
vapply(list, function, type)  # Type-safe

# Multiple inputs
mapply(function, x, y)

# Grouped
tapply(values, groups, function)

# Modern alternative
library(purrr)
map(list, function)           # Like lapply
map_dbl(list, function)       # Like sapply with numeric
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Use vectorized operations when possible
Use vapply() for type safety
Choose right function for task
Consider purrr for complex operations

# ‚ùå Avoid
Using apply() on vectors
Using sapply() when type matters
Growing objects in loops
Unnecessary apply when vectorized solution exists
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Apply Practice**

Using mtcars:
1. Calculate row means using apply
2. Calculate column medians using apply
3. Find max value in each row
4. Compare performance with vectorized versions
</div>

<div class="exercise-box">
üìù **Exercise 2: Custom Function with Apply**

Write function to:
1. Take a data frame
2. For each numeric column, calculate mean, sd, min, max
3. Return as data frame
4. Use appropriate apply function
</div>

<div class="exercise-box">
üìù **Exercise 3: mapply Practice**

Create two vectors and:
1. Add them element-wise with mapply
2. Use custom function with multiple arguments
3. Compare with vectorized approach
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# 1. Row means
row_means_apply <- apply(mtcars, 1, mean)
row_means_vec <- rowMeans(mtcars)

all.equal(row_means_apply, row_means_vec)

# 2. Column medians
col_medians <- apply(mtcars, 2, median)
col_medians

# 3. Max in each row
row_max <- apply(mtcars, 1, max)
head(row_max)

# 4. Performance comparison
library(microbenchmark)

microbenchmark(
  apply = apply(mtcars, 1, mean),
  rowMeans = rowMeans(mtcars),
  times = 100
)

# Vectorized is much faster!
```

**Exercise 2:**

```{r}
summarize_numeric <- function(df) {
  # Get numeric columns
  numeric_cols <- sapply(df, is.numeric)
  df_numeric <- df[, numeric_cols]
  
  # Calculate statistics for each column
  stats <- lapply(df_numeric, function(col) {
    c(
      mean = mean(col, na.rm = TRUE),
      sd = sd(col, na.rm = TRUE),
      min = min(col, na.rm = TRUE),
      max = max(col, na.rm = TRUE)
    )
  })
  
  # Convert to data frame
  result <- do.call(rbind, stats)
  result <- as.data.frame(result)
  result$variable <- rownames(result)
  rownames(result) <- NULL
  
  result[, c("variable", "mean", "sd", "min", "max")]
}

# Test
summarize_numeric(mtcars)

# Alternative using vapply for type safety
summarize_numeric_safe <- function(df) {
  numeric_cols <- sapply(df, is.numeric)
  df_numeric <- df[, numeric_cols]
  
  stats <- vapply(df_numeric, function(col) {
    c(mean = mean(col, na.rm = TRUE),
      sd = sd(col, na.rm = TRUE),
      min = min(col, na.rm = TRUE),
      max = max(col, na.rm = TRUE))
  }, FUN.VALUE = numeric(4))
  
  result <- as.data.frame(t(stats))
  result$variable <- rownames(result)
  rownames(result) <- NULL
  
  result[, c("variable", "mean", "sd", "min", "max")]
}

summarize_numeric_safe(iris)
```

**Exercise 3:**

```{r}
# Create vectors
x <- 1:10
y <- 11:20

# 1. Add with mapply
result_mapply <- mapply(function(a, b) a + b, x, y)
result_mapply

# 2. Custom function
weighted_sum <- function(a, b, weight = 0.5) {
  a * weight + b * (1 - weight)
}

result_custom <- mapply(weighted_sum, x, y, MoreArgs = list(weight = 0.3))
result_custom

# 3. Compare with vectorized
result_vec <- x + y
all.equal(result_mapply, result_vec)

# Performance
microbenchmark(
  mapply = mapply(`+`, x, y),
  vectorized = x + y,
  times = 1000
)

# Vectorized is MUCH faster
```
</details>

<!--chapter:end:36-apply-family.Rmd-->

# purrr Package {#purrr-package}

<div class="chapter-summary">
**What You'll Learn:**

- map() family functions
- Type-safe iteration
- Error handling in iteration
- Advanced patterns
- Advantages over apply family

**Key Errors Covered:** 15+ purrr errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

purrr provides modern, type-safe iteration:

```{r message=FALSE}
library(purrr)

# map() instead of lapply()
map(1:3, ~ . * 2)

# Type-safe variants
map_dbl(1:3, ~ . * 2)
```

## map() Family

<div class="insight-box">
üí° **Key Insight: Type-Safe Mapping**

```{r}
library(purrr)

# map() returns list (like lapply)
map(1:3, sqrt)

# Type-specific variants
map_dbl(1:3, sqrt)      # numeric vector
map_chr(1:3, as.character)  # character vector
map_int(1:3, ~ .x)      # integer vector
map_lgl(c(TRUE, FALSE, TRUE), ~ .x)  # logical vector

# Error if wrong type
# map_dbl(1:3, as.character)  # Error!

# map_df for data frames
map_df(1:3, ~ data.frame(x = .x, y = .x^2))
```
</div>

## Formula Syntax

<div class="insight-box">
üí° **Key Insight: Convenient Formula Syntax**

```{r}
# Three ways to write functions

# 1. Regular function
map(1:3, function(x) x * 2)

# 2. Formula with ~ (one argument: .x or .)
map(1:3, ~ .x * 2)
map(1:3, ~ . * 2)

# 3. Formula with ~ (two arguments: .x and .y)
map2(1:3, 4:6, ~ .x + .y)

# Complex expressions
map(1:3, ~ {
  squared <- .x^2
  sqrt(squared)
})

# Accessing list elements
lst <- list(
  list(a = 1, b = 2),
  list(a = 3, b = 4)
)

map(lst, ~ .x$a)
# Or simpler:
map(lst, "a")
```
</div>

## Error #1: Type Mismatch {#purrr-type-mismatch}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-type">üî¢ TYPE</span>

### The Error

```{r error=TRUE}
# Function returns character, but expecting numeric
map_dbl(1:3, ~ as.character(.x))
```

<div class="error-box">
üî¥ **ERROR**

```
Error: Can't coerce element 1 from a character to a double
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Use Correct Type**

```{r}
# Use map_chr for character output
map_chr(1:3, ~ as.character(.x))

# Or use map() and get list
map(1:3, ~ as.character(.x))

# Convert inside function
map_dbl(1:3, ~ as.numeric(as.character(.x)))
```
</div>

## map2() and pmap()

<div class="insight-box">
üí° **Key Insight: Multiple Inputs**

```{r}
# map2() for two inputs
map2_dbl(1:3, 4:6, ~ .x + .y)

map2_chr(c("a", "b", "c"), 1:3, ~ paste(.x, .y))

# pmap() for multiple inputs (list of inputs)
inputs <- list(
  x = 1:3,
  y = 4:6,
  z = 7:9
)

pmap_dbl(inputs, function(x, y, z) x + y + z)

# With formula
pmap_dbl(inputs, ~ ..1 + ..2 + ..3)

# Named arguments
pmap_chr(
  list(
    name = c("Alice", "Bob"),
    age = c(25, 30)
  ),
  ~ paste(.x, "is", .y, "years old")
)
```
</div>

## Error Handling

<div class="bestpractice-box">
üéØ **Best Practice: Safe Iteration**

```{r}
# Data with potential errors
data <- list("1", "2", "not_a_number", "4")

# map() will fail
# map_dbl(data, as.numeric)  # Error!

# possibly() returns default on error
safe_numeric <- possibly(as.numeric, otherwise = NA_real_)
map_dbl(data, safe_numeric)

# safely() returns list of result and error
safe_parse <- safely(as.numeric)
map(data, safe_parse)

# quietly() captures messages/warnings
quiet_sqrt <- quietly(sqrt)
map(c(4, -1, 9), quiet_sqrt)

# Try each until one works
try_functions <- list(
  as.numeric,
  function(x) 0
)

map(data, ~ reduce(try_functions, function(val, f) {
  if (!is.na(val)) return(val)
  try(f(.x), silent = TRUE)
}, .init = NA))
```
</div>

## Advanced Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Complex Patterns**

```{r}
# Keep/discard based on condition
numbers <- list(1, "a", 3, "b", 5)

keep(numbers, is.numeric)
discard(numbers, is.character)

# Detect if any/all meet condition
some(numbers, is.numeric)
every(numbers, is.numeric)

# Find position
detect(numbers, is.character)
detect_index(numbers, is.character)

# Reduce (fold)
reduce(1:5, `+`)
reduce(1:5, `*`)

# Accumulate (show intermediate steps)
accumulate(1:5, `+`)

# Modify elements
modify(list(1, 2, 3), ~ .x * 2)
modify_if(list(1, "a", 3), is.numeric, ~ .x * 2)
modify_at(list(a = 1, b = 2, c = 3), "b", ~ .x * 10)
```
</div>

## Nested Data

<div class="insight-box">
üí° **Key Insight: Working with Nested Lists**

```{r}
# Nested list
nested <- list(
  person1 = list(name = "Alice", age = 25, scores = c(90, 85, 92)),
  person2 = list(name = "Bob", age = 30, scores = c(88, 92, 87)),
  person3 = list(name = "Charlie", age = 35, scores = c(95, 89, 91))
)

# Extract single element
map(nested, "name")
map(nested, "age")

# Extract nested element
map(nested, list("scores", 1))  # First score

# Complex extraction
map(nested, ~ mean(.x$scores))

# Modify nested structure
map(nested, ~ {
  .x$avg_score <- mean(.x$scores)
  .x
})

# Flatten nested lists
nested_scores <- map(nested, "scores")
flatten_dbl(nested_scores)
```
</div>

## Comparison with Base R

<div class="bestpractice-box">
üéØ **Best Practice: purrr vs Base R**

```{r}
# Get means of each column
df <- mtcars[, 1:3]

# Base R
lapply(df, mean)
sapply(df, mean)

# purrr (type-safe)
map(df, mean)
map_dbl(df, mean)

# Multiple inputs
# Base R
mapply(function(x, y) x + y, 1:3, 4:6)

# purrr (cleaner)
map2_dbl(1:3, 4:6, ~ .x + .y)

# Error handling
# Base R
tryCatch(as.numeric("a"), error = function(e) NA)

# purrr (composable)
possibly(as.numeric, NA)("a")

# Advantages of purrr:
# - Type safety
# - Consistent interface
# - Better error handling
# - Cleaner syntax
# - Composable functions
```
</div>

## Real-World Examples

<div class="bestpractice-box">
üéØ **Best Practice: Practical Uses**

```{r message=FALSE}
library(dplyr)

# 1. Read multiple files
# files <- list.files(pattern = "\\.csv$")
# data <- map_df(files, read_csv, .id = "file")

# 2. Fit multiple models
models <- mtcars %>%
  split(.$cyl) %>%
  map(~ lm(mpg ~ hp, data = .))

# Get R-squared from each
map_dbl(models, ~ summary(.)$r.squared)

# 3. Extract nested information
results <- list(
  model1 = list(coef = c(1.5, 2.3), r2 = 0.85),
  model2 = list(coef = c(1.8, 2.1), r2 = 0.90),
  model3 = list(coef = c(1.2, 2.5), r2 = 0.78)
)

map_dbl(results, "r2")
map(results, "coef")

# 4. Validate data
data_list <- list(
  df1 = data.frame(x = 1:3, y = 4:6),
  df2 = data.frame(x = 1:3),  # Missing y
  df3 = data.frame(x = 1:3, y = 4:6)
)

# Check all have 'y' column
map_lgl(data_list, ~ "y" %in% names(.))

# Filter to valid ones
valid_data <- keep(data_list, ~ "y" %in% names(.))
length(valid_data)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Type-safe mapping** - Use map_dbl(), map_chr(), etc.
2. **Formula syntax** - Clean with ~ .x
3. **Error handling** - possibly(), safely(), quietly()
4. **Multiple inputs** - map2(), pmap()
5. **Powerful helpers** - keep(), discard(), reduce()
6. **Nested data** - Easy extraction with list indexing
7. **Consistent interface** - All functions work similarly

**Quick Reference:**

| Function | Purpose | Returns |
|----------|---------|---------|
| map() | Apply to each | List |
| map_dbl() | Apply to each | Numeric vector |
| map_chr() | Apply to each | Character vector |
| map_int() | Apply to each | Integer vector |
| map_lgl() | Apply to each | Logical vector |
| map2() | Two inputs | List/vector |
| pmap() | Multiple inputs | List/vector |
| walk() | Side effects only | Input invisibly |

**Common Patterns:**

```{r eval=FALSE}
# Basic mapping
map(list, function)
map_dbl(list, ~ .x * 2)

# Multiple inputs
map2(x, y, ~ .x + .y)
pmap(list(x, y, z), function(x, y, z) x + y + z)

# Error handling
possibly(function, otherwise = NA)
safely(function)

# Filtering
keep(list, is.numeric)
discard(list, is.na)

# Detection
some(list, is.numeric)
every(list, is.numeric)

# Reduction
reduce(list, `+`)
accumulate(list, `+`)

# Extraction
map(nested_list, "element_name")
map(nested_list, list("level1", "level2"))
```

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Use type-specific map variants (map_dbl, etc.)
Use formula syntax for clarity
Handle errors with possibly/safely
Use descriptive function names

# ‚ùå Avoid
Using map() when type matters
Ignoring potential errors
Complex nested anonymous functions
```
</div>

<!--chapter:end:37-purrr-package.Rmd-->

# Iteration Best Practices {#iteration-best-practices}

<div class="chapter-summary">
**What You'll Learn:**

- When to use loops vs apply vs purrr
- Vectorization strategies
- Performance optimization
- Common pitfalls
- Design patterns

**Key Errors Covered:** 12+ iteration errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Choosing the right iteration method matters:

```{r message=FALSE}
library(purrr)
library(dplyr)
```

## Vectorization First

<div class="bestpractice-box">
üéØ **Best Practice: Prefer Vectorized Operations**

```{r}
# ‚ùå Bad: Loop
result <- numeric(length(mtcars$mpg))
for (i in seq_along(mtcars$mpg)) {
  result[i] <- mtcars$mpg[i] * 2
}

# ‚ùå Bad: apply
result <- sapply(mtcars$mpg, function(x) x * 2)

# ‚úÖ Good: Vectorized
result <- mtcars$mpg * 2

# Performance comparison
n <- 10000
x <- 1:n

system.time(sapply(x, sqrt))
system.time(sqrt(x))  # Much faster!
```
</div>

## When to Use Each

<div class="insight-box">
üí° **Key Insight: Decision Guide**

```{r eval=FALSE}
# Use VECTORIZED operations when possible
x * 2
sqrt(x)
paste0("ID_", x)

# Use FOR LOOPS when:
# - Sequential dependencies
# - Early termination needed
# - Side effects (plotting, writing files)

# Use APPLY family when:
# - Row/column operations on matrices
# - Simple transformations on lists
# - Base R only (no tidyverse)

# Use PURRR when:
# - Type safety matters
# - Complex error handling needed
# - Working with nested lists
# - Modern tidyverse workflows
```
</div>

## Growing Objects Anti-Pattern

<div class="pitfall-box">
‚ö†Ô∏è **Avoid Growing Objects**

```{r}
# ‚ùå Very bad: Growing vector
n <- 1000
system.time({
  result <- c()
  for (i in 1:n) {
    result <- c(result, i^2)
  }
})

# ‚úÖ Good: Pre-allocate
system.time({
  result <- numeric(n)
  for (i in 1:n) {
    result[i] <- i^2
  }
})

# ‚úÖ Best: Vectorize
system.time({
  result <- (1:n)^2
})

# Growing lists
# ‚ùå Bad
result_list <- list()
for (i in 1:n) {
  result_list[[i]] <- i^2
}

# ‚úÖ Good: Pre-allocate
result_list <- vector("list", n)
for (i in 1:n) {
  result_list[[i]] <- i^2
}

# ‚úÖ Better: Use map
result_list <- map(1:n, ~ .^2)
```
</div>

## Summary

<div class="chapter-summary">
**Decision Tree:**

```
Can it be vectorized?
‚îú‚îÄ Yes ‚Üí Use vectorized operations
‚îî‚îÄ No ‚Üí Is it row/column-wise on matrix?
    ‚îú‚îÄ Yes ‚Üí Use apply()
    ‚îî‚îÄ No ‚Üí Working with lists?
        ‚îú‚îÄ Yes ‚Üí Need type safety?
        ‚îÇ   ‚îú‚îÄ Yes ‚Üí Use purrr::map_*()
        ‚îÇ   ‚îî‚îÄ No ‚Üí Use lapply/sapply
        ‚îî‚îÄ No ‚Üí Sequential dependencies?
            ‚îî‚îÄ Yes ‚Üí Use for loop
```

**Quick Reference:**

| Task | Best Choice | Why |
|------|-------------|-----|
| Element-wise math | Vectorized | Fastest |
| Row operations | apply() | Built-in |
| List operations | purrr::map() | Type-safe |
| Sequential | for loop | Clear logic |
| Side effects | for/walk() | Explicit |

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Vectorize when possible
Pre-allocate in loops
Use type-safe functions
Consider readability
Profile before optimizing

# ‚ùå Avoid
Growing objects in loops
Unnecessary apply/map
Over-optimization early
Complex nested iterations
```
</div>

## Completion

<div class="chapter-summary">
**Part XIII Complete!**

You've mastered:
- apply family functions
- purrr for modern iteration
- Best practices and patterns
- Performance considerations

**Ready for:** Part XIV (Package Development)!
</div>

<!--chapter:end:38-iteration-best-practices.Rmd-->

# Part XIV: Package Development {-}

# Package Development Basics {#package-basics}

<div class="chapter-summary">
**What You'll Learn:**

- Creating R packages
- Package structure
- devtools workflow
- Common package errors
- DESCRIPTION and NAMESPACE

**Key Errors Covered:** 20+ package errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

R packages organize and share code:

```{r eval=FALSE}
library(devtools)
library(usethis)

# Create new package
create_package("~/mypackage")
```

## Package Structure

<div class="insight-box">
üí° **Key Insight: Essential Package Files**

```
mypackage/
‚îú‚îÄ‚îÄ R/                  # R code (.R files)
‚îú‚îÄ‚îÄ man/                # Documentation (.Rd files)
‚îú‚îÄ‚îÄ tests/              # Unit tests
‚îÇ   ‚îî‚îÄ‚îÄ testthat/
‚îú‚îÄ‚îÄ DESCRIPTION         # Package metadata
‚îú‚îÄ‚îÄ NAMESPACE           # Exports and imports
‚îú‚îÄ‚îÄ LICENSE             # License file
‚îú‚îÄ‚îÄ README.md           # Package description
‚îú‚îÄ‚îÄ NEWS.md             # Version history
‚îî‚îÄ‚îÄ .Rbuildignore       # Files to ignore
```
</div>

## Creating a Package

<div class="bestpractice-box">
üéØ **Best Practice: Modern Package Creation**

```{r eval=FALSE}
# Use usethis for package creation
library(usethis)

# Create package
create_package("~/mypackage")

# Set up Git
use_git()

# Add license
use_mit_license()

# Create README
use_readme_md()

# Set up testing
use_testthat()

# Add package dependencies
use_package("dplyr")
use_package("ggplot2")
```
</div>

## DESCRIPTION File

<div class="insight-box">
üí° **Key Insight: Package Metadata**

```
Package: mypackage
Title: What the Package Does (One Line)
Version: 0.1.0
Authors@R: 
    person("First", "Last", email = "first.last@example.com",
           role = c("aut", "cre"))
Description: What the package does (one paragraph).
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
Roxygen: list(markdown = TRUE)
RoxygenNote: 7.2.3
Imports:
    dplyr,
    ggplot2
Suggests:
    testthat (>= 3.0.0)
```

**Key Fields:**
- **Package**: Name (letters, numbers, dots only)
- **Title**: Short description (< 65 chars)
- **Version**: Major.Minor.Patch
- **Authors@R**: Package authors
- **Description**: Detailed description
- **License**: Legal terms
- **Imports**: Required packages
- **Suggests**: Optional packages
</div>

## Error #1: Invalid Package Name {#invalid-package-name}

<span class="difficulty-beginner">‚≠ê BEGINNER</span> <span class="category-badge cat-name">üìù NAME</span>

### The Error

```{r error=TRUE, eval=FALSE}
# Invalid package names
create_package("my-package")     # Hyphens not allowed
create_package("my_package")     # OK but not recommended
create_package("123package")     # Can't start with number
```

<div class="error-box">
üî¥ **ERROR**

```
Error: 'my-package' is not a valid package name
```
</div>

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Valid Package Names**

```{r eval=FALSE}
# ‚úÖ Good names
create_package("mypackage")
create_package("MyPackage")
create_package("my.package")     # OK but uncommon
create_package("mypackage2")

# Package name rules:
# - Letters, numbers, and dots only
# - Must start with letter
# - No hyphens or underscores
# - Case sensitive
# - 2+ characters recommended
```
</div>

## Adding Functions

<div class="bestpractice-box">
üéØ **Best Practice: Add Functions with Documentation**

```{r eval=FALSE}
# Create new R file
use_r("my_function")

# In R/my_function.R:

#' Calculate Mean with NA Removal
#'
#' @param x A numeric vector
#' @param na.rm Logical; remove NA values?
#'
#' @return The mean of x
#' @export
#'
#' @examples
#' safe_mean(c(1, 2, 3, NA))
#' safe_mean(c(1, 2, 3, NA), na.rm = TRUE)
safe_mean <- function(x, na.rm = FALSE) {
  if (!is.numeric(x)) {
    stop("x must be numeric")
  }
  mean(x, na.rm = na.rm)
}

# Generate documentation
devtools::document()
```
</div>

## NAMESPACE

<div class="insight-box">
üí° **Key Insight: Exports and Imports**

NAMESPACE controls what functions are exported (visible to users) and what external functions are imported.

```{r eval=FALSE}
# Generated by roxygen2
# Export your functions
export(safe_mean)
export(my_function)

# Import from other packages
importFrom(dplyr, filter)
importFrom(ggplot2, ggplot)

# Import entire package (not recommended)
import(dplyr)
```

**Best Practices:**
- Use `@export` in roxygen comments
- Use `@importFrom pkg function` for imports
- Let roxygen2 manage NAMESPACE
- Never edit NAMESPACE manually
</div>

## Error #2: Function Not Exported {#not-exported}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-namespace">üì¶ NAMESPACE</span>

### The Problem

```{r eval=FALSE}
# Function defined but not accessible
# In package: my_function exists
# After install: Error: object 'my_function' not found
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Export Functions**

```{r eval=FALSE}
# Add @export to roxygen comment
#' My Function
#'
#' @export
my_function <- function(x) {
  x * 2
}

# Then document
devtools::document()

# Check NAMESPACE was updated
# Should see: export(my_function)
```
</div>

## Dependencies

<div class="bestpractice-box">
üéØ **Best Practice: Manage Dependencies**

```{r eval=FALSE}
# Add required package
use_package("dplyr")
# Adds to DESCRIPTION Imports

# Add suggested package
use_package("ggplot2", type = "Suggests")

# Using imported functions
# Option 1: Import in NAMESPACE
#' @importFrom dplyr filter
#' @export
my_filter <- function(data, condition) {
  filter(data, {{ condition }})
}

# Option 2: Use :: (no import needed)
my_summarize <- function(data) {
  dplyr::summarize(data, mean = mean(value))
}

# Option 3: Import entire package (not recommended)
#' @import dplyr
```
</div>

## Development Workflow

<div class="bestpractice-box">
üéØ **Best Practice: Iterative Development**

```{r eval=FALSE}
# 1. Load package in development
devtools::load_all()
# Simulates installing and loading

# 2. Try functions
safe_mean(c(1, 2, 3, NA), na.rm = TRUE)

# 3. Update documentation
devtools::document()

# 4. Run tests
devtools::test()

# 5. Check package
devtools::check()

# 6. Install locally
devtools::install()

# Keyboard shortcuts in RStudio:
# Ctrl/Cmd + Shift + L  - Load all
# Ctrl/Cmd + Shift + D  - Document
# Ctrl/Cmd + Shift + T  - Test
# Ctrl/Cmd + Shift + E  - Check
# Ctrl/Cmd + Shift + B  - Build and reload
```
</div>

## Error #3: Missing Dependencies {#missing-deps}

<span class="difficulty-intermediate">‚≠ê‚≠ê INTERMEDIATE</span> <span class="category-badge cat-deps">üì¶ DEPENDENCIES</span>

### The Error

```{r eval=FALSE}
# Using dplyr without declaring dependency
my_function <- function(data) {
  filter(data, value > 0)  # Error: could not find function "filter"
}
```

### Solutions

<div class="solution-box">
‚úÖ **SOLUTION: Declare and Import**

```{r eval=FALSE}
# 1. Add to DESCRIPTION
use_package("dplyr")

# 2. Import in function
#' @importFrom dplyr filter
#' @export
my_function <- function(data) {
  filter(data, value > 0)
}

# Or use ::
#' @export  
my_function <- function(data) {
  dplyr::filter(data, value > 0)
}

# 3. Document
devtools::document()
```
</div>

## Package Documentation

<div class="bestpractice-box">
üéØ **Best Practice: Complete Documentation**

```{r eval=FALSE}
# Package-level documentation
use_package_doc()

# In R/mypackage-package.R:
#' mypackage: A Short Title
#'
#' A longer description of what the package does.
#'
#' @docType package
#' @name mypackage
NULL

# Function documentation with roxygen2
#' Calculate Summary Statistics
#'
#' This function calculates mean, median, and standard deviation
#' for a numeric vector.
#'
#' @param x A numeric vector
#' @param na.rm Logical; should NA values be removed?
#' @param digits Integer; number of decimal places
#'
#' @return A named vector with mean, median, and sd
#' @export
#'
#' @examples
#' x <- c(1, 2, 3, 4, 5, NA)
#' summary_stats(x, na.rm = TRUE)
#' summary_stats(x, na.rm = TRUE, digits = 2)
#'
#' @seealso \code{\link{mean}}, \code{\link{median}}, \code{\link{sd}}
summary_stats <- function(x, na.rm = FALSE, digits = 3) {
  c(
    mean = round(mean(x, na.rm = na.rm), digits),
    median = round(median(x, na.rm = na.rm), digits),
    sd = round(sd(x, na.rm = na.rm), digits)
  )
}
```
</div>

## Data in Packages

<div class="insight-box">
üí° **Key Insight: Including Data**

```{r eval=FALSE}
# Create data
my_data <- data.frame(
  x = 1:10,
  y = rnorm(10)
)

# Add to package
use_data(my_data)
# Creates data/my_data.rda

# Document the data
# In R/data.R:
#' My Example Data
#'
#' A dataset containing example values.
#'
#' @format A data frame with 10 rows and 2 variables:
#' \describe{
#'   \item{x}{Integer values from 1 to 10}
#'   \item{y}{Random normal values}
#' }
#' @source Generated for package examples
"my_data"

# Use in examples
#' @examples
#' data(my_data)
#' plot(my_data$x, my_data$y)
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Use devtools/usethis** - Modern package development
2. **Valid package names** - Letters, numbers, dots only
3. **Document everything** - roxygen2 comments
4. **Export functions** - Use @export
5. **Declare dependencies** - DESCRIPTION and @importFrom
6. **Iterative workflow** - load_all, document, test, check
7. **Include data properly** - use_data() and document

**Quick Reference:**

```{r eval=FALSE}
# Create package
usethis::create_package("mypackage")

# Add function
usethis::use_r("function_name")

# Document
devtools::document()

# Test
devtools::test()

# Check
devtools::check()

# Install
devtools::install()

# Add dependency
usethis::use_package("dplyr")

# Add data
usethis::use_data(my_data)
```

**Package Name Rules:**
- Letters, numbers, and dots only
- Start with letter
- No hyphens or underscores
- Case sensitive
- Keep it short and memorable

**Best Practices:**

```{r eval=FALSE}
# ‚úÖ Good
Use roxygen2 for documentation
Declare all dependencies
Use :: for external functions
Test thoroughly
Keep functions focused
Document all parameters

# ‚ùå Avoid
Editing NAMESPACE manually
Missing @export
Undeclared dependencies
No examples
Long function names
```
</div>

<!--chapter:end:39-package-basics.Rmd-->

# Documentation & Testing {#package-documentation-testing}

<div class="chapter-summary">
**What You'll Learn:**

- roxygen2 documentation
- testthat framework
- Unit testing best practices
- Code coverage
- Vignettes

**Key Errors Covered:** 15+ testing errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Documentation and testing ensure package quality:

```{r eval=FALSE}
library(testthat)
library(devtools)

# Document
document()

# Test
test()
```

## roxygen2 Documentation

<div class="insight-box">
üí° **Key Insight: Complete Function Documentation**

```{r eval=FALSE}
#' Add Two Numbers
#'
#' This function adds two numbers together.
#' It handles NA values appropriately.
#'
#' @param x A numeric value
#' @param y A numeric value
#' @param na.rm Logical; should NA values be removed?
#'
#' @return The sum of x and y
#' @export
#'
#' @examples
#' add_numbers(2, 3)
#' add_numbers(2, NA, na.rm = TRUE)
#'
#' @seealso \code{\link{sum}}
add_numbers <- function(x, y, na.rm = FALSE) {
  if (na.rm) {
    x <- ifelse(is.na(x), 0, x)
    y <- ifelse(is.na(y), 0, y)
  }
  x + y
}
```

**Key Tags:**
- `@param` - Parameter description
- `@return` - What function returns
- `@export` - Make function available
- `@examples` - Usage examples
- `@seealso` - Related functions
- `@importFrom` - Import external functions
</div>

## testthat Framework

<div class="bestpractice-box">
üéØ **Best Practice: Comprehensive Testing**

```{r eval=FALSE}
# Set up testing
use_testthat()

# Create test file
use_test("add_numbers")

# In tests/testthat/test-add_numbers.R:
test_that("add_numbers works correctly", {
  expect_equal(add_numbers(2, 3), 5)
  expect_equal(add_numbers(0, 0), 0)
  expect_equal(add_numbers(-1, 1), 0)
})

test_that("add_numbers handles NA", {
  expect_true(is.na(add_numbers(2, NA)))
  expect_equal(add_numbers(2, NA, na.rm = TRUE), 2)
})

test_that("add_numbers validates input", {
  expect_error(add_numbers("a", 2))
  expect_error(add_numbers(2, "b"))
})

# Run tests
test()
```

**Common Expectations:**
- `expect_equal(x, y)` - Values are equal
- `expect_true(x)` - x is TRUE
- `expect_false(x)` - x is FALSE
- `expect_error(code)` - Code produces error
- `expect_warning(code)` - Code produces warning
- `expect_message(code)` - Code produces message
- `expect_length(x, n)` - x has length n
- `expect_type(x, type)` - x is of type
</div>

## Code Coverage

<div class="insight-box">
üí° **Key Insight: Measure Test Coverage**

```{r eval=FALSE}
# Install covr
install.packages("covr")

# Check coverage
library(covr)
coverage <- package_coverage()
coverage

# View in browser
report(coverage)

# Target: >80% coverage
```
</div>

## Vignettes

<div class="bestpractice-box">
üéØ **Best Practice: Write Vignettes**

```{r eval=FALSE}
# Create vignette
use_vignette("introduction")

# In vignettes/introduction.Rmd:
---
title: "Introduction to mypackage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to mypackage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Build vignettes
devtools::build_vignettes()
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Document completely** - All parameters, returns, examples
2. **Test thoroughly** - Cover all cases
3. **Use expectations** - Clear, specific tests
4. **Check coverage** - Aim for >80%
5. **Write vignettes** - Long-form documentation

**Quick Reference:**

```{r eval=FALSE}
# Documentation
devtools::document()

# Testing
usethis::use_testthat()
usethis::use_test("function")
devtools::test()

# Coverage
covr::package_coverage()

# Vignettes
usethis::use_vignette("name")
```
</div>

<!--chapter:end:40-documentation-testing.Rmd-->

# Package Best Practices {#package-best-practices}

<div class="chapter-summary">
**What You'll Learn:**

- Package design principles
- Code organization
- Version control
- CRAN submission
- Maintenance

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Best practices for professional package development including design, organization, and maintenance.

**Key Principles:**
- Clear, focused functionality
- Comprehensive documentation
- Thorough testing
- Semantic versioning
- Active maintenance

<!--chapter:end:41-package-best-practices.Rmd-->

# Part XV: Performance {-}

# Performance Profiling {#profiling}

<div class="chapter-summary">
**What You'll Learn:**

- profvis for profiling
- Identifying bottlenecks
- Memory profiling
- Benchmarking

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Profile R code to identify performance bottlenecks using profvis and bench.

**Key Tools:**
- `profvis()` - Visual profiler
- `bench::mark()` - Benchmarking
- `Rprof()` - Base R profiling

<!--chapter:end:42-profiling.Rmd-->

# Code Optimization {#optimization}

<div class="chapter-summary">
**What You'll Learn:**

- Vectorization techniques
- Avoiding copies
- Efficient data structures
- Rcpp basics

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Optimize R code for better performance through vectorization and efficient structures.

**Key Techniques:**
- Vectorize operations
- Pre-allocate memory
- Use appropriate data structures
- Consider Rcpp for loops

<!--chapter:end:43-optimization.Rmd-->

# Memory Management {#memory}

<div class="chapter-summary">
**What You'll Learn:**

- Memory profiling
- Garbage collection
- Large data strategies
- Memory-efficient coding

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Manage memory effectively in R for large datasets.

**Key Concepts:**
- Monitor memory usage
- Understand gc()
- Use data.table for large data
- Clean up objects

<!--chapter:end:44-memory.Rmd-->

# Part XVI: Advanced Topics {-}

# Parallel Processing {#parallel}

<div class="chapter-summary">
**What You'll Learn:**

- parallel package
- future package
- Common pitfalls
- When to parallelize

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Use parallel processing in R with parallel and future packages.

**Key Functions:**
- `mclapply()` - Parallel lapply (Unix)
- `parLapply()` - Parallel lapply (cross-platform)
- `future_map()` - Modern parallel mapping

<!--chapter:end:45-parallel.Rmd-->

# Advanced Database Operations {#advanced-databases}

<div class="chapter-summary">
**What You'll Learn:**

- Complex queries
- Database optimization
- Bulk operations
- Connection pooling

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Advanced database techniques including optimization and bulk operations.

**Key Topics:**
- Query optimization
- Indexes and performance
- Transaction management
- Connection pooling with pool

<!--chapter:end:46-advanced-databases.Rmd-->

# Web Scraping {#web-scraping}

<div class="chapter-summary">
**What You'll Learn:**

- rvest for scraping
- httr for APIs
- Common errors
- Ethical scraping

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Web scraping and API interaction using rvest and httr.

**Key Packages:**
- `rvest` - HTML scraping
- `httr` - HTTP requests
- `jsonlite` - JSON parsing
- `xml2` - XML parsing

<!--chapter:end:47-web-scraping.Rmd-->

# Shiny Basics {#shiny}

<div class="chapter-summary">
**What You'll Learn:**

- Shiny app structure
- Reactive programming
- Common Shiny errors
- Deployment

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Build interactive web applications with Shiny.

**Key Concepts:**
- UI and server
- Reactive expressions
- render* functions
- Deploy to shinyapps.io

<!--chapter:end:48-shiny-basics.Rmd-->

# Advanced R Programming {#advanced-programming}

<div class="chapter-summary">
**What You'll Learn:**

- Metaprogramming
- Non-standard evaluation
- R6 classes
- Advanced patterns

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Advanced R programming techniques including metaprogramming and OOP.

**Key Topics:**
- Tidy evaluation
- Quasiquotation
- R6 object system
- Function operators

<!--chapter:end:49-advanced-programming.Rmd-->

# Production R Code {#production}

<div class="chapter-summary">
**What You'll Learn:**

- Production best practices
- Error handling
- Logging
- Monitoring

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Write production-ready R code with proper error handling and logging.

**Key Principles:**
- Robust error handling
- Comprehensive logging
- Input validation
- Graceful failures

<!--chapter:end:50-production-code.Rmd-->

# Final Best Practices {#final-best-practices}

<div class="chapter-summary">
**What You'll Learn:**

- Code review checklist
- Style guidelines
- Project organization
- Continuous integration

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Summary

Comprehensive best practices for professional R development.

**Final Checklist:**
- [ ] Code is documented
- [ ] Tests are comprehensive
- [ ] Style is consistent
- [ ] Performance is acceptable
- [ ] Errors are handled
- [ ] Code is reviewed

## Book Completion

<div class="chapter-summary">
**üéä CONGRATULATIONS! üéä**

You've completed all 51 chapters of "R Errors and How to Fix Them"!

**What You've Learned:**
- Complete R fundamentals
- Modern data manipulation
- Professional visualization
- Statistical analysis
- Package development
- Performance optimization
- Advanced patterns

**Total Coverage:**
- 51 chapters
- 700+ errors documented
- 2000+ code examples
- 170+ exercises
- Complete R mastery

**Next Steps:**
- Practice with real projects
- Build your own packages
- Contribute to R community
- Teach others

Thank you for this journey!
</div>

<!--chapter:end:51-final-best-practices.Rmd-->

# Part XVII: Advanced R Programming {-}

# S3 Object System {#s3-oop}

<div class="chapter-summary">
**What You'll Learn:**

- S3 classes and objects
- Generic functions and method dispatch
- Inheritance
- Common S3 errors

**Key Errors Covered:** 15+ S3 errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

S3 is R's simplest OOP system, used throughout base R and many packages.

```{r}
# S3 objects are just lists with a class attribute
person <- list(name = "Alice", age = 30)
class(person) <- "person"

# Method dispatch based on class
class(mtcars)  # "data.frame"
class(lm(mpg ~ wt, mtcars))  # "lm"
```

## Creating S3 Objects

<div class="insight-box">
üí° **Key Insight: Constructor Pattern**

```{r}
# Constructor
new_person <- function(name, age) {
  structure(
    list(name = name, age = age),
    class = "person"
  )
}

# Validator
validate_person <- function(x) {
  if (!is.character(x$name)) stop("name must be character")
  if (!is.numeric(x$age) || x$age < 0) stop("age must be positive")
  x
}

# Helper (user-facing)
person <- function(name, age) {
  validate_person(new_person(name, age))
}

alice <- person("Alice", 30)
```
</div>

## Generic Functions

```{r}
# Create generic
greet <- function(x) {
  UseMethod("greet")
}

# Define methods
greet.person <- function(x) {
  paste("Hello", x$name)
}

greet.default <- function(x) {
  "Hello!"
}

# Test
greet(alice)  # Calls greet.person
greet(123)    # Calls greet.default
```

## Common Errors

### Error: no applicable method

```{r error=TRUE}
# Forgot default method
process <- function(x) UseMethod("process")
process.person <- function(x) x$name

process(123)  # Error!
```

**Solution:** Always provide default method

```{r}
process.default <- function(x) {
  stop("No method for class ", class(x)[1], call. = FALSE)
}
```

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **S3 = simple OOP** - Just lists with class attribute
2. **UseMethod()** - Enables dispatch
3. **Generic.class** - Method naming
4. **Always provide default** - Avoid errors
5. **Validate inputs** - Use constructor pattern

**Quick Reference:**

```{r eval=FALSE}
# Create class
new_class <- function(...) {
  structure(list(...), class = "myclass")
}

# Create generic
generic <- function(x) UseMethod("generic")

# Create method
generic.myclass <- function(x) {
  # Implementation
}

# Default
generic.default <- function(x) {
  stop("No method")
}
```
</div>

<!--chapter:end:52-s3-oop.Rmd-->

# R6 and S4 Systems {#r6-s4-oop}

<div class="chapter-summary">
**What You'll Learn:**

- R6 classes (mutable objects)
- S4 system (formal OOP)
- When to use each
- Common errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## R6 Classes

R6 provides mutable, encapsulated objects:

```{r message=FALSE}
library(R6)

# Define R6 class
Person <- R6Class("Person",
  public = list(
    name = NULL,
    age = NULL,
    
    initialize = function(name, age) {
      self$name <- name
      self$age <- age
    },
    
    greet = function() {
      paste("Hello, I'm", self$name)
    },
    
    birthday = function() {
      self$age <- self$age + 1
      invisible(self)
    }
  )
)

# Create instance
alice <- Person$new("Alice", 30)
alice$greet()
alice$birthday()
alice$age  # Now 31 (mutable!)
```

## S4 System

S4 provides formal class definitions:

```{r}
# Define S4 class
setClass("PersonS4",
  slots = list(
    name = "character",
    age = "numeric"
  )
)

# Create instance
alice_s4 <- new("PersonS4", name = "Alice", age = 30)

# Define method
setGeneric("greet", function(x) standardGeneric("greet"))
setMethod("greet", "PersonS4", function(x) {
  paste("Hello", x@name)
})

greet(alice_s4)
```

## When to Use Each

| System | Use When |
|--------|----------|
| S3 | Simple classes, R-like feel |
| R6 | Mutable state, encapsulation |
| S4 | Formal definitions, Bioconductor |

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **R6** - Mutable objects with encapsulation
2. **S4** - Formal OOP with type checking
3. **S3** - Still most common for simple cases
4. **Choose based on needs** - Each has trade-offs

**Quick Reference:**

```{r eval=FALSE}
# R6
MyClass <- R6Class("MyClass",
  public = list(
    initialize = function() {},
    method = function() {}
  )
)
obj <- MyClass$new()

# S4
setClass("MyClass", slots = list(x = "numeric"))
obj <- new("MyClass", x = 1)
```
</div>

<!--chapter:end:53-r6-s4-oop.Rmd-->

# Non-Standard Evaluation {#nse-metaprogramming}

<div class="chapter-summary">
**What You'll Learn:**

- Non-standard evaluation (NSE)
- Tidy evaluation
- Quasiquotation
- Common metaprogramming errors

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

NSE allows functions to capture and manipulate code:

```{r message=FALSE}
library(dplyr)
library(rlang)

# Standard evaluation
filter(mtcars, cyl == 4)

# The 'cyl == 4' is captured as an expression
# Not evaluated immediately
```

## Tidy Evaluation

<div class="insight-box">
üí° **Key Insight: Embrace and Inject**

```{r}
# Problem: variables don't work
my_filter <- function(df, condition) {
  filter(df, condition)  # Error!
}

# Solution: embrace with {{}}
my_filter <- function(df, condition) {
  filter(df, {{ condition }})
}

my_filter(mtcars, cyl == 4)

# For column names
my_select <- function(df, col) {
  select(df, {{ col }})
}

my_select(mtcars, mpg)
```
</div>

## Quasiquotation

```{r}
# Inject values with !!
threshold <- 20
mtcars %>%
  filter(mpg > !!threshold)

# Inject names with :=
name_col <- "efficiency"
mtcars %>%
  mutate(!!name_col := mpg / wt)

# Splice multiple arguments with !!!
group_vars <- c("cyl", "gear")
mtcars %>%
  group_by(!!!syms(group_vars)) %>%
  summarize(mean_mpg = mean(mpg))
```

## Common Errors

### Error: object not found

```{r error=TRUE}
# Problem: forgot to embrace
my_mutate <- function(df, new_col, expr) {
  mutate(df, new_col = expr)
}

my_mutate(mtcars, efficiency, mpg / wt)
```

**Solution:** Use {{}} and :=

```{r}
my_mutate <- function(df, new_col, expr) {
  mutate(df, {{new_col}} := {{expr}})
}

my_mutate(mtcars, efficiency, mpg / wt)
```

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **{{}}** - Embrace and inject
2. **!!** - Unquote single value
3. **!!!** - Unquote-splice multiple
4. **:=** - Dynamic names
5. **NSE** - Enables dplyr's clean syntax

**Quick Reference:**

```{r eval=FALSE}
# Embrace columns
function(df, col) {
  df %>% select({{ col }})
}

# Inject values
x <- 5
filter(df, value > !!x)

# Dynamic names
name <- "new_col"
mutate(df, !!name := expression)

# Splice multiple
cols <- c("a", "b")
select(df, !!!syms(cols))
```
</div>

<!--chapter:end:54-nse-metaprogramming.Rmd-->

# Rcpp Basics {#rcpp-basics}

<div class="chapter-summary">
**What You'll Learn:**

- When to use C++
- Basic Rcpp syntax
- Common errors
- Performance gains

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Introduction

Rcpp allows you to write C++ code called from R:

```{r}
library(Rcpp)

# Simple C++ function
cppFunction('
int add(int x, int y) {
  return x + y;
}
')

add(2, 3)
```

## When to Use Rcpp

‚úÖ **Use Rcpp when:**
- Loops that can't be vectorized
- Recursive functions
- Need maximum speed
- Processing large data

‚ùå **Don't use Rcpp when:**
- R solution is fast enough
- Can vectorize in R
- Maintenance burden too high

## Basic Syntax

<div class="insight-box">
üí° **Key Insight: Rcpp Sugar**

```{r}
# R-like syntax in C++
cppFunction('
NumericVector compute(NumericVector x) {
  return sqrt(x * 2 + 1);
}
')

compute(1:5)

# Loops in C++
cppFunction('
double sum_cpp(NumericVector x) {
  double total = 0;
  for(int i = 0; i < x.size(); i++) {
    total += x[i];
  }
  return total;
}
')

sum_cpp(1:1000000)
```
</div>

## Performance Example

```{r}
# R version
mean_r <- function(x) {
  sum(x) / length(x)
}

# C++ version
cppFunction('
double mean_cpp(NumericVector x) {
  int n = x.size();
  double total = 0;
  for(int i = 0; i < n; i++) {
    total += x[i];
  }
  return total / n;
}
')

# Compare
x <- rnorm(1000000)

library(microbenchmark)
microbenchmark(
  mean(x),
  mean_r(x),
  mean_cpp(x),
  times = 100
)
```

## Common Errors

### Error: No matching function

```{r error=TRUE, eval=FALSE}
# Wrong: R syntax in C++
cppFunction('
NumericVector add_one(NumericVector x) {
  return x + 1  # Needs semicolon!
}
')
```

**Solution:** C++ requires semicolons

```{r}
cppFunction('
NumericVector add_one(NumericVector x) {
  return x + 1;
}
')
```

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Rcpp** - Integrate C++ for speed
2. **Use for loops** - When can't vectorize
3. **Rcpp Sugar** - R-like syntax
4. **Test performance** - Not always faster
5. **Maintenance cost** - Consider complexity

**Quick Reference:**

```{r eval=FALSE}
# Inline C++
library(Rcpp)

cppFunction('
double my_function(NumericVector x) {
  // C++ code here
  return result;
}
')

# Common types:
# NumericVector - numeric vector
# IntegerVector - integer vector
# CharacterVector - character vector
# NumericMatrix - matrix
# List - list
```
</div>

<!--chapter:end:55-rcpp-basics.Rmd-->

# Function Factories & Operators {#function-factories}

<div class="chapter-summary">
**What You'll Learn:**

- Function factories
- Function operators
- Closures
- Practical applications

**Difficulty:** ‚≠ê‚≠ê‚≠ê Advanced
</div>

## Function Factories

Functions that create functions:

```{r}
# Factory: returns a function
power_factory <- function(exp) {
  function(x) {
    x ^ exp
  }
}

# Create specific functions
square <- power_factory(2)
cube <- power_factory(3)

square(4)  # 16
cube(4)   # 64

# The exponent is "captured" in the closure
```

## Practical Example

<div class="insight-box">
üí° **Key Insight: Custom Validators**

```{r}
# Create validators
in_range <- function(min, max) {
  function(x) {
    x >= min & x <= max
  }
}

is_percentage <- in_range(0, 100)
is_probability <- in_range(0, 1)

is_percentage(50)   # TRUE
is_percentage(150)  # FALSE

is_probability(0.5)  # TRUE
is_probability(1.5)  # FALSE
```
</div>

## Function Operators

Functions that take functions and return modified functions:

```{r}
# Add logging to any function
add_logging <- function(f) {
  function(...) {
    cat("Calling function\n")
    result <- f(...)
    cat("Function returned:", result, "\n")
    result
  }
}

# Wrap existing function
logged_sqrt <- add_logging(sqrt)
logged_sqrt(4)

# Add error handling
safe_function <- function(f, default = NULL) {
  function(...) {
    tryCatch(
      f(...),
      error = function(e) {
        message("Error occurred: ", e$message)
        default
      }
    )
  }
}

safe_log <- safe_function(log, default = NA)
safe_log(10)
safe_log(-1)  # Returns NA instead of error
```

## Memoization

<div class="bestpractice-box">
üéØ **Best Practice: Cache Results**

```{r}
# Memoize slow functions
memoize <- function(f) {
  cache <- new.env(parent = emptyenv())
  
  function(...) {
    key <- paste(..., sep = "_")
    
    if (!exists(key, envir = cache)) {
      cache[[key]] <- f(...)
    }
    
    cache[[key]]
  }
}

# Slow function
fibonacci <- function(n) {
  if (n <= 1) return(n)
  fibonacci(n - 1) + fibonacci(n - 2)
}

# Fast version with memoization
fibonacci_memo <- memoize(fibonacci)

system.time(fibonacci(30))
system.time(fibonacci_memo(30))  # Much faster on repeat
```
</div>

## Real-World Applications

```{r}
# 1. Create family of similar functions
make_adder <- function(n) {
  function(x) x + n
}

add_10 <- make_adder(10)
add_100 <- make_adder(100)

add_10(5)
add_100(5)

# 2. Configure behavior
make_filter <- function(pattern) {
  function(x) {
    grep(pattern, x, value = TRUE)
  }
}

filter_r <- make_filter("^r")
filter_r(c("apple", "rose", "banana", "ruby"))

# 3. Delayed computation
make_lazy <- function(expr) {
  computed <- FALSE
  value <- NULL
  
  function() {
    if (!computed) {
      value <<- expr
      computed <<- TRUE
    }
    value
  }
}

# Computation only happens when called
get_data <- make_lazy({
  cat("Computing...\n")
  rnorm(1000)
})

# First call computes
data <- get_data()

# Subsequent calls use cached value
data2 <- get_data()  # No "Computing..." message
```

## Common Patterns

<div class="bestpractice-box">
üéØ **Best Practice: Common Factory Patterns**

```{r}
# 1. Partial application
partial <- function(f, ...) {
  args <- list(...)
  function(...) {
    do.call(f, c(args, list(...)))
  }
}

# Create specialized version
divide_by_10 <- partial(`/`, e2 = 10)
divide_by_10(100)

# 2. Compose functions
compose <- function(f, g) {
  function(...) {
    f(g(...))
  }
}

# sqrt(abs(x))
sqrt_abs <- compose(sqrt, abs)
sqrt_abs(-16)

# 3. Negate predicate
negate <- function(f) {
  function(...) {
    !f(...)
  }
}

is_not_na <- negate(is.na)
is_not_na(c(1, NA, 3))
```
</div>

## Summary

<div class="chapter-summary">
**Key Takeaways:**

1. **Function factories** - Functions that create functions
2. **Closures** - Capture environment
3. **Function operators** - Modify function behavior
4. **Practical uses** - Validation, logging, memoization
5. **Composition** - Build complex from simple

**Quick Reference:**

```{r eval=FALSE}
# Factory
make_power <- function(n) {
  function(x) x^n
}

# Operator
add_logging <- function(f) {
  function(...) {
    cat("Calling\n")
    f(...)
  }
}

# Composition
compose <- function(f, g) {
  function(...) f(g(...))
}

# Partial application
partial <- function(f, ...) {
  args <- list(...)
  function(...) do.call(f, c(args, list(...)))
}

# Memoization
memoize <- function(f) {
  cache <- new.env()
  function(...) {
    key <- paste(...)
    if (!exists(key, cache)) cache[[key]] <- f(...)
    cache[[key]]
  }
}
```

**Common Applications:**

```{r eval=FALSE}
# ‚úÖ Good uses
Validators (in_range, matches_pattern)
Adders (add_10, multiply_by)
Loggers (add_logging)
Error handlers (make_safe)
Memoizers (cache results)

# ‚ùå Avoid
Over-complicating simple code
When direct function is clearer
Excessive abstraction
```
</div>

## Exercises

<div class="exercise-box">
üìù **Exercise 1: Temperature Converter Factory**

Create a factory that makes temperature converters:
- `to_fahrenheit()` - Celsius to Fahrenheit
- `to_celsius()` - Fahrenheit to Celsius
- `to_kelvin()` - Celsius to Kelvin
</div>

<div class="exercise-box">
üìù **Exercise 2: Timing Function Operator**

Create a function operator that times how long a function takes:
- Prints execution time
- Returns the result
- Works with any function
</div>

## Exercise Answers

<details>
<summary>Click to see answers</summary>

**Exercise 1:**

```{r}
# Temperature converter factory
make_temp_converter <- function(formula) {
  function(temp) {
    formula(temp)
  }
}

# Create converters
to_fahrenheit <- make_temp_converter(function(c) c * 9/5 + 32)
to_celsius <- make_temp_converter(function(f) (f - 32) * 5/9)
to_kelvin <- make_temp_converter(function(c) c + 273.15)

# Test
to_fahrenheit(0)   # 32
to_celsius(32)     # 0
to_kelvin(0)       # 273.15
```

**Exercise 2:**

```{r}
# Timing operator
add_timing <- function(f) {
  function(...) {
    start <- Sys.time()
    result <- f(...)
    end <- Sys.time()
    
    cat("Execution time:", 
        format(difftime(end, start, units = "secs")), "\n")
    
    result
  }
}

# Test
slow_sum <- function(n) {
  total <- 0
  for (i in 1:n) total <- total + i
  total
}

timed_sum <- add_timing(slow_sum)
timed_sum(1000000)
```
</details>

## Completion

<div class="chapter-summary">
**Part XVII Complete!**

You've mastered advanced R programming:
- S3 object system
- R6 and S4
- Non-standard evaluation
- Rcpp integration
- Function factories

**Ready for:** Production R development!
</div>

<!--chapter:end:56-function-factories.Rmd-->

# (APPENDIX) Appendix {-}

# Complete Error Dictionary (A-Z) {#error-dictionary}

This appendix provides an alphabetical quick reference of all errors covered in the book. Each entry includes:

- Error message
- Chapter reference
- Quick fix
- Difficulty level

Use Ctrl+F (Cmd+F on Mac) to search for specific error text.

---

## A

### `All aesthetics have length 1, but data has X rows`

**Package:** ggplot2  
**Chapter:** \@ref(ggplot2-basics)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Pass a data frame to ggplot(), not individual vectors  
**Example:**
```{r eval=FALSE}
# Wrong:
ggplot() + geom_point(aes(x = 1:10, y = 1:10))

# Right:
df <- data.frame(x = 1:10, y = 1:10)
ggplot(df) + geom_point(aes(x, y))
```

### `argument "x" is missing, with no default`

**Package:** base  
**Chapter:** \@ref(function-definition)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Provide the required argument or set a default value  
**Example:**
```{r eval=FALSE}
# Function needs argument:
my_func <- function(x) { x + 1 }
my_func()  # Error!

# Fix: provide it:
my_func(5)

# Or give it a default:
my_func <- function(x = 0) { x + 1 }
```

### `argument is not interpretable as logical`

**Package:** base  
**Chapter:** \@ref(control-flow)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Ensure condition evaluates to TRUE/FALSE  
**Example:**
```{r eval=FALSE}
# Wrong:
if ("yes") { }  # Character not logical

# Right:
if (TRUE) { }
```

### `argument is of length zero`

**Package:** base  
**Chapter:** \@ref(control-flow)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check for empty vectors before using in if()  
**Example:**
```{r eval=FALSE}
x <- numeric(0)
if (x > 5) { }  # Error!

# Fix:
if (length(x) > 0 && x > 5) { }
```

### `arguments imply differing number of rows: X, Y`

**Package:** base  
**Chapter:** \@ref(dataframe-construction)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Ensure all columns have same length or use recycling explicitly  
**Example:**
```{r eval=FALSE}
# Wrong:
data.frame(a = 1:5, b = 1:3)  # Error!

# Right:
data.frame(a = 1:5, b = rep(1:3, length.out = 5))
```

---

## B

### `bytecode version mismatch`

**Package:** base  
**Chapter:** \@ref(package-loading)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Reinstall packages after R update  

### `by must specify column(s) as numbers, names or logical`

**Package:** base  
**Chapter:** \@ref(base-manipulation)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check merge/aggregate by argument format  

---

## C

### `Can't combine <type1> and <type2>`

**Package:** dplyr  
**Chapter:** \@ref(dplyr)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Convert columns to compatible types before combining  
**Example:**
```{r eval=FALSE}
# If binding rows with incompatible types:
df1 <- data.frame(x = 1:5)
df2 <- data.frame(x = letters[1:5])
bind_rows(df1, df2)  # Error!

# Fix: make types consistent
df2$x <- as.character(df2$x)
```

### `Can't rename columns that don't exist`

**Package:** dplyr  
**Chapter:** \@ref(dplyr)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check column name spelling  

### `Can't subset columns that don't exist`

**Package:** dplyr  
**Chapter:** \@ref(dplyr)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Verify column names with `names()` or `colnames()`  

### `cannot allocate vector of size X`

**Package:** base  
**Chapter:** \@ref(memory-errors)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Reduce data size, use data.table, or add RAM  
**See also:** Memory management techniques in Chapter \@ref(memory-errors)

### `cannot change value of locked binding for 'X'`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Don't try to reassign T, F, or other protected objects  

### `cannot change working directory`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check path exists and you have permission  

### `cannot coerce class "X" to a data.frame`

**Package:** base  
**Chapter:** \@ref(type-mismatch)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Convert object to appropriate type first  

### `cannot open file 'X': No such file or directory`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check file path and working directory with `getwd()`  
**See also:** File path best practices in Chapter \@ref(working-directory-paths)

### `cannot open the connection`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Close file in other programs, check file path  

### `character string is not in a standard unambiguous format`

**Package:** base  
**Chapter:** \@ref(datetime-parsing)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Specify date format explicitly with `format` argument  

### `column 'X' not found`

**Package:** various  
**Chapter:** \@ref(column-manipulation)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check spelling and use `names(data)` to verify  

### `contexts stack overflow`

**Package:** base  
**Chapter:** \@ref(scoping-environment)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Check for infinite recursion  

### `contrasts can be applied only to factors with 2 or more levels`

**Package:** stats  
**Chapter:** \@ref(model-fitting)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check factor has multiple levels or convert to numeric  

### `could not find function "X"`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Load required package with `library()` or use `package::function()`  
**See also:** Package management in Chapter \@ref(package-loading)

---

## D

### `do not know how to convert 'X' to class "Date"`

**Package:** base  
**Chapter:** \@ref(datetime-parsing)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Use proper date parsing function like `as.Date()` with format  

### `duplicate row.names are not allowed`

**Package:** base  
**Chapter:** \@ref(dataframe-construction)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Ensure row names are unique or use `row.names = FALSE`  

---

## E

### `embedded nul in string`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** File is corrupted or binary; re-download or clean data  

### `ERROR: dependency 'X' is not available`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Install with `dependencies = TRUE` or install dependency first  

### `Error in library(X) : there is no package called 'X'`

**Package:** base  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Install package first: `install.packages("X")`  

### `evaluation nested too deeply`

**Package:** base  
**Chapter:** \@ref(scoping-environment)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Increase `options(expressions = ...)` or fix infinite recursion  

---

## F

### `Faceting variables must have at least one value`

**Package:** ggplot2  
**Chapter:** \@ref(ggplot2-advanced)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Remove empty factor levels or NA values  

### `figure margins too large`

**Package:** graphics  
**Chapter:** \@ref(base-graphics)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Increase plot window size or adjust `par(mar = ...)`  

### `formal argument "X" matched by multiple actual arguments`

**Package:** base  
**Chapter:** \@ref(function-definition)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Don't provide same argument twice (by name and position)  

---

## G

### `geom_X requires the following missing aesthetics: Y`

**Package:** ggplot2  
**Chapter:** \@ref(ggplot2-basics)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Provide required aesthetic mapping  

### `glm.fit: algorithm did not converge`

**Package:** stats  
**Chapter:** \@ref(model-fitting)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Increase iterations, check data scaling, simplify model  

---

## I

### `incomplete final line found`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Usually harmless; add newline to file or use readr  

### `incorrect number of dimensions`

**Package:** base  
**Chapter:** \@ref(subscript-dimension)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check object dimensions with `dim()` or `str()`  

### `incorrect number of subscripts on matrix`

**Package:** base  
**Chapter:** \@ref(subscript-dimension)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Use correct number of indices [row, col]  

### `installation of package 'X' had non-zero exit status`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check error details, ensure dependencies installed  

### `invalid factor level, NA generated`

**Package:** base  
**Chapter:** \@ref(factor-creation)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Add new levels to factor before assigning  

### `invalid multibyte string`

**Package:** base  
**Chapter:** \@ref(working-directory-paths)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Specify file encoding: `fileEncoding = "UTF-8"`  

---

## L

### `lazy-load database 'X' is corrupt`

**Package:** base  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Reinstall the package  

### `longer object length is not a multiple of shorter object length`

**Package:** base  
**Chapter:** \@ref(vectors-recycling)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Ensure vectors have compatible lengths  

---

## M

### `missing value where TRUE/FALSE needed`

**Package:** base  
**Chapter:** \@ref(na-null-nan-inf)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Handle NA values before using in if() or logic  

### `more columns than column names`

**Package:** base  
**Chapter:** \@ref(reading-data)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check CSV delimiter, specify `sep` argument  

---

## N

### `NAs introduced by coercion`

**Package:** base  
**Chapter:** \@ref(type-mismatch)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check data before converting; can't convert "abc" to number  

### `need finite 'xlim' values`

**Package:** graphics  
**Chapter:** \@ref(base-graphics)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Remove infinite or NA values from data  

### `no applicable method for 'X' applied to an object of class "Y"`

**Package:** base  
**Chapter:** \@ref(s3-s4-methods)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Object type doesn't work with that function; convert or use different function  

### `non-conformable arrays`

**Package:** base  
**Chapter:** \@ref(matrix-operations)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Ensure matrix dimensions match for operation  

### `non-numeric argument to binary operator`

**Package:** base  
**Chapter:** \@ref(type-mismatch)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Convert character to numeric before math operations  

---

## O

### `object 'X' not found`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check spelling, ensure object created, load package if needed  
**Most Common Error:** See Chapter \@ref(objects-variables) for comprehensive guide

### `object of type 'closure' is not subsettable`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Add () to call function, or you referenced function name instead of object  

---

## P

### `package 'X' is not available for R version Y`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Update R or install from archive  

### `package 'X' was built before R 4.0.0`

**Package:** base  
**Chapter:** \@ref(package-loading)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Reinstall package  

### `pandoc document conversion failed`

**Package:** rmarkdown  
**Chapter:** \@ref(rmarkdown-quarto)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Check pandoc installation, update RStudio  

### `plot.new has not been called yet`

**Package:** graphics  
**Chapter:** \@ref(base-graphics)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Create plot before adding elements  

### `promise already under evaluation`

**Package:** base  
**Chapter:** \@ref(scoping-environment)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Circular dependency in default arguments; break the cycle  

### `protect(): protection stack overflow`

**Package:** base  
**Chapter:** \@ref(memory-errors)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Simplify code, reduce nested calls, restart R  

---

## R

### `rank-deficient fit may be misleading`

**Package:** stats  
**Chapter:** \@ref(model-fitting)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Remove collinear predictors, check for perfect correlation  

### `recursive indexing failed at level X`

**Package:** base  
**Chapter:** \@ref(dollar-double-bracket)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** List element doesn't exist or check index depth  

### `Removed X rows containing missing values`

**Package:** ggplot2  
**Chapter:** \@ref(ggplot2-basics)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Handle NA values or acknowledge they're being dropped  

### `replacement has X rows, data has Y`

**Package:** base  
**Chapter:** \@ref(subscript-dimension)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Ensure replacement vector matches subset size  

### `Rtools is required to build R packages but is not currently installed`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Install Rtools (Windows) or use binary packages  

---

## S

### `stat_count() must not be used with a y aesthetic`

**Package:** ggplot2  
**Chapter:** \@ref(ggplot2-basics)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Use `geom_col()` instead of `geom_bar()` when providing y values  

### `subscript out of bounds`

**Package:** base  
**Chapter:** \@ref(subscript-dimension)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Index is too large; check object length/dimensions  

### `system is computationally singular`

**Package:** base  
**Chapter:** \@ref(matrix-operations)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** Matrix not invertible; check for zero determinant  

---

## T

### `the condition has length > 1`

**Package:** base  
**Chapter:** \@ref(control-flow)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Use `any()` or `all()`, or use `&&` instead of `&`  

### `there is no package called 'X'`

**Package:** base  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Install package first  

---

## U

### `unable to access index for repository`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check internet connection, try different CRAN mirror  

### `undefined columns selected`

**Package:** base  
**Chapter:** \@ref(column-manipulation)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check column name spelling  

### `unexpected '=' in "X"`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Use `<-` for assignment or `==` for comparison  

### `unexpected symbol in "X"`

**Package:** base  
**Chapter:** \@ref(objects-variables)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Remove spaces from variable names, add missing operators  

### `unused argument (X = Y)`

**Package:** base  
**Chapter:** \@ref(function-definition)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Remove incorrect argument or check function documentation  

---

## V

### `variable 'X' has no visible binding`

**Package:** base  
**Chapter:** \@ref(scoping-environment)  
**Difficulty:** ‚≠ê‚≠ê‚≠ê  
**Quick Fix:** R CMD check issue; use `.data$` pronoun or declare global  

### `variable lengths differ`

**Package:** stats  
**Chapter:** \@ref(model-fitting)  
**Difficulty:** ‚≠ê‚≠ê  
**Quick Fix:** Ensure all variables in formula have same length  

---

## W

### `Warning in install.packages : unable to access index`

**Package:** utils  
**Chapter:** \@ref(installation-environment)  
**Difficulty:** ‚≠ê  
**Quick Fix:** Check internet, try different mirror  

---

## X-Z

[Additional errors as needed]

---

## Notes on Using This Dictionary

1. **Error text matching**: Some errors have variables (like 'X', 'Y') that will show actual values
2. **Package column**: Indicates which package generates the error
3. **Difficulty**: ‚≠ê = Common beginner, ‚≠ê‚≠ê‚≠ê = Advanced/rare
4. **Quick Fix**: First thing to try; full details in referenced chapter
5. **See also**: Links to related errors and concepts

## Can't Find Your Error?

1. Use the index at the beginning of book
2. Search within relevant chapter (e.g., all ggplot errors in ggplot chapter)
3. Check Appendix D for package-specific errors
4. Search complete book text (Ctrl+F in HTML version)
5. Post on Stack Overflow with `[r]` tag
6. Ask on RStudio Community

## Contributing Error Definitions

Found an error not listed? Submit it via GitHub issues at [repo-link]

<!--chapter:end:appendix-A-error-dictionary.Rmd-->

# References {-}

This section contains all references cited throughout the book.

## Core R Documentation

- R Core Team (2024). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

## Package Documentation

[Auto-generated from packages.bib]

## Online Resources

- Stack Overflow R Questions: https://stackoverflow.com/questions/tagged/r
- RStudio Community: https://community.rstudio.com/
- R-help Mailing List: https://stat.ethz.ch/mailman/listinfo/r-help
- CRAN Task Views: https://cran.r-project.org/web/views/

## Books

- Wickham, H. (2019). Advanced R, Second Edition. Chapman and Hall/CRC.
- Wickham, H., & Grolemund, G. (2017). R for Data Science. O'Reilly Media.
- Chambers, J. M. (2016). Extending R. Chapman and Hall/CRC.
- Venables, W. N., & Ripley, B. D. (2002). Modern Applied Statistics with S. Springer.

## Style Guides

- Tidyverse Style Guide: https://style.tidyverse.org/
- Google's R Style Guide: https://google.github.io/styleguide/Rguide.html

## Debugging Resources

- RStudio Debugging Documentation: https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio
- R-bloggers Debugging Articles: https://www.r-bloggers.com/tag/debugging/

## Error Message Databases

- Stack Overflow Common R Errors: https://stackoverflow.com/questions/tagged/r+error-handling
- R FAQ: https://cran.r-project.org/doc/FAQ/R-FAQ.html

<!--chapter:end:references.Rmd-->

